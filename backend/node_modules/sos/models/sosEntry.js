// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require(`lodash`);
const deepEqual = require(`deep-equal`);
const autoIncrement = require(`mongoose-plugin-autoinc-fix`);
const userInfoSchema = require(`user/models/userInfoSchema`);

exports.name = `SosEntry`;

exports.setUp = (app, mongoose) =>
{
  const STATUSES = [
    `new`,
    `in-progress`,
    `resolved`
  ];

  const observerSchema = new mongoose.Schema({
    user: userInfoSchema,
    role: {
      type: String,
      required: true,
      enum: [`sender`, `creator`, `subscriber`]
    },
    lastSeenAt: {
      type: Date,
      default: null
    },
    notify: {
      type: Boolean,
      default: false
    },
    changes: {}
  }, {
    _id: false,
    minimize: false
  });

  const changeSchema = new mongoose.Schema({
    date: {
      type: Date,
      required: true
    },
    user: userInfoSchema,
    data: {},
    comment: {
      type: String,
      trim: true,
      default: ``
    }
  }, {
    _id: false,
    minimize: false
  });

  const sosEntrySchema = new mongoose.Schema({
    sender: {
      ...userInfoSchema,
      privileges: [String],
      headers: {},
      navigator: {},
      screen: {},
      locations: {},
      date: {}
    },
    creator: userInfoSchema,
    createdAt: {
      type: Date,
      required: true
    },
    updater: userInfoSchema,
    updatedAt: {
      type: Date,
      required: true
    },
    startedAt: Date,
    finishedAt: Date,
    status: {
      type: String,
      required: true,
      enum: STATUSES
    },
    critical: {
      type: Boolean,
      default: false
    },
    subject: String,
    problem: String,
    solution: String,
    observers: [observerSchema],
    changes: [changeSchema]
  }, {
    id: false
  });

  sosEntrySchema.plugin(autoIncrement.plugin, {
    model: exports.name,
    field: `rid`,
    startAt: 1,
    incrementBy: 1
  });

  sosEntrySchema.index({status: 1});
  sosEntrySchema.index({
    'observers.user.id': 1,
    'observers.notify': 1
  });

  sosEntrySchema.statics.TOPIC_PREFIX = `sos.entries`;
  sosEntrySchema.statics.BROWSE_LIMIT = 100;

  sosEntrySchema.pre(`save`, function(next)
  {
    this.updatedAt = new Date();

    if (this.isNew)
    {
      this.createdAt = new Date();
      this.updatedAt = this.createdAt;

      this.createObservers();
    }

    if (this.isModified(`status`))
    {
      if (this.status === `in-progress`)
      {
        this.startedAt = this.updatedAt;
        this.finishedAt = null;
      }
      else if (this.status === `resolved`)
      {
        this.finishedAt = this.updatedAt;
      }
    }

    next();
  });

  sosEntrySchema.statics.markAsSeen = function(modelId, userId, done)
  {
    const Model = this;

    Model.findById(modelId, {_id: 1}).lean().exec((err, model) =>
    {
      if (err)
      {
        return done(err);
      }

      if (!model)
      {
        return done();
      }

      const conditions = {
        _id: model._id,
        'observers.user.id': userId
      };
      const update = {
        $set: {
          'observers.$.lastSeenAt': new Date(),
          'observers.$.notify': false,
          'observers.$.changes': {}
        }
      };

      Model.collection.updateOne(conditions, update, (err) =>
      {
        if (err)
        {
          return done(err);
        }

        app.broker.publish(`${Model.TOPIC_PREFIX}.seen.${userId}`, {modelId, userId});
      });
    });
  };

  sosEntrySchema.statics.observe = function(modelId, state, userInfo, done)
  {
    const Model = this;

    Model.findById(modelId, (err, model) =>
    {
      if (err)
      {
        return done(err);
      }

      if (!model)
      {
        return done();
      }

      const now = new Date();
      const userId = userInfo.id.toString();
      const observerIndex = _.findIndex(model.observers, observer => observer.user.id === userId);

      if (state)
      {
        if (observerIndex !== -1)
        {
          return done();
        }

        model.observers.push({
          user: {
            id: userId,
            label: userInfo.label
          },
          role: `subscriber`,
          lastSeenAt: now,
          notify: false,
          changes: {}
        });
        model.changes.push({
          date: now,
          user: userInfo,
          data: {observer: [0, 1]},
          comment: ``
        });
      }
      else
      {
        if (observerIndex === -1 || model.observers[observerIndex].role !== `subscriber`)
        {
          return done();
        }

        model.observers.splice(observerIndex, 1);
        model.changes.push({
          date: now,
          user: userInfo,
          data: {observer: [1, 0]},
          comment: ``
        });
      }

      model.markModified(`observers`);
      model.markModified(`changes`);
      model.save((err) =>
      {
        if (err)
        {
          return done(err);
        }

        app.broker.publish(`${Model.TOPIC_PREFIX}.edited`, {
          model,
          user: userInfo,
          notify: null
        });
      });
    });
  };

  sosEntrySchema.methods.createObservers = function()
  {
    const observers = {};

    observers[this.creator.id] = {
      user: this.creator,
      role: `creator`,
      lastSeenAt: this.createdAt,
      notify: false,
      changes: {}
    };

    if (!observers[this.sender.id])
    {
      observers[this.sender.id] = {
        user: {
          id: this.sender.id,
          label: this.sender.label
        },
        role: `sender`,
        lastSeenAt: null,
        notify: true,
        changes: {}
      };
    }

    this.observers.forEach((subscriber) =>
    {
      if (!observers[subscriber.user.id])
      {
        observers[subscriber.user.id] = subscriber;
      }
    });

    this.observers = Object.values(observers);
  };

  sosEntrySchema.methods.updateObservers = function(changedPropertyList, changes, newSubscribers)
  {
    const changedPropertyMap = {};

    changedPropertyList.forEach(property => { changedPropertyMap[property] = true; });

    const usersToNotify = {};
    const oldObserverMap = {};
    const newObserverMap = {};

    // Old observers
    _.forEach(this.observers, function(observer)
    {
      oldObserverMap[observer.user.id] = observer;

      if (observer.role === `subscriber`)
      {
        addObserver(observer, true);
      }
    });

    // Creator
    addObserver(oldObserverMap[this.creator.id], true);

    // Sender
    if (this.sender && !newObserverMap[this.sender.id])
    {
      let sender = oldObserverMap[this.sender.id];

      if (!sender)
      {
        sender = {
          user: {
            id: this.sender.id,
            label: this.sender.label
          },
          role: `sender`,
          lastSeenAt: null,
          notify: false,
          changes: {}
        };
      }

      addObserver(sender, true);
    }

    // New subscribers specified in the form
    const subscribers = [];

    newSubscribers.forEach(function(newSubscriber)
    {
      if (!newObserverMap[newSubscriber.user.id])
      {
        newObserverMap[newSubscriber.user.id] = newSubscriber;
        usersToNotify[newSubscriber.user.id] = {};
        subscribers.push(newSubscriber.user.label);
      }
    });

    if (subscribers.length)
    {
      changes.subscribers = [null, subscribers];
    }

    // Updater
    const updater = newObserverMap[this.updater.id];

    if (updater)
    {
      updater.lastSeenAt = this.updatedAt;
      updater.notify = false;
      updater.changes = {};

      delete usersToNotify[updater.user.id];
    }

    this.observers = Object.values(newObserverMap);

    this.markModified(`observers`);

    return usersToNotify;

    function addObserver(observer, notify)
    {
      Object.assign(observer.changes, changedPropertyMap);

      if (!observer.notify && notify)
      {
        observer.notify = notify;
        usersToNotify[observer.user.id] = observer.changes;
      }

      newObserverMap[observer.user.id] = observer;
    }
  };

  sosEntrySchema.methods.applyChanges = function(input, updater)
  {
    this.updater = updater;
    this.updatedAt = new Date();

    const changes = this.compareProperties(_.pick(input, [
      `status`,
      `critical`,
      `subject`,
      `problem`,
      `solution`
    ]));
    const changedProperties = Object.keys(changes);
    const comment = _.isEmpty(input.comment) || !_.isString(input.comment) ? `` : input.comment.trim();

    if (!_.isEmpty(input.comment))
    {
      changedProperties.push(`comment`);
    }

    if (!_.isEmpty(input.subscribers))
    {
      changedProperties.push(`subscribers`);
    }

    if (!changedProperties.length)
    {
      return null;
    }

    const usersToNotify = this.updateObservers(changedProperties, changes, input.subscribers);

    if (!_.isEmpty(input.subscribers))
    {
      if (_.isEmpty(changes.subscribers))
      {
        changedProperties.pop();
      }

      if (!changedProperties.length)
      {
        return null;
      }
    }

    this.changes.push({
      date: this.updatedAt,
      user: updater,
      data: changes,
      comment
    });

    return usersToNotify;
  };

  sosEntrySchema.methods.compareProperties = function(input)
  {
    const changes = {};

    _.forEach(input, (value, key) => { this.compareProperty(key, input, changes); });

    return changes;
  };

  sosEntrySchema.methods.compareProperty = function(property, input, changes)
  {
    let oldValue = this[property];
    let newValue = input[property];

    if (_.isObject(oldValue) && _.isFunction(oldValue.toObject))
    {
      oldValue = oldValue.toObject();
    }

    if (_.isObject(newValue) && _.isFunction(newValue.toObject))
    {
      newValue = newValue.toObject();
    }

    if (_.isString(newValue))
    {
      newValue = newValue.trim();
    }

    if (deepEqual(newValue, oldValue, {strict: true}))
    {
      return false;
    }

    changes[property] = [oldValue, newValue];
    this[property] = newValue;

    return true;
  };

  mongoose.model(exports.name, sosEntrySchema);
};
