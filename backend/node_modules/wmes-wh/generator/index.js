// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const moment = require('moment');
const step = require('h5.step');
const deepEqual = require('deep-equal');
const {ObjectId} = require('mongoose').Types;

const TOPIC_PREFIX = 'wh.generator';
const DEFAULT_SETTINGS = {
  ignoredMrps: [],
  groupDuration: 2,
  groupExtraItems: 5
};
const ORDER_COMPARE_PROPERTIES = [
  'date',
  'qtyTodo',
  'startTime',
  'finishTime'
];

module.exports = (app, module) =>
{
  if (!module.config.generator)
  {
    return;
  }

  const {
    settings,
    Order,
    WhOrder,
    Plan,
    PlanSettings
  } = module;

  const logger = module.logger.create({submodule: 'generator'});

  const generatorQueue = [];
  let generatorState = null;
  let generatorTimer = null;

  app.broker.subscribe(`${TOPIC_PREFIX}.requested`, handleRequest);

  app.broker.subscribe('settings.updated.wh.planning.**', generateActivePlans);

  app.broker.subscribe('planning.changes.created', change =>
  {
    if (change.user !== null || (Object.keys(change.data).length === 1 && change.data.settings))
    {
      return;
    }

    generatePlan(change.plan);
  });

app.broker.subscribe('app.started', () => generatePlan('2020-02-19')).setLimit(1);

  function handleRequest(message)
  {
    const date = moment.utc(message.date, 'YYYY-MM-DD');

    if (date.isValid())
    {
      generatePlan(date.toDate());
    }
  }

  function createPlanGeneratorState(key)
  {
    return {
      key,
      date: moment.utc(key, 'YYYY-MM-DD').toDate(),
      cancelled: false,
      logger: logger.create({key})
    };
  }

  function generateActivePlans()
  {
    const now = moment();
    const from = moment.utc(now.format('YYYY-MM-DD'), 'YYYY-MM-DD');

    if (now.hours() < 6)
    {
      from.subtract(1, 'days');
    }

    Plan.find({_id: {$gt: from}}, {_id: 1}).lean().exec((err, plans) =>
    {
      if (err)
      {
        logger.error(err, `Failed to find active plans.`);
      }

      plans.forEach(plan => generatePlan(moment.utc(plan._id).format('YYYY-MM-DD')));
    });
  }

  function generatePlan(date)
  {
    const dateMoment = moment.utc(date, 'YYYY-MM-DD').startOf('day');

    if (!dateMoment.isValid())
    {
      return;
    }

    const planKey = dateMoment.format('YYYY-MM-DD');

    if (!generatorQueue.includes(planKey))
    {
      generatorQueue.push(planKey);

      app.broker.publish(`${TOPIC_PREFIX}.started`, {
        date: planKey
      });
    }

    if (generatorState !== null)
    {
      generatorState.logger.info(`Cancelling...`);

      generatorState.cancelled = true;

      return;
    }

    if (generatorTimer !== null)
    {
      clearTimeout(generatorTimer);
    }

    generatorTimer = setTimeout(generateNextPlan, 1);
  }

  function generateNextPlan()
  {
    if (generatorState)
    {
      return;
    }

    const planKey = generatorQueue.sort((a, b) => a.localeCompare(b)).shift();

    if (!planKey)
    {
      return;
    }

    generatorTimer = null;
    generatorState = createPlanGeneratorState(planKey);

    tryGeneratePlan(generatorState, () =>
    {
      if (generatorState.cancelled && !generatorQueue.includes(planKey))
      {
        generatorQueue.push(planKey);
      }

      generatorState = null;

      if (generatorTimer !== null)
      {
        clearTimeout(generatorTimer);
      }

      generatorTimer = setTimeout(generateNextPlan, 1);
    });
  }

  function tryGeneratePlan(state, done)
  {
    const startedAt = Date.now();

    state.logger.info(`Generating...`);

    step(
      function()
      {
        settings.findValues({_id: /^wh\.planning/}, 'wh.planning.', this.parallel());

        PlanSettings
          .findById(state.date, {requiredStatuses: 1, ignoredStatuses: 1})
          .lean()
          .exec(this.parallel());

        Plan.aggregate([
          {$match: {_id: state.date}},
          {$unwind: '$lines'},
          {$unwind: '$lines.orders'},
          {$project: {
            line: '$lines._id',
            orderNo: '$lines.orders.orderNo',
            quantity: '$lines.orders.quantity',
            pceTime: '$lines.orders.pceTime',
            startAt: '$lines.orders.startAt',
            finishAt: '$lines.orders.finishAt'
          }},
          {$sort: {
            line: 1,
            startAt: 1
          }}
        ], this.parallel());
      },
      function(err, whSettings, planSettings, allLineOrders)
      {
        if (err)
        {
          return this.skip(app.createError(`Failed to fetch data: ${err.message}`, err.code, 500));
        }

        this.settings = Object.assign(DEFAULT_SETTINGS, whSettings, planSettings);
        this.noToOrders = new Map();
        this.lineToOrders = new Map();

        allLineOrders.forEach(lineOrder =>
        {
          if (!this.noToOrders.has(lineOrder.orderNo))
          {
            this.noToOrders.set(lineOrder.orderNo, []);
          }

          this.noToOrders.get(lineOrder.orderNo).push(lineOrder);
        });

        setImmediate(this.next());
      },
      function()
      {
        const conditions = {
          _id: {
            $in: Array.from(this.noToOrders.keys())
          },
          statuses: {
            $in: this.settings.requiredStatuses,
            $nin: this.settings.ignoredStatuses
          }
        };

        if (!_.isEmpty(this.settings.ignoredMrps))
        {
          conditions.mrp = {
            $nin: this.settings.ignoredMrps
          };
        }

        const fields = {
          _id: 1,
          mrp: 1,
          psStatus: 1
        };

        Order
          .find(conditions, fields)
          .lean()
          .exec(this.parallel());
      },
      function(err, sapOrderList)
      {
        if (err)
        {
          return this.skip(app.createError(`Failed to find SAP orders: ${err.message}`, err.code, 500));
        }

        const sapOrderMap = new Map();

        sapOrderList.forEach(o => sapOrderMap.set(o._id, o));

        this.noToOrders.forEach((allLineOrders, orderNo) =>
        {
          const sapOrder = sapOrderMap.get(orderNo);

          if (!sapOrder)
          {
            return;
          }

          allLineOrders.forEach(lineOrder =>
          {
            lineOrder.mrp = sapOrder.mrp;
            lineOrder.psStatus = sapOrder.psStatus;

            if (!this.lineToOrders.has(lineOrder.line))
            {
              this.lineToOrders.set(lineOrder.line, []);
            }

            const lineLineOrders = this.lineToOrders.get(lineOrder.line);
            const lastLineOrder = lineLineOrders.length ? lineLineOrders[lineLineOrders.length - 1] : null;

            if (lastLineOrder && lastLineOrder.orderNo === lineOrder.orderNo)
            {
              const prevDuration = lastLineOrder.pceTime * lastLineOrder.quantity;
              const nextDuration = lineOrder.pceTime * lineOrder.quantity;

              lastLineOrder.pceTime = Math.ceil((prevDuration + nextDuration) / 2);
              lastLineOrder.quantity += lineOrder.quantity;
              lastLineOrder.finishAt = lineOrder.finishAt;

              return;
            }

            lineLineOrders.push(lineOrder);
          });
        });

        this.noToOrders = null;

        setImmediate(this.next());
      },
      function()
      {
        this.newOrders = new Map();

        this.lineToOrders.forEach(lineOrders =>
        {
          lineOrders.forEach(lineOrder =>
          {
            const whOrder = WhOrder.createFromLineOrder(lineOrder, state.date);
            const key = WhOrder.generateKey(whOrder);

            this.newOrders.set(key, whOrder);
          });
        });

        this.lineToOrders = null;

        setImmediate(this.next());
      },
      function()
      {
        WhOrder.find({date: state.date}).lean().exec(this.next());
      },
      function(err, oldOrders)
      {
        if (err)
        {
          return this.skip(new Error(`Failed to find WH orders: ${err.message}`));
        }

        this.oldOrders = new Map();

        oldOrders.forEach(whOrder =>
        {
          const key = WhOrder.generateKey(whOrder);

          this.oldOrders.set(key, whOrder);
        });

        setImmediate(this.next());
      },
      function()
      {
        this.changes = {
          added: [],
          changed: [],
          removed: []
        };

        state.logger.info(`Comparing orders...`, {
          oldCount: this.oldOrders.size,
          newCount: this.newOrders.size
        });

        const v = Date.now();

        this.oldOrders.forEach((oldOrder, key) =>
        {
          const newOrder = this.newOrders.get(key);

          this.newOrders.delete(key);

          resolveOrderChanges(this.changes, v, oldOrder, newOrder);
        });

        this.newOrders.forEach(newOrder =>
        {
          newOrder._id = new ObjectId();

          this.changes.added.push(newOrder);
        });

        this.oldOrders = null;
        this.newOrders = null;

        setImmediate(this.next());
      },
      async function()
      {
        this.session = await WhOrder.startSession();
        this.session.startTransaction();
      },
      function(err)
      {
        if (state.cancelled)
        {
          this.changes = null;

          return this.skip();
        }

        if (err)
        {
          return this.skip(err);
        }

        const {added, changed, removed} = this.changes;

        if (added.length)
        {
          WhOrder.collection.deleteMany(
            {_id: {$in: added.map(o => o._id)}},
            {session: this.session},
            this.group()
          );

          WhOrder.collection.insertMany(
            added,
            {session: this.session},
            this.group()
          );
        }

        const operations = [];

        if (removed.length)
        {
          operations.push({
            deleteMany: {
              filter: {_id: {$in: removed}}
            }
          });
        }

        changed.forEach(change =>
        {
          operations.push({
            updateOne: {
              filter: {_id: change._id},
              update: {$set: change}
            }
          });
        });

        if (operations.length)
        {
          WhOrder.collection.bulkWrite(
            operations,
            {ordered: false, session: this.session},
            this.group()
          );
        }
      },
      async function(err)
      {
        if (err)
        {
          state.logger.warn('Aborting...');

          setImmediate(this.group(), err);

          this.session.abortTransaction(this.group());
        }
        else
        {
          this.session.commitTransaction(this.next());
        }
      },
      function(err)
      {
        const duration = (Date.now() - startedAt) / 1000;

        if (this.session)
        {
          this.session.endSession();
          this.session = null;
        }

        if (err)
        {
          state.logger.error(err, 'Failed to generate!');
        }
        else if (this.changes)
        {
          const added = this.changes.added.length;
          const changed = this.changes.changed.length;
          const removed = this.changes.removed.length;

          if (added || changed || removed)
          {
            state.logger.info(`Plan changed.`, {added, changed, removed});

            app.broker.publish(`${WhOrder.TOPIC_PREFIX}.changed.${state.key}`, {
              date: state.date,
              changes: this.changes
            });
          }
        }

        if (state.cancelled)
        {
          state.logger.info(`Cancelled!`, {duration});
        }
        else
        {
          state.logger.info(`Finished!`, {duration});

          app.broker.publish(`${TOPIC_PREFIX}.finished`, {
            date: state.key
          });
        }

        done();
      }
    );
  }

  function resolveOrderChanges(changes, v, oldOrder, newOrder)
  {
    if (!newOrder)
    {
      handleOrderRemovedFromPlan(changes, v, oldOrder);

      return;
    }

    const changed = compareOrder(v, oldOrder, newOrder);

    if (changed)
    {
      changes.changed.push(changed);
    }
  }

  function handleOrderRemovedFromPlan(changes, v, oldOrder)
  {
    if (oldOrder.status === 'pending')
    {
      changes.removed.push(oldOrder._id);

      return;
    }

    if (oldOrder.status !== 'finished' && oldOrder.status !== 'cancelled')
    {
      changes.changed.push({
        _id: oldOrder._id,
        v,
        status: 'cancelled',
        problem: {
          cause: 'REMOVED_FROM_PLAN',
          data: {},
          comment: ''
        }
      });

      return;
    }
  }

  function compareOrder(v, oldOrder, newOrder)
  {
    const changes = {
      _id: oldOrder._id,
      v
    };
    let anyChanges = false;

    ORDER_COMPARE_PROPERTIES.forEach(p =>
    {
      const oldValue = oldOrder[p];
      const newValue = newOrder[p];

      if (!deepEqual(oldValue, newValue))
      {
        changes[p] = newValue;
        anyChanges = true;
      }
    });

    return anyChanges ? changes : null;
  }
};
