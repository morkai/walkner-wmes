// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const request = require('request');

module.exports = class MoxaRestLamps
{
  constructor(app, module, lc)
  {
    this.lc = lc;
    this.line = lc.line;
    this.logger = lc.logger;

    this.destroyed = false;
    this.timers = {};
    this.readLampsCallbacks = null;
    this.readLampsAt = 0;
    this.state = null;
  }

  destroy()
  {
    _.forEach(this.timers, timer => clearTimeout(timer));

    this.destroyed = true;
  }

  trace(...args)
  {
    this.lc.trace(...args);
  }

  shouldReadLamps()
  {
    return !this.timers.readLamps
      && (Date.now() - this.readLampsAt) > 300000;
  }

  readLamps(done)
  {
    const lamps = this;

    clearTimeout(lamps.timers.readLamps);

    if (lamps.readLampsCallbacks)
    {
      lamps.readLampsCallbacks.push(done);

      return;
    }

    lamps.readLampsAt = Date.now();
    lamps.readLampsCallbacks = [done];

    lamps.request(null, (err, res) =>
    {
      if (err)
      {
        lamps.logger.error(err, 'Failed to read lamps.');
      }
      else if (res.statusCode !== 200 || !res.body.io || !res.body.io.do)
      {
        lamps.logger.warn('Failed to read lamps: invalid response.', {
          response: {
            statusCode: res.statusCode,
            body: res.body
          }
        });
      }
      else
      {
        lamps.state = res.body;

        lamps.line.stations.forEach((station, i) =>
        {
          const redLampIo = lamps.state.io.do[station.redLampI];
          const orangeLampIo = lamps.state.io.do[station.orangeLampI];

          lamps.lc.stations[i + 1].map = redLampIo && redLampIo.doStatus === 1
            ? 'red'
            : orangeLampIo && orangeLampIo.doStatus === 1
              ? 'orange'
              : 'off';
        });
      }

      lamps.timers.readLamps = setTimeout(lamps.readLamps.bind(lamps), _.random(25000, 60000), _.noop);

      const callbacks = lamps.readLampsCallbacks;

      lamps.readLampsCallbacks = null;

      callbacks.forEach(done => done());
    });
  }

  writeLamps(stations, done)
  {
    const lamps = this;
    const outputs = lamps.state.io.do;

    outputs.forEach(output =>
    {
      output.doStatus = 0;
    });

    stations.forEach(station =>
    {
      const config = lamps.line.stations[station._id - 1];

      if (station.lamp === 'red' && outputs[config.redLampI])
      {
        outputs[config.redLampI].doStatus = 1;
      }
      else if (station.lamp === 'orange' && outputs[config.orangeLampI])
      {
        outputs[config.orangeLampI].doStatus = 1;
      }
    });

    lamps.request(lamps.state, (err, res) =>
    {
      if (err)
      {
        lamps.logger.error(err, 'Failed to write lamps.');
      }
      else if (res.statusCode !== 200)
      {
        lamps.logger.warn('Failed to write lamp: invalid response.', {
          response: {
            statusCode: res.statusCode,
            body: res.body
          }
        });
      }

      done();
    });
  }

  request(body, done)
  {
    const options = {
      method: body ? 'PUT' : 'GET',
      url: `http://${this.line.common.lampControllerIp}/api/slot/0/io/do`,
      headers: {
        accept: 'vdn.dac.v1',
        'content-type': 'application/json'
      },
      json: true,
      body: body || undefined
    };

    request(options, (err, res) => done(err, res));
  }
};
