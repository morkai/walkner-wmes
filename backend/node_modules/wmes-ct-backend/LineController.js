// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');
const request = require('request');

const INVEO_USER = 'admin';
const INVEO_PASS = 'admin00';
const INVEO_TIMEOUT = 6000;

module.exports = class LineController
{
  constructor(app, module, line)
  {
    this.checkTodos = this.checkTodos.bind(this);

    this.module = module;
    this.line = line;
    this.broker = app.broker.sandbox();
    this.logger = module.logger.create({line: line._id});

    this.destroyed = false;
    this.updated = false;
    this.updatedAt = line.state && line.state.updatedAt || Date.now();
    this.updatedStations = {};
    this.stations = line.state && line.state.stations || {};
    this.hasMoreTodos = false;
    this.checkingTodos = false;
    this.timers = {};

    this.initialize();
  }

  destroy()
  {
    _.forEach(this.timers, timer => clearTimeout(timer));

    this.broker.destroy();

    this.destroyed = true;
  }

  trace(...args)
  {
    this.logger.debug(...args);
  }

  initialize()
  {
    const oldStations = this.stations;

    this.line.stations.forEach((station, i) =>
    {
      const stationNo = i + 1;

      this.stations[stationNo] = oldStations[stationNo] || createEmptyStation(stationNo);
    });

    const lc = this;

    step(
      function()
      {
        lc.readLamps(this.next());
      },
      function()
      {
        lc.toggleLamps(this.next());
      },
      function()
      {
        lc.broker.subscribe('ct.todos.saved', lc.onTodoSaved.bind(lc));

        lc.scheduleCheckTodos(1);
      }
    );
  }

  getState()
  {
    return {
      _id: this.line._id,
      updatedAt: this.updatedAt,
      stations: this.stations
    };
  }

  onTodoSaved(todo)
  {
    if (todo.line === this.line._id)
    {
      this.scheduleCheckTodos(1);
    }
  }

  scheduleCheckTodos(delay)
  {
    clearTimeout(this.timers.checkTodos);

    if (this.checkingTodos)
    {
      this.hasMoreTodos = true;

      return;
    }

    this.hasMoreTodos = false;
    this.timers.checkTodos = setTimeout(this.checkTodos, delay);
  }

  checkTodos()
  {
    if (this.checkingTodos)
    {
      return;
    }

    this.checkingTodos = true;
    this.hasMoreTodos = false;

    this.doCheckTodos();
  }

  doCheckTodos()
  {
    const conditions = {
      line: this.line._id
    };
    const sort = {
      time: 1
    };

    this.module.CtTodo.find(conditions).sort(sort).lean().exec((err, todos) =>
    {
      if (err)
      {
        this.logger.error(err, 'Failed to check todos.');
      }

      this.updated = false;

      this.handleNextTodo(todos || []);
    });
  }

  handleNextTodo(todos)
  {
    if (this.destroyed)
    {
      return;
    }

    const todo = todos.shift();

    if (!todo)
    {
      this.finishHandlingTodos();

      return;
    }

    const lc = this;

    step(
      function()
      {
        lc.handleTodo(todo, this.next());
      },
      function(err)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!lc.updatedStations)
        {
          return;
        }

        const updatedStations = Object.values(lc.updatedStations);
        const $set = {};

        if (updatedStations.length === lc.line.stations.length)
        {
          $set.state = {
            updatedAt: lc.updatedAt,
            stations: lc.updatedStations
          };
        }
        else
        {
          $set['state.updatedAt'] = lc.updatedAt;

          updatedStations.forEach(station =>
          {
            $set[`state.stations.${station._id}`] = station;
          });
        }

        lc.module.CtLine.updateOne({_id: lc.line._id}, {$set}, this.next());
      },
      function(err)
      {
        if (err)
        {
          return this.skip(err);
        }

        lc.module.CtTodo.deleteOne({_id: todo._id}).exec(this.next());
      },
      function(err)
      {
        if (err)
        {
          lc.logger.error(err, 'Failed to handle todo.', {todo});

          lc.hasMoreTodos = false;
        }

        if (lc.updatedStations)
        {
          lc.broker.publish('ct.state.updated', {
            line: lc.line._id,
            updatedAt: lc.updatedAt,
            stations: lc.updatedStations
          });

          lc.updated = true;
          lc.updatedStations = null;
        }

        lc.handleNextTodo(todos);
      }
    );
  }

  finishHandlingTodos()
  {
    const lc = this;

    step(
      function()
      {
        if (lc.updated)
        {
          lc.toggleLamps(this.next());
        }
      },
      function()
      {
        lc.checkingTodos = false;

        lc.scheduleCheckTodos(lc.hasMoreTodos ? 1 : 15000);
      }
    );
  }

  handleTodo(todo, done)
  {
    this.trace('Handling todo...', {todo});

    switch (todo.action)
    {
      case 'reset':
        this.handleResetAction(todo, done);
        break;

      case 'input':
        this.handleInputAction(todo, done);
        break;

      case 'changeOrder':
      case 'correctOrder':
        this.handleOrderAction(todo, done);
        break;

      case 'cart':
        this.handleCartAction(todo, done);
        break;

      case 'sn':
        this.handleSnAction(todo, done);
        break;

      default:
      {
        this.logger.warn('Unknown action.', {todo: todo});

        done();
      }
    }
  }

  handleResetAction(todo, done)
  {
    _.forEach(this.stations, station =>
    {
      station = this.stations[station._id] = createEmptyStation(station._id);

      this.markUpdatedStation(station);
    });

    done();
  }

  handleInputAction(todo, done)
  {
    if (!todo.data.state)
    {
      this.trace('Ignored the elevator going down.', {todo});

      return done();
    }

    // Only the second station can initiate the PCE start by input
    if (todo.station !== 2)
    {
      this.trace('Ignored elevator going up on an invalid station.', {todo});

      return done();
    }

    this.startFirstPce(todo.time, null, done);
  }

  handleOrderAction(todo, done)
  {
    const station = this.stations[1];

    if (station.startedAt && !station.finishedAt)
    {
      this.logger.warn('Ignored order action: finished PCE.', {station});

      return done();
    }

    const lc = this;

    step(
      function()
      {
        lc.findLatestOrder(this.next());
      },
      function(err, newOrder)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!newOrder)
        {
          lc.logger.warn('Ignored order action: no latest order.', {station});

          return;
        }

        _.forEach(lc.stations, (station, n) =>
        {
          if (todo.action === 'changeOrder')
          {
            if (n === '1' && !station.pceFinishedAt)
            {
              station.order = newOrder;

              lc.trace('Order changed.', {station});

              lc.markUpdatedStation(station);
            }
          }
          else if (todo.action === 'correctOrder')
          {
            if (station.order.pso === newOrder.pso)
            {
              station.order = newOrder;

              lc.trace('Order corrected.', {station});

              lc.markUpdatedStation(station);
            }
          }
        });
      },
      done
    );
  }

  handleCartAction(todo, done)
  {
    if (todo.station === 1)
    {
      this.startFirstPce(todo.time, todo.data.cart, done);
    }
    else
    {
      this.startNextPce(todo.time, todo.station, todo.data.cart, done);
    }
  }

  handleSnAction(todo, done)
  {
    if (todo.station !== this.line.stations.length)
    {
      this.logger.warn('Ignored SN action: invalid station.');

      return done();
    }

    const station = this.stations[todo.station];

    if (!station.pceStartedAt || station.pceFinishedAt)
    {
      this.logger.warn('Ignored SN action: PCE completed.', {station});

      return done();
    }

    if (station.order._id !== todo.data.orderNo)
    {
      this.logger.warn('Ignored SN action: invalid order.', {station});
    }

    this.finishPce(station, todo.time, done);
  }

  finishPce(station, finishedAt, done)
  {
    station.pceFinishedAt = finishedAt;
    station.qtyDone += 1;

    const pceDurations = {
      total: station.pceFinishedAt - station.pceStartedAt,
      work: 0,
      downtime: 0,
      scheduled: 0
    };

    const lc = this;

    step(
      function()
      {
        const fields = {
          reason: 1,
          startedAt: 1,
          finishedAt: 1
        };

        lc.module.ProdDowntime
          .findOne({
            prodLine: lc.line._id,
            startedAt: {$lt: station.pceStartedAt}
          })
          .select(fields)
          .sort({startedAt: -1})
          .lean()
          .exec(this.parallel());

        lc.module.ProdDowntime
          .find({
            prodLine: lc.line._id,
            startedAt: {$gte: station.pceStartedAt}
          })
          .select(fields)
          .sort({startedAt: 1})
          .lean()
          .exec(this.parallel());
      },
      function(err, prevDowntime, nextDowntimes)
      {
        if (err)
        {
          lc.logger.error(err, 'Failed to find downtimes while finishing a PCE.', {station});

          return;
        }

        const downtimes = new Map();

        if (prevDowntime)
        {
          downtimes.set(prevDowntime._id, prevDowntime);
        }

        nextDowntimes.forEach(dt => downtimes.set(dt._id, dt));

        downtimes.forEach(dt =>
        {
          if (!dt.finishedAt)
          {
            dt.finishedAt = new Date();
          }

          if (dt.finishedAt < station.pceStartedAt)
          {
            return;
          }

          if (dt.startedAt < station.pceStartedAt)
          {
            dt.startedAt = station.pceStartedAt;
          }

          const duration = dt.finishedAt - dt.startedAt;

          pceDurations.downtime += duration;

          if (lc.module.scheduledDowntimes.has(dt.reason))
          {
            pceDurations.scheduled += duration;
          }
        });

        pceDurations.work = pceDurations.total - pceDurations.scheduled;
      },
      function()
      {
        _.forEach(pceDurations, (value, key) =>
        {
          station.durations[key] += value;
        });

        lc.trace('PCE finished.', {station});

        lc.markUpdatedStation(station);

        lc.recordPce(station, pceDurations);
      },
      done
    );
  }

  markUpdatedStation(station)
  {
    if (!this.updatedStations)
    {
      this.updatedStations = {};
    }

    this.updatedStations[station._id] = station;
    this.updatedAt = Date.now();
  }

  startFirstPce(startedAt, cart, done)
  {
    this.trace('Starting first PCE...', {startedAt, cart});

    const lc = this;

    step(
      function()
      {
        lc.findLatestOrder(this.next());
      },
      function(err, newOrder)
      {
        if (err)
        {
          return this.skip(err);
        }

        const station = lc.stations[1];

        if (!station)
        {
          lc.trace('Ignored first PCE: no stations defined.');

          return this.skip();
        }

        const oldOrder = station.order;

        if (newOrder._id !== oldOrder._id)
        {
          lc.changeOrder(station, oldOrder, newOrder);
        }

        station.cart = cart;
        station.order = newOrder;
        station.pceStartedAt = startedAt;
        station.pceFinishedAt = null;

        if (!station.orderStartedAt)
        {
          station.orderStartedAt = station.pceStartedAt;
        }

        lc.trace('First PCE started.', {station});

        lc.markUpdatedStation(station);

        setImmediate(this.next());
      },
      done
    );
  }

  changeOrder(station, oldOrder, newOrder)
  {
    station.prev = {
      order: oldOrder,
      qtyTodo: station.qtyTodo,
      qtyDone: station.qtyDone,
      startedAt: station.orderStartedAt,
      finishedAt: station.pceFinishedAt,
      durations: station.durations
    };
    station.qtyTodo = 0;
    station.qtyDone = 0;
    station.orderStartedAt = null;
    station.durations = {
      total: 0,
      work: 0,
      downtime: 0,
      scheduled: 0
    };

    this.trace('Order changed.', {
      oldOrder: oldOrder._id,
      newOrder: newOrder._id
    });
  }

  startNextPce(startedAt, stationNo, cart, done)
  {
    this.trace('Starting next PCE...', {startedAt, stationNo, cart});

    const startedStation = this.stations[stationNo];

    if (!startedStation)
    {
      this.trace('Ignored next PCE: invalid station.', {stationNo});

      return done();
    }

    const lc = this;
    const finishedStation = lc.stations[stationNo - 1];

    step(
      function()
      {
        if (finishedStation.pceFinishedAt)
        {
          return;
        }

        if (finishedStation.cart && finishedStation.cart !== cart)
        {
          return;
        }

        finishedStation.cart = cart;

        lc.finishPce(finishedStation, startedAt, this.next());
      },
      function()
      {
        const oldOrder = startedStation.order;
        const newOrder = {...finishedStation.order};

        if (newOrder._id !== oldOrder._id)
        {
          lc.changeOrder(startedStation, oldOrder, newOrder);
        }

        startedStation.cart = cart;
        startedStation.order = newOrder;
        startedStation.pceStartedAt = startedAt;
        startedStation.pceFinishedAt = null;

        if (!startedStation.orderStartedAt)
        {
          startedStation.orderStartedAt = startedAt;
        }

        lc.trace('Started next PCE.', {station: startedStation});

        lc.markUpdatedStation(startedStation);
      },
      done
    );
  }

  findLatestOrder(done)
  {
    this.module.ProdShiftOrder
      .findOne({prodLine: this.line._id})
      .select({
        orderId: 1,
        'orderData.nc12': 1,
        'orderData.name': 1,
        'orderData.qty': 1,
        workerCount: 1,
        sapTaktTime: 1
      })
      .sort({startedAt: -1})
      .lean()
      .exec((err, pso) =>
      {
        if (err)
        {
          return done(err);
        }

        if (!pso)
        {
          return createEmptyOrder();
        }

        done(null, {
          _id: pso.orderId,
          pso: pso._id,
          nc12: pso.orderData && pso.orderData.nc12 || '',
          name: pso.orderData && pso.orderData.name || '',
          qty: pso.orderData && pso.orderData.qty || 0,
          workerCount: pso.workerCount,
          sapTaktTime: pso.sapTaktTime
        });
      });
  }

  readLamps(done)
  {
    const lc = this;

    lc.trace('Reading lamps...');

    step(
      function()
      {
        lc.line.stations.forEach(station =>
        {
          readLamp(station.lampIp, this.group());
        });
      },
      function(err, lamps)
      {
        if (err)
        {
          return done(err);
        }

        let anyFailure = false;

        (lamps || []).forEach((lamp, i) =>
        {
          anyFailure = anyFailure || lamp === null;
          lc.stations[i + 1].lamp = !!lamp;
        });

        if (anyFailure)
        {
          lc.timers.readLamps = setTimeout(lc.readLamps.bind(lc), 30000, _.noop);
        }

        done();
      }
    );

    function readLamp(lampIp, done)
    {
      const options = {
        method: 'GET',
        url: `http://${lampIp}/status.xml`,
        auth: {
          user: INVEO_USER,
          pass: INVEO_PASS,
          sendImmediately: true
        },
        proxy: null,
        followRedirect: false,
        timeout: INVEO_TIMEOUT
      };

      request(options, (err, res, body) =>
      {
        if (err)
        {
          lc.logger.error(err, 'Failed to read lamp.', {lampIp});
        }

        done(null, err ? null : (typeof body === 'string' && body.includes('<out>1</out>')));
      });
    }
  }

  toggleLamps(done)
  {
    this.trace('Toggling lamps...');

    const stations = _.map(this.stations, station =>
    {
      const sapTaktTime = station.order.sapTaktTime;
      const actualTaktTime = station.durations.work / station.qtyDone / 1000;
      const rank = sapTaktTime ? (actualTaktTime / sapTaktTime) : 0;

      return {
        station,
        rank: Math.round(rank * 1000) / 1000
      };
    });

    stations.sort((a, b) => b.rank - a.rank);

    const bestCandidate = stations[0];
    const toTurnOn = [];
    const toTurnOff = [];

    stations.forEach(({rank, station}) =>
    {
      if (rank <= 0)
      {
        if (station.lamp)
        {
          toTurnOff.push(station);
        }
      }
      else if (rank === bestCandidate.rank)
      {
        if (!station.lamp)
        {
          toTurnOn.push(station);
        }
      }
    });

    if (!toTurnOn.length && !toTurnOff.length)
    {
      this.trace('No lamps to change.');

      return done();
    }

    const lc = this;

    step(
      function()
      {
        toTurnOff.forEach(station =>
        {
          lc.trace('Turning lamp off.', {station});

          station.lamp = false;

          toggleLamp(station, this.group());
        });

        toTurnOn.forEach(station =>
        {
          lc.trace('Turning lamp on.', {station});

          station.lamp = true;

          toggleLamp(station, this.group());
        });
      },
      done
    );

    function toggleLamp(station, done)
    {
      const lampIp = lc.line.stations[station._id - 1].lampIp;
      const options = {
        method: 'GET',
        url: `http://${lampIp}/status.xml?out=${station.lamp ? 1 : 0}`,
        auth: {
          user: INVEO_USER,
          pass: INVEO_PASS,
          sendImmediately: true
        },
        proxy: null,
        followRedirect: false,
        timeout: INVEO_TIMEOUT
      };

      request(options, (err, res, body) =>
      {
        if (err)
        {
          lc.logger.error(err, 'Failed to toggle lamp.', {station});
        }

        done(null, typeof body === 'string' && body.includes('<out>'));
      });
    }
  }

  recordPce(station, durations)
  {
    durations.work = durations.total - durations.scheduled;

    const pce = new this.module.CtPce({
      line: this.line._id,
      station: station._id,
      cart: station.cart,
      order: station.order,
      pce: station.qtyDone,
      startedAt: station.pceStartedAt,
      finishedAt: station.pceFinishedAt,
      durations
    });

    pce.save(err =>
    {
      if (err)
      {
        this.logger.error(err, 'Failed to record pce.', {pce: pce.toJSON()});
      }
    });
  }
};

function createEmptyStation(sectionNo)
{
  return {
    _id: sectionNo,
    cart: null,
    order: createEmptyOrder(),
    qtyTodo: 0,
    qtyDone: 0,
    orderStartedAt: null,
    pceStartedAt: null,
    pceFinishedAt: null,
    durations: {
      total: 0,
      work: 0,
      downtime: 0,
      scheduled: 0
    },
    lamp: false,
    prev: null
  };
}

function createEmptyOrder()
{
  return {
    _id: null,
    pso: null,
    nc12: null,
    name: null,
    qty: 0,
    workerCount: 0,
    sapTaktTime: 0
  };
}
