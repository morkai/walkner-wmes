// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');
const MoxaRestLamps = require('./MoxaRestLamps');
const InveoLamps = require('./InveoLamps');

const FIRST_PCE_ELEVATOR_WINDOW = 60000;
const TODO_LIMIT = 25;

module.exports = class LineController
{
  constructor(app, module, line)
  {
    this.checkTodos = this.checkTodos.bind(this);

    this.module = module;
    this.line = line;
    this.broker = app.broker.sandbox();
    this.logger = module.logger.create({line: line._id});
    this.lamps = line.common && line.common.lampControllerIp
      ? new MoxaRestLamps(app, module, this)
      : new InveoLamps(app, module, this);

    this.destroyed = false;
    this.timers = {};
    this.updated = false;
    this.updatedAt = line.state && line.state.updatedAt || Date.now();
    this.updatedStations = {};
    this.stations = line.state && line.state.stations || {};
    this.medians = {};
    this.hasMoreTodos = false;
    this.checkingTodos = false;
    this.toggleLampsAt = 0;

    this.initialize();
  }

  destroy()
  {
    _.forEach(this.timers, timer => clearTimeout(timer));

    this.broker.destroy();
    this.lamps.destroy();

    this.destroyed = true;
  }

  trace(...args)
  {
    this.logger.debug(...args);
  }

  initialize()
  {
    const oldStations = this.stations;

    this.line.stations.forEach((station, i) =>
    {
      const stationNo = i + 1;

      this.stations[stationNo] = oldStations[stationNo] || createEmptyStation(stationNo);
      this.medians[stationNo] = [];
    });

    const lc = this;

    step(
      function()
      {
        const shiftOrders = [];

        _.forEach(lc.stations, station =>
        {
          if (station.order.pso)
          {
            shiftOrders.push(station.order.pso);
          }
        });

        if (!shiftOrders.length)
        {
          return;
        }

        const pipeline = [
          {$match: {'order.pso': {$in: shiftOrders}}},
          {$group: {
            _id: {
              pso: '$order.pso',
              station: '$station'
            },
            durations: {$addToSet: '$durations.work'}
          }}
        ];

        lc.module.CtPce.aggregate(pipeline, this.next());
      },
      function(err, results)
      {
        if (err)
        {
          lc.logger.error(err, 'Failed to aggregate the median.');

          return;
        }

        if (!results)
        {
          return;
        }

        const psoToDurations = {};

        results.forEach(result =>
        {
          result.durations.sort((a, b) => a - b);

          if (!psoToDurations[result._id.pso])
          {
            psoToDurations[result._id.pso] = {};
          }

          psoToDurations[result._id.pso][result._id.station] = result.durations;
        });

        _.forEach(lc.stations, station =>
        {
          const psoDurations = psoToDurations[station.order.pso];

          if (!psoDurations)
          {
            return;
          }

          const stationDurations = psoDurations[station._id];

          if (!stationDurations)
          {
            return;
          }

          lc.medians[station._id] = stationDurations;
          station.median = calcMedian(stationDurations);
        });
      },
      function()
      {
        lc.lamps.readLamps(this.next());
      },
      function()
      {
        lc.toggleLamps(this.next());
      },
      function()
      {
        lc.broker.subscribe('ct.todos.saved', lc.onTodoSaved.bind(lc));

        lc.broker.publish('ct.state.updated', {
          line: lc.line._id,
          updatedAt: lc.updatedAt,
          stations: lc.stations
        });

        lc.scheduleCheckTodos(1);
      }
    );
  }

  getState()
  {
    return {
      _id: this.line._id,
      updatedAt: this.updatedAt,
      stations: this.stations
    };
  }

  onTodoSaved(todo)
  {
    if (todo.line === this.line._id)
    {
      this.scheduleCheckTodos(1);
    }
  }

  scheduleCheckTodos(delay)
  {
    clearTimeout(this.timers.checkTodos);

    if (this.checkingTodos)
    {
      this.hasMoreTodos = true;

      return;
    }

    this.hasMoreTodos = false;
    this.timers.checkTodos = setTimeout(this.checkTodos, delay);
  }

  checkTodos()
  {
    if (this.checkingTodos)
    {
      return;
    }

    this.checkingTodos = true;
    this.hasMoreTodos = false;

    this.doCheckTodos();
  }

  doCheckTodos()
  {
    const conditions = {
      line: this.line._id
    };
    const sort = {
      line: 1,
      time: 1
    };

    this.module.CtTodo.find(conditions).sort(sort).limit(TODO_LIMIT + 1).lean().exec((err, todos) =>
    {
      if (err)
      {
        this.logger.error(err, 'Failed to check todos.');
      }

      this.updated = false;

      if (todos && todos.length > TODO_LIMIT)
      {
        this.hasMoreTodos = true;
      }

      this.handleNextTodo(todos || []);
    });
  }

  handleNextTodo(todos)
  {
    const lc = this;

    if (lc.destroyed)
    {
      return;
    }

    const todo = todos.shift();

    if (!todo)
    {
      lc.finishHandlingTodos();

      return;
    }

    step(
      function()
      {
        lc.handleTodo(todo, this.next());
      },
      function(err)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (lc.updatedStations && lc.lamps.shouldReadLamps())
        {
          lc.lamps.readLamps(this.next());
        }
      },
      function()
      {
        if (lc.updatedStations)
        {
          lc.toggleLamps(this.next());
        }
      },
      function()
      {
        if (!lc.updatedStations)
        {
          return;
        }

        const updatedStations = Object.values(lc.updatedStations);
        const $set = {};

        if (updatedStations.length === lc.line.stations.length)
        {
          $set.state = {
            updatedAt: lc.updatedAt,
            stations: lc.updatedStations
          };
        }
        else
        {
          $set['state.updatedAt'] = lc.updatedAt;

          updatedStations.forEach(station =>
          {
            $set[`state.stations.${station._id}`] = station;
          });
        }

        lc.module.CtLine.updateOne({_id: lc.line._id}, {$set}, this.next());
      },
      function(err)
      {
        if (err)
        {
          return this.skip(err);
        }

        lc.module.CtTodo.deleteOne({_id: todo._id}).exec(this.next());
      },
      function(err)
      {
        if (err)
        {
          lc.logger.error(err, 'Failed to handle todo.', {todo});

          lc.hasMoreTodos = false;
        }

        if (lc.updatedStations)
        {
          if (todo.time > Date.now() - 8 * 3600 * 1000)
          {
            lc.broker.publish('ct.state.updated', {
              line: lc.line._id,
              updatedAt: lc.updatedAt,
              stations: lc.updatedStations
            });
          }

          lc.updated = true;
          lc.updatedStations = null;
        }

        lc.handleNextTodo(todos);
      }
    );
  }

  finishHandlingTodos()
  {
    this.checkingTodos = false;

    this.scheduleCheckTodos(this.hasMoreTodos ? 1 : 15000);
  }

  handleTodo(todo, done)
  {
    this.trace('Handling todo...', {todo});

    switch (todo.action)
    {
      case 'reset':
        this.handleResetAction(todo, done);
        break;

      case 'input':
        this.handleInputAction(todo, done);
        break;

      case 'changeOrder':
      case 'correctOrder':
        this.handleOrderAction(todo, done);
        break;

      case 'cart':
        this.handleCartAction(todo, done);
        break;

      case 'sn':
        this.handleSnAction(todo, done);
        break;

      case 'pce-started':
        this.handlePceStartedAction(todo, done);
        break;

      case 'pce-finished':
        this.handlePceFinishedAction(todo, done);
        break;

      default:
      {
        this.logger.warn('Unknown action.', {todo: todo});

        done();
      }
    }
  }

  handleResetAction(todo, done)
  {
    _.forEach(this.stations, station =>
    {
      station = this.stations[station._id] = createEmptyStation(station._id);
      this.medians[station._id] = [];

      this.markUpdatedStation(station);
    });

    done();
  }

  handleInputAction(todo, done)
  {
    if (!todo.data.state)
    {
      this.trace('Ignored the elevator going down.', {todo});

      return done();
    }

    // Only the second station can initiate the PCE start by input
    if (todo.station !== 2)
    {
      this.trace('Ignored elevator going up on an invalid station.', {todo});

      return done();
    }

    this.startFirstPce(todo.time, null, done);
  }

  handleOrderAction(todo, done)
  {
    const lc = this;

    if (lc.line.type === 'luma2')
    {
      this.trace('Ignored order action: luma2.', {todo});

      return done();
    }

    const station = lc.stations[1];

    step(
      function()
      {
        lc.findOrderData(null, this.next());
      },
      function(err, newOrder)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!newOrder)
        {
          lc.logger.warn('Ignored order action: no latest order.', {station});

          return;
        }

        _.forEach(lc.stations, (station, n) =>
        {
          if (todo.action === 'changeOrder')
          {
            if (n === '1')
            {
              if (!station.pceStartedAt || station.pceFinishedAt)
              {
                lc.startFirstPce(todo.time, null, this.next());
              }
              else
              {
                lc.changeOrder(station, newOrder);
                lc.markUpdatedStation(station);
              }
            }
          }
          else if (todo.action === 'correctOrder')
          {
            if (station.order.pso === newOrder.pso)
            {
              station.order = newOrder;

              lc.trace('Order corrected.', {station});

              lc.markUpdatedStation(station);
            }
          }
        });

        if (todo.action === 'correctOrder')
        {
          lc.module.CtPce.updateMany(
            {'order.pso': newOrder.pso},
            {$set: {order: newOrder}},
            this.next()
          );
        }
      },
      done
    );
  }

  handleCartAction(todo, done)
  {
    if (todo.station === 1)
    {
      this.startFirstPce(todo.time, todo.data.cart, done);
    }
    else
    {
      this.startNextPce(todo.time, todo.station, todo.data.cart, done);
    }
  }

  handleSnAction(todo, done)
  {
    if (this.line.type === 'luma2')
    {
      this.trace('Ignored SN action: luma2.');

      return done();
    }

    const station = this.stations[todo.station];

    if (!station)
    {
      this.logger.warn('Ignored SN action: invalid station.');

      return done();
    }

    if (!station.pceStartedAt || station.pceFinishedAt)
    {
      this.logger.warn('Ignored SN action: invalid PCE.', {station});

      return done();
    }

    if (station.order._id !== todo.data.orderNo)
    {
      this.logger.warn('Ignored SN action: invalid order.', {station});
    }

    this.finishPce(station, todo.time, null, done);
  }

  handlePceStartedAction(todo, done)
  {
    const lc = this;
    const station = lc.stations[todo.station];

    lc.trace('Starting next PCE...', {
      stationNo: todo.station,
      orderNo: todo.data.orderNo,
      pce: todo.data.pce,
      startedAt: todo.time
    });

    if (!station)
    {
      lc.logger.warn('Ignored PCE started action: invalid station.');

      return done();
    }

    step(
      function()
      {
        const conditions = {
          orderId: todo.data.orderNo,
          startedAt: {
            $gte: new Date(todo.time.getTime() - 8 * 3600 * 1000),
            $lte: todo.time
          }
        };

        lc.findOrderData(conditions, this.next());
      },
      function(err, newOrder)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!newOrder)
        {
          lc.logger.warn('Ignored PCE started action: no order data.', {station});

          return this.skip();
        }

        if (station.order.pso !== newOrder.pso)
        {
          lc.changeOrder(station, newOrder);

          station.orderStartedAt = todo.time;
        }
      },
      function()
      {
        station.pceStartedAt = todo.time;
        station.pceFinishedAt = null;

        lc.markUpdatedStation(station);

        lc.trace('PCE started.', {station});
      },
      done
    );
  }

  handlePceFinishedAction(todo, done)
  {
    const lc = this;
    const station = lc.stations[todo.station];

    lc.trace('Finishing PCE...', {
      stationNo: todo.station,
      orderNo: todo.data.orderNo,
      pce: todo.data.pce,
      finishedAt: todo.time
    });

    if (!station)
    {
      lc.logger.warn('Ignored PCE finish action: invalid station.');

      return done();
    }

    if (todo.data.orderNo !== station.order._id)
    {
      lc.logger.warn('Ignored PCE finish action: invalid order no.');

      return done();
    }

    if (!station.pceStartedAt || station.pceFinishedAt)
    {
      lc.logger.warn('Ignored PCE finish action: invalid PCE times.');

      return done();
    }

    lc.finishPce(station, todo.time, todo.data.pce, done);
  }

  finishPce(station, finishedAt, qtyDone, done)
  {
    station.pceFinishedAt = finishedAt;

    if (qtyDone === null)
    {
      station.qtyDone += 1;
    }
    else
    {
      station.qtyDone = qtyDone;
    }

    const pceDurations = {
      total: station.pceFinishedAt - station.pceStartedAt,
      work: 0,
      downtime: 0,
      scheduled: 0
    };

    const lc = this;

    step(
      function()
      {
        const fields = {
          reason: 1,
          startedAt: 1,
          finishedAt: 1
        };

        lc.module.ProdDowntime
          .findOne({
            prodLine: lc.line._id,
            startedAt: {$lt: station.pceStartedAt}
          })
          .select(fields)
          .sort({startedAt: -1})
          .lean()
          .exec(this.parallel());

        lc.module.ProdDowntime
          .find({
            prodLine: lc.line._id,
            startedAt: {
              $gte: station.pceStartedAt,
              $lt: station.pceFinishedAt
            }
          })
          .select(fields)
          .sort({startedAt: 1})
          .lean()
          .exec(this.parallel());
      },
      function(err, prevDowntime, nextDowntimes)
      {
        if (err)
        {
          lc.logger.error(err, 'Failed to find downtimes while finishing a PCE.', {station});

          return;
        }

        const downtimes = new Map();

        if (prevDowntime)
        {
          downtimes.set(prevDowntime._id, prevDowntime);
        }

        nextDowntimes.forEach(dt => downtimes.set(dt._id, dt));

        downtimes.forEach(dt =>
        {
          if (!dt.finishedAt)
          {
            dt.finishedAt = new Date();
          }

          if (dt.finishedAt < station.pceStartedAt)
          {
            return;
          }

          if (dt.startedAt < station.pceStartedAt)
          {
            dt.startedAt = station.pceStartedAt;
          }

          if (dt.finishedAt > station.pceFinishedAt)
          {
            dt.finishedAt = station.pceFinishedAt;
          }

          const duration = dt.finishedAt - dt.startedAt;

          pceDurations.downtime += duration;

          if (lc.module.scheduledDowntimes.has(dt.reason))
          {
            pceDurations.scheduled += duration;
          }
        });

        pceDurations.work = pceDurations.total - pceDurations.scheduled;
      },
      function()
      {
        _.forEach(pceDurations, (value, key) =>
        {
          station.durations[key] += value;
        });

        sortedInsert(lc.medians[station._id], pceDurations.work);

        station.median = calcMedian(lc.medians[station._id]);

        lc.trace('PCE finished.', {station});

        lc.markUpdatedStation(station);

        lc.recordPce(station, pceDurations);
      },
      done
    );
  }

  markUpdatedStation(station)
  {
    if (!this.updatedStations)
    {
      this.updatedStations = {};
    }

    this.updatedStations[station._id] = station;
    this.updatedAt = Date.now();
  }

  startFirstPce(startedAt, cart, done)
  {
    const lc = this;

    lc.trace('Starting first PCE...', {startedAt, cart});

    step(
      function()
      {
        lc.findOrderData(null, this.next());
      },
      function(err, newOrder)
      {
        if (err)
        {
          return this.skip(err);
        }

        const station = lc.stations[1];

        if (!station)
        {
          lc.trace('Ignored first PCE: no stations defined.');

          return this.skip();
        }

        if (newOrder._id !== station.order._id)
        {
          lc.changeOrder(station, newOrder);
        }

        station.cart = cart;
        station.pceStartedAt = startedAt;
        station.pceFinishedAt = null;

        if (!station.orderStartedAt
          || (!cart && station.qtyDone === 0 && (Date.now() - station.orderStartedAt) <= FIRST_PCE_ELEVATOR_WINDOW))
        {
          station.orderStartedAt = station.pceStartedAt;
        }

        lc.trace('First PCE started.', {station});

        lc.markUpdatedStation(station);

        setImmediate(this.next());
      },
      done
    );
  }

  changeOrder(station, newOrder)
  {
    station.prev = {
      order: station.order,
      qtyTodo: station.qtyTodo,
      qtyDone: station.qtyDone,
      startedAt: station.orderStartedAt,
      finishedAt: station.pceFinishedAt,
      durations: station.durations,
      median: station.median
    };
    station.order = newOrder;

    if (station.pceStartedAt && !station.pceFinishedAt)
    {
      station.orderStartedAt = station.pceStartedAt;
    }
    else
    {
      station.orderStartedAt = null;
      station.pceStartedAt = null;
      station.pceFinishedAt = null;
    }

    station.qtyTodo = 0;
    station.qtyDone = 0;
    station.durations = {
      total: 0,
      work: 0,
      downtime: 0,
      scheduled: 0
    };
    station.median = 0;

    this.medians[station._id] = [];

    this.trace('Order changed.', {
      stationNo: station._id,
      oldOrder: station.prev.order._id,
      newOrder: station.order._id
    });
  }

  startNextPce(startedAt, stationNo, cart, done)
  {
    const lc = this;

    lc.trace('Starting next PCE...', {startedAt, stationNo, cart});

    const startedStation = lc.stations[stationNo];

    if (!startedStation)
    {
      lc.trace('Ignored next PCE: invalid station.', {stationNo});

      return done();
    }

    const finishedStation = lc.stations[stationNo - 1];

    if (!finishedStation.order._id)
    {
      lc.trace('Ignored next PCE: no order at previous station.', {stationNo});

      return done();
    }

    step(
      function()
      {
        if (finishedStation.pceFinishedAt)
        {
          return;
        }

        if (finishedStation.cart && finishedStation.cart !== cart)
        {
          lc.trace('Ignored PCE finish: invalid cart.', {
            stationNo,
            requiredCart: finishedStation.cart,
            actualCart: cart
          });

          return;
        }

        finishedStation.cart = cart;

        lc.finishPce(finishedStation, startedAt, null, this.next());
      },
      function()
      {
        const oldOrder = startedStation.order;
        const newOrder = {...finishedStation.order};

        if (newOrder._id !== oldOrder._id)
        {
          lc.changeOrder(startedStation, newOrder);
        }

        startedStation.cart = cart;
        startedStation.order = newOrder;
        startedStation.pceStartedAt = startedAt;
        startedStation.pceFinishedAt = null;

        if (!startedStation.orderStartedAt)
        {
          startedStation.orderStartedAt = startedAt;
        }

        lc.trace('Started next PCE.', {station: startedStation});

        lc.markUpdatedStation(startedStation);
      },
      done
    );
  }

  findOrderData(conditions, done)
  {
    this.module.ProdShiftOrder
      .findOne({
        prodLine: this.line._id,
        ...conditions
      })
      .select({
        orderId: 1,
        'orderData.nc12': 1,
        'orderData.name': 1,
        'orderData.qty': 1,
        workerCount: 1,
        sapTaktTime: 1
      })
      .sort({startedAt: -1})
      .lean()
      .exec((err, pso) =>
      {
        if (err)
        {
          return done(err);
        }

        if (!pso)
        {
          return done(null, createEmptyOrder());
        }

        done(null, {
          _id: pso.orderId,
          pso: pso._id,
          nc12: pso.orderData && pso.orderData.nc12 || '',
          name: pso.orderData && pso.orderData.name || '',
          qty: pso.orderData && pso.orderData.qty || 0,
          workerCount: pso.workerCount,
          sapTaktTime: pso.sapTaktTime
        });
      });
  }

  toggleLamps(done)
  {
    const lc = this;

    lc.trace('Toggling lamps...');

    const MIN_LAMP_QTY_DONE = 3;

    const candidates = _.map(lc.stations, station =>
    {
      const candidate = {station, lamp: 'off', rank: 0};

      if (station.qtyDone > MIN_LAMP_QTY_DONE)
      {
        const sapTaktTime = station.order.sapTaktTime * 1000;
        const medianTaktTime = station.median;

        candidate.rank = Math.round(medianTaktTime / sapTaktTime * 1000) / 1000;
      }

      return candidate;
    });

    candidates.sort((a, b) => b.rank - a.rank);

    if (candidates[0] >= 1)
    {
      candidates[0].lamp = 'red';
    }

    const orange = _.findLast(candidates, candidate => candidate.rank > 0 && candidate.rank < 1);

    if (orange)
    {
      orange.lamp = 'orange';
    }

    lc.trace('Candidates:', {
      candidates: candidates.map(c =>
      {
        return {station: c.station._id, lamp: c.lamp, rank: c.rank};
      })
    });

    const now = Date.now();
    const forceRequests = now - lc.toggleLampsAt > 300000;
    const stationsToWrite = [];

    lc.toggleLampsAt = now;

    candidates.forEach(({lamp, station}) =>
    {
      const changed = lamp !== station.lamp;

      if (changed)
      {
        lc.trace('Changing lamp...', {
          station: station._id,
          oldLamp: station.lamp,
          newLamp: lamp
        });

        station.lamp = lamp;

        lc.markUpdatedStation(station);
      }

      if (forceRequests || changed)
      {
        stationsToWrite.push(station);
      }
    });

    if (!stationsToWrite.length)
    {
      lc.trace('No lamps to change.');

      return done();
    }

    lc.trace('Writing lamps...', {
      stationsToWrite: stationsToWrite.map(s => ({_id: s._id, lamp: s.lamp}))
    });

    lc.lamps.writeLamps(stationsToWrite, done);
  }

  recordPce(station, durations)
  {
    durations.work = durations.total - durations.scheduled;

    const pce = new this.module.CtPce({
      line: this.line._id,
      station: station._id,
      cart: station.cart,
      order: station.order,
      pce: station.qtyDone,
      startedAt: station.pceStartedAt,
      finishedAt: station.pceFinishedAt,
      durations
    });

    pce.save(err =>
    {
      if (err)
      {
        this.logger.error(err, 'Failed to record pce.', {pce: pce.toJSON()});
      }
    });
  }
};

function createEmptyStation(stationNo)
{
  return {
    _id: stationNo,
    cart: null,
    order: createEmptyOrder(),
    qtyTodo: 0,
    qtyDone: 0,
    orderStartedAt: null,
    pceStartedAt: null,
    pceFinishedAt: null,
    durations: {
      total: 0,
      work: 0,
      downtime: 0,
      scheduled: 0
    },
    median: 0,
    lamp: 'off',
    prev: null
  };
}

function createEmptyOrder()
{
  return {
    _id: null,
    pso: null,
    nc12: null,
    name: null,
    qty: 0,
    workerCount: 0,
    sapTaktTime: 0
  };
}

function sortedInsert(sortedArray, newValue)
{
  if (sortedArray.length === 0)
  {
    sortedArray.push(newValue);

    return;
  }

  if (newValue < sortedArray[0])
  {
    sortedArray.unshift(newValue);

    return;
  }

  if (newValue >= sortedArray[sortedArray.length - 1])
  {
    sortedArray.push(newValue);

    return;
  }

  let minI = 0;
  let maxI = sortedArray.length - 1;
  let i = -1;
  let v = -1;

  while (minI <= maxI)
  {
    i = (minI + maxI) / 2 | 0;
    v = sortedArray[i];

    if (v < newValue)
    {
      minI = i + 1;
    }
    else if (v > newValue)
    {
      maxI = i - 1;
    }
    else
    {
      break;
    }
  }

  sortedArray.splice(v < newValue ? (i + 1) : i, 0, newValue);
}

function calcMedian(sortedArray)
{
  if (sortedArray.length === 0)
  {
    return 0;
  }

  if (sortedArray.length === 1)
  {
    return sortedArray[0];
  }

  if (sortedArray.length % 2 === 0)
  {
    return Math.round((sortedArray[sortedArray.length / 2 - 1] + sortedArray[sortedArray.length / 2]) / 2);
  }

  return sortedArray[(sortedArray.length + 1) / 2 - 1];
}
