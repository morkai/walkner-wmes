// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const step = require('h5.step');
const LineController = require('./LineController');

exports.DEFAULT_CONFIG = {
  mongooseId: 'mongoose',
  messengerServerId: 'messenger/server'
};

exports.models = [
  require('./models/ctLine'),
  require('./models/ctPce'),
  require('./models/ctTodo'),
  require('prodShiftOrders/models/prodShiftOrder'),
  require('prodDowntimes/models/prodDowntime'),
  require('downtimeReasons/models/downtimeReason')
];

exports.requiredModules = 'mongoose';

exports.optionalModules = {
  'messengerServer': require('./server')
};

exports.start = (app, module) =>
{
  const {
    DowntimeReason,
    CtLine
  } = module;

  const controllers = new Map();

  module.scheduledDowntimes = new Set();

  module.getAllLineState = (done) =>
  {
    const allLineState = Array.from(controllers.values()).map(c => c.getState());

    done(null, allLineState);
  };

  app.broker.subscribe('app.started', onAppStarted);
  app.broker.subscribe('ct.downtimeReasonUpdated', () => reloadScheduledDowntimes());
  app.broker.subscribe('ct.lines.added', onLineAdded);
  app.broker.subscribe('ct.lines.edited', onLineEdited);
  app.broker.subscribe('ct.lines.deleted', onLineDeleted);

  function onAppStarted()
  {
    step(
      function()
      {
        CtLine
          .find({active: true})
          .select({_id: 1})
          .lean()
          .exec(this.parallel());

        reloadScheduledDowntimes(this.parallel());
      },
      function(err, lines)
      {
        if (err)
        {
          module.error(err, 'Failed to load initial state.');

          setTimeout(onAppStarted, 5000);

          return;
        }

        lines.forEach(line => startLine(line._id));
      }
    );
  }

  function reloadScheduledDowntimes(done)
  {
    DowntimeReason.find({scheduled: true}).select({_id: 1}).lean().exec((err, reasons) =>
    {
      if (err)
      {
        if (done)
        {
          done(err);
        }
        else
        {
          module.error(err, 'Failed to reload scheduled downtimes.');
        }

        return;
      }

      module.scheduledDowntimes.clear();

      reasons.forEach(reason => module.scheduledDowntimes.add(reason._id));

      if (done)
      {
        done();
      }
    });
  }

  function onLineAdded({model})
  {
    startLine(model._id);
  }

  function onLineEdited({model})
  {
    stopLine(model._id);
    startLine(model._id);
  }

  function onLineDeleted({model})
  {
    stopLine(model._id);
  }

  function startLine(lineId)
  {
    CtLine.findById(lineId).exec((err, line) =>
    {
      if (controllers.has(lineId))
      {
        return module.warn('Not starting already started line.', {line: lineId});
      }

      if (err)
      {
        return module.error(err, 'Failed to start line.', {line: lineId});
      }

      if (!line)
      {
        return module.error(new Error('Line not found.'), 'Failed to start line.', {line: lineId});
      }

      if (!line.active)
      {
        return module.warn('Not starting inactive line.', {line: lineId});
      }

      module.info('Starting line....', {line: lineId});

      controllers.set(lineId, new LineController(app, module, line));
    });
  }

  function stopLine(lineId)
  {
    if (!controllers.has(lineId))
    {
      return module.warn('Not stopping already stopped line.', {line: lineId});
    }

    module.info('Stopping line...', {line: lineId});

    controllers.get(lineId).destroy();
    controllers.delete(lineId);
  }
};
