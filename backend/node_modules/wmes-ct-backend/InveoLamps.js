// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const net = require('net');
const _ = require('lodash');
const step = require('h5.step');

const INVEO_AUTH = 'YWRtaW46YWRtaW4wMA==';
const INVEO_TIMEOUT = 2500;

module.exports = class InveoLamps
{
  constructor(app, module, lc)
  {
    this.lc = lc;
    this.line = lc.line;
    this.logger = lc.logger;

    this.destroyed = false;
    this.timers = {};
    this.readLampsCallbacks = null;
    this.readLampsAt = 0;
  }

  destroy()
  {
    _.forEach(this.timers, timer => clearTimeout(timer));

    this.destroyed = true;
  }

  trace(...args)
  {
    this.lc.trace(...args);
  }

  shouldReadLamps()
  {
    return !this.timers.readLamps
      && (Date.now() - this.readLampsAt) > 300000;
  }

  readLamps(done)
  {
    const lamps = this;

    clearTimeout(lamps.timers.readLamps);

    if (lamps.readLampsCallbacks)
    {
      lamps.readLampsCallbacks.push(done);

      return;
    }

    lamps.trace('Reading lamps...');

    lamps.readLampsAt = Date.now();
    lamps.readLampsCallbacks = [done];

    step(
      function()
      {
        lamps.line.stations.forEach(station =>
        {
          readLamp(station.lampIp, this.group());
        });
      },
      function(err, lampStatuses) // eslint-disable-line handle-callback-err
      {
        (lampStatuses || []).forEach((lampStatus, i) =>
        {
          lamps.lc.stations[i + 1].lamp = lampStatus ? 'red' : 'off';
        });

        lamps.timers.readLamps = setTimeout(lamps.readLamps.bind(lamps), _.random(25000, 60000), _.noop);

        const callbacks = lamps.readLampsCallbacks;

        lamps.readLampsCallbacks = null;

        callbacks.forEach(done => done());
      }
    );

    function readLamp(lampIp, done)
    {
      if (!lampIp)
      {
        return done(null, false);
      }

      lamps.request(lampIp, '', (err, res) =>
      {
        const validResponse = res.includes('<out>');

        if (err)
        {
          lamps.logger.error(err, 'Failed to read lamp.', {lampIp});
        }
        else if (!validResponse)
        {
          lamps.logger.warn('Failed to read lamp: invalid response.', {lampIp, response: {
            body: res
          }});
        }

        done(null, validResponse && res.includes('<out>1</out>'));
      });
    }
  }

  writeLamps(stations, done)
  {
    const lamps = this;

    step(
      function()
      {
        stations.forEach(station => writeLamp(station, this.group()));
      },
      done
    );

    function writeLamp(station, done)
    {
      const lampIp = lamps.line.stations[station._id - 1].lampIp;

      if (!lampIp)
      {
        return done(null, true);
      }

      lamps.request(lampIp, `?out=${station.lamp === 'red' ? 1 : 0}`, (err, res) =>
      {
        const validResponse = res.includes('<out>');

        if (err)
        {
          lamps.logger.error(err, 'Failed to write lamp.', {lampIp});
        }
        else if (!validResponse)
        {
          lamps.logger.warn('Failed to write lamp: invalid response.', {lampIp, response: res});
        }

        done(null, validResponse);
      });
    }
  }

  request(lampIp, query, done)
  {
    const complete = _.once(finalize);
    const socket = net.connect(80, lampIp);
    const timerId = Date.now() + ':' + Math.random();
    const timers = this.timers;

    timers[timerId] = setTimeout(() => socket.destroy(), INVEO_TIMEOUT);

    let res = '';

    socket.once('connect', () =>
    {
      const req = [
        `GET /status.xml${query} HTTP/1.1`,
        `Host: ${lampIp}`,
        'Connection: close',
        `Authorization: Basic ${INVEO_AUTH}`,
        'Content-Length: 0',
        '',
        ''
      ];

      socket.write(req.join('\r\n'));
    });

    socket.on('data', data =>
    {
      res += data.toString();
    });

    socket.once('error', complete);
    socket.once('close', complete);

    function finalize(err)
    {
      clearTimeout(timers[timerId]);
      delete timers[timerId];
      done(err, res);
    }
  }
};
