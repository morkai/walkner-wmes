// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const {ObjectId} = require('mongoose').Types;
const step = require('h5.step');
const moment = require('moment');
const {formatTime} = require('util/dateFormatter');

module.exports = (app, module) =>
{
  const {express, user, PressWorksheet, LossReason, DowntimeReason} = module;

  const canView = user.auth('LOCAL', 'PROD_DATA:VIEW', 'PRESS_WORKSHEETS:VIEW');
  const canManage = user.auth('PRESS_WORKSHEETS:MANAGE', 'PROD_DATA:MANAGE');

  express.get(
    '/pressWorksheets',
    canView,
    limitToMine,
    express.crud.browseRoute.bind(null, app, PressWorksheet)
  );

  express.get('/pressWorksheets;export.:format?', canView, prepareExport, express.crud.exportRoute.bind(null, app, {
    filename: 'WORKSHEETS',
    freezeRows: 2,
    freezeColumns: 1,
    subHeader: true,
    subHeaderHeight: 145,
    subHeaderRotation: 90,
    subHeaderAlignmentH: 'Center',
    subHeaderAlignmentV: 'Bottom',
    columns: {
      rid: {width: 7, mergeV: 1},
      date: {type: 'date', mergeV: 1},
      shift: {type: 'integer', width: 4, mergeV: 1},
      type: {width: 10, mergeV: 1},
      shiftLeader: {width: 20, mergeV: 1},
      operator: {width: 20, mergeV: 1},
      no: {type: 'integer', width: 3, mergeV: 1},
      nc12: {width: 12, mergeV: 1},
      name: {width: 40, mergeV: 1},
      operationName: {width: 40, mergeV: 1},
      operationNo: {width: 4, mergeV: 1},
      division: {width: 5, mergeV: 1},
      machine: {width: 15, mergeV: 1},
      quantityDone: {type: 'integer', width: 6, mergeV: 1},
      startedAt: {width: 8, mergeV: 1},
      finishedAt: {width: 8, mergeV: 1},
      opWorkDuration: {width: 8, mergeV: 1},
      mmh: {type: 'decimal', width: 7, mergeV: 1},
      notes: {width: 40, mergeV: 1}
    },
    prepareColumn: (column, req) =>
    {
      if (column.name.startsWith('spacer'))
      {
        column.width = 5;
        column.caption = '';
        column.mergeV = 1;

        return;
      }

      column.type = 'integer';
      column.width = 3;

      if (column.name === 'loss.0')
      {
        column.mergeH = req.lossReasons.length - 1;
        column.caption = 'losses';
        column.headerAlignmentH = 'Center';
      }
      else if (column.name === 'downtime.0')
      {
        column.mergeH = req.downtimeReasons.length - 1;
        column.caption = 'downtimes';
        column.headerAlignmentH = 'Center';
      }
      else
      {
        column.caption = '';
      }
    },
    serializeStream: exportEntries,
    cleanUp: cleanUpExport,
    model: PressWorksheet
  }));

  express.get('/pressWorksheets;rid', canView, findByRidRoute);

  express.post(
    '/pressWorksheets',
    canManage,
    prepareDataForAdd,
    express.crud.addRoute.bind(null, app, PressWorksheet)
  );

  express.get(
    '/pressWorksheets/:id',
    canView,
    express.crud.readRoute.bind(null, app, PressWorksheet)
  );

  express.put(
    '/pressWorksheets/:id',
    canManage,
    prepareDataForEdit,
    express.crud.editRoute.bind(null, app, PressWorksheet)
  );

  express.delete(
    '/pressWorksheets/:id',
    canManage,
    express.crud.deleteRoute.bind(null, app, PressWorksheet)
  );

  function findByRidRoute(req, res, next)
  {
    const rid = parseInt(req.query.rid, 10);

    if (isNaN(rid) || rid <= 0)
    {
      return res.sendStatus(400);
    }

    PressWorksheet.findOne({rid: rid}, {_id: 1}).lean().exec((err, pressWorksheet) =>
    {
      if (err)
      {
        return next(err);
      }

      if (pressWorksheet)
      {
        return res.json(pressWorksheet._id);
      }

      return res.sendStatus(404);
    });
  }

  function prepareDataForAdd(req, res, next)
  {
    const date = new Date(`${req.body.date} 00:00:00`);

    if (req.body.shift === 1)
    {
      date.setHours(6);
    }
    else if (req.body.shift === 2)
    {
      date.setHours(14);
    }
    else
    {
      date.setHours(22);
    }

    req.body.date = date;
    req.body.createdAt = new Date();
    req.body.creator = user.createUserInfo(req.session.user, req);

    return next();
  }

  function prepareDataForEdit(req, res, next)
  {
    const date = new Date(`${req.body.date} 00:00:00`);

    if (req.body.shift === 1)
    {
      date.setHours(6);
    }
    else if (req.body.shift === 2)
    {
      date.setHours(14);
    }
    else
    {
      date.setHours(22);
    }

    req.body.date = date;
    req.body.updatedAt = new Date();
    req.body.updater = user.createUserInfo(req.session.user, req);

    PressWorksheet.findById(req.params.id, (err, pressWorksheet) =>
    {
      if (err)
      {
        return next(err);
      }

      req.model = pressWorksheet;

      return next();
    });
  }

  function limitToMine(req, res, next)
  {
    const selector = req.rql.selector;

    if (!Array.isArray(selector.args) || !selector.args.length)
    {
      return next();
    }

    const mineTerm = selector.args.find((term) => term.name === 'eq' && term.args[0] === 'mine');

    if (mineTerm)
    {
      mineTerm.args = ['creator.id', new ObjectId(req.session.user._id)];
    }

    return next();
  }

  function prepareExport(req, res, next)
  {
    req.rql.fields = {};

    step(
      function()
      {
        LossReason
          .find({}, {label: 1})
          .sort({position: 1})
          .lean()
          .exec(this.parallel());

        DowntimeReason
          .find({subdivisionTypes: {$in: ['press', 'paintShop']}}, {label: 1})
          .sort({opticsPosition: 1, pressPosition: 1})
          .lean()
          .exec(this.parallel());
      },
      function(err, lossReasons, downtimeReasons)
      {
        if (err)
        {
          return this.skip(err);
        }

        req.lossReasons = lossReasons;
        req.downtimeReasons = downtimeReasons;
      },
      next
    );
  }

  function cleanUpExport(req)
  {
    req.lossReasons = null;
    req.downtimeReasons = null;
  }

  function exportEntries(cursor, emitter, req)
  {
    const subHeader = {
      rid: '',
      date: '',
      shift: '',
      type: '',
      shiftLeader: '',
      operator: '',
      no: '',
      nc12: '',
      name: '',
      operationName: '',
      operationNo: '',
      division: '',
      machine: '',
      quantityDone: '',
      startedAt: '',
      finishedAt: '',
      opWorkDuration: '',
      mmh: '',
      notes: '',
      spacer: ''
    };

    req.lossReasons.forEach((reason, i) =>
    {
      subHeader[`loss.${i}`] = `${reason._id}: ${reason.label}`;
    });

    subHeader.spacer2 = '';

    req.downtimeReasons.forEach((reason, i) =>
    {
      subHeader[`downtime.${i}`] = `${reason._id}: ${reason.label}`;
    });

    emitter.emit('data', subHeader);

    cursor.on('error', err => emitter.emit('error', err));

    cursor.on('end', () => emitter.emit('end'));

    cursor.on('data', doc =>
    {
      doc.orders.forEach((order, i) => emitter.emit('data', exportOrder(doc, order, i + 1, req)));
    });
  }

  function exportOrder(doc, order, no, dictionaries)
  {
    const row = {
      rid: doc.rid,
      date: doc.date,
      shift: doc.shift,
      type: doc.type,
      shiftLeader: doc.master ? doc.master.label : '',
      operator: doc.operator ? doc.operator.label : '',
      no,
      nc12: order.nc12,
      name: order.name,
      operationName: order.operationName,
      operationNo: order.operationNo,
      division: order.division,
      machine: order.prodLine,
      quantityDone: order.quantityDone,
      startedAt: order.startedAt.length === 5 ? `${order.startedAt}:00` : formatTime(order.startedAt),
      finishedAt: order.finishedAt.length === 5 ? `${order.finishedAt}:00` : formatTime(order.finishedAt),
      opWorkDuration: order.opWorkDuration ? moment.utc(order.opWorkDuration * 3600000).format('HH:mm:ss') : '',
      mmh: 0,
      notes: order.notes,
      spacer1: ''
    };

    const operation = order.orderData.operations[order.operationNo];

    if (operation)
    {
      row.mmh = operation.machineTime / 100 * order.quantityDone;
    }

    const losses = {};
    const downtimes = {};

    order.losses.forEach(loss => losses[loss.reason] = loss.count);
    order.downtimes.forEach(downtime => downtimes[downtime.reason] = downtime.duration);

    dictionaries.lossReasons.forEach((reason, i) =>
    {
      row[`loss.${i}`] = losses[reason._id] || null;
    });

    row.spacer2 = '';

    dictionaries.downtimeReasons.forEach((reason, i) =>
    {
      row[`downtime.${i}`] = downtimes[reason._id] || null;
    });

    return row;
  }
};
