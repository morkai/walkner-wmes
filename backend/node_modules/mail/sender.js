// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const path = require('path');
const fs = require('fs');
const _ = require('lodash');
const step = require('h5.step');
const nodemailer = require('nodemailer');
const request = require('request');

const HEADERS = {
  to: 'to',
  cc: 'cc',
  bcc: 'bcc',
  from: 'from',
  replyto: 'replyTo',
  subject: 'subject',
  html: 'html'
};

exports.DEFAULT_CONFIG = {
  smtp: null,
  from: 'someone@the.net',
  bcc: '',
  replyTo: 'someone@the.net',
  expressId: 'express',
  secretKey: null,
  remoteSenderUrl: null,
  emailsPath: null,
  overrideFrom: false
};

exports.onModuleSetUp = (app, {module, setUpModule}) =>
{
  if (setUpModule.name === module.config.expressId)
  {
    setUpModule.config.noSessionPatterns.push(req => req.url === '/mail;send');
  }
};

exports.start = (app, module) =>
{
  if (module.config.smtp && module.config.remoteSenderUrl)
  {
    throw new Error('`smtp` and `remoteSenderUrl` cannot be used at the same time!');
  }

  if (!module.config.smtp && !module.config.remoteSenderUrl && !module.config.emailsPath)
  {
    module.warn('No `smtp`, `remoteSenderUrl` or `emailsPath` specified.');
  }

  const transport = module.config.smtp ? nodemailer.createTransport(module.config.smtp) : null;
  const recentlySentFromFile = {};

  app.broker.subscribe('directoryWatcher.changed')
    .setFilter((fileInfo) => /\.email$/.test(fileInfo.fileName))
    .on('message', sendFromFile);

  setInterval(cleanRecentlySentFromFile, 30 * 60 * 1000);

  /**
   * @param {(string|Array.<string>)} to
   * @param {string} subject
   * @param {string} text
   * @param {function((Error|null), Object)} done
   * @returns {undefined}
   */
  module.send = function(to, subject, text, done)
  {
    let mailOptions;

    if (arguments.length > 2)
    {
      mailOptions = {
        to: to,
        subject: subject,
        text: text
      };
    }
    else
    {
      mailOptions = to;
      done = subject;
    }

    if (_.isEmpty(mailOptions.to))
    {
      module.warn(`Not sending e-mail: empty recipients.`, {
        mailOptions: _.omit(mailOptions, ['html', 'text'])
      });

      return setImmediate(done);
    }

    _.defaults(mailOptions, {
      from: module.config.from,
      bcc: module.config.bcc,
      replyTo: module.config.replyTo
    });

    if (module.config.from && module.config.overrideFrom)
    {
      mailOptions.from = module.config.from;
    }

    if (module.config.remoteSenderUrl !== null)
    {
      sendThroughRemote(mailOptions, done);
    }
    else if (transport !== null)
    {
      sendThroughSmtp(mailOptions, done);
    }
    else if (module.config.emailsPath !== null)
    {
      sendThroughFile(mailOptions, done);
    }
    else
    {
      module.warn(`Not sending e-mail: no mode configured.`, {
        mailOptions: _.omit(mailOptions, ['html', 'text'])
      });

      setImmediate(done);
    }
  };

  function sendThroughRemote(mailOptions, done)
  {
    const options = {
      url: module.config.remoteSenderUrl,
      method: 'POST',
      json: true,
      body: {
        ...mailOptions,
        secretKey: module.config.secretKey
      }
    };

    request(options, (err, res) =>
    {
      if (res && res.statusCode !== 204)
      {
        err = new Error('INVALID_REMOTE_RESPONSE');
      }

      if (err)
      {
        module.error(err, `Failed to send e-mail.`, {
          mode: 'remote',
          mailOptions: _.omit(mailOptions, ['html', 'text'])
        });

        return done(err);
      }

      module.debug(`Sent e-mail.`, {
        mode: 'remote',
        mailOptions: _.omit(mailOptions, ['html', 'text'])
      });

      return done();
    });
  }

  function sendThroughSmtp(mailOptions, done)
  {
    transport.sendMail(mailOptions, err =>
    {
      if (err)
      {
        module.error(err, `Failed to send e-mail.`, {
          mode: 'smtp',
          mailOptions: _.omit(mailOptions, ['html', 'text'])
        });

        if (err.message.includes('550 5.1.1'))
        {
          err = null;
        }
      }
      else
      {
        module.debug(`Sent e-mail.`, {
          mode: 'smtp',
          mailOptions: _.omit(mailOptions, ['html', 'text'])
        });
      }

      done(err);
    });
  }

  function sendThroughFile(mailOptions, done)
  {
    const email = [];

    _.forEach(['subject', 'to', 'cc', 'bcc', 'from', 'replyTo'], header =>
    {
      if (!_.isEmpty(mailOptions[header]))
      {
        email.push(`${header}: ${mailOptions[header]}`);
      }
    });

    const htmlBody = _.isString(mailOptions.html) && !_.isEmpty(mailOptions.html);

    if (htmlBody)
    {
      email.push('html: 1');
    }

    email.push('Body:', mailOptions[htmlBody ? 'html' : 'text'] || '');

    step(
      function openFileStep()
      {
        const emailFileName = (Date.now() + Math.random() * 99999999).toString(36).toUpperCase() + '.email';

        fs.open(path.join(module.config.emailsPath, emailFileName), 'wx+', this.next());
      },
      function writeFileStep(err, fd)
      {
        if (err)
        {
          return this.done(done, err);
        }

        this.fd = fd;

        fs.write(fd, email.join('\r\n'), 0, 'utf8', this.next());
      },
      function closeFileStep(err)
      {
        const fd = this.fd;
        this.fd = null;

        if (err)
        {
          fs.close(fd, () => {});

          return done(err);
        }

        fs.close(fd, done);
      }
    );
  }

  function sendFromFile(fileInfo)
  {
    if (recentlySentFromFile[fileInfo.fileName])
    {
      return;
    }

    recentlySentFromFile[fileInfo.fileName] = Date.now();

    fs.readFile(fileInfo.filePath, 'utf8', (err, contents) =>
    {
      if (err)
      {
        return module.error(err, `Failed to read contents of file.`, {fileName: fileInfo.fileName});
      }

      let bodyIndex = contents.indexOf('Body:');

      if (bodyIndex === -1)
      {
        bodyIndex = contents.indexOf('body:');
      }

      const headers = contents.substring(0, bodyIndex).trim().split('\n');
      const body = contents.substring(bodyIndex + 'Body:'.length).trim();
      const mailOptions = {};

      _.forEach(headers, header =>
      {
        const colonIndex = header.indexOf(':');
        const headerName = HEADERS[header.substring(0, colonIndex).trim().toLowerCase()];
        const headerValue = header.substring(colonIndex + 1).trim();

        if (headerName)
        {
          mailOptions[headerName] = headerValue;
        }
      });

      if (mailOptions.html)
      {
        mailOptions.html = body;
      }
      else
      {
        mailOptions.text = body;
      }

      module.send(mailOptions, err =>
      {
        if (err)
        {
          module.error(err, `Failed to send email.`, {
            mode: 'file',
            fileName: fileInfo.fileName,
            mailOptions: _.omit(mailOptions, ['html', 'text'])
          });

          setTimeout(resendFromFile, 60000, fileInfo);
        }
        else
        {
          fs.unlink(fileInfo.filePath, err =>
          {
            if (err)
            {
              module.warn(err, 'Failed to remove e-mail file.', {fileInfo});
            }
          });
        }
      });
    });
  }

  function resendFromFile(fileInfo)
  {
    delete recentlySentFromFile[fileInfo.fileName];

    sendFromFile(fileInfo);
  }

  function cleanRecentlySentFromFile()
  {
    const halfHourAgo = Date.now() - 30 * 60 * 1000;

    _.forEach(recentlySentFromFile, (sentAt, fileName) =>
    {
      if (sentAt < halfHourAgo)
      {
        delete recentlySentFromFile[fileName];
      }
    });
  }

  app.onModuleReady(module.config.expressId, () =>
  {
    const express = app[module.config.expressId];

    express.options('/mail;send', (req, res) =>
    {
      res.set('Access-Control-Allow-Origin', '*');
      res.set('Access-Control-Allow-Headers', req.headers['access-control-request-headers'] || '');
      res.end();
    });

    express.post('/mail;send', (req, res, next) =>
    {
      res.set('Access-Control-Allow-Origin', '*');
      res.set('Access-Control-Allow-Headers', req.headers['access-control-request-headers'] || '');

      if (module.config.secretKey !== null && req.body.secretKey !== module.config.secretKey)
      {
        return next(app.createError('INVALID_SECRET_KEY', 401));
      }

      module.send(req.body, err =>
      {
        if (err)
        {
          module.error(err, 'Failed to send e-mail.', {
            mode: 'remote',
            mailOptions: _.omit(req.body, ['html', 'text'])
          });

          return next(err);
        }

        module.info(`Sent e-mail.`, {
          mode: 'remote',
          mailOptions: _.omit(req.body, ['html', 'text'])
        });

        res.sendStatus(204);
      });
    });
  });
};
