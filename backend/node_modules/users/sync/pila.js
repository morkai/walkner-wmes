// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const bcrypt = require('bcrypt');
const step = require('h5.step');
const {transliterate} = require('transliteration');
const {ObjectId} = require('mongoose').Types;

module.exports = async (app, module, options) =>
{
  const logger = module.logger.create({submodule: 'sync'});
  const mongoose = app[module.config.mongooseId];
  const User = mongoose.model('User');
  const OshWorkplace = mongoose.model('OshWorkplace');
  const OshDepartment = mongoose.model('OshDepartment');
  const OshBrigade = mongoose.model('OshBrigade');
  let tedious;

  return new Promise((resolve, reject) =>
  {
    try
    {
      tedious = require('tedious');
    }
    catch (err)
    {
      return reject(app.createError('No tedious module.', 'DEPENDENCY'));
    }

    if (!options.tediousConnection)
    {
      return reject(app.createError('No tedious config.', 'DEPENDENCY'));
    }

    sync((err, stats) =>
    {
      if (err)
      {
        reject(err);
      }
      else
      {
        resolve(stats);
      }
    });
  });

  function sync(done)
  {
    step(
      function()
      {
        const cursor = User
          .find({
            syncId: {$ne: ''},
            active: true
          })
          .select({
            syncId: 1,
            active: 1
          })
          .lean()
          .cursor();

        this.missingUsers = new Set();

        cursor.on('data', user =>
        {
          this.missingUsers.add(user._id.toString());
        });

        const next = _.once(this.next());

        cursor.on('error', next);
        cursor.on('end', next);
      },
      function()
      {
        this.conn = tedious.connect(options.tediousConnection);

        this.conn.on('error', err => logger.error(err, 'Tedious error.'));

        this.conn.on('connect', this.next());
      },
      function(err)
      {
        if (err)
        {
          return this.skip(err);
        }

        prepareMatchers(this.next());
      },
      function(err, matchers)
      {
        if (err)
        {
          return this.skip(err);
        }

        prepareNewUsers(this.conn, matchers, this.next());
      },
      function(err, newUsers)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (newUsers.length)
        {
          logger.debug('Found users.', {userCount: newUsers.length});
        }
        else
        {
          logger.debug('No users found.');
        }

        const stats = {
          created: 0,
          updated: 0,
          errors: 0
        };

        syncNextUser(stats, newUsers, 0, this.missingUsers, this.next());
      },
      function(err, stats)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!this.missingUsers.size)
        {
          return this.skip(null, stats);
        }

        logger.debug('Deactivating missing users...', {userCount: this.missingUsers.size});

        deactivateNextUser(stats, Array.from(this.missingUsers).map(id => new ObjectId(id)), this.next());
      },
      done
    );
  }

  function prepareMatchers(done)
  {
    const matchers = {
      departments: []
    };

    step(
      function()
      {
        OshWorkplace
          .find({})
          .select({
            division: 1
          })
          .lean()
          .exec(this.parallel());

        OshDepartment
          .find({})
          .select({
            workplace: 1,
            syncPatterns: 1
          })
          .lean()
          .exec(this.parallel());
      },
      function(err, workplaces, departments)
      {
        if (err)
        {
          return this.skip(err);
        }

        const workplaceToDivision = new Map();

        for (const workplace of workplaces)
        {
          workplaceToDivision.set(workplace._id, workplace.division);
        }

        for (const department of departments)
        {
          const data = {
            oshDivision: workplaceToDivision.get(department.workplace),
            oshWorkplace: department.workplace,
            oshDepartment: department._id
          };

          for (const syncPattern of department.syncPatterns.split('\n'))
          {
            const matcher = createMatcher(syncPattern, data);

            if (matcher)
            {
              matchers.departments.push(matcher);
            }
          }
        }

        done(null, matchers);
      }
    );
  }

  function createMatcher(pattern, data)
  {
    if (!pattern.startsWith('/') || !pattern.endsWith('/'))
    {
      if (!pattern.length)
      {
        return null;
      }

      pattern = preparePattern(pattern);

      return {
        data,
        match: input => input.includes(pattern)
      };
    }

    try
    {
      pattern = pattern.substring(1, pattern.length - 1);

      if (!pattern.length)
      {
        return null;
      }

      pattern = new RegExp(pattern, 'i');
    }
    catch (err)
    {
      logger.warn(err, 'Invalid pattern.', {pattern});

      return null;
    }

    return {
      data,
      match: input => pattern.test(input)
    };
  }

  function preparePattern(pattern)
  {
    return transliterate(pattern, {unknown: ''}).toUpperCase();
  }

  function createSelectUsersSql()
  {
    return `
      SELECT
        [nrpersonalny],
        [nazwisko],
        [imie],
        [firma],
        [podobszar],
        [dzial],
        [stanowisko],
        [email]
      FROM [vPersonalDataBHP]
    `;
  }

  function prepareNewUsers(conn, matchers, done)
  {
    const newUsers = [];

    const req = new tedious.Request(createSelectUsersSql(), err =>
    {
      conn.close();

      done(err, newUsers);
    });

    req.on('row', row =>
    {
      const personnelId = str(row[0].value);
      const newUser = {
        personnelId,
        lastName: str(row[1].value),
        firstName: str(row[2].value),
        email: str(row[7].value),
        syncId: personnelId,
        syncData: {
          company: str(row[3].value),
          workplace: str(row[4].value),
          department: str(row[5].value),
          jobTitle: str(row[6].value)
        }
      };

      applyMatcher(matchers.departments, newUser.syncData.department, newUser);

      newUsers.push(newUser);
    });

    conn.execSql(req);
  }

  function applyMatcher(matchers, input, newUser)
  {
    if (!input.length)
    {
      return;
    }

    input = preparePattern(input);

    const matcher = matchers.find(({match}) => match(input));

    if (matcher)
    {
      Object.assign(newUser, matcher.data);
    }
  }

  function syncNextUser(stats, newUsers, newUserI, missingUsers, done)
  {
    if (newUserI === newUsers.length)
    {
      return setImmediate(done, null, stats);
    }

    const newUser = newUsers[newUserI];

    step(
      function findUserModelStep()
      {
        if (!newUser.syncId)
        {
          return this.skip();
        }

        User
          .find({syncId: newUser.syncId})
          .exec(this.next());
      },
      function prepareUserModelStep(err, users)
      {
        if (err)
        {
          return this.skip(err);
        }

        users.forEach(user =>
        {
          missingUsers.delete(user._id.toString());
        });

        const newSearchName = User.prepareSearchName(newUser);
        const candidates = users.filter(u => u.searchName === newSearchName);
        let activeUser = candidates.find(u => u.active) || candidates[0];
        const inactiveUsers = activeUser && activeUser.active
          ? users.filter(u => u.active && u !== activeUser)
          : [];

        this.isNew = false;

        if (activeUser)
        {
          if (!newUser.email && activeUser.email)
          {
            newUser.email = activeUser.email;
          }

          activeUser.set(newUser);
        }
        else
        {
          this.isNew = true;

          activeUser = new User(newUser);
          activeUser.login = newUser.personnelId;
          activeUser.password = ']:->';
        }

        if (activeUser.gender === 'unknown')
        {
          activeUser.gender = /a$/i.test(activeUser.firstName) ? 'female' : 'male';
        }

        activeUser.active = true;

        this.activeUser = activeUser;
        this.inactiveUsers = inactiveUsers;
      },
      function hashPasswordStep()
      {
        if (this.isNew)
        {
          bcrypt.hash(this.activeUser.login, 10, this.next());
        }
      },
      function setPasswordHashStep(err, hash)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (hash)
        {
          this.activeUser.password = hash;
        }
      },
      function findExternalOrgUnit()
      {
        if (newUser.oshDepartment)
        {
          return;
        }

        OshBrigade
          .findOne({
            $or: [
              {'leader.id': this.activeUser._id.toString()},
              {'members.id': this.activeUser._id.toString()}
            ]
          })
          .select({
            _id: 0,
            leader: 1
          })
          .sort({date: -1})
          .exec(this.next());
      },
      function setExternalOrgUnit(err, brigade)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (brigade)
        {
          this.activeUser.oshDivision = brigade.leader.oshDivision;
          this.activeUser.oshWorkplace = brigade.leader.oshWorkplace;
          this.activeUser.oshDepartment = brigade.leader.oshDepartment;
        }

        this.activeUser.oshExternal = this.activeUser.syncData.workplace === 'ZEWN'
          && !/(philips|signify)/i.test(this.activeUser.syncData.company)
          && !/(philips|signify)/i.test(this.activeUser.syncData.department);
      },
      function deactivateExistingLoginStep()
      {
        for (const user of this.inactiveUsers)
        {
          user.active = false;
          user.save(this.group());
        }
      },
      function saveUserModelStep(err)
      {
        if (err)
        {
          return this.skip(err);
        }

        for (const user of this.inactiveUsers)
        {
          logger.debug('Deactivated a duplicate user.', {
            inactiveUser: user._id,
            activeUser: this.activeUser._id
          });

          app.broker.publish('users.edited', {model: user});
        }

        if (!this.isNew)
        {
          const modified = this.activeUser.modifiedPaths();

          if (!modified.length)
          {
            return this.skip();
          }
        }

        this.activeUser.save(this.next());
      },
      function handleActiveUserSaveStep(err)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (this.isNew)
        {
          ++stats.created;

          app.broker.publish('users.added', {model: this.activeUser});

          return;
        }

        ++stats.updated;

        app.broker.publish('users.edited', {model: this.activeUser});
      },
      function finalizeStep(err)
      {
        if (err)
        {
          return done(err);
        }

        setImmediate(syncNextUser, stats, newUsers, newUserI + 1, missingUsers, done);
      }
    );
  }

  function deactivateNextUser(stats, remaining, done)
  {
    const batch = remaining.splice(0, 25);

    step(
      function()
      {
        User.find({_id: {$in: batch}, active: true}).exec(this.next());
      },
      function(err, users)
      {
        if (err)
        {
          return this.skip(err);
        }

        users.forEach(u =>
        {
          u.active = false;
        });

        setImmediate(this.parallel(), null, users);

        User.collection.updateMany({_id: {$in: batch}}, {$set: {active: false}}, this.parallel());
      },
      function(err, users)
      {
        if (err)
        {
          return this.skip(err);
        }

        users.forEach(user =>
        {
          ++stats.updated;

          app.broker.publish('users.edited', {model: user});
        });
      },
      function(err)
      {
        if (err)
        {
          return done(err);
        }

        if (remaining.length)
        {
          setTimeout(deactivateNextUser, 30, stats, remaining, done);
        }
        else
        {
          done(null, stats);
        }
      }
    );
  }
};

function str(v)
{
  if (!v)
  {
    return '';
  }

  if (typeof v === 'string')
  {
    return v.replace(/\s+/, ' ').trim();
  }

  return v.toString();
}
