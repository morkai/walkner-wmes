// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const bcrypt = require('bcrypt');
const {transliterate} = require('transliteration');
const step = require('h5.step');

module.exports = async (app, module, options) =>
{
  const logger = module.logger.create({submodule: 'sync'});
  const companies = app[module.config.companiesId];
  const {User} = module;
  let tedious;

  const patternToCompany = new Map();

  if (companies)
  {
    companies.models.forEach(company =>
    {
      (company.syncPatterns || []).forEach(syncPattern =>
      {
        syncPattern = transliterate(syncPattern, {unknown: ''}).replace(/[^a-zA-Z0-9]+/g, '').toLowerCase();

        patternToCompany.set(syncPattern, company._id);
      });
    });
  }

  return new Promise((resolve, reject) =>
  {
    try
    {
      tedious = require('tedious');
    }
    catch (err)
    {
      return reject(app.createError('No tedious module.', 'DEPENDENCY'));
    }

    if (!options.tediousConnection)
    {
      return reject(app.createError('No tedious config.', 'DEPENDENCY'));
    }

    sync((err, stats) =>
    {
      if (err)
      {
        reject(err);
      }
      else
      {
        resolve(stats);
      }
    });
  });

  function sync(done)
  {
    step(
      function()
      {
        this.conn = tedious.connect(options.tediousConnection);

        this.conn.on('error', err => logger.error(err, 'Tedious error.'));

        this.conn.on('connect', this.next());
      },
      function(err)
      {
        if (err)
        {
          return this.skip(err);
        }

        prepareNewUsers(this.conn, this.next());
      },
      function(err, newUsers)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (newUsers.length)
        {
          logger.debug('Found users.', {userCount: newUsers.length});
        }
        else
        {
          logger.debug('No users found.');
        }

        const stats = {
          created: 0,
          updated: 0,
          errors: 0
        };

        syncNextUser(stats, newUsers, 0, this.next());
      },
      done
    );
  }

  function createSelectUsersSql()
  {
    return `
      SELECT
        US_CARDS_NUMBER_ACTIVE_STR,
        US_NAME,
        US_SURNAME,
        US_PERSONELLID,
        US_GROUP_NAME,
        US_SEX
      FROM USERS
      WHERE US_TYPE <> 2 AND US_PERSONELLID IS NOT NULL
      ORDER BY US_ID ASC
    `;
  }

  function prepareNewUsers(conn, done)
  {
    if (app.options.env === 'development')
    {
      try
      {
        const newUsers = JSON.parse(require('fs').readFileSync(`${app.options.rootPath}/../ket-users.json`, 'utf8'));

        return done(null, newUsers);
      }
      catch (err)
      {
        logger.error(err);
      }
    }

    const newUsers = new Map();

    const req = new tedious.Request(createSelectUsersSql(), err =>
    {
      conn.close();

      done(err, Array.from(newUsers.values()));
    });

    req.on('row', row =>
    {
      const personnelId = str(row[3].value);

      if (!personnelId)
      {
        return;
      }

      const company = str(row[4].value);
      const newUser = {
        personnelId,
        lastName: str(row[2].value),
        firstName: str(row[1].value),
        card: str(row[0].value),
        company: resolveCompany(company),
        gender: row[5].value === 67641345 ? 'female' : row[5].value === 67641346 ? 'male' : 'unknown',
        syncId: personnelId,
        syncData: {
          company
        }
      };

      if (!newUser.company
        || (newUser.firstName === 'Randstad' && newUser.lastName === 'Randstad'))
      {
        return;
      }

      newUsers.set(personnelId, newUser);
    });

    conn.execSql(req);
  }

  function resolveCompany(input)
  {
    input = transliterate(input, {unknown: ''}).replace(/[^a-zA-Z0-9]+/g, '').toLowerCase();

    return patternToCompany.get(input) || null;
  }

  function syncNextUser(stats, newUsers, newUserI, done)
  {
    if (newUserI === newUsers.length)
    {
      return setImmediate(done, null, stats);
    }

    const newUser = newUsers[newUserI];

    step(
      function findUserModelStep()
      {
        User
          .find({syncId: newUser.syncId})
          .exec(this.next());
      },
      function prepareUserModelStep(err, users)
      {
        if (err)
        {
          logger.error(err, 'Failed to find a user to sync.', {
            syncId: newUser.syncId
          });

          ++stats.errors;

          return this.skip();
        }

        const newSearchName = User.prepareSearchName(newUser);
        const candidates = users.filter(u => u.searchName === newSearchName);
        let activeUser = candidates.find(u => u.active) || candidates[0];
        const inactiveUsers = activeUser && activeUser.active
          ? users.filter(u => u.active && u !== activeUser)
          : [];

        this.isNew = false;

        if (activeUser)
        {
          activeUser.set(newUser);
        }
        else
        {
          this.isNew = true;

          activeUser = new User(newUser);
          activeUser.login = newUser.personnelId;
          activeUser.password = ']:->';
          activeUser.email = generateEmailAddress(module.config.emailGenerator, newUser);
        }

        if (activeUser.gender === 'unknown')
        {
          activeUser.gender = /a$/i.test(activeUser.firstName) ? 'female' : 'male';
        }

        this.activeUser = activeUser;
        this.inactiveUsers = inactiveUsers;
      },
      function hashPasswordStep()
      {
        if (this.isNew)
        {
          bcrypt.hash(this.activeUser.login, 10, this.next());
        }
      },
      function setPasswordHashStep(err, hash)
      {
        if (err)
        {
          logger.warn(err, `Failed to hash password.`);
        }

        if (hash)
        {
          this.activeUser.password = hash;
        }
      },
      function deactivateExistingLoginStep()
      {
        for (const user of this.inactiveUsers)
        {
          user.active = false;
          user.save(this.group());
        }
      },
      function saveUserModelStep(err)
      {
        if (err)
        {
          return this.skip(err);
        }

        for (const user of this.inactiveUsers)
        {
          logger.debug('Deactivated a duplicate user.', {
            inactiveUser: user._id,
            activeUser: this.activeUser._id
          });

          app.broker.publish('users.edited', {model: user});
        }

        if (!this.isNew)
        {
          const modified = this.activeUser.modifiedPaths();

          if (!modified.length)
          {
            return this.skip();
          }
        }

        this.activeUser.save(this.next());
      },
      function handleActiveUserSaveStep(err)
      {
        if (err)
        {
          logger.error(err, 'Failed to save an active user.', {
            userId: this.activeUser._id,
            syncId: this.activeUser.syncId
          });

          ++stats.errors;

          return;
        }

        if (this.isNew)
        {
          ++stats.created;

          app.broker.publish('users.added', {model: this.activeUser});

          return;
        }

        ++stats.updated;

        app.broker.publish('users.edited', {model: this.activeUser});
      },
      function finalizeStep(err)
      {
        if (err)
        {
          return done(err);
        }

        setImmediate(syncNextUser, stats, newUsers, newUserI + 1, done);
      }
    );
  }
};

function generateEmailAddress(generator, user)
{
  return !generator ? '' : generator({
    firstName: transliterate(user.firstName, {unknown: ''}).toLowerCase(),
    lastName: transliterate(user.lastName, {unknown: ''}).toLowerCase(),
    personnelId: user.personnelId,
    company: user.syncData.company.toUpperCase()
  });
}

function str(v)
{
  if (!v)
  {
    return '';
  }

  if (typeof v === 'string')
  {
    return v.trim();
  }

  return v.toString();
}
