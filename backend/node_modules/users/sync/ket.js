// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const bcrypt = require('bcrypt');
const {transliterate} = require('transliteration');
const step = require('h5.step');

module.exports = async (app, module, options) =>
{
  const logger = module.logger.create({submodule: 'sync'});
  const companies = app[module.config.companiesId];
  const mongoose = app[module.config.mongooseId];
  const User = mongoose.model('User');
  let tedious;

  return new Promise((resolve, reject) =>
  {
    try
    {
      tedious = require('tedious');
    }
    catch (err)
    {
      return reject(app.createError('No tedious module.', 'DEPENDENCY'));
    }

    if (!options.tediousConnection)
    {
      return reject(app.createError('No tedious config.', 'DEPENDENCY'));
    }

    sync((err, stats) =>
    {
      if (err)
      {
        reject(err);
      }
      else
      {
        resolve(stats);
      }
    });
  });

  function sync(done)
  {
    step(
      function()
      {
        this.conn = tedious.connect(options.tediousConnection);

        this.conn.on('error', err => logger.error(err, 'Tedious error.'));

        this.conn.on('connect', this.next());
      },
      function(err)
      {
        if (err)
        {
          return this.skip(err);
        }

        prepareNewUsers(this.conn, this.next());
      },
      function(err, newUsers)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (newUsers.length)
        {
          logger.debug('Found users.', {userCount: newUsers.length});
        }
        else
        {
          logger.debug('No users found.');
        }

        const stats = {
          created: 0,
          updated: 0,
          errors: 0
        };

        syncNextUser(stats, newUsers, 0, this.next());
      },
      done
    );
  }

  function createSelectUsersSql()
  {
    let sql = `
      SELECT
        [CARDS].[CA_NUMBER],
        [USERS].[US_NAME],
        [USERS].[US_SURNAME],
        [USERS].[US_PERSONELLID],
        [USERS].[US_ADD_FIELDS]
      FROM [USERS]
      LEFT JOIN [CARDS] ON [USERS].[US_CARD_ID]=[CARDS].[CA_ID]
      WHERE [USERS].[US_ACTIVE]=1
    `;

    const where = [];

    if (companies)
    {
      companies.models.forEach(companyModel =>
      {
        const companyId = companyModel._id.replace(/'/g, "\\'");

        where.push(`[USERS].[US_ADD_FIELDS] LIKE '10001&${companyId}&%'`);
      });
    }

    if (where.length)
    {
      sql += ` AND (${where.join(' OR ')}) `;
    }

    sql += ' ORDER BY [USERS].[US_ID]';

    return sql;
  }

  function prepareNewUsers(conn, done)
  {
    if (0 && app.options.env === 'development')
    {
      try
      {
        const newUsers = JSON.parse(require('fs').readFileSync(`${app.options.rootPath}/../ket-users.json`, 'utf8'));

        return done(null, newUsers);
      }
      catch (err)
      {
        logger.error(err);
      }
    }

    const newUsers = new Map();

    const req = new tedious.Request(createSelectUsersSql(), err =>
    {
      conn.close();

      done(err, Array.from(newUsers.values()));
    });

    req.on('row', row =>
    {
      const personnelId = str(row[3].value);

      if (!personnelId)
      {
        return;
      }

      const addFields = parseAddFields(row[4].value);
      const company = str(addFields['10001']);
      const newUser = {
        personnelId,
        lastName: str(row[2].value),
        firstName: str(row[1].value),
        card: str(row[0].value),
        company: company || null,
        syncId: personnelId,
        syncData: {
          company,
          division: str(addFields['10003']),
          jobTitle: str(addFields['10004'])
        }
      };

      const oldUser = newUsers.get(personnelId);

      if (!oldUser)
      {
        newUsers.set(personnelId, newUser);

        return;
      }

      const oldScore = 0
        + !!oldUser.card
        + !!oldUser.company
        + !!oldUser.syncData.division
        + !!oldUser.syncData.jobTitle;
      const newScore = 0
        + !!newUser.card
        + !!newUser.company
        + !!newUser.syncData.division
        + !!newUser.syncData.jobTitle;

      if (newScore > oldScore)
      {
        newUsers.set(personnelId, newUser);
      }
    });

    conn.execSql(req);
  }

  function syncNextUser(stats, newUsers, newUserI, done)
  {
    if (newUserI === newUsers.length)
    {
      return setImmediate(done, null, stats);
    }

    const newUser = newUsers[newUserI];

    step(
      function findUserModelStep()
      {
        User
          .find({syncId: newUser.syncId})
          .exec(this.next());
      },
      function prepareUserModelStep(err, users)
      {
        if (err)
        {
          logger.error(err, 'Failed to find a user to sync.', {
            syncId: newUser.syncId
          });

          ++stats.errors;

          return this.skip();
        }

        const newSearchName = User.prepareSearchName(newUser);
        const candidates = users.filter(u => u.searchName === newSearchName);
        let activeUser = candidates.find(u => u.active) || candidates[0];
        const inactiveUsers = activeUser && activeUser.active
          ? users.filter(u => u.active && u !== activeUser)
          : [];

        this.isNew = false;

        if (activeUser)
        {
          activeUser.set(newUser);
        }
        else
        {
          this.isNew = true;

          activeUser = new User(newUser);
          activeUser.login = newUser.personnelId;
          activeUser.password = ']:->';
          activeUser.email = generateEmailAddress(module.config.emailGenerator, newUser);
        }

        if (activeUser.gender === 'unknown')
        {
          activeUser.gender = /a$/i.test(activeUser.firstName) ? 'female' : 'male';
        }

        this.activeUser = activeUser;
        this.inactiveUsers = inactiveUsers;
      },
      function hashPasswordStep()
      {
        if (this.isNew)
        {
          bcrypt.hash(this.activeUser.login, 10, this.next());
        }
      },
      function setPasswordHashStep(err, hash)
      {
        if (err)
        {
          logger.warn(err, `Failed to hash password.`);
        }

        if (hash)
        {
          this.activeUser.password = hash;
        }
      },
      function deactivateExistingLoginStep()
      {
        for (const user of this.inactiveUsers)
        {
          user.active = false;
          user.save(this.group());
        }
      },
      function saveUserModelStep(err)
      {
        if (err)
        {
          return this.skip(err);
        }

        for (const user of this.inactiveUsers)
        {
          logger.debug('Deactivated a duplicate user.', {
            inactiveUser: user._id,
            activeUser: this.activeUser._id
          });

          app.broker.publish('users.edited', {model: user});
        }

        if (!this.isNew)
        {
          const modified = this.activeUser.modifiedPaths();

          if (!modified.length)
          {
            return this.skip();
          }
        }

        this.activeUser.save(this.next());
      },
      function handleActiveUserSaveStep(err)
      {
        if (err)
        {
          logger.error(err, 'Failed to save an active user.', {
            userId: this.activeUser._id,
            syncId: this.activeUser.syncId
          });

          ++stats.errors;

          return;
        }

        if (this.isNew)
        {
          ++stats.created;

          app.broker.publish('users.added', {model: this.activeUser});

          return;
        }

        ++stats.updated;

        app.broker.publish('users.edited', {model: this.activeUser});
      },
      function finalizeStep(err)
      {
        if (err)
        {
          return done(err);
        }

        setImmediate(syncNextUser, stats, newUsers, newUserI + 1, done);
      }
    );
  }
};

function parseAddFields(addFields)
{
  if (!_.isString(addFields) || _.isEmpty(addFields))
  {
    return {};
  }

  const addFieldList = addFields.split('&');
  const addFieldMap = {};

  for (let i = 0, l = addFieldList.length; i < l; i += 2)
  {
    const key = addFieldList[i].trim();

    if (key == null || key === '')
    {
      continue;
    }

    addFieldMap[key] = addFieldList[i + 1].trim();
  }

  return addFieldMap;
}

function generateEmailAddress(generator, user)
{
  return !generator ? '' : generator({
    firstName: transliterate(user.firstName, {unknown: ''}).toLowerCase(),
    lastName: transliterate(user.lastName, {unknown: ''}).toLowerCase(),
    personnelId: user.personnelId,
    company: user.syncData.company.toUpperCase()
  });
}

function str(v)
{
  if (!v)
  {
    return '';
  }

  if (typeof v === 'string')
  {
    return v.trim();
  }

  return v.toString();
}
