// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const fs = require('fs-extra');
const _ = require('lodash');
const step = require('h5.step');

module.exports = (app, module, req, res) =>
{
  const {mongoose, user, User} = module;

  const modelsToUpdate = {
    BehaviorObsCard: {
      condition: ['users'],
      update: ['creator', 'updater', 'observer', 'superior']
    },
    D8Area: {
      condition: ['manager']
    },
    D8Entry: {
      condition: ['observers.user', 'changes.user'],
      update: ['creator', 'updater', 'owner', 'manager', 'members', 'observers.user', 'changes.user']
    },
    Event: {
      condition: ['user'],
      update: ['user'],
      custom: anonymizeEvents
    },
    FteLeaderEntry: {
      condition: ['creator', 'updater']
    },
    FteMasterEntry: {
      condition: ['creator', 'updater']
    },
    HourlyPlan: {
      condition: ['creator', 'updater']
    },
    InvalidOrder: {
      condition: ['updater']
    },
    IsaEvent: {
      condition: ['user', 'data.responder']
    },
    IsaRequest: {
      condition: ['requester', 'responder', 'finisher']
    },
    IsaShiftPersonnel: {
      condition: ['users+']
    },
    KaizenOrder: {
      condition: ['finisher', 'observers.user', 'changes.user'],
      update: [
        'creator',
        'updater',
        'confirmer',
        'finisher',
        'nearMissOwners',
        'suggestionOwners',
        'kaizenOwners',
        'owners',
        'observers.user',
        'changes.user'
      ]
    },
    KaizenProductFamily: {
      condition: ['owners']
    },
    MinutesForSafetyCard: {
      condition: ['users'],
      update: [
        'creator',
        'updater',
        'owner',
        'orgPropositions.who',
        'techPropositions.who',
        'participants'
      ]
    },
    OpinionSurvey: {
      condition: ['superiors'],
      update: ['superiors.full!', 'superiors.short!'],
      custom: anonymizeOpinionSurveys
    },
    OpinionSurveyAction: {
      condition: ['creator', 'updater', 'participants'],
      update: ['creator', 'updater', 'owners', 'superior']
    },
    OpinionSurveyResponse: {
      condition: ['creator']
    },
    Order: {
      condition: ['changes.user']
    },
    DrillingEvent: {
      condition: ['user']
    },
    PlanChange: {
      condition: ['user']
    },
    PressWorksheet: {
      condition: ['creator', 'updater', 'master', 'operator', 'operators']
    },
    // TODO Data?
    ProdChangeRequest: {
      condition: ['creator', 'confirmer']
    },
    ProdDowntime: {
      condition: ['corroborator', 'creator', 'master', 'leader', 'operator', 'operators', 'changes.user']
    },
    ProdDowntimeAlert: {
      condition: ['usedObjects'],
      update: ['userWhitelist+', 'userBlacklist+', 'usedObjects', 'actions.userWhitelist+', 'actions.userBlacklist+']
    },
    ProdLogEntry: {
      condition: ['creator'],
      custom: anonymizeProdLogEntries
    },
    ProdShift: {
      condition: ['creator', 'master', 'leader', 'operator', 'operators']
    },
    ProdShiftOrder: {
      condition: ['creator', 'master', 'leader', 'operator', 'operators']
    },
    PscsResult: {
      condition: ['creator', 'user']
    },
    PurchaseOrder: {
      condition: ['changes.user', 'user']
    },
    PurchaseOrderPrint: {
      condition: ['printedBy', 'cancelledBy']
    },
    QiResult: {
      condition: ['users'],
      update: ['creator', 'updater', 'inspector', 'nokOwner', 'leader', 'correctiveActions.who+']
    },
    Setting: {
      condition: ['updater']
    },
    Suggestion: {
      condition: ['finisher', 'observers.user', 'changes.user'],
      update: [
        'creator',
        'updater',
        'confirmer',
        'finisher',
        'suggestionOwners',
        'kaizenOwners',
        'owners',
        'observers.user',
        'changes.user'
      ]
    }
  };

  req.setTimeout(0);

  const userId = req.params.id;

  module.info(`[anonymize] [${userId}] Started...`);

  step(
    function()
    {
      User.anonymize(userId, this.next());
    },
    function(err, userModel)
    {
      if (err)
      {
        return this.skip(err);
      }

      if (userModel)
      {
        app.broker.publish('users.edited', {
          user: user.createUserInfo(req.session.user, req),
          model: userModel
        });
      }

      anonymizeNextModel(userId, Object.keys(modelsToUpdate), modelsToUpdate, this.next());
    },
    function(err)
    {
      if (err)
      {
        module.error(`[anonymize] [${userId}] ${err.message}`);
      }
      else
      {
        module.info(`[anonymize] [${userId}] Finished!`);
      }

      res.sendStatus(204);
    }
  );


  function anonymizeEvents(Event, userId, done)
  {
    const $set = {};
    const data = User.anonymizeData(userId);

    Object.keys(data).forEach(prop =>
    {
      $set[`data.model.${prop}`] = data[prop];
    });

    Event.collection.updateMany(
      {type: /^users/, 'data.model._id': userId},
      {$set},
      done
    );
  }

  function anonymizeOpinionSurveys(OpinionSurvey, userId, done)
  {
    if (!app.opinionSurveys || !app.opinionSurveys.config)
    {
      return done();
    }

    fs.emptyDir(app.opinionSurveys.config.surveysPath, done);
  }

  function anonymizeProdLogEntries(ProdLogEntry, userId, done)
  {
    const conditions = {
      type: {$in: ['changeMaster', 'changeLeader', 'changeOperator']},
      'data.id': userId
    };
    const update = {$set: {
      'data.label': '?'
    }};

    ProdLogEntry.collection.updateMany(conditions, update, done);
  }

  function anonymizeNextModel(userId, modelQueue, modelsToUpdate, done)
  {
    if (modelQueue.length === 0)
    {
      return done();
    }

    const modelName = modelQueue.shift();
    const {condition, update, custom} = modelsToUpdate[modelName];
    let Model = null;

    try
    {
      Model = mongoose.model(modelName);
    }
    catch (err)
    {
      return setImmediate(anonymizeNextModel, userId, modelQueue, modelsToUpdate, done);
    }

    const conditions = {$or: []};
    const updates = [];
    const fields = {};

    condition.forEach(prop =>
    {
      if (prop === 'users')
      {
        conditions.$or.push({users: userId});
      }
      else
      {
        conditions.$or.push({[`${prop.replace(/[+!]+/g, '')}.id`]: userId});

        if (!update)
        {
          updates.push(createAnonymizeUpdate(prop, userId));

          fields[prop.replace(/[+!]+/g, '').split('.')[0]] = 1;
        }
      }
    });

    (update || []).forEach(prop =>
    {
      updates.push(createAnonymizeUpdate(prop, userId));

      fields[prop.replace(/[+!]+/g, '').split('.')[0]] = 1;
    });

    module.info(`[anonymize] [${userId}] ${modelName}...`);

    step(
      function()
      {
        anonymizeNextBatch(Model, conditions, fields, updates, this.group());

        if (typeof custom === 'function')
        {
          custom(Model, userId, this.group());
        }
      },
      function(err)
      {
        if (err)
        {
          module.warn(`[anonymize] [${userId}] Failed to anonymize: ${err.message}\n${JSON.stringify(conditions)}`);
        }

        setImmediate(anonymizeNextModel, userId, modelQueue, modelsToUpdate, done);
      }
    );
  }

  function createAnonymizeUpdate(prop, userId)
  {
    const path = prop.replace(/[+!]+/g, '').split('.');
    const modifier = prop.endsWith('!')
      ? '!'
      : prop.endsWith('+')
        ? '+'
        : '';
    const isList = modifier === '+' || path[0].endsWith('s');
    const isDirect = modifier === '!';

    return model =>
    {
      let o = model[path[0]];

      if (!o)
      {
        return;
      }

      if ((isList && !Array.isArray(o)) || (!isList && Array.isArray(o)))
      {
        return;
      }

      if (path.length > 1 && !isDirect)
      {
        o = o[path[1]];
      }

      if (!o)
      {
        return;
      }

      if (isList)
      {
        o.forEach(user =>
        {
          if ((user.id !== userId) && (user._id !== userId))
          {
            return;
          }

          if (user.label)
          {
            user.label = '?';
          }

          if (isDirect && user[path[1]])
          {
            user[path[1]] = '?';
          }
        });
      }
      else if (o.id === userId || o._id === userId)
      {
        if (o.label)
        {
          o.label = '?';
        }

        if (isDirect && o[path[1]])
        {
          o[path[1]] = '?';
        }
      }
    };
  }

  function anonymizeNextBatch(Model, conditions, fields, updates, done)
  {
    const cursor = Model.find(conditions, fields).lean().cursor({batchSize: 10});
    const complete = _.once(done);

    cursor.once('error', complete);
    cursor.once('end', complete);
    cursor.on('data', model =>
    {
      updates.forEach(update => update(model));

      Model.collection.updateOne({_id: model._id}, {$set: model}, () => {});
    });
  }
};
