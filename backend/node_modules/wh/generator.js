// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const {createHash} = require('crypto');
const _ = require('lodash');
const moment = require('moment');
const step = require('h5.step');
const jsonDeepEqual = require('util/jsonDeepEqual');

const TOPIC_PREFIX = 'old.wh.generator';
const DEFAULT_SETTINGS = {
  ignoredMrps: [],
  groupDuration: 2,
  groupExtraItems: 5
};
const ORDER_COMPARE_PROPS = [
  'date',
  'qty',
  'startTime',
  'finishTime',
  'group',
  'line',
  'lines',
  'redirLine',
  'redirLines',
  'psStatus',
  'drilling'
];
const IGNORE_DELIVERED_PROPS = {
  line: true,
  lines: true,
  redirLine: true,
  redirLines: true
};

module.exports = (app, module) =>
{
  if (!module.config.generator)
  {
    return;
  }

  const {
    settings,
    Order,
    OldWhOrder: WhOrder,
    OldWhLine: WhLine,
    OldWhPlanChange: WhPlanChange,
    Plan,
    PlanSettings
  } = module;

  const logger = module.logger.create({submodule: 'generator'});

  const generatorQueue = [];
  let generatorState = null;
  let generatorTimer = null;

  app.broker.subscribe(`${TOPIC_PREFIX}.requested`, handleRequest);
  app.broker.subscribe('paintShop.generator.finished', handleRequest);
  app.broker.subscribe('settings.updated.wh.planning.**', generateActivePlans);

  function handleRequest(message)
  {
    if (message.date)
    {
      const date = moment.utc(message.date, 'YYYY-MM-DD');

      if (date.isValid())
      {
        generatePlan(date.toDate());
      }
    }
    else
    {
      generateActivePlans();
    }
  }

  function createPlanGeneratorState(key)
  {
    const date = moment.utc(key, 'YYYY-MM-DD');

    return {
      key,
      date: date.toDate(),
      cancelled: false,
      logger: logger.create({key}),
      newGrouping: date.isAfter(moment.utc('2020-09-30'))
    };
  }

  function generateActivePlans()
  {
    const now = moment();
    const from = moment.utc(now.format('YYYY-MM-DD'), 'YYYY-MM-DD');

    if (now.hours() < 6)
    {
      from.subtract(1, 'days');
    }

    Plan.find({_id: {$gt: from}}, {_id: 1}).lean().exec((err, plans) =>
    {
      if (err)
      {
        logger.error(err, `Failed to find active plans.`);
      }

      plans.forEach(plan => generatePlan(moment.utc(plan._id).format('YYYY-MM-DD')));
    });
  }

  function generatePlan(date)
  {
    const dateMoment = moment.utc(date, 'YYYY-MM-DD').startOf('day');

    if (!dateMoment.isValid())
    {
      return;
    }

    const planKey = dateMoment.format('YYYY-MM-DD');

    if (!generatorQueue.includes(planKey))
    {
      generatorQueue.push(planKey);

      app.broker.publish(`${TOPIC_PREFIX}.started`, {
        date: planKey
      });
    }

    if (generatorState !== null)
    {
      generatorState.logger.info('Cancelling...');

      generatorState.cancelled = true;

      return;
    }

    if (generatorTimer !== null)
    {
      clearTimeout(generatorTimer);
    }

    generatorTimer = setTimeout(generateNextPlan, 1);
  }

  function generateNextPlan()
  {
    if (generatorState)
    {
      return;
    }

    const planKey = generatorQueue.sort((a, b) => a.localeCompare(b)).shift();

    if (!planKey)
    {
      return;
    }

    generatorTimer = null;
    generatorState = createPlanGeneratorState(planKey);

    tryGeneratePlan(generatorState, () =>
    {
      if (generatorState.cancelled && !generatorQueue.includes(planKey))
      {
        generatorQueue.push(planKey);
      }

      generatorState = null;

      if (generatorTimer !== null)
      {
        clearTimeout(generatorTimer);
      }

      generatorTimer = setTimeout(generateNextPlan, 1);
    });
  }

  function tryGeneratePlan(state, done)
  {
    const startedAt = Date.now();

    state.logger.info(`Generating...`);

    step(
      function()
      {
        settings.findValues({_id: /^wh\.planning/}, 'wh.planning.', this.parallel());

        PlanSettings
          .findById(state.date).select({
            requiredStatuses: 1,
            ignoredStatuses: 1
          })
          .lean()
          .exec(this.parallel());

        Plan.aggregate([
          {$match: {_id: state.date}},
          {$unwind: '$lines'},
          {$unwind: '$lines.orders'},
          {$project: {
            _id: 0,
            line: '$lines._id',
            order: '$lines.orders.orderNo',
            quantity: '$lines.orders.quantity',
            pceTime: '$lines.orders.pceTime',
            startAt: '$lines.orders.startAt',
            finishAt: '$lines.orders.finishAt'
          }},
          {$sort: {
            line: 1,
            startAt: 1
          }}
        ], this.parallel());
      },
      function(err, whSettings, planSettings, lineOrders)
      {
        if (err)
        {
          return this.skip(app.createError(`Failed to fetch data: ${err.message}`, err.code, 500));
        }

        this.settings = Object.assign(DEFAULT_SETTINGS, whSettings, planSettings);
        this.noToOrders = new Map();
        this.lineToOrders = new Map();

        const lineGroupMap = new Map();

        (whSettings.lineGroups || []).forEach(lineGroup =>
        {
          if (lineGroup.lines.length < 2)
          {
            return;
          }

          lineGroup.lines.forEach(line =>
          {
            if (!lineGroupMap.has(line))
            {
              lineGroupMap.set(line, []);
            }

            lineGroupMap.get(line).push(lineGroup);
          });
        });

        lineOrders.forEach(lineOrder =>
        {
          const {order} = lineOrder;

          lineOrder.lines = {
            [lineOrder.line]: {
              _id: lineOrder.line,
              qty: lineOrder.quantity,
              pceTime: lineOrder.pceTime,
              startTime: lineOrder.startAt,
              finishTime: lineOrder.finishAt
            }
          };

          if (!this.noToOrders.has(order))
          {
            this.noToOrders.set(order, []);
          }

          this.noToOrders.get(order).push(lineOrder);
        });

        this.noToOrders.forEach((oldLineOrders, no) =>
        {
          if (oldLineOrders.length === 1
            || !oldLineOrders.some(lineOrder => lineGroupMap.has(lineOrder.line)))
          {
            return;
          }

          const groupedLineOrders = [];

          while (oldLineOrders.length)
          {
            const thisOrder = oldLineOrders.shift();
            const lineGroups = lineGroupMap.get(thisOrder.line);

            groupedLineOrders.push(thisOrder);

            if (oldLineOrders.length === 0 || !lineGroups)
            {
              continue;
            }

            for (let g = 0; g < lineGroups.length; ++g)
            {
              const lineGroup = lineGroups[g];
              const candidates = !state.newGrouping
                ? oldLineOrders.filter(lineOrder => lineGroup.lines.includes(lineOrder.line))
                : oldLineOrders.filter(lineOrder =>
                {
                  if (!lineGroup.lines.includes(lineOrder.line))
                  {
                    return false;
                  }

                  if (lineOrder.line === Object.keys(thisOrder.lines)[0]._id)
                  {
                    return true;
                  }

                  const candidateShifts = calcShiftsInTimeRange(lineOrder.startAt, lineOrder.finishAt);
                  const thisShifts = calcShiftsInTimeRange(thisOrder.startAt, thisOrder.finishAt);

                  return _.intersection(thisShifts, candidateShifts).length > 0;
                });

              if (!candidates.length)
              {
                continue;
              }

              thisOrder.line = lineGroup._id;

              candidates.forEach(candidate =>
              {
                if (!thisOrder.lines[candidate.line])
                {
                  thisOrder.lines[candidate.line] = {
                    _id: candidate.line,
                    qty: 0,
                    pceTime: candidate.pceTime,
                    startTime: candidate.startAt,
                    finishTime: candidate.finishAt
                  };
                }

                if (candidate.startAt < thisOrder.startAt)
                {
                  thisOrder.startAt = candidate.startAt;

                  if (candidate.startAt < thisOrder.lines[candidate.line].startTime)
                  {
                    thisOrder.lines[candidate.line].startTime = candidate.startAt;
                  }
                }

                if (candidate.finishAt > thisOrder.finishAt)
                {
                  thisOrder.finishAt = candidate.finishAt;

                  if (candidate.finishAt > thisOrder.lines[candidate.line].finishTime)
                  {
                    thisOrder.lines[candidate.line].finishTime = candidate.finishAt;
                  }
                }

                thisOrder.quantity += candidate.quantity;
                thisOrder.lines[candidate.line].qty += candidate.quantity;
              });

              oldLineOrders = oldLineOrders.filter(lineOrder => !candidates.includes(lineOrder));
            }
          }

          if (state.newGrouping)
          {
            groupedLineOrders.forEach(lineOrder =>
            {
              const lines = Object.keys(lineOrder.lines);

              if (lines.length === 1)
              {
                lineOrder.line = lines[0];
              }
            });
          }

          this.noToOrders.set(no, groupedLineOrders);
        });

        setImmediate(this.next());
      },
      function()
      {
        const conditions = {
          _id: {
            $in: Array.from(this.noToOrders.keys())
          }
        };

        if (!_.isEmpty(this.settings.ignoredMrps))
        {
          conditions.mrp = {
            $nin: this.settings.ignoredMrps
          };
        }

        const fields = {
          _id: 1,
          mrp: 1,
          psStatus: 1,
          drillStatus: 1
        };

        Order
          .find(conditions)
          .select(fields)
          .lean()
          .exec(this.parallel());
      },
      function(err, sapOrderList)
      {
        if (err)
        {
          return this.skip(app.createError(`Failed to find SAP orders: ${err.message}`, err.code, 500));
        }

        const sapOrderMap = new Map();

        sapOrderList.forEach(o => sapOrderMap.set(o._id, o));

        this.lineToOrders = new Map();

        this.noToOrders.forEach((lineOrders, orderNo) =>
        {
          const sapOrder = sapOrderMap.get(orderNo);

          if (!sapOrder)
          {
            return;
          }

          lineOrders.forEach(lineOrder =>
          {
            lineOrder.mrp = sapOrder.mrp;
            lineOrder.psStatus = sapOrder.psStatus || 'unknown';
            lineOrder.drilling = false;

            if (sapOrder.drillStatus
              && sapOrder.psStatus === 'unknown'
              && sapOrder.drillStatus !== 'unknown')
            {
              lineOrder.psStatus = sapOrder.drillStatus;
              lineOrder.drilling = true;
            }

            lineOrder.lines = Object.values(lineOrder.lines);

            if (!this.lineToOrders.has(lineOrder.line))
            {
              this.lineToOrders.set(lineOrder.line, []);
            }

            this.lineToOrders.get(lineOrder.line).push(lineOrder);
          });
        });

        this.noToOrders = null;

        setImmediate(this.next());
      },
      function()
      {
        const whOrders = [];
        const groupExtraItems = this.settings.groupExtraItems;
        const groupDuration = this.settings.groupDuration;
        const groupTimeWindow = groupDuration * 3600 * 1000;

        this.lineToOrders.forEach(lineOrders =>
        {
          lineOrders.forEach(lineOrder =>
          {
            const whOrder = createOrder(lineOrder, state.date, groupDuration);

            if (state.newGrouping)
            {
              if (whOrder.lines.some(l => (l.finishTime - l.startTime) >= groupTimeWindow))
              {
                splitOrder(whOrders, whOrder, groupDuration, groupTimeWindow);
              }
              else
              {
                whOrders.push(whOrder);
              }
            }
            else
            {
              const duration = lineOrder.finishAt - lineOrder.startAt;

              if (duration > groupTimeWindow)
              {
                const pceTime = Math.ceil(duration / lineOrder.quantity);

                splitOrderOld(whOrders, whOrder, groupDuration, groupTimeWindow, duration, pceTime);
              }
              else
              {
                whOrders.push(whOrder);
              }
            }

            combineOrder(whOrders, groupExtraItems);
          });
        });

        this.newOrders = new Map();
        this.lines = new Set();

        const oidCount = {};

        whOrders.forEach(whOrder =>
        {
          const oid = `${state.key}:${whOrder.order}:${whOrder.line}`;

          if (!oidCount[oid])
          {
            oidCount[oid] = 0;
          }

          const idx = ++oidCount[oid];

          whOrder._id = createHash('md5')
            .update(`${oid}:${idx}`)
            .digest('hex');

          this.newOrders.set(whOrder._id, whOrder);

          whOrder.lines.forEach(whOrderLine =>
          {
            this.lines.add(whOrderLine._id);
          });
        });

        this.lineToOrders = null;

        setImmediate(this.next());
      },
      function()
      {
        WhOrder
          .find({date: state.date})
          .lean()
          .exec(this.parallel());

        WhLine
          .find({redirLine: {$ne: null}})
          .select({redirLine: 1})
          .lean()
          .exec(this.parallel());
      },
      function(err, oldOrders, redirLines)
      {
        if (err)
        {
          return this.skip(new Error(`Failed to find WH orders: ${err.message}`));
        }

        this.oldOrders = new Map();

        oldOrders.forEach(o => this.oldOrders.set(o._id, o));

        this.redirLines = new Map();

        redirLines.forEach(line =>
        {
          this.redirLines.set(line._id, line.redirLine);
        });

        setImmediate(this.next());
      },
      function()
      {
        this.changes = {
          added: [],
          changed: [],
          removed: []
        };

        state.logger.debug('Comparing orders...', {
          oldOrders: this.oldOrders.size,
          newOrders: this.newOrders.size
        });

        this.oldOrders.forEach(oldOrder =>
        {
          const newOrder = this.newOrders.get(oldOrder._id);

          this.newOrders.delete(oldOrder._id);

          if (!newOrder)
          {
            if (oldOrder.status === 'pending')
            {
              this.changes.removed.push(oldOrder._id);
            }
            else if (oldOrder.status !== 'finished' && oldOrder.status !== 'cancelled')
            {
              this.changes.changed.push({
                _id: oldOrder._id,
                status: 'cancelled',
                problem: 'PLAN'
              });
            }

            return;
          }

          redirLines(oldOrder, newOrder, this.redirLines);

          const changed = compareOrders(oldOrder, newOrder);

          if (changed)
          {
            this.changes.changed.push(changed);
          }
        });

        this.newOrders.forEach(newOrder =>
        {
          redirLines(null, newOrder, this.redirLines);

          this.changes.added.push(newOrder);
        });

        setImmediate(this.next());
      },
      function()
      {
        if (state.cancelled)
        {
          this.changes = null;

          return this.skip();
        }

        if (this.lines.size)
        {
          const next = this.group();
          const lines = Array.from(this.lines).map(_id => new WhLine({_id}).toJSON());

          WhLine.collection.insertMany(lines, {ordered: false, writeConcern: {w: 'majority'}}, (err) =>
          {
            next(err && err.code === 11000 ? null : err);
          });
        }

        const {added, changed, removed} = this.changes;

        if (added.length)
        {
          const next = this.group();

          WhOrder.collection.insertMany(added, {ordered: false, writeConcern: {w: 'majority'}}, (err, res) =>
          {
            if (res && res.hasWriteErrors && res.hasWriteErrors())
            {
              const notAdded = new Set();

              res.getWriteErrors().forEach(writeError => notAdded.add(writeError.getOperation()._id));

              this.changes.added = added.filter(o => !notAdded.has(o._id));
            }

            next(err && err.code === 11000 ? null : err);
          });
        }

        if (removed.length)
        {
          WhOrder.collection.deleteMany({_id: {$in: removed}}, {writeConcern: {w: 'majority'}}, this.group());
        }

        changed.forEach(change =>
        {
          WhOrder.collection.updateOne({_id: change._id}, {$set: change}, {writeConcern: {w: 'majority'}}, this.group());
        });
      },
      function(err)
      {
        if (err)
        {
          state.logger.error(err, 'Failed to generate.');
        }
        else if (this.changes)
        {
          const added = this.changes.added.length;
          const changed = this.changes.changed.length;
          const removed = this.changes.removed.length;
          const duration = (Date.now() - startedAt) / 1000;

          state.logger.info('Generated!', {added, changed, removed, duration});

          if (added || changed || removed)
          {
            app.broker.publish(`${WhOrder.TOPIC_PREFIX}.changed.${state.key}`, {
              date: state.date,
              changes: this.changes
            });

            saveChanges(state.date, this.changes);
          }
        }

        if (state.cancelled)
        {
          state.logger.info('Cancelled!');
        }
        else
        {
          app.broker.publish(`${TOPIC_PREFIX}.finished`, {
            date: state.key
          });
        }

        done();
      }
    );
  }

  function saveChanges(plan, changes)
  {
    const change = new WhPlanChange({
      time: new Date(),
      plan,
      added: changes.added,
      changed: changes.changed,
      removed: changes.removed
    });

    change.save(err =>
    {
      if (err)
      {
        module.error(err, 'Failed to save plan changes.');
      }
    });
  }

  function calcShiftsInTimeRange(from, to)
  {
    const fromH = from.getUTCHours();
    const toH = to.getUTCHours();

    if (fromH >= 22 || (fromH >= 0 && fromH < 6))
    {
      return [3];
    }

    if (fromH >= 14)
    {
      if (toH < 22)
      {
        return [2];
      }

      return [2, 3];
    }

    if (toH < 14)
    {
      return [1];
    }

    if (toH < 22)
    {
      return [1, 2];
    }

    return [1, 2, 3];
  }

  function compareOrders(oldOrder, newOrder)
  {
    const changes = {
      _id: oldOrder._id
    };
    let anyChanges = false;

    ORDER_COMPARE_PROPS.forEach(p =>
    {
      if (IGNORE_DELIVERED_PROPS[p]
        && (!!oldOrder.forcedRedir || oldOrder.distStatus !== 'pending'))
      {
        return;
      }

      const oldValue = oldOrder[p];
      const newValue = newOrder[p];

      if (!jsonDeepEqual(oldValue, newValue))
      {
        changes[p] = newValue;
        anyChanges = true;
      }
    });

    return anyChanges ? changes : null;
  }

  function createOrder(lineOrder, date, groupDuration)
  {
    return {
      _id: '',
      status: 'pending',
      distStatus: 'pending',
      fifoStatus: 'pending',
      packStatus: 'pending',
      psDistStatus: 'pending',
      setDistStarted: false,
      psStatus: lineOrder.psStatus,
      drilling: lineOrder.drilling,
      problem: '',
      order: lineOrder.order,
      mrp: lineOrder.mrp,
      group: getOrderGroup(lineOrder.startAt, groupDuration),
      line: lineOrder.line,
      lines: lineOrder.lines,
      redirLine: null,
      redirLines: [],
      forcedRedir: null,
      forceDelivery: false,
      set: null,
      startedAt: null,
      finishedAt: null,
      problemAt: null,
      date,
      qty: lineOrder.quantity,
      startTime: lineOrder.startAt,
      finishTime: lineOrder.finishAt,
      picklistFunc: null,
      picklistDone: 'pending',
      funcs: WhOrder.FUNCS.map(createFunc),
      users: []
    };
  }

  function createFunc(id)
  {
    return {
      _id: id,
      user: null,
      startedAt: null,
      finishedAt: null,
      status: 'pending',
      picklist: 'pending',
      pickup: 'pending',
      carts: [],
      problemArea: '',
      comment: ''
    };
  }

  function redirLines(oldOrder, newOrder, redirLines)
  {
    if (oldOrder && oldOrder.distStatus !== 'pending')
    {
      return;
    }

    const anyLineRedirected = newOrder.lines.some(line => redirLines.has(line._id));

    if (!anyLineRedirected)
    {
      return;
    }

    newOrder.redirLine = newOrder.line;
    newOrder.redirLines = newOrder.lines.map(line => line._id);

    if (newOrder.lines.length === 1)
    {
      newOrder.line = redirLines.get(newOrder.line);
      newOrder.lines[0]._id = newOrder.line;

      return;
    }

    newOrder.lines.forEach(line =>
    {
      const redirLine = redirLines.get(line._id);

      if (redirLine)
      {
        line._id = redirLine;
      }
    });
  }

  function getOrderGroup(startTime, groupDuration)
  {
    let startHour = startTime.getUTCHours();

    if (startHour < 6)
    {
      startHour = 18 + startHour;
    }
    else
    {
      startHour -= 6;
    }

    return Math.floor(startHour / groupDuration) + 1;
  }

  function splitOrder(whOrders, bigWhOrder, groupDuration, groupTimeWindow)
  {
    let {group, qty} = bigWhOrder;
    const pceTimes = [];
    const groupStartTime = moment.utc(bigWhOrder.startTime)
      .startOf('day')
      .add(6 + (group - 1) * groupDuration, 'hours')
      .valueOf();
    let groupFinishTime = groupStartTime + groupTimeWindow;

    bigWhOrder.lines.forEach(line =>
    {
      line.startTime = line.startTime.getTime();
      line.finishTime = line.finishTime.getTime();

      pceTimes.push(Math.ceil((line.finishTime - line.startTime) / line.qty));
    });

    while (qty > 0)
    {
      const smallWhOrder = {
        ..._.cloneDeep(bigWhOrder),
        startTime: Number.MAX_SAFE_INTEGER,
        finishTime: Number.MIN_SAFE_INTEGER,
        group: group++,
        qty: 0
      };

      smallWhOrder.lines.forEach(line =>
      {
        line.qty = 0;
        line.finishTime = line.startTime;
      });

      const linesTodo = smallWhOrder.lines.map((smallLine, lineI) =>
      {
        return {
          done: false,
          small: smallLine,
          big: bigWhOrder.lines[lineI]
        };
      });
      let linesDone = 0;

      while (linesDone !== linesTodo.length)
      {
        for (let lineI = 0; lineI < linesTodo.length; ++lineI)
        {
          const line = linesTodo[lineI];

          if (line.done)
          {
            continue;
          }

          const pceTime = pceTimes[lineI];

          if (line.big.qty > 0)
          {
            line.big.qty -= 1;
            line.big.startTime += pceTime;
            line.small.qty += 1;
            line.small.finishTime += pceTime;
          }

          if (line.big.qty === 0 || line.small.finishTime + pceTime >= groupFinishTime)
          {
            line.done = true;
            linesDone += 1;
          }
        }
      }

      smallWhOrder.lines = smallWhOrder.lines.filter(l => l.qty > 0);

      if (smallWhOrder.lines.length === 1)
      {
        smallWhOrder.line = smallWhOrder.lines[0]._id;
      }

      let minFinishTime = Number.MAX_SAFE_INTEGER;

      for (let lineI = 0; lineI < smallWhOrder.lines.length; ++lineI)
      {
        const line = smallWhOrder.lines[lineI];

        qty -= line.qty;
        smallWhOrder.qty += line.qty;

        line.startTime = new Date(line.startTime);
        line.finishTime = new Date(line.finishTime);

        if (line.startTime < smallWhOrder.startTime)
        {
          smallWhOrder.startTime = line.startTime;
        }

        if (line.finishTime > smallWhOrder.finishTime)
        {
          smallWhOrder.finishTime = line.finishTime;
        }

        if (line.finishTime < minFinishTime)
        {
          minFinishTime = line.finishTime;
        }
      }

      whOrders.push(smallWhOrder);

      groupFinishTime += groupTimeWindow;
    }
  }

  // TODO remove after 2020-10-01
  function splitOrderOld(whOrders, bigWhOrder, groupDuration, groupTimeWindow, duration, pceTime)
  {
    let qty = bigWhOrder.qty;
    let startTime = bigWhOrder.startTime;
    let group = bigWhOrder.group;
    const groupStartTime = moment.utc(startTime)
      .startOf('day')
      .add(6 + (group - 1) * groupDuration, 'hours')
      .valueOf();
    let groupFinishTime = groupStartTime + groupTimeWindow;

    while (qty > 0)
    {
      const availableTime = groupFinishTime - startTime;
      const maxQty = Math.floor(availableTime / pceTime);
      const smallWhOrder = _.assign(_.cloneDeep(bigWhOrder), {
        startTime,
        finishTime: 0,
        group: group++,
        qty: Math.min(qty, maxQty)
      });

      if (smallWhOrder.lines.length === 1)
      {
        smallWhOrder.lines[0].qty = smallWhOrder.qty;
      }
      else
      {
        smallWhOrder.lines.forEach(line =>
        {
          line.qty = 0;
        });

        let qtyRemaining = smallWhOrder.qty;

        while (qtyRemaining > 0)
        {
          for (let i = 0; i < smallWhOrder.lines.length; ++i)
          {
            if (qtyRemaining > 0 && bigWhOrder.lines[i].qty > 0)
            {
              smallWhOrder.lines[i].qty += 1;
              bigWhOrder.lines[i].qty -= 1;
              qtyRemaining -= 1;
            }
          }
        }
      }

      whOrders.push(smallWhOrder);

      qty -= smallWhOrder.qty;
      startTime = smallWhOrder.finishTime = new Date(startTime.getTime() + pceTime * smallWhOrder.qty);
      groupFinishTime += groupTimeWindow;
    }
  }

  function minWhOrder(o) // eslint-disable-line no-unused-vars
  {
    return {
      _id: o._id,
      order: o.order,
      startTime: o.startTime,
      finishTime: o.finishTime,
      qty: o.qty,
      line: o.line,
      lines: o.lines,
      redirLine: o.redirLine,
      redirLines: o.redirLines,
      forcedRedir: o.forcedRedir
    };
  }

  function combineOrder(whOrders, groupExtraItems)
  {
    const prevPart = whOrders[whOrders.length - 2];

    if (!prevPart)
    {
      return;
    }

    const lastPart = whOrders[whOrders.length - 1];

    if (lastPart.order !== prevPart.order || lastPart.line !== prevPart.line)
    {
      return;
    }

    if (lastPart.qty <= groupExtraItems)
    {
      prevPart.finishTime = lastPart.finishTime;
      prevPart.qty += lastPart.qty;

      prevPart.lines.forEach((line, i) =>
      {
        line.qty += lastPart.lines[i].qty;

        if (lastPart.lines[i].finishTime > line.finishTime)
        {
          line.finishTime = lastPart.lines[i].finishTime;
        }
      });

      whOrders.pop();
    }

    let firstPartI = -1;

    for (let i = whOrders.length - 1; i >= 0; --i)
    {
      if (whOrders[i].order !== lastPart.order || whOrders[i].line !== lastPart.line)
      {
        break;
      }

      firstPartI = i;
    }

    const firstPart = whOrders[firstPartI];

    if (firstPart.qty <= groupExtraItems)
    {
      const nextPart = whOrders[firstPartI + 1];

      if (nextPart)
      {
        nextPart.startTime = firstPart.startTime;
        nextPart.qty += firstPart.qty;

        nextPart.lines.forEach((line, i) =>
        {
          line.qty += firstPart.lines[i].qty;

          if (lastPart.lines[i].startTime < line.startTime)
          {
            line.startTime = lastPart.lines[i].startTime;
          }
        });

        whOrders.splice(firstPartI, 1);
      }
    }
  }
};
