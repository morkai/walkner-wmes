// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const {createHash} = require('crypto');
const _ = require('lodash');
const moment = require('moment');
const step = require('h5.step');
const deepEqual = require('deep-equal');

const TOPIC_PREFIX = 'old.wh.generator';
const DEFAULT_SETTINGS = {
  ignoredMrps: [],
  groupDuration: 2,
  groupExtraItems: 5
};
const ORDER_COMPARE_PROPERTIES = [
  'date',
  'qty',
  'startTime',
  'finishTime',
  'group',
  'lines'
];

module.exports = (app, module) =>
{
  if (!module.config.generator)
  {
    return;
  }

  const {
    settings,
    Order,
    OldWhOrder: WhOrder,
    OldWhLine: WhLine,
    Plan,
    PlanSettings
  } = module;

  const generatorQueue = [];
  let generatorState = null;
  let generatorTimer = null;

  app.broker.subscribe(`${TOPIC_PREFIX}.requested`, handleRequest);

  app.broker.subscribe('settings.updated.wh.planning.**', generateActivePlans);

  app.broker.subscribe('planning.changes.created', change =>
  {
    if (change.user !== null || (Object.keys(change.data).length === 1 && change.data.settings))
    {
      return;
    }

    generatePlan(change.plan);
  });

  function handleRequest(message)
  {
    const date = moment.utc(message.date, 'YYYY-MM-DD');

    if (date.isValid())
    {
      generatePlan(date.toDate());
    }
  }

  function createPlanGeneratorState(key)
  {
    return {
      key,
      date: moment.utc(key, 'YYYY-MM-DD').toDate(),
      cancelled: false,
      log: message => module.info(`[generator] [${key}] ${message}`)
    };
  }

  function generateActivePlans()
  {
    const now = moment();
    const from = moment.utc(now.format('YYYY-MM-DD'), 'YYYY-MM-DD');

    if (now.hours() < 6)
    {
      from.subtract(1, 'days');
    }

    Plan.find({_id: {$gt: from}}, {_id: 1}).lean().exec((err, plans) =>
    {
      if (err)
      {
        module.error(`[generator] Failed to find active plans: ${err.message}`);
      }

      plans.forEach(plan => generatePlan(moment.utc(plan._id).format('YYYY-MM-DD')));
    });
  }

  function generatePlan(date)
  {
    const dateMoment = moment.utc(date, 'YYYY-MM-DD').startOf('day');

    if (!dateMoment.isValid())
    {
      return;
    }

    const planKey = dateMoment.format('YYYY-MM-DD');

    if (!generatorQueue.includes(planKey))
    {
      generatorQueue.push(planKey);

      app.broker.publish(`${TOPIC_PREFIX}.started`, {
        date: planKey
      });
    }

    if (generatorState !== null)
    {
      module.info(`[generator] [${generatorState.key}] Cancelling...`);

      generatorState.cancelled = true;

      return;
    }

    if (generatorTimer !== null)
    {
      clearTimeout(generatorTimer);
    }

    generatorTimer = setTimeout(generateNextPlan, 1);
  }

  function generateNextPlan()
  {
    if (generatorState)
    {
      return;
    }

    const planKey = generatorQueue.sort((a, b) => a.localeCompare(b)).shift();

    if (!planKey)
    {
      return;
    }

    generatorTimer = null;
    generatorState = createPlanGeneratorState(planKey);

    tryGeneratePlan(generatorState, () =>
    {
      if (generatorState.cancelled && !generatorQueue.includes(planKey))
      {
        generatorQueue.push(planKey);
      }

      generatorState = null;

      if (generatorTimer !== null)
      {
        clearTimeout(generatorTimer);
      }

      generatorTimer = setTimeout(generateNextPlan, 1);
    });
  }

  function tryGeneratePlan(state, done)
  {
    const startedAt = Date.now();

    state.log(`Generating...`);

    step(
      function()
      {
        settings.findValues({_id: /^wh\.planning/}, 'wh.planning.', this.parallel());

        PlanSettings
          .findById(state.date).select({
            requiredStatuses: 1,
            ignoredStatuses: 1
          })
          .lean()
          .exec(this.parallel());

        Plan.aggregate([
          {$match: {_id: state.date}},
          {$unwind: '$lines'},
          {$unwind: '$lines.orders'},
          {$project: {
            line: '$lines._id',
            order: '$lines.orders.orderNo',
            quantity: '$lines.orders.quantity',
            pceTime: '$lines.orders.pceTime',
            startAt: '$lines.orders.startAt',
            finishAt: '$lines.orders.finishAt'
          }},
          {$sort: {
            line: 1,
            startAt: 1
          }}
        ], this.parallel());
      },
      function(err, whSettings, planSettings, lineOrders)
      {
        if (err)
        {
          return this.skip(app.createError(`Failed to fetch data: ${err.message}`, err.code, 500));
        }

        this.settings = Object.assign(DEFAULT_SETTINGS, whSettings, planSettings);
        this.noToOrders = new Map();
        this.lineToOrders = new Map();

        const lineGroupMap = new Map();

        (whSettings.lineGroups || []).forEach(lineGroup =>
        {
          if (lineGroup.lines.length < 2)
          {
            return;
          }

          lineGroup.lines.forEach(line =>
          {
            if (!lineGroupMap.has(line))
            {
              lineGroupMap.set(line, []);
            }

            lineGroupMap.get(line).push(lineGroup);
          });
        });

        lineOrders.forEach(lineOrder =>
        {
          const {order} = lineOrder;

          lineOrder.lines = {
            [lineOrder.line]: {
              _id: lineOrder.line,
              quantity: lineOrder.quantity,
              pceTime: lineOrder.pceTime
            }
          };

          if (!this.noToOrders.has(order))
          {
            this.noToOrders.set(order, []);
          }

          this.noToOrders.get(order).push(lineOrder);
        });

        this.noToOrders.forEach((oldLineOrders, no) =>
        {
          if (oldLineOrders.length === 1
            || !oldLineOrders.some(lineOrder => lineGroupMap.has(lineOrder.line)))
          {
            return;
          }

          const groupedLineOrders = [];

          while (oldLineOrders.length)
          {
            const thisOrder = oldLineOrders.shift();
            const lineGroups = lineGroupMap.get(thisOrder.line);

            groupedLineOrders.push(thisOrder);

            if (oldLineOrders.length === 0 || !lineGroups)
            {
              break;
            }

            for (let g = 0; g < lineGroups.length; ++g)
            {
              const lineGroup = lineGroups[g];
              const candidates = oldLineOrders.filter(lineOrder => lineGroup.lines.includes(lineOrder.line));

              if (!candidates)
              {
                continue;
              }

              thisOrder.line = lineGroup._id;

              candidates.forEach(candidate =>
              {
                if (candidate.startAt < thisOrder.startAt)
                {
                  thisOrder.startAt = candidate.startAt;
                }

                if (candidate.finishAt > thisOrder.finishAt)
                {
                  thisOrder.finishAt = candidate.finishAt;
                }

                thisOrder.quantity += candidate.quantity;

                if (!thisOrder.lines[candidate.line])
                {
                  thisOrder.lines[candidate.line] = {
                    _id: candidate.line,
                    quantity: candidate.quantity,
                    pceTime: candidate.pceTime
                  };
                }

                thisOrder.lines[candidate.line].quantity += candidate.quantity;
              });

              oldLineOrders = oldLineOrders.filter(lineOrder => !candidates.includes(lineOrder));
            }
          }

          this.noToOrders.set(no, groupedLineOrders);
        });

        setImmediate(this.next());
      },
      function()
      {
        const conditions = {
          _id: {
            $in: Array.from(this.noToOrders.keys())
          },
          statuses: {
            $in: this.settings.requiredStatuses,
            $nin: this.settings.ignoredStatuses
          }
        };

        if (!_.isEmpty(this.settings.ignoredMrps))
        {
          conditions.mrp = {
            $nin: this.settings.ignoredMrps
          };
        }

        const fields = {
          _id: 1,
          mrp: 1,
          psStatus: 1
        };

        Order
          .find(conditions, fields)
          .lean()
          .exec(this.parallel());
      },
      function(err, sapOrderList)
      {
        if (err)
        {
          return this.skip(app.createError(`Failed to find SAP orders: ${err.message}`, err.code, 500));
        }

        const sapOrderMap = new Map();

        sapOrderList.forEach(o => sapOrderMap.set(o._id, o));

        this.lineToOrders = new Map();

        this.noToOrders.forEach((lineOrders, orderNo) =>
        {
          const sapOrder = sapOrderMap.get(orderNo);

          if (!sapOrder)
          {
            return;
          }

          lineOrders.forEach(lineOrder =>
          {
            lineOrder.mrp = sapOrder.mrp;
            lineOrder.psStatus = sapOrder.psStatus;
            lineOrder.lines = Object.values(lineOrder.lines);

            if (!this.lineToOrders.has(lineOrder.line))
            {
              this.lineToOrders.set(lineOrder.line, []);
            }

            this.lineToOrders.get(lineOrder.line).push(lineOrder);
          });
        });

        this.noToOrders = null;

        setImmediate(this.next());
      },
      function()
      {
        const whOrders = [];
        const groupExtraItems = this.settings.groupExtraItems;
        const groupDuration = this.settings.groupDuration;
        const groupTimeWindow = groupDuration * 3600 * 1000;

        this.lineToOrders.forEach(lineOrders =>
        {
          lineOrders.forEach(lineOrder =>
          {
            const duration = lineOrder.finishAt - lineOrder.startAt;
            const whOrder = createOrder(lineOrder, state.date, groupDuration);

            if (duration > groupTimeWindow)
            {
              const pceTime = Math.ceil(duration / lineOrder.quantity);

              splitOrder(whOrders, whOrder, groupDuration, groupTimeWindow, duration, pceTime);
            }
            else
            {
              whOrders.push(whOrder);
            }

            combineOrder(whOrders, groupExtraItems);
          });
        });

        this.newOrders = new Map();
        this.lines = new Set();

        const oidCount = {};

        whOrders.forEach(whOrder =>
        {
          const oid = `${state.key}:${whOrder.order}:${whOrder.line}`;

          if (!oidCount[oid])
          {
            oidCount[oid] = 0;
          }

          const idx = ++oidCount[oid];

          whOrder._id = createHash('md5')
            .update(`${oid}:${idx}`)
            .digest('hex');

          this.newOrders.set(whOrder._id, whOrder);
          this.lines.add(whOrder.line);
        });

        this.lineToOrders = null;

        setImmediate(this.next());
      },
      function()
      {
        WhOrder.find({date: state.date}).lean().exec(this.next());
      },
      function(err, oldOrders)
      {
        if (err)
        {
          return this.skip(new Error(`Failed to find WH orders: ${err.message}`));
        }

        this.oldOrders = new Map();

        oldOrders.forEach(o => this.oldOrders.set(o._id, o));

        setImmediate(this.next());
      },
      function()
      {
        this.changes = {
          added: [],
          changed: [],
          removed: []
        };

        state.log(`Comparing ${this.oldOrders.size} old with ${this.newOrders.size} new...`);

        this.oldOrders.forEach(oldOrder =>
        {
          const newOrder = this.newOrders.get(oldOrder._id);

          this.newOrders.delete(oldOrder._id);

          if (!newOrder)
          {
            if (oldOrder.status === 'pending')
            {
              this.changes.removed.push(oldOrder._id);
            }
            else if (oldOrder.status !== 'finished' && oldOrder.status !== 'cancelled')
            {
              this.changes.changed.push({
                _id: oldOrder._id,
                status: 'cancelled',
                problem: 'PLAN'
              });
            }

            return;
          }

          const changed = compareOrders(oldOrder, newOrder);

          if (changed)
          {
            this.changes.changed.push(changed);
          }
        });

        this.newOrders.forEach(newOrder =>
        {
          this.changes.added.push(newOrder);
        });

        setImmediate(this.next());
      },
      function()
      {
        if (state.cancelled)
        {
          this.changes = null;

          return this.skip();
        }

        if (this.lines.size)
        {
          const next = this.group();
          const lines = Array.from(this.lines).map(_id =>
          {
            return {
              _id,
              pickup: {
                pending: {
                  orders: 0,
                  sets: 0,
                  pce: 0,
                  time: 0
                },
                orders: 0,
                sets: 0,
                pce: 0,
                time: 0
              },
              components: {
                pce: 0,
                time: 0
              },
              packaging: {
                pce: 0,
                time: 0
              }
            };
          });

          WhLine.collection.insertMany(lines, {ordered: false}, (err) =>
          {
            next(err && err.code === 11000 ? null : err);
          });
        }

        const {added, changed, removed} = this.changes;

        if (added.length)
        {
          const next = this.group();

          WhOrder.collection.insertMany(added, {ordered: false}, (err, res) =>
          {
            if (res && res.hasWriteErrors && res.hasWriteErrors())
            {
              const notAdded = new Set();

              res.getWriteErrors().forEach(writeError => notAdded.add(writeError.getOperation()._id));

              this.changes.added = added.filter(o => !notAdded.has(o._id));
            }

            next(err && err.code === 11000 ? null : err);
          });
        }

        if (removed.length)
        {
          WhOrder.collection.deleteMany({_id: {$in: removed}}, this.group());
        }

        changed.forEach(change =>
        {
          WhOrder.collection.updateOne({_id: change._id}, {$set: change}, this.group());
        });
      },
      function(err)
      {
        if (err)
        {
          module.error(`[generator] [${state.key}] ${err.message}`);
        }
        else if (this.changes)
        {
          const added = this.changes.added.length;
          const changed = this.changes.changed.length;
          const removed = this.changes.removed.length;
          const duration = (Date.now() - startedAt) / 1000;

          state.log(`${added} added, ${changed} changed, ${removed} removed in ${duration}s`);

          if (added || changed || removed)
          {
            app.broker.publish(`${WhOrder.TOPIC_PREFIX}.changed.${state.key}`, {
              date: state.date,
              changes: this.changes
            });
          }
        }

        if (state.cancelled)
        {
          state.log(`[generator] [${state.key}] Cancelled!`);
        }
        else
        {
          app.broker.publish(`${TOPIC_PREFIX}.finished`, {
            date: state.key
          });
        }

        done();
      }
    );
  }

  function compareOrders(oldOrder, newOrder)
  {
    const changes = {
      _id: oldOrder._id
    };
    let anyChanges = false;

    ORDER_COMPARE_PROPERTIES.forEach(p =>
    {
      const oldValue = oldOrder[p];
      const newValue = newOrder[p];

      if (!deepEqual(oldValue, newValue))
      {
        changes[p] = newValue;
        anyChanges = true;
      }
    });

    return anyChanges ? changes : null;
  }

  function createOrder(lineOrder, date, groupDuration)
  {
    return {
      _id: '',
      status: 'pending',
      psStatus: lineOrder.psStatus,
      problem: '',
      order: lineOrder.order,
      mrp: lineOrder.mrp,
      group: getOrderGroup(lineOrder.startAt, groupDuration),
      line: lineOrder.line,
      lines: lineOrder.lines,
      set: null,
      startedAt: null,
      finishedAt: null,
      date,
      qty: lineOrder.quantity,
      startTime: lineOrder.startAt,
      finishTime: lineOrder.finishAt,
      picklistFunc: null,
      picklistDone: null,
      funcs: WhOrder.FUNCS.map(createFunc),
      users: []
    };
  }

  function createFunc(id)
  {
    return {
      _id: id,
      user: null,
      startedAt: null,
      finishedAt: null,
      status: 'pending',
      picklist: 'pending',
      pickup: 'pending',
      carts: [],
      problemArea: '',
      comment: ''
    };
  }

  function getOrderGroup(startTime, groupDuration)
  {
    let startHour = startTime.getUTCHours();

    if (startHour < 6)
    {
      startHour = 18 + startHour;
    }
    else
    {
      startHour -= 6;
    }

    return Math.floor(startHour / groupDuration) + 1;
  }

  function splitOrder(whOrders, bigWhOrder, groupDuration, groupTimeWindow, duration, pceTime)
  {
    let qty = bigWhOrder.qty;
    let startTime = bigWhOrder.startTime;
    let group = bigWhOrder.group;
    const groupStartTime = moment.utc(startTime)
      .startOf('day')
      .add(6 + (group - 1) * groupDuration, 'hours')
      .valueOf();
    let groupFinishTime = groupStartTime + groupTimeWindow;

    while (qty > 0)
    {
      const availableTime = groupFinishTime - startTime;
      const maxQty = Math.floor(availableTime / pceTime);
      const smallWhOrder = _.assign(_.cloneDeep(bigWhOrder), {
        startTime,
        finishTime: 0,
        group: group++,
        qty: Math.min(qty, maxQty)
      });

      whOrders.push(smallWhOrder);

      qty -= smallWhOrder.qty;
      startTime = smallWhOrder.finishTime = new Date(startTime.getTime() + pceTime * smallWhOrder.qty);
      groupFinishTime += groupTimeWindow;
    }
  }

  function combineOrder(whOrders, groupExtraItems)
  {
    const prevPart = whOrders[whOrders.length - 2];

    if (!prevPart)
    {
      return;
    }

    const lastPart = whOrders[whOrders.length - 1];

    if (lastPart.order !== prevPart.order || lastPart.line !== prevPart.line)
    {
      return;
    }

    if (lastPart.qty <= groupExtraItems)
    {
      prevPart.finishTime = lastPart.finishTime;
      prevPart.qty += lastPart.qty;

      whOrders.pop();
    }

    let firstPartI = -1;

    for (let i = whOrders.length - 1; i >= 0; --i)
    {
      if (whOrders[i].order !== lastPart.order)
      {
        break;
      }

      firstPartI = i;
    }

    const firstPart = whOrders[firstPartI];

    if (firstPart.qty <= groupExtraItems)
    {
      const nextPart = whOrders[firstPartI + 1];

      if (nextPart)
      {
        nextPart.startTime = firstPart.startTime;
        nextPart.qty += firstPart.qty;

        whOrders.splice(firstPartI, 1);
      }
    }
  }
};
