// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

/* eslint-disable curly */

'use strict';

const fs = require('fs-extra');
const moment = require('moment');
const step = require('h5.step');

module.exports = (app, module) =>
{
  const {
    settings,
    html2pdf,
    User,
    WhUser,
    WhOrder,
    WhEvent,
    Order,
    Printer
  } = module;

  const log = app.options.env === 'development' ? console.log.bind(console) : null;

  const actions = {};
  let queue = null;

  module.state = {
    act: (input, done) =>
    {
      if (typeof actions[input.action] !== 'function')
      {
        return done(app.createError(`Unknown action: ${input.action}`, 'UNKNOWN_ACTION', 400));
      }

      if (queue !== null)
      {
        queue.push({input, done});

        return;
      }

      queue = [{input, done}];

      setImmediate(executeNextAction);
    }
  };

  actions.resolveAction = (data, done) =>
  {
    step(
      function resolveUserStep()
      {
        resolveUser(data.personnelId, this.next());
      },
      function handleResultUserStep(err, user)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!user)
        {
          return this.skip(app.createError('User not found.', 'USER_NOT_FOUND', 400));
        }

        this.user = user;
      },
      function findAssignedOrActiveOrderStep()
      {
        const funcIndex = WhOrder.FUNCS.indexOf(this.user.func);

        WhOrder
          .findOne({
            date: data.date,
            status: 'started',
            [`funcs.${funcIndex}.user.id`]: this.user._id,
            [`funcs.${funcIndex}.status`]: {$nin: ['problem', 'finished']}
          })
          .sort({
            group: 1,
            line: 1,
            startTime: 1
          })
          .lean()
          .exec(this.parallel());

        WhOrder
          .findOne({
            date: data.date,
            status: 'started',
            [`funcs.${funcIndex}.user`]: {$type: 'null'}
          })
          .sort({
            group: 1,
            line: 1,
            startTime: 1
          })
          .lean()
          .exec(this.parallel());
      },
      function handleFindActiveOrderStep(err, assignedOrder, activeOrder)
      {
        if (err)
        {
          return this.skip(app.createError(
            `Failed to find active order: ${err.message}`,
            'FIND_ACTIVE_ORDER_FAILURE'
          ));
        }

        if (assignedOrder)
        {
          continueSet(this.user, assignedOrder.set, this.next());
        }
        else if (activeOrder)
        {
          assignSet(this.user, activeOrder, this.next());
        }
        else
        {
          startNewSet(this.user, data.date, this.next());
        }
      },
      done
    );
  };

  actions.resetOrders = (data, done) =>
  {
    step(
      function()
      {
        const conditions = {
          date: data.date
        };

        if (data.orders)
        {
          conditions._id = {$in: data.orders};
        }
        else if (data.set)
        {
          conditions.set = data.set;
        }

        WhOrder.find(conditions).lean().exec(this.next());
      },
      function(err, orders)
      {
        if (err)
        {
          return this.skip(app.createError(
            `Failed to find orders to reset: ${err.message}`,
            'FIND_RESET_ORDERS_FAILURE'
          ));
        }

        this.orders = orders;

        if (!orders.length)
        {
          return this.skip();
        }

        const $set = {};

        orders.forEach(order =>
        {
          $set.status = order.status = 'pending';
          $set.problem = order.problem = '';
          $set.set = order.set = null;
          $set.startedAt = order.startedAt = null;
          $set.finishedAt = order.finishedAt = null;
          $set.picklistFunc = order.picklistFunc = null;
          $set.picklistDone = order.picklistDone = null;
          $set.users = order.users = [];

          order.funcs.forEach((func, i) =>
          {
            $set[`funcs.${i}.user`] = func.user = null;
            $set[`funcs.${i}.startedAt`] = func.startedAt = null;
            $set[`funcs.${i}.finishedAt`] = func.finishedAt = null;
            $set[`funcs.${i}.status`] = func.status = 'pending';
            $set[`funcs.${i}.picklist`] = func.picklist = 'pending';
            $set[`funcs.${i}.pickup`] = func.pickup = 'pending';
            $set[`funcs.${i}.carts`] = func.carts = [];
            $set[`funcs.${i}.problemArea`] = func.problemArea = '';
            $set[`funcs.${i}.comment`] = func.comment = '';
          });
        });

        WhOrder.updateMany({_id: {$in: orders.map(o => o._id)}}, {$set}, this.parallel());
      },
      function(err)
      {
        if (err)
        {
          return this.skip(app.createError(
            `Failed to reset orders: ${err.message}`,
            'RESET_ORDERS_FAILURE'
          ));
        }
      },
      function(err)
      {
        if (err)
        {
          return done(err);
        }

        if (this.orders.length)
        {
          app.broker.publish('wh.orders.updated', {orders: this.orders});
        }

        done(null, {orders: this.orders.map(o => o._id)}, this.orders.map(o => ({
          type: 'orderReset',
          order: o._id,
          data: {
            orders: data.orders || null,
            set: data.set || null
          }
        })));
      }
    );
  };

  actions.cancelOrders = (data, done) =>
  {
    step(
      function()
      {
        const conditions = {
          date: data.date,
          status: {$ne: 'cancelled'}
        };

        if (data.orders)
        {
          conditions._id = {$in: data.orders};
        }
        else if (data.set)
        {
          conditions.set = data.set;
        }

        WhOrder.find(conditions).lean().exec(this.next());
      },
      function(err, orders)
      {
        if (err)
        {
          return this.skip(app.createError(
            `Failed to find orders to cancel: ${err.message}`,
            'FIND_CANCEL_ORDERS_FAILURE'
          ));
        }

        this.orders = [];

        if (!orders.length)
        {
          return this.skip();
        }

        const $set = {};

        orders.forEach(order =>
        {
          $set.status = order.status = 'cancelled';
          $set.finishedAt = order.finishedAt = new Date();
        });

        this.orders = orders;

        WhOrder.updateMany({_id: {$in: orders.map(o => o._id)}}, {$set}, this.next());
      },
      function(err)
      {
        if (err)
        {
          return this.skip(app.createError(
            `Failed to cancel orders: ${err.message}`,
            'CANCEL_ORDERS_FAILURE'
          ));
        }
      },
      function(err)
      {
        if (err)
        {
          return done(err);
        }

        if (this.orders.length)
        {
          app.broker.publish('wh.orders.updated', {orders: this.orders});
        }

        done(null, {orders: this.orders.map(o => o._id)}, this.orders.map(o => ({
          type: 'orderCancelled',
          order: o._id,
          data: {
            orders: data.orders || null,
            set: data.set || null
          }
        })));
      }
    );
  };

  actions.restoreOrders = (data, done) =>
  {
    step(
      function()
      {
        const conditions = {
          date: data.date,
          status: 'cancelled'
        };

        if (data.orders)
        {
          conditions._id = {$in: data.orders};
        }
        else if (data.set)
        {
          conditions.set = data.set;
        }

        WhOrder.find(conditions).lean().exec(this.next());
      },
      function(err, orders)
      {
        if (err)
        {
          return this.skip(app.createError(
            `Failed to find orders to restore: ${err.message}`,
            'FIND_RESTORE_ORDERS_FAILURE'
          ));
        }

        this.orders = [];

        if (!orders.length)
        {
          return this.skip();
        }

        const $set = {};

        orders.forEach(order =>
        {
          let anyProblem = order.picklistDone === false;
          let allFinished = true;
          let finishedAt = 0;

          order.funcs.forEach(function(func)
          {
            if (anyProblem)
            {
              return;
            }

            if (func.finishedAt)
            {
              finishedAt = Math.max(finishedAt, func.finishedAt.getTime());
            }

            if (func.status === 'problem')
            {
              anyProblem = true;
            }

            if (func.status !== 'finished')
            {
              allFinished = false;
            }
          });

          if (anyProblem)
          {
            order.status = 'problem';
            order.finishedAt = new Date();
          }
          else if (allFinished)
          {
            order.status = 'finished';
            order.finishedAt = new Date(finishedAt);
            order.problem = '';
          }
          else
          {
            order.status = 'started';
            order.finishedAt = null;
            order.problem = '';
          }

          $set.status = order.status;
          $set.problem = order.problem;
          $set.finishedAt = order.finishedAt;
        });

        this.orders = orders;

        WhOrder.updateMany({_id: {$in: orders.map(o => o._id)}}, {$set}, this.next());
      },
      function(err)
      {
        if (err)
        {
          return this.skip(app.createError(
            `Failed to cancel orders: ${err.message}`,
            'CANCEL_ORDERS_FAILURE'
          ));
        }
      },
      function(err)
      {
        if (err)
        {
          return done(err);
        }

        if (this.orders.length)
        {
          app.broker.publish('wh.orders.updated', {orders: this.orders});
        }

        done(null, {orders: this.orders.map(o => o._id)}, this.orders.map(o => ({
          type: 'orderRestored',
          order: o._id,
          data: {
            orders: data.orders || null,
            set: data.set || null
          }
        })));
      }
    );
  };

  actions.updateOrder = (data, done) =>
  {
    const newOrder = data.order;

    if (!newOrder)
    {
      return done(app.createError(`Invalid input.`, 'INPUT', 400));
    }

    step(
      function()
      {
        WhOrder.findOne({_id: newOrder._id}).exec(this.next());
      },
      function(err, oldOrder)
      {
        if (err)
        {
          return this.skip(app.createError(
            `Failed to find order for update: ${err.message}`,
            'UPDATE_FIND_ORDER_FAILURE'
          ));
        }

        if (!oldOrder)
        {
          return this.skip(app.createError(
            `Order not found: ${newOrder._id}`,
            'ORDER_NOT_FOUND',
            404
          ));
        }

        oldOrder.$set(newOrder);
        oldOrder.save(this.parallel());
      },
      function(err, order)
      {
        if (err)
        {
          return this.skip(app.createError(
            `Failed to update order: ${err.message}`,
            'UPDATE_ORDER_FAILURE'
          ));
        }

        this.order = order;
      },
      function(err)
      {
        if (err)
        {
          return done(err);
        }

        app.broker.publish('wh.orders.updated', {orders: [this.order]});

        done(null, {order: this.order}, data.events);
      }
    );
  };

  actions.updatePsStatus = (data, done) =>
  {
    step(
      function()
      {
        WhOrder
          .find({
            order: data.orderNo,
            psStatus: {$ne: data.psStatus}
          })
          .exec(this.next());
      },
      function(err, whOrders)
      {
        if (err)
        {
          return this.skip(app.createError(
            `Failed to find order for PS status update: ${err.message}`,
            'UPDATE_FIND_ORDER_FAILURE'
          ));
        }

        this.orders = whOrders;

        if (!whOrders.length)
        {
          return this.skip();
        }

        whOrders.forEach(whOrder =>
        {
          whOrder.psStatus = data.psStatus;
        });

        WhOrder
          .updateMany({order: data.orderNo}, {$set: {psStatus: data.psStatus}})
          .exec(this.next());
      },
      function(err)
      {
        if (err)
        {
          return this.skip(app.createError(
            `Failed to update PS status: ${err.message}`,
            'UPDATE_ORDER_FAILURE'
          ));
        }
      },
      function(err)
      {
        if (err)
        {
          return done(err);
        }

        if (this.orders.length)
        {
          app.broker.publish('wh.orders.updated', {orders: this.orders});
        }

        done();
      }
    );
  };

  actions.printLabels = (data, done) =>
  {
    if (typeof data.qty !== 'number' || data.qty < 1 || data.qty > 10)
    {
      return done(app.createError(`Invalid label quantity: ${data.qty}`, 'INPUT', 400));
    }

    step(
      function()
      {
        WhOrder.findById(data.order).lean().exec(this.next());
      },
      function(err, whOrder)
      {
        if (err)
        {
          return this.skip(app.createError(
            `Failed to find order for printing: ${err.message}`,
            'PRINT_FIND_ORDER_FAILURE'
          ));
        }

        if (!whOrder)
        {
          return this.skip(app.createError(
            `Order not found: ${data.order}`,
            'PRINT_ORDER_NOT_FOUND',
            404
          ));
        }

        printLabels([whOrder], data.qty, data.func, this.next());
      },
      function(err)
      {
        done(err, null, [{
          type: 'labelsPrinted',
          order: data.order,
          data: {
            qty: data.qty,
            func: data.func
          }
        }]);
      }
    );
  };

  function executeNextAction()
  {
    const next = queue.shift();

    actions[next.input.action](next.input.data, (err, res, events) =>
    {
      next.done(err, res);

      if (queue.length)
      {
        setImmediate(executeNextAction);
      }
      else
      {
        queue = null;
      }

      recordEvents(events, next.input.user);
    });
  }

  function recordEvents(events, user)
  {
    if (!Array.isArray(events) || !events.length)
    {
      return;
    }

    events.forEach(event =>
    {
      event.time = event.time || new Date();
      event.user = event.user || user;
      event.order = event.order || null;
    });

    WhEvent.insertMany(events, err =>
    {
      if (err)
      {
        module.error(err, `Failed to record events.`, {events});
      }
    });
  }

  function resolveUser(personnelId, done)
  {
    step(
      function()
      {
        const conditions = {
          $or: [
            {personellId: personnelId},
            {card: personnelId},
            {cardUid: personnelId}
          ]
        };

        User.findOne(conditions, {_id: 1}).lean().exec(this.next());
      },
      function(err, user)
      {
        if (err)
        {
          return this.skip(app.createError(
            `Failed to find user: ${err.message}`,
            'RESOLVE_USER_FAILURE'
          ));
        }

        if (!user)
        {
          return this.skip(null, null);
        }

        WhUser
          .findOne({_id: user._id.toString()})
          .select({__v: 0})
          .lean()
          .exec(this.next());
      },
      function(err, whUser)
      {
        if (err)
        {
          return this.skip(app.createError(
            `Failed to find WH user: ${err.message}`,
            'RESOLVE_WH_USER_FAILURE'
          ));
        }

        if (!whUser)
        {
          return this.skip(null, null);
        }

        return this.skip(null, whUser);
      },
      done
    );
  }

  function continueSet(user, set, done)
  {
    done(null, {result: 'continueSet', set, user}, [{
      type: 'setContinued',
      data: {set, user}
    }]);
  }

  function assignSet(user, activeOrder, done)
  {
    step(
      function()
      {
        WhOrder
          .find({
            date: activeOrder.date,
            set: activeOrder.set
          })
          .sort({startTime: 1})
          .lean()
          .exec(this.next());
      },
      function(err, orders)
      {
        if (err)
        {
          return this.skip(app.createError(
            `Failed to find orders for assignment: ${err.message}`,
            'FIND_ASSIGN_ORDERS_FAILURE'
          ));
        }

        const $set = {};

        orders.forEach(order =>
        {
          $set.users = order.users = order.users.concat([user._id]);

          const func = order.funcs.find(f => f._id === user.func);
          const funcI = order.funcs.indexOf(func);

          $set[`funcs.${funcI}.user`] = func.user = {id: user._id, label: user.label};
          $set[`funcs.${funcI}.startedAt`] = func.startedAt = new Date();
          $set[`funcs.${funcI}.status`] = func.status = 'picklist';
        });

        this.orders = orders;

        WhOrder.collection.updateMany({_id: {$in: orders.map(o => o._id)}}, {$set}, this.next());
      },
      function(err)
      {
        if (err)
        {
          return this.skip(app.createError(
            `Failed to update new set: ${err.message}`,
            'ASSIGN_SET_UPDATE_FAILURE'
          ));
        }
      },
      function(err)
      {
        if (err)
        {
          return done(err);
        }

        app.broker.publish('wh.orders.updated', {orders: this.orders});

        done(null, {
          result: 'assignedToSet',
          orders: this.orders,
          user
        }, this.orders.map(o => ({
          type: 'assignedToSet',
          order: o._id,
          data: {
            set: o.set,
            user
          }
        })));

        printLabels(this.orders, 1, user.func, err =>
        {
          if (err)
          {
            module.error(`Failed to print labels after set assignment: ${err.message}`);
          }
        });
      }
    );
  }

  function startNewSet(user, date, done)
  {
    step(
      function()
      {
        if (user.func === 'packer')
        {
          return this.skip(app.createError(
            'No orders for Packer.',
            'NO_PENDING_ORDERS',
            400
          ));
        }
      },
      function()
      {
        findNextPendingOrder(date, this.next());
      },
      function(err, pendingOrder)
      {
        if (err)
        {
          return this.skip(err);
        }

        findMorePendingOrders(pendingOrder, this.parallel());

        findNextSetId(date, this.parallel());
      },
      function(err, orders, set)
      {
        if (err)
        {
          return this.skip(err);
        }

        const startedAt = new Date();
        const $set = {};

        orders.forEach(order =>
        {
          $set.status = order.status = 'started';
          $set.set = order.set = set;
          $set.startedAt = order.startedAt = startedAt;
          $set.picklistFunc = order.picklistFunc = user.func;
          $set.picklistDone = order.picklistDone = null;
          $set.users = order.users = [user._id];

          const func = order.funcs.find(f => f._id === user.func);
          const funcI = order.funcs.indexOf(func);

          $set[`funcs.${funcI}.user`] = func.user = {id: user._id, label: user.label};
          $set[`funcs.${funcI}.startedAt`] = func.startedAt = startedAt;
          $set[`funcs.${funcI}.status`] = func.status = 'picklist';
        });

        this.orders = orders;

        WhOrder.collection.updateMany({_id: {$in: orders.map(o => o._id)}}, {$set}, this.next());
      },
      function(err)
      {
        if (err)
        {
          return this.skip(app.createError(
            `Failed to update new set: ${err.message}`,
            'NEW_SET_UPDATE_FAILURE'
          ));
        }
      },
      function(err)
      {
        if (err)
        {
          return done(err);
        }

        app.broker.publish('wh.orders.updated', {orders: this.orders});

        done(null, {
          result: 'newSetStarted',
          orders: this.orders,
          user
        }, this.orders.map(o => ({
          type: 'newSetStarted',
          order: o._id,
          data: {
            set: o.set,
            user
          }
        })));

        printLabels(this.orders, 1, user.func, err =>
        {
          if (err)
          {
            module.error(`Failed to print labels after set start: ${err.message}`);
          }
        });
      }
    );
  }

  function findNextPendingOrder(date, done)
  {
    step(
      function findLastProblemLineStep()
      {
        findLastProblemLine(date, this.parallel());

        // TODO remove
        settings.findById('planning.wh.newIncludedMrps', this.parallel());
      },
      function findNextPendingOrderStep(err, problemLine, mrpsSetting)
      {
        if (err)
        {
          return this.skip(err);
        }

        this.problemLine = problemLine;
        this.mrps = mrpsSetting ? mrpsSetting.value : [];

        tryFindNextPendingOrder(date, problemLine, this.mrps, [], this.next());
      },
      function findNextNoProblemPendingOrderStep(err, whOrder)
      {
        if (err)
        {
          if (this.problemLine && err.code === 'NO_PENDING_ORDERS')
          {
            return tryFindNextPendingOrder(date, null, this.mrps, [], this.next());
          }
        }

        setImmediate(this.next(), err, whOrder);
      },
      done
    );
  }

  function findLastProblemLine(date, done)
  {
    step(
      function findLastSetIdStep()
      {
        const pipeline = [
          {$match: {date}},
          {$group: {_id: null, set: {$max: '$set'}}}
        ];

        WhOrder.aggregate(pipeline, this.next());
      },
      function findLastProblemStep(err, results)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (results.length)
        {
          WhOrder
            .findOne({
              date,
              set: results[0].set,
              status: 'problem'
            })
            .select({
              line: 1
            })
            .lean()
            .exec(this.next());
        }
      },
      function(err, whOrder)
      {
        if (err)
        {
          return done(app.createError(
            `Failed to find last problem line for [${date}]: ${err.message}`,
            'FIND_LAST_PROBLEM_LINE_FAILURE'
          ));
        }

        if (whOrder)
        {
          return done(null, whOrder.line);
        }

        done(null, null);
      }
    );
  }

  function tryFindNextPendingOrder(date, line, mrps, ignore, done)
  {
    step(
      function()
      {
        const conditions = {
          status: 'pending',
          psStatus: {$in: ['unknown', 'finished']},
          date
        };

        if (line)
        {
          conditions.line = line;
        }

        if (ignore.length)
        {
          conditions._id = {$nin: ignore};
        }

        if (mrps.length)
        {
          conditions.mrp = {$in: mrps};
        }

        const sort = {
          startTime: 1,
          line: 1
        };

        WhOrder
          .findOne(conditions)
          .sort(sort)
          .lean()
          .exec(this.next());
      },
      function(err, whOrder)
      {
        if (err)
        {
          return this.skip(app.createError(
            `Failed to find next pending order: ${err.message}`,
            'FIND_PENDING_FAILURE'
          ));
        }

        if (!whOrder)
        {
          return this.skip(app.createError(
            'No valid, pending orders.',
            'NO_PENDING_ORDERS',
            400
          ));
        }

        this.whOrder = whOrder;
      },
      function(err)
      {
        if (err)
        {
          return done(err);
        }

        if (this.whOrder)
        {
          return done(null, this.whOrder);
        }

        setImmediate(tryFindNextPendingOrder, date, line, mrps, ignore, done);
      }
    );
  }

  function findMorePendingOrders(pendingOrder, done)
  {
    if (log) log(`findMorePendingOrders id=${pendingOrder._id} order=${pendingOrder.order}`);

    step(
      function()
      {
        settings.findValues({_id: /^wh\.planning/}, 'wh.planning.', this.parallel());
      },
      function(err, whSettings)
      {
        if (err)
        {
          return this.skip(app.createError(
            `Failed to find settings: ${err.message}`,
            'FIND_SETTINGS_FAILURE'
          ));
        }

        this.groupDuration = (whSettings.groupDuration || 2) * 3600 * 1000;
        this.minSetDuration = (whSettings.minSetDuration || 120) * 60 * 1000;
        this.maxSetDuration = (whSettings.maxSetDuration || 120) * 60 * 1000;
        this.maxSetDifference = (whSettings.maxSetDifference || 120) * 60 * 1000;
        this.maxSetSize = whSettings.maxSetSize || 5;

        if (log) log('settings=', {
          groupDuration: this.groupDuration / 60000,
          minSetDuration: this.minSetDuration / 60000,
          maxSetDuration: this.maxSetDuration / 60000,
          maxSetDifference: this.maxSetDifference / 60000,
          maxSetSize: this.maxSetSize
        });

        const conditions = {
          status: 'pending',
          psStatus: {$in: ['unknown', 'finished']},
          date: pendingOrder.date,
          line: pendingOrder.line
        };

        WhOrder
          .find(conditions)
          .sort({startTime: 1})
          .lean()
          .exec(this.next());
      },
      function(err, whOrders)
      {
        if (err)
        {
          return this.skip(app.createError(
            `Failed to find more pending orders: ${err.message}`,
            'FIND_PENDING_FAILURE'
          ));
        }

        const set = [];
        let setDuration = 0;

        if (log) log({
          whOrders: whOrders.length
        });

        while (whOrders.length && set.length < this.maxSetSize)
        {
          const whOrder = whOrders.shift();
          const orderDuration = whOrder.finishTime - whOrder.startTime;

          if (log) log('candidate', {
            order: whOrder.order,
            orderDuration: orderDuration / 60000,
            setDuration: setDuration / 60000
          });

          // Stop: the time difference between orders is too big.
          if (set.length && whOrder.startTime - set[set.length - 1].finishTime > this.maxSetDifference)
          {
            if (log) log('stop: max set diff');

            break;
          }

          // Order fits in the group's boundaries or it's the first order.
          if ((setDuration + orderDuration <= this.groupDuration)
            || set.length === 0)
          {
            setDuration += orderDuration;

            set.push(whOrder);

            if (log) log('add');

            continue;
          }

          // Min set duration exceeded, don't extend.
          if (setDuration > this.minSetDuration)
          {
            if (log) log('stop: min set duration');

            break;
          }

          // Max set duration exceeded, ignore.
          if (setDuration + orderDuration > this.maxSetDuration)
          {
            if (log) log('ignore: max set duration');

            continue;
          }

          // Extend set.
          setDuration += orderDuration;

          set.push(whOrder);

          if (log) log('extend');
        }

        if (log) log('final', {
          set: set.map(o => o.order),
          duration: setDuration / 60000
        });

        this.skip(null, set);
      },
      done
    );
  }

  function findNextSetId(date, done)
  {
    const pipeline = [
      {$match: {date}},
      {$group: {_id: null, set: {$max: '$set'}}}
    ];

    WhOrder.aggregate(pipeline, (err, result) =>
    {
      if (err)
      {
        return done(app.createError(
          `Failed to find next set ID: ${err.message}`,
          'FIND_SET_ID_FAILURE'
        ));
      }

      done(null, (result[0].set || 0) + 1);
    });
  }

  function printLabels(whOrders, labelQty, userFunc, done)
  {
    if (!WhOrder.FUNCS.includes(userFunc))
    {
      return done(app.createError(`Unknown user function: ${userFunc}`, 'PRINT_FAILURE'));
    }

    step(
      function()
      {
        fs.readFile(`${__dirname}/templates/label.tpl.prn`, 'utf8', this.parallel());

        Printer
          .findOne({tags: `wh/cart/${userFunc}`})
          .lean()
          .exec(this.parallel());

        Order
          .find({_id: {$in: whOrders.map(o => o.order)}}, {nc12: 1, qty: 1})
          .lean()
          .exec(this.parallel());

        settings.findById('wh.printing.barcodeData', this.parallel());
      },
      function(err, template, printer, sapOrders, barcodeDataSetting)
      {
        if (err)
        {
          return this.skip(app.createError(
            `Failed to find print data: ${err.message}`,
            'PRINT_FAILURE'
          ));
        }

        if (!printer)
        {
          return this.skip(app.createError(`No wh/cart/${userFunc} printer!`, 'PRINT_FAILURE'));
        }

        const barcodeData = barcodeDataSetting ? barcodeDataSetting.value : '12nc';
        const zpl = whOrders.map(whOrder =>
        {
          const sapOrder = sapOrders.find(o => o._id === whOrder.order) || {
            nc12: '000000000000',
            qty: 0
          };

          return compileZpl(template, barcodeData, {
            labelQty,
            time: moment.utc(whOrder.startTime).format('DD.MM.YYYY, HH:mm'),
            line: whOrder.line,
            order: whOrder.order,
            nc12: sapOrder.nc12,
            qtyPlan: whOrder.qty,
            qtyTodo: sapOrder.qty
          });
        });

        html2pdf.printZpl(zpl.join('\r\n'), {printer}, this.next());
      },
      function(err)
      {
        if (err)
        {
          return done(app.createError(
            `Failed to print labels: ${err.message}`,
            'PRINT_FAILURE'
          ));
        }
      },
      done
    );
  }

  function compileZpl(zpl, barcodeData, data)
  {
    const qtyPlan = Math.max(1, Math.min(data.qtyPlan, 9999)).toString();
    const templateData = {
      DLE: '\u0010',
      TIME: data.time,
      LINE: e(data.line),
      ORDER_NO: data.order,
      NC12: data.nc12,
      QTY_PLAN: qtyPlan,
      QTY_TODO: data.qtyTodo,
      BARCODE_X: 0,
      BARCODE_DATA: '',
      LABEL_QTY: data.labelQty
    };

    encodeBarcodeData(templateData, barcodeData === 'orderNo' ? data.order : data.nc12, qtyPlan);

    Object.keys(templateData).forEach(key =>
    {
      zpl = zpl.replace(new RegExp('\\$\\{' + key + '\\}', 'g'), templateData[key]);
    });

    return zpl;
  }

  function encodeBarcodeData(templateData, id, qty)
  {
    let barcodeX = [];
    let barcodeData = '>';

    if (id.length === 9)
    {
      barcodeX = [0, 170, 140, 110, 110];
      barcodeData += `;${id.substring(0, 8)}>7${encodeCodeC(id.substring(8, 9))}`;
    }
    else if (id.length === 7)
    {
      barcodeX = [0, 102, 75, 45, 45];
      barcodeData += `:${id}>7`;
    }
    else if (id.length === 12)
    {
      barcodeX = [0, 140, 110, 80, 80];
      barcodeData += `;${id}>7`;
    }
    else
    {
      templateData.BARCODE_X = 192;
      templateData.BARCODE_DATA = '>:?>7737373>6?';

      return templateData;
    }

    barcodeData += `737373`;

    if (qty.length === 4)
    {
      barcodeData += `>5${qty}`;
    }
    else
    {
      barcodeData += encodeCodeC(qty);
    }

    templateData.BARCODE_X = barcodeX[qty.length];
    templateData.BARCODE_DATA = barcodeData;

    return templateData;
  }

  function encodeCodeC(n)
  {
    return n.toString().split('').map(s => (parseInt(s, 10) + 16).toString()).join('');
  }

  function e(v)
  {
    return (v || '').replace('~', '\\7e');
  }
};
