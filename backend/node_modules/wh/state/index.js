// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

/* eslint-disable curly */

'use strict';

const _ = require('lodash');
const locks = require('util/locks');
const actions = require('./actions');
const printLabels = require('./printLabels');
const handleSerialNumber = require('./handleSerialNumber');
const handleFinishOrder = require('./handleFinishOrder');

module.exports = (app, module) =>
{
  if (module.config.generator)
  {
    return;
  }

  const {
    settings,
    OldWhOrder: WhOrder,
    OldWhLine: WhLine
  } = module;

  let releases = [];
  let queue = null;
  const recountingLines = new Set();

  app.broker.subscribe('app.started', onAppStarted).setLimit(1);
  app.broker.subscribe('settings.updated.wh.planning.**', onSettingUpdated);
  app.broker.subscribe('production.taktTime.snChecked.**', onSnChecked);
  app.broker.subscribe('production.synced.**', onProductionSynced);

  module.state = {
    settings: {},
    act: (input, done) =>
    {
      if (!actions[input.action])
      {
        return done(app.createError(`Unknown action.`, 'UNKNOWN_ACTION', 400, {input}));
      }

      if (queue !== null)
      {
        queue.push({input, done});

        return;
      }

      queue = [{input, done}];

      setImmediate(executeNextAction);
    },
    lock,
    printLabels: printLabels.bind(null, app, module),
    scheduleLineRecount,
    abortTransaction
  };

  async function executeNextAction()
  {
    const next = queue.shift();
    const action = actions[next.input.action];
    const input = {...next.input};

    if (input.data
      && typeof input.data.date === 'string'
      && /^[0-9]{4}-[0-9]{2}-[0-9]{2}$/.test(input.data.date))
    {
      input.data.date = new Date(`${input.data.date}T00:00:00Z`);
    }

    const timeout = setTimeout(handleActionTimeout, 5000, input);

    if (action.detached)
    {
      if (queue.length)
      {
        setImmediate(executeNextAction);
      }
      else
      {
        queue = null;
      }
    }

    try
    {
      if (action.session)
      {
        input.session = await WhOrder.startSession();
        input.session.startTransaction();
      }

      const result = {
        response: {},
        messages: [],
        results: [],
        ...(await action.execute(app, module, input))
      };

      result.messages.forEach(({topic, message, meta}) =>
      {
        app.broker.publish(topic, message, meta);
      });

      _.flatten(result.results).forEach(subResult =>
      {
        if (!subResult)
        {
          return;
        }

        if (Array.isArray(subResult.messages))
        {
          subResult.messages.forEach(({topic, message, meta}) =>
          {
            app.broker.publish(topic, message, meta);
          });
        }
      });

      next.done(null, result.response);
    }
    catch (err)
    {
      next.done(err);

      await abortTransaction(input.session);
    }
    finally
    {
      clearTimeout(timeout);

      if (input.session)
      {
        input.session.endSession();
        input.session = null;
      }

      if (releases.length)
      {
        releases.forEach(release => release());
        releases = [];
      }
    }

    if (!action.detached)
    {
      if (queue.length)
      {
        setImmediate(executeNextAction);
      }
      else
      {
        queue = null;
      }
    }
  }

  function handleActionTimeout(input)
  {
    module.warn(`Action timeout.`, {
      input,
      queueLength: queue ? queue.length : 0
    });
  }

  async function onAppStarted()
  {
    try
    {
      module.state.settings = await settings.findValues('wh.planning.');
    }
    catch (err)
    {
      module.error(err, 'Failed to load settings.');
    }
  }

  function onSettingUpdated({_id, value})
  {
    module.state.settings[_id.replace('wh.planning.', '')] = value;
  }

  function onSnChecked({serialNumber})
  {
    handleSerialNumber(app, module, serialNumber);
  }

  async function abortTransaction(session)
  {
    if (session)
    {
      try
      {
        await session.abortTransaction();
      }
      catch (err)
      {
        if (err.message !== 'Cannot call abortTransaction twice')
        {
          module.error(err, `Failed to abort a transaction.`);
        }
      }
    }
  }

  function onProductionSynced({prodLine, finishedPso})
  {
    if (Array.isArray(finishedPso) && finishedPso.length)
    {
      handleFinishOrder(app, module, prodLine, finishedPso);
    }
  }

  async function lock(key)
  {
    return new Promise((resolve) =>
    {
      const release = locks.create(key, () =>
      {
        resolve(release);
      });

      releases.push(release);
    });
  }

  function scheduleLineRecount(lineId)
  {
    if (recountingLines.has(lineId))
    {
      return;
    }

    recountingLines.add(lineId);

    setTimeout(recountLine, 60000, lineId);
  }

  async function recountLine(lineId)
  {
    const releaseLock = await locks.createAsync(`${WhLine.TOPIC_PREFIX}.${lineId}`);

    try
    {
      const {messages} = await WhLine.recountComponents(lineId, null);

      messages.forEach(({topic, message, meta}) =>
      {
        app.broker.publish(topic, message, meta);
      });

      recountingLines.delete(lineId);
    }
    catch (err)
    {
      module.error(err, `Failed to recount line.`, {lineId});

      recountingLines.delete(lineId);

      scheduleLineRecount(lineId);
    }

    releaseLock();
  }
};
