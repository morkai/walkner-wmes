// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

/* eslint-disable curly */

'use strict';

const fs = require('fs-extra');
const _ = require('lodash');
const moment = require('moment');
const step = require('h5.step');
const locks = require('util/locks');
const actions = require('./actions');

module.exports = (app, module) =>
{
  if (module.config.generator)
  {
    return;
  }

  const {
    settings,
    html2pdf,
    OldWhOrder: WhOrder,
    OldWhDeliveredOrder: WhDeliveredOrder,
    OldWhLine: WhLine,
    Order,
    Printer
  } = module;

  let releases = [];
  let queue = null;
  const recountingLines = new Set();

  app.broker.subscribe('app.started', onAppStarted).setLimit(1);
  app.broker.subscribe('settings.updated.wh.planning.**', onSettingUpdated);
  app.broker.subscribe('production.taktTime.snChecked.**', onSnChecked);

  module.state = {
    settings: {},
    act: (input, done) =>
    {
      if (!actions[input.action])
      {
        return done(app.createError(`Unknown action.`, 'UNKNOWN_ACTION', 400, {input}));
      }

      module.debug(`Action queued.`, {
        queueLength: queue ? 0 : queue.length,
        action: input
      });

      if (queue !== null)
      {
        queue.push({input, done});

        return;
      }

      queue = [{input, done}];

      setImmediate(executeNextAction);
    },
    lock,
    printLabels
  };

  actions.restoreOrders = (data, done) =>
  {
    step(
      function()
      {
        const conditions = {
          date: data.date,
          status: 'cancelled'
        };

        if (data.orders)
        {
          conditions._id = {$in: data.orders};
        }
        else if (data.set)
        {
          conditions.set = data.set;
        }

        WhOrder.find(conditions).lean().exec(this.next());
      },
      function(err, orders)
      {
        if (err)
        {
          return this.skip(app.createError(
            `Failed to find orders to restore: ${err.message}`,
            'FIND_RESTORE_ORDERS_FAILURE'
          ));
        }

        this.orders = [];

        if (!orders.length)
        {
          return this.skip();
        }

        const $set = {};

        orders.forEach(order =>
        {
          let anyProblem = order.picklistDone === 'failure';
          let allFinished = true;
          let finishedAt = 0;

          order.funcs.forEach(function(func)
          {
            if (anyProblem)
            {
              return;
            }

            if (func.finishedAt)
            {
              finishedAt = Math.max(finishedAt, func.finishedAt.getTime());
            }

            if (func.status === 'problem')
            {
              anyProblem = true;
            }

            if (func.status !== 'finished')
            {
              allFinished = false;
            }
          });

          if (anyProblem)
          {
            order.status = 'problem';
            order.finishedAt = new Date();
          }
          else if (allFinished)
          {
            order.status = 'finished';
            order.finishedAt = new Date(finishedAt);
            order.problem = '';
          }
          else
          {
            order.status = 'started';
            order.finishedAt = null;
            order.problem = '';
          }

          $set.status = order.status;
          $set.problem = order.problem;
          $set.finishedAt = order.finishedAt;
        });

        this.orders = orders;

        WhOrder.updateMany({_id: {$in: orders.map(o => o._id)}}, {$set}, this.next());
      },
      function(err)
      {
        if (err)
        {
          return this.skip(app.createError(
            `Failed to cancel orders: ${err.message}`,
            'CANCEL_ORDERS_FAILURE'
          ));
        }
      },
      function(err)
      {
        if (err)
        {
          return done(err);
        }

        if (this.orders.length)
        {
          app.broker.publish(`${WhOrder.TOPIC_PREFIX}.updated`, {orders: this.orders});
        }

        done(null, {orders: this.orders.map(o => o._id)}, this.orders.map(o => ({
          type: 'orderRestored',
          order: o._id,
          data: {
            orders: data.orders || null,
            set: data.set || null
          }
        })));
      }
    );
  };

  async function executeNextAction()
  {
    const next = queue.shift();

    module.debug(`Executing action.`, {action: next.input.action});

    const action = actions[next.input.action];
    const input = {...next.input};

    if (input.data
      && typeof input.data.date === 'string'
      && /^[0-9]{4}-[0-9]{2}-[0-9]{2}$/.test(input.data.date))
    {
      input.data.date = new Date(`${input.data.date}T00:00:00Z`);
    }

    if (action.detached)
    {
      if (queue.length)
      {
        setImmediate(executeNextAction);
      }
      else
      {
        queue = null;
      }
    }

    try
    {
      if (action.session)
      {
        input.session = await WhOrder.startSession();
        input.session.startTransaction();
      }

      const result = {
        response: {},
        messages: [],
        results: [],
        ...(await action.execute(app, module, input))
      };

      result.messages.forEach(({topic, message, meta}) =>
      {
        app.broker.publish(topic, message, meta);
      });

      _.flatten(result.results).forEach(subResult =>
      {
        if (!subResult)
        {
          return;
        }

        if (Array.isArray(subResult.messages))
        {
          subResult.messages.forEach(({topic, message, meta}) =>
          {
            app.broker.publish(topic, message, meta);
          });
        }
      });

      next.done(null, result.response);
    }
    catch (err)
    {
      next.done(err);

      if (input.session)
      {
        try
        {
          await input.session.abortTransaction();
        }
        catch (err)
        {
          if (err.message !== 'Cannot call abortTransaction twice')
          {
            module.error(err, `Failed to abort action transaction.`, {input: next.input});
          }
        }
      }
    }
    finally
    {
      if (input.session)
      {
        input.session.endSession();
        input.session = null;
      }

      if (releases.length)
      {
        releases.forEach(release => release());
        releases = [];
      }
    }

    if (!action.detached)
    {
      if (queue.length)
      {
        setImmediate(executeNextAction);
      }
      else
      {
        queue = null;
      }
    }
  }

  async function onAppStarted()
  {
    try
    {
      module.state.settings = await settings.findValues('wh.planning.');
    }
    catch (err)
    {
      module.error(err, 'Failed to load settings.');
    }
  }

  function onSettingUpdated({_id, value})
  {
    module.state.settings[_id.replace('wh.planning.', '')] = value;
  }

  async function onSnChecked({serialNumber})
  {
    const releaseLock = await locks.createAsync(`${WhLine.TOPIC_PREFIX}.${serialNumber.prodLine}`);

    let session = null;

    try
    {
      session = await WhLine.startSession();
      session.startTransaction();

      let whDeliveredOrder = null;
      let whLine = null;

      const deliveredOrderResult = await WhDeliveredOrder.collection.findOneAndUpdate(
        {
          sapOrder: serialNumber.orderNo,
          line: serialNumber.prodLine,
          qtyRemaining: {$gt: 0}
        },
        {$inc: {
          qtyDone: 1,
          qtyRemaining: -1
        }},
        {
          projection: {
            qtyDone: 1,
            qtyRemaining: 1,
            pceTime: 1,
            line: 1
          },
          sort: {startTime: 1},
          returnOriginal: false,
          session
        }
      );

      whDeliveredOrder = deliveredOrderResult.value;

      if (whDeliveredOrder)
      {
        const lineResult = await WhLine.collection.findOneAndUpdate(
          {_id: serialNumber.prodLine},
          {$inc: {
            'components.qty': -1,
            'components.time': deliveredOrderResult.value.pceTime * -1
          }},
          {
            projection: {
              components: 1
            },
            returnOriginal: false,
            session
          }
        );

        whLine = lineResult.value;
      }

      await session.commitTransaction();

      if (whDeliveredOrder)
      {
        app.broker.publish(`${WhDeliveredOrder.TOPIC_PREFIX}.updated`, {
          updated: [whDeliveredOrder]
        });
      }

      if (whLine)
      {
        app.broker.publish(`${WhLine.TOPIC_PREFIX}.updated`, {
          updated: [whLine]
        });
      }
    }
    catch (err)
    {
      if (session)
      {
        try
        {
          await session.abortTransaction();
        }
        catch (err)
        {
          if (err.message !== 'Cannot call abortTransaction twice')
          {
            module.error(err, `Failed to abort SN transaction.`);
          }
        }
      }

      module.error(err, `Failed to update line after SN check.`, {serialNumber});

      scheduleLineRecount(serialNumber.prodLine);
    }

    if (session)
    {
      session.endSession();
    }

    releaseLock();
  }

  async function lock(key)
  {
    return new Promise((resolve) =>
    {
      const release = locks.create(key, () =>
      {
        resolve(release);
      });

      releases.push(release);
    });
  }

  async function printLabels(whOrders, labelQty, userFunc)
  {
    return new Promise((resolve, reject) =>
    {
      if (!WhOrder.FUNCS.includes(userFunc))
      {
        return reject(app.createError(`Unknown user function.`, 'PRINT_FAILURE'));
      }

      step(
        function()
        {
          fs.readFile(`${__dirname}/../templates/label.tpl.prn`, 'utf8', this.parallel());

          Printer
            .findOne({tags: `wh/cart/${userFunc}`})
            .lean()
            .exec(this.parallel());

          Order
            .find({_id: {$in: whOrders.map(o => o.order)}}, {nc12: 1, qty: 1})
            .lean()
            .exec(this.parallel());

          settings.findById('wh.printing.barcodeData', this.parallel());
        },
        function(err, template, printer, sapOrders, barcodeDataSetting)
        {
          if (err)
          {
            return this.skip(app.createError(
              `Failed to find print data: ${err.message}`,
              'PRINT_FAILURE'
            ));
          }

          if (!printer)
          {
            return this.skip(app.createError(`No wh/cart/${userFunc} printer!`, 'PRINT_FAILURE'));
          }

          const barcodeData = barcodeDataSetting ? barcodeDataSetting.value : '12nc';
          const zpl = whOrders.map(whOrder =>
          {
            const sapOrder = sapOrders.find(o => o._id === whOrder.order) || {
              nc12: '000000000000',
              qty: 0
            };

            return compileZpl(template, barcodeData, {
              labelQty,
              time: moment.utc(whOrder.startTime).format('DD.MM.YYYY, HH:mm'),
              line: whOrder.line,
              order: whOrder.order,
              nc12: sapOrder.nc12,
              qtyPlan: whOrder.qty,
              qtyTodo: sapOrder.qty
            });
          });

          html2pdf.printZpl(zpl.join('\r\n'), {printer}, this.next());
        },
        function(err)
        {
          if (err)
          {
            return this.skip(app.createError(
              `Failed to print labels: ${err.message}`,
              'PRINT_FAILURE'
            ));
          }
        },
        function(err)
        {
          if (err)
          {
            return reject(err);
          }

          resolve();
        }
      );
    });
  }

  function compileZpl(zpl, barcodeData, data)
  {
    const qtyPlan = Math.max(1, Math.min(data.qtyPlan, 9999)).toString();
    const templateData = {
      DLE: '\u0010',
      TIME: data.time,
      LINE: e(data.line),
      ORDER_NO: data.order,
      NC12: data.nc12,
      QTY_PLAN: qtyPlan,
      QTY_TODO: data.qtyTodo,
      BARCODE_X: 0,
      BARCODE_DATA: '',
      LABEL_QTY: data.labelQty
    };

    encodeBarcodeData(templateData, barcodeData === 'orderNo' ? data.order : data.nc12, qtyPlan);

    Object.keys(templateData).forEach(key =>
    {
      zpl = zpl.replace(new RegExp('\\$\\{' + key + '\\}', 'g'), templateData[key]);
    });

    return zpl;
  }

  function encodeBarcodeData(templateData, id, qty)
  {
    let barcodeX = [];
    let barcodeData = '>';

    if (id.length === 9)
    {
      barcodeX = [0, 170, 140, 110, 110];
      barcodeData += `;${id.substring(0, 8)}>7${encodeCodeC(id.substring(8, 9))}`;
    }
    else if (id.length === 7)
    {
      barcodeX = [0, 102, 75, 45, 45];
      barcodeData += `:${id}>7`;
    }
    else if (id.length === 12)
    {
      barcodeX = [0, 140, 110, 80, 80];
      barcodeData += `;${id}>7`;
    }
    else
    {
      templateData.BARCODE_X = 192;
      templateData.BARCODE_DATA = '>:?>7737373>6?';

      return templateData;
    }

    barcodeData += `737373`;

    if (qty.length === 4)
    {
      barcodeData += `>5${qty}`;
    }
    else
    {
      barcodeData += encodeCodeC(qty);
    }

    templateData.BARCODE_X = barcodeX[qty.length];
    templateData.BARCODE_DATA = barcodeData;

    return templateData;
  }

  function encodeCodeC(n)
  {
    return n.toString().split('').map(s => (parseInt(s, 10) + 16).toString()).join('');
  }

  function e(v)
  {
    return (v || '').replace('~', '\\7e');
  }

  function scheduleLineRecount(lineId)
  {
    if (recountingLines.has(lineId))
    {
      return;
    }

    recountingLines.add(lineId);

    setTimeout(recountLine, 60000, lineId);
  }

  async function recountLine(lineId)
  {
    const releaseLock = await locks.createAsync(`${WhLine.TOPIC_PREFIX}.${lineId}`);

    try
    {
      const {messages} = await WhLine.recountComponents(lineId, null);

      messages.forEach(({topic, message, meta}) =>
      {
        app.broker.publish(topic, message, meta);
      });

      recountingLines.delete(lineId);
    }
    catch (err)
    {
      module.error(err, `Failed to recount line.`, {lineId});

      recountingLines.delete(lineId);

      scheduleLineRecount(lineId);
    }

    releaseLock();
  }
};
