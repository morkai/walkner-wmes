// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

/* eslint-disable curly */

'use strict';

const _ = require('lodash');
const {ObjectId} = require('mongoose').Types;
const locks = require('util/locks');
const shifts = require('util/shifts');
const actions = require('./actions');
const printLabels = require('./printLabels');
const printPsPicklist = require('./printPsPicklist');
const handleSerialNumber = require('./handleSerialNumber');
const handleFinishOrder = require('./handleFinishOrder');
const createPickupStatus = require('./pickupStatus');
const setUpCancelQueue = require('./cancelQueue');
const updateStartedPlan = require('./updateStartedPlan');
const updatePlanInfo = require('./updatePlanInfo');

module.exports = (app, module) =>
{
  if (module.config.generator)
  {
    return;
  }

  const {
    settings,
    OldWhOrder: WhOrder,
    OldWhLine: WhLine,
    OldWhLineSnapshot: WhLineSnapshot
  } = module;

  const doUpdateStartedPlan = updateStartedPlan.bind(null, app, module);
  const doUpdatePlanInfo = updatePlanInfo.bind(null, app, module);
  const scheduleNextPlanInfoUpdate = _.debounce(doUpdatePlanInfo, 15000);

  let releases = [];
  let queue = null;
  const recountingLines = new Set();
  const workingLines = new Map();

  app.broker.subscribe('app.started', onAppStarted).setLimit(1);
  app.broker.subscribe('settings.updated.wh.planning.**', onSettingUpdated);
  app.broker.subscribe('production.taktTime.snChecked.**', onSnChecked);
  app.broker.subscribe('production.synced.**', onProductionSynced);
  app.broker.subscribe('production.stateChanged.**', onProductionStateChanged);
  app.broker.subscribe('orders.updated.*', onOrderUpdated);
  app.broker.subscribe('planning.changes.created', onPlanChanged);
  app.broker.subscribe('shiftChanged', onShiftChanged);
  app.broker.subscribe(`${WhLine}.updated`, onLineUpdated);

  module.state = {
    settings: {},
    pendingPriorityLines: [],
    act: (input, done) =>
    {
      if (!actions[input.action])
      {
        return done(app.createError(`Unknown action.`, 'UNKNOWN_ACTION', 400, {input}));
      }

      if (queue !== null)
      {
        queue.push({input, done});

        return;
      }

      queue = [{input, done}];

      setImmediate(executeNextAction);
    },
    inspectResults: (results, prop) =>
    {
      const props = prop ? [prop] : Object.keys(results);

      props.forEach(prop =>
      {
        console.log(`${prop}=`);

        if (results[prop])
        {
          console.inspect(_.omit(results[prop], ['messages']));
        }
        else
        {
          console.inspect(null);
        }
      });
    },
    lock,
    printLabels: printLabels.bind(null, app, module),
    printPsPicklist: printPsPicklist.bind(null, app, module),
    scheduleLineRecount,
    abortTransaction,
    pickupStatus: createPickupStatus(app, module),
    getLineWorkStatus: lineId => workingLines.get(lineId)
  };

  setUpCancelQueue(app, module);

  async function executeNextAction()
  {
    const next = queue.shift();
    const action = actions[next.input.action];
    const input = {
      data: {},
      ...next.input
    };

    if (typeof input.data.date === 'string'
      && /^[0-9]{4}-[0-9]{2}-[0-9]{2}$/.test(input.data.date))
    {
      input.data.date = new Date(`${input.data.date}T00:00:00Z`);
    }

    const timeout = setTimeout(handleActionTimeout, 5000, input);

    if (action.detached)
    {
      if (queue.length)
      {
        setImmediate(executeNextAction);
      }
      else
      {
        queue = null;
      }
    }

    try
    {
      if (action.session)
      {
        input.session = await WhOrder.startSession();
        input.session.startTransaction();
      }

      const result = {
        response: {},
        messages: [],
        results: [],
        ...(await action.execute(app, module, input))
      };

      result.messages.forEach(({topic, message, meta}) =>
      {
        app.broker.publish(topic, message, meta);
      });

      _.flatten(result.results).forEach(subResult =>
      {
        if (!subResult)
        {
          return;
        }

        if (Array.isArray(subResult.messages))
        {
          subResult.messages.forEach(({topic, message, meta}) =>
          {
            app.broker.publish(topic, message, meta);
          });
        }
      });

      next.done(null, result.response);
    }
    catch (err)
    {
      next.done(err);

      if (input.session)
      {
        await abortTransaction(input.session);
      }
    }
    finally
    {
      clearTimeout(timeout);

      if (input.session)
      {
        input.session.endSession();
        input.session = null;
      }

      if (releases.length)
      {
        releases.forEach(release => release());
        releases = [];
      }
    }

    if (!action.detached)
    {
      if (queue.length)
      {
        setImmediate(executeNextAction);
      }
      else
      {
        queue = null;
      }
    }
  }

  function handleActionTimeout(input)
  {
    module.warn(`Action timeout.`, {
      input: {...input, session: undefined},
      queueLength: queue ? queue.length : 0
    });
  }

  async function onAppStarted()
  {
    try
    {
      module.state.settings = await settings.findValues('wh.planning.');
    }
    catch (err)
    {
      module.error(err, 'Failed to load settings.');
    }

    module.state.pickupStatus.updateNow();
    scheduleNextPlanInfoUpdate();
    snapshotLines();
  }

  function onSettingUpdated({_id, value})
  {
    module.state.settings[_id.replace('wh.planning.', '')] = value;
  }

  function onSnChecked({serialNumber})
  {
    handleSerialNumber(app, module, serialNumber);
  }

  async function abortTransaction(session)
  {
    if (session)
    {
      try
      {
        await session.abortTransaction();
      }
      catch (err)
      {
        if (err.message !== 'Cannot call abortTransaction twice')
        {
          module.error(err, `Failed to abort a transaction.`);
        }
      }
    }
  }

  function toggleLineWorkStatus(lineId, working)
  {
    if (typeof working !== 'boolean')
    {
      const production = app[module.config.productionId];
      const lineState = production && production.getProdLineState(lineId);

      working = !!lineState && !!lineState.getCurrentOrder();
    }

    if (workingLines.get(lineId) === working)
    {
      return;
    }

    workingLines.set(lineId, working);

    app.broker.publish(`${WhLine.TOPIC_PREFIX}.updated`, {
      updated: [{
        _id: lineId,
        working
      }]
    });
  }

  function onProductionSynced(message)
  {
    const {types, prodLine, finishedPso} = message;

    if (Array.isArray(finishedPso) && finishedPso.length)
    {
      handleFinishOrder(app, module, prodLine, finishedPso);
    }

    if (types.includes('changeOrder') || types.includes('endWork'))
    {
      doUpdateStartedPlan(prodLine);
    }
  }

  function onProductionStateChanged(changes)
  {
    if (changes.online || changes.prodShiftOrders !== undefined)
    {
      toggleLineWorkStatus(changes._id);
    }
  }

  function onOrderUpdated(message)
  {
    const {psStatus, drillStatus} = message.change.newValues;

    if (!psStatus && !drillStatus)
    {
      return;
    }

    const input = {
      action: 'updatePsStatus',
      data: {
        orderNo: message._id,
        psStatus,
        drillStatus
      }
    };

    module.state.act(input, err =>
    {
      if (err)
      {
        module.error(err, 'Failed to update PS status.', {input});
      }
    });
  }

  async function lock(key)
  {
    return new Promise((resolve) =>
    {
      const release = locks.create(key, () =>
      {
        resolve(release);
      });

      releases.push(release);
    });
  }

  function scheduleLineRecount(lineId)
  {
    if (recountingLines.has(lineId))
    {
      return;
    }

    recountingLines.add(lineId);

    setTimeout(recountLine, 60000, lineId);
  }

  async function recountLine(lineId)
  {
    const releaseLock = await locks.createAsync(`${WhLine.TOPIC_PREFIX}.${lineId}`);

    try
    {
      const {messages} = await WhLine.recountAvailable(lineId, null);

      messages.forEach(({topic, message, meta}) =>
      {
        app.broker.publish(topic, message, meta);
      });

      recountingLines.delete(lineId);
    }
    catch (err)
    {
      module.error(err, `Failed to recount line.`, {lineId});

      recountingLines.delete(lineId);

      scheduleLineRecount(lineId);
    }

    releaseLock();
  }

  function onPlanChanged()
  {
    scheduleNextPlanInfoUpdate();
  }

  function onShiftChanged()
  {
    doUpdatePlanInfo();
    scheduleSetUnassignment();
  }

  function onLineUpdated({added})
  {
    if (added && added.length)
    {
      doUpdatePlanInfo();

      added.forEach(line => doUpdateStartedPlan(line._id));
    }
  }

  async function snapshotLines()
  {
    const time = new Date();

    try
    {
      const lines = await WhLine.find({}).lean().exec();

      await WhLine.prepareLines(lines);

      const ops = lines.map(line => ({
        insertOne: {
          document: {
            _id: new ObjectId(),
            line: line._id,
            time,
            data: line
          }
        }
      }));

      ops.push({
        deleteMany: {
          filter: {
            time: {$lt: new Date(time.getTime() - 21 * 24 * 3600 * 1000)}
          }
        }
      });

      await WhLineSnapshot.collection.bulkWrite(ops);

      module.debug(`Snapshotted lines.`);
    }
    catch (err)
    {
      module.error(err, `Failed to snapshot lines.`);
    }

    setTimeout(snapshotLines, Math.floor(5 * 60 * 1000 - (time.getTime() % (5 * 60 * 1000))));
  }

  function scheduleSetUnassignment()
  {
    if (module.state.settings.unassignSetDelay >= 1)
    {
      setTimeout(unassignSets, Math.min(module.state.settings.unassignSetDelay, 475) * 60 * 1000);
    }
  }

  async function unassignSets()
  {
    try
    {
      const shiftStartedAt = shifts.getCurrentShiftInfo().date;
      const startedSets = await WhOrder.aggregate([
        {$match: {
          status: 'started',
          'funcs.startedAt': {$lt: shiftStartedAt}
        }},
        {$group: {
          _id: {
            date: '$date',
            set: '$set'
          },
          orders: {$push: '$funcs'}
        }}
      ]).exec();

      for (const startedSet of startedSets)
      {
        const funcsToUnassign = new Set();

        startedSet.orders.forEach(orderFuncs =>
        {
          orderFuncs.forEach(orderFunc =>
          {
            if (orderFunc.user
              && orderFunc.status !== 'problem'
              && orderFunc.status !== 'finished'
              && orderFunc.startedAt < shiftStartedAt)
            {
              funcsToUnassign.add(orderFunc._id);
            }
          });
        });

        for (const func of funcsToUnassign)
        {
          await unassignSet(startedSet._id.date, startedSet._id.set, func);
        }
      }
    }
    catch (err)
    {
      module.error(err, 'Failed to unassign sets.');
    }
  }

  async function unassignSet(date, set, func)
  {
    return new Promise(resolve =>
    {
      const input = {
        action: 'unassignSet',
        data: {
          date,
          set,
          func,
          user: {
            id: null,
            label: 'System'
          }
        }
      };

      module.state.act(input, err =>
      {
        if (err)
        {
          module.error(err, 'Failed to unassign set.', {date, set, func});
        }
        else
        {
          module.debug('Unassigned from set.', {date, set, func});
        }

        resolve();
      });
    });
  }
};
