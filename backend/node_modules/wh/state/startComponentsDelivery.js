// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const {ObjectId} = require('mongoose').Types;

module.exports = async (app, module, {data, user, whUser, session}) =>
{
  const {
    OldWhEvent: WhEvent,
    OldWhOrder: WhOrder,
    OldWhSetCart: WhSetCart,
    OldWhLine: WhLine,
    OldWhPendingComponents: WhPendingComponents,
    OldWhPendingPackaging: WhPendingPackaging,
    OldWhDeliveredOrder: WhDeliveredOrder
  } = module;

  const {
    kind
  } = data;
  const now = new Date();
  const minTimeForDelivery = (module.state.settings.minTimeForDelivery || 45) * 60 * 1000;
  const maxSetCartsPerDelivery = module.state.settings.maxSetCartsPerDelivery || 3;

  const pendingComponentsResult = {
    deleted: [],
    added: [],
    messages: []
  };
  const pendingPackagingResult = {
    added: [],
    messages: []
  };
  const deliveredOrdersResult = {
    added: [],
    messages: []
  };
  const linesResult = {
    updated: [],
    messages: []
  };
  const whOrdersResult = {
    updated: [],
    messages: []
  };
  const setCartsResult = {
    updated: [],
    messages: []
  };

  // Check if there are any pending sets for delivery
  const pendingComponents = await WhPendingComponents
    .find()
    .sort({_id: 1})
    .lean()
    .session(session)
    .exec();

  // Find carts from the pending sets that are awaiting delivery
  const pendingSets = [];
  let pendingCount = 0;

  for (const pendingDelivery of pendingComponents)
  {
    const setCarts = await WhSetCart
      .find({
        status: 'completed',
        date: pendingDelivery.date,
        set: pendingDelivery.set,
        kind
      })
      .sort({startTime: 1})
      .hint({status: 1, date: -1})
      .lean()
      .session(session)
      .exec();

    // No more carts: delete pending delivery
    if (!setCarts.length)
    {
      pendingComponentsResult.deleted.push(pendingDelivery);

      continue;
    }

    pendingSets.push({
      pendingDelivery,
      setCarts
    });

    pendingCount += setCarts.length;

    // Max reached: ignore the rest of pending deliveries
    if (pendingCount >= maxSetCartsPerDelivery)
    {
      break;
    }
  }

  // Get at most max carts from the pending deliveries
  const setCarts = [];

  for (const pendingSet of pendingSets)
  {
    const pendingSetCarts = pendingSet.setCarts.splice(0, maxSetCartsPerDelivery - setCarts.length);

    for (const pendingSetCart of pendingSetCarts)
    {
      setCarts.push(pendingSetCart);
    }

    // Full set delivered: mark the pending delivery for deletion
    if (!pendingSet.setCarts.length)
    {
      pendingComponentsResult.deleted.push({_id: pendingSet.pendingDelivery._id});
    }

    // Max reached: ignore the rest of pending deliveries
    if (setCarts.length === maxSetCartsPerDelivery)
    {
      break;
    }
  }

  // Max not yet reached: try to fill
  if (setCarts.length < maxSetCartsPerDelivery)
  {
    // Find qualifying lines
    const availableLines = (await WhLine
      .find({'components.time': {$lt: minTimeForDelivery}})
      .select({_id: 1})
      .sort({'components.time': 1})
      .lean()
      .session(session)
      .exec())
      .map(l => l._id);

    // Find available carts for the qualifying lines
    const availableSetCarts = await WhSetCart
      .aggregate([
        {$match: {
          status: 'completed',
          lines: {$in: availableLines},
          kind
        }},
        {$group: {
          _id: {
            line: '$line',
            date: '$date',
            set: '$set'
          },
          carts: {
            $addToSet: {
              _id: '$_id',
              startTime: '$startTime'
            }
          },
          startTime: {$min: '$startTime'}
        }},
        {$sort: {startTime: 1}}
      ])
      .hint({status: 1, date: -1})
      .session(session)
      .exec();

    const lineToSets = new Map();

    // Group sets by line
    availableSetCarts.forEach(lineSetCarts =>
    {
      if (!lineToSets.has(lineSetCarts._id.line))
      {
        lineToSets.set(lineSetCarts._id.line, []);
      }

      lineToSets.get(lineSetCarts._id.line).push({
        date: lineSetCarts._id.date,
        set: lineSetCarts._id.set,
        carts: lineSetCarts.carts.sort((a, b) => a.startTime - b.startTime)
      });
    });

    // Find the remaining carts
    const remainingSetCarts = [];
    const usedSetCarts = new Set();
    let remainingDone = false;

    setCarts.forEach(setCart => usedSetCarts.add(setCart._id.toString()));

    for (const line of availableLines)
    {
      const lineSets = lineToSets.get(line);

      if (!lineSets)
      {
        continue;
      }

      for (const lineSet of lineSets)
      {
        while (lineSet.carts.length)
        {
          const setCartId = lineSet.carts.shift()._id;
          const usedId = setCartId.toString();

          // Ignore possible duplicates due to line groups
          if (usedSetCarts.has(usedId))
          {
            continue;
          }

          remainingSetCarts.push(setCartId);
          usedSetCarts.add(usedId);

          if (setCarts.length + remainingSetCarts.length === maxSetCartsPerDelivery)
          {
            remainingDone = true;

            break;
          }
        }

        // Mark the set as pending delivery if there are any carts remaining
        if (lineSet.carts.length)
        {
          pendingComponentsResult.added.push({
            _id: new ObjectId(),
            date: lineSet.date,
            set: lineSet.set,
            line
          });
        }

        if (remainingDone)
        {
          break;
        }
      }

      if (remainingDone)
      {
        break;
      }
    }

    // Fetch the remaining carts
    const newSetCarts = !remainingSetCarts.length ? [] : (await WhSetCart
      .find({_id: {$in: remainingSetCarts}})
      .lean()
      .session(session)
      .exec());

    const newOrderSets = new Map();

    newSetCarts.forEach(setCart =>
    {
      setCarts.push(setCart);

      const orderSetKey = `${setCart.date.getTime()}:${setCart.set}`;

      if (!newOrderSets.has(orderSetKey))
      {
        newOrderSets.set(orderSetKey, {
          set: setCart.set,
          date: setCart.date
        });
      }
    });

    // Update line stats
    const allNewWhOrders = !newOrderSets.size ? [] : (await WhOrder
      .find({
        $or: Array.from(newOrderSets.values())
      })
      .select({
        order: 1,
        lines: 1,
        date: 1,
        set: 1,
        startTime: 1
      })
      .hint({set: 1, date: -1})
      .lean()
      .session(session)
      .exec());
    const lines = new Map();

    allNewWhOrders.forEach(whOrder =>
    {
      whOrder.lines.forEach(whOrderLine =>
      {
        if (!lines.has(whOrderLine._id))
        {
          lines.set(whOrderLine._id, {
            sets: new Set(),
            qty: 0,
            time: 0
          });
        }

        const line = lines.get(whOrderLine._id);

        line.sets.add(`${whOrder.date.getTime()}:${whOrder.set}`);

        line.qty += whOrderLine.qty;
        line.time += whOrderLine.qty * whOrderLine.pceTime;

        deliveredOrdersResult.added.push({
          _id: new ObjectId(),
          line: whOrderLine._id,
          qtyTodo: whOrderLine.qty,
          qtyDone: 0,
          qtyRemaining: whOrderLine.qty,
          pceTime: whOrderLine.pceTime,
          sapOrder: whOrder.order,
          whOrder: whOrder._id,
          date: whOrder.date,
          set: whOrder.set,
          startTime: whOrder.startTime
        });
      });
    });

    const lineIds = Array.from(lines.keys());

    await WhLine.lockLines(lineIds);

    const whLines = !lines.size ? [] : (await WhLine
      .find({_id: {$in: lineIds}})
      .lean()
      .session(session)
      .exec());

    whLines.forEach(whLine =>
    {
      const line = lines.get(whLine._id);

      line.sets = line.sets.size;

      whLine.pickup.sets = Math.max(0, whLine.pickup.sets - line.sets);
      whLine.pickup.qty = Math.max(0, whLine.pickup.qty - line.qty);
      whLine.pickup.time = Math.max(0, whLine.pickup.time - line.time);

      whLine[kind].qty += line.qty;
      whLine[kind].time += line.time;

      linesResult.updated.push({
        _id: whLine._id,
        pickup: whLine.pickup,
        [kind]: whLine[kind]
      });
    });
  }

  if (!setCarts.length)
  {
    return {
      response: {
        result: 'nothingToDeliver',
        setCarts: []
      }
    };
  }

  // Apply pending delivery operations
  const pendingComponentsOps = [];

  if (pendingComponentsResult.deleted.length)
  {
    pendingComponentsOps.push({
      deleteMany: {
        filter: {_id: pendingComponentsResult.deleted.map(d => d._id)}
      }
    });
  }

  pendingComponentsResult.added.forEach(pendingDelivery =>
  {
    pendingComponentsOps.push({
      insertOne: {
        document: pendingDelivery
      }
    });
  });

  // Apply delivered orders operations
  const deliveredOrdersOps = [];

  deliveredOrdersResult.added.forEach(deliveredOrder =>
  {
    deliveredOrdersOps.push({
      insertOne: {
        document: deliveredOrder
      }
    });
  });

  // Apply lines operations
  const linesOps = [];

  linesResult.updated.forEach(line =>
  {
    linesOps.push({
      updateOne: {
        filter: {_id: line._id},
        update: {$set: line}
      }
    });
  });

  // Apply set carts & orders operations
  setCarts.sort((a, b) => a.startTime - b.startTime);

  let whOrderIds = new Set();
  const setCartsOps = [];
  const whOrdersOps = [{
    updateMany: {
      filter: {_id: {$in: []}},
      update: {$set: {
        distStatus: 'started',
        fifoStatus: 'started'
      }}
    }
  }];
  const deliveringBy = {id: whUser._id, label: whUser.label};

  setCarts.forEach(setCart =>
  {
    setCart.deliveringBy = deliveringBy;

    const update = {
      status: 'delivering',
      deliveringBy,
      deliveringAt: now,
      users: WhSetCart.collectUsers(setCart)
    };

    Object.assign(setCart, update);

    setCartsResult.updated.push(setCart);

    setCartsOps.push({
      updateOne: {
        filter: {_id: setCart._id},
        update: {$set: update}
      }
    });

    setCart.orders.forEach(whSetCartOrder =>
    {
      const whOrderId = whSetCartOrder.whOrder;

      if (whOrderIds.has(whOrderId))
      {
        return;
      }

      whOrderIds.add(whOrderId);

      whOrdersOps[0].updateMany.filter._id.$in.push(whOrderId);

      whOrdersResult.updated.push({
        _id: whOrderId,
        distStatus: 'started',
        fifoStatus: 'started'
      });
    });
  });

  // Create pending packaging deliveries
  whOrderIds = Array.from(whOrderIds);

  const [allPackagingCarts, pendingPackagingDeliveries] = await Promise.all([
    WhSetCart
      .find({
        kind: 'packaging',
        status: 'completed',
        'orders.whOrder': {$in: whOrderIds}
      })
      .select({_id: 1})
      .hint({'orders.whOrder': 1})
      .lean()
      .session(session)
      .exec(),
    WhPendingPackaging
      .find({whOrders: {$in: whOrderIds}})
      .select({setCarts: 1})
      .lean()
      .session(session)
      .exec()
  ]);

  const oldPackagingCarts = new Set();

  pendingPackagingDeliveries.forEach(pendingDelivery =>
  {
    pendingDelivery.setCarts.forEach(setCartId =>
    {
      oldPackagingCarts.add(setCartId.toString());
    });
  });

  const pendingPackaging = {
    _id: new ObjectId(),
    setCarts: [],
    whOrders: whOrderIds
  };

  pendingPackagingResult.added.push(pendingPackaging);

  const pendingPackagingOps = [{
    insertOne: {
      document: pendingPackaging
    }
  }];

  allPackagingCarts.forEach(setCart =>
  {
    if (!oldPackagingCarts.has(setCart._id.toString()))
    {
      pendingPackaging.setCarts.push(setCart._id);
    }
  });

  // Write operations
  const [eventsResult] = await Promise.all([
    WhEvent.record([{
      type: 'deliveryStarted',
      time: now,
      user,
      order: null,
      data: {
        user: whUser,
        kind,
        setCarts: setCarts.map(setCart => setCart._id)
      }
    }], session),
    pendingComponentsOps.length ? WhPendingComponents.collection.bulkWrite(pendingComponentsOps, {session}) : null,
    pendingPackagingOps.length ? WhPendingPackaging.collection.bulkWrite(pendingPackagingOps, {session}) : null,
    deliveredOrdersOps.length ? WhDeliveredOrder.collection.bulkWrite(deliveredOrdersOps, {session}) : null,
    linesOps.length ? WhLine.collection.bulkWrite(linesOps, {session}) : null,
    whOrdersOps.length ? WhOrder.collection.bulkWrite(whOrdersOps, {session}) : null,
    setCartsOps.length ? WhSetCart.collection.bulkWrite(setCartsOps, {session}) : null
  ]);

  // Create messages
  if (pendingComponentsOps.length)
  {
    pendingComponentsResult.messages.push({
      topic: `${WhPendingComponents.TOPIC_PREFIX}.updated`,
      message: {
        deleted: pendingComponentsResult.deleted,
        added: pendingComponentsResult.added
      }
    });
  }

  if (pendingPackagingOps.length)
  {
    pendingPackagingResult.messages.push({
      topic: `${WhPendingPackaging.TOPIC_PREFIX}.updated`,
      message: {
        added: pendingPackagingResult.added
      }
    });
  }

  deliveredOrdersResult.messages.push({
    topic: `${WhDeliveredOrder.TOPIC_PREFIX}.updated`,
    message: {
      added: deliveredOrdersResult.added
    }
  });

  linesResult.messages.push({
    topic: `${WhLine.TOPIC_PREFIX}.updated`,
    message: {
      updated: linesResult.updated
    }
  });

  whOrdersResult.messages.push({
    topic: `${WhOrder.TOPIC_PREFIX}.updated`,
    message: {
      updated: whOrdersResult.updated
    }
  });

  setCartsResult.messages.push({
    topic: `${WhSetCart.TOPIC_PREFIX}.updated`,
    message: {
      updated: setCartsResult.updated
    }
  });

  await session.commitTransaction();

  return {
    response: {
      result: 'deliveryStarted',
      setCarts,
      user: whUser
    },
    results: [
      eventsResult,
      pendingComponentsResult,
      pendingPackagingResult,
      deliveredOrdersResult,
      linesResult,
      whOrdersResult,
      setCartsResult
    ]
  };
};
