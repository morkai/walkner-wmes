// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const {ObjectId} = require('mongoose').Types;
const startComponentsDelivery = require('./startComponentsDelivery');

module.exports = async (app, module, {data, user, whUser, session}) =>
{
  const {
    OldWhEvent: WhEvent,
    OldWhLine: WhLine,
    OldWhOrder: WhOrder,
    OldWhDeliveredOrder: WhDeliveredOrder,
    OldWhSetCart: WhSetCart,
    OldWhPendingPackaging: WhPendingPackaging,
    OldWhPendingComponents: WhPendingComponents
  } = module;

  const {
    kind,
    forceLine
  } = data;
  const now = new Date();
  const whOrdersResult = {
    updated: []
  };
  const pendingPackagingResult = {
    deleted: []
  };
  const pendingComponentsResult = {
    added: []
  };
  const setCartsResult = {
    updated: []
  };
  const linesResult = {
    updated: []
  };
  const deliveredOrdersResult = {
    added: []
  };

  const linesOps = [];
  const whOrdersOps = [];
  const pendingPackagingOps = [];
  const pendingComponentsOps = [];
  const setCartsOps = [];
  const deliveredOrdersOps = [];

  const event = {
    type: 'deliveryStarted',
    time: now,
    user,
    data: {
      kind,
      whUser: WhEvent.whUser(whUser),
      orders: [],
      lines: new Set(),
      setCarts: null
    }
  };

  let pendingPackaging = null;

  if (forceLine)
  {
    const pendingPackagings = await WhPendingPackaging
      .find({})
      .sort({_id: 1})
      .lean()
      .session(session)
      .exec();

    if (pendingPackagings.length)
    {
      const setCartIds = [];

      pendingPackagings.forEach(pendingPackaging =>
      {
        setCartIds.push(...pendingPackaging.setCarts);
      });

      const setCarts = await WhSetCart
        .find({
          _id: {$id: setCartIds},
          lines: forceLine
        })
        .select({_id: 1})
        .lean()
        .exec();

      const lineSetCartIds = new Set(setCarts.map(c => c._id.toString()));

      pendingPackaging = pendingPackagings.find(
        pendingPackaging => pendingPackaging.setCarts.some(c => lineSetCartIds.has(c.toString()))
      );
    }
  }
  else
  {
    pendingPackaging = await WhPendingPackaging
      .findOne({})
      .sort({_id: 1})
      .lean()
      .session(session)
      .exec();
  }

  if (!pendingPackaging)
  {
    const {response} = await startComponentsDelivery(app, module, {
      data: {
        kind: 'components',
        pendingDelivery: true,
        forceLine
      },
      user,
      whUser,
      session
    });

    pendingPackaging = response.pendingPackagingResult && response.pendingPackagingResult.added[0] || null;

    if (pendingPackaging)
    {
      const pendingComponentsSet = new Set();

      response.deliveredOrdersResult.added.forEach(deliveredOrder =>
      {
        const key = deliveredOrder.date.getTime() + ':' + deliveredOrder.set;

        if (!pendingComponentsSet.has(key))
        {
          pendingComponentsSet.add(key);
          pendingComponentsResult.added.push({
            _id: new ObjectId(),
            date: deliveredOrder.date,
            set: deliveredOrder.set
          });
        }
      });

      linesResult.updated = response.linesResult.updated;
      deliveredOrdersResult.added = response.deliveredOrdersResult.added;
    }
  }
  else
  {
    pendingPackagingResult.deleted.push(pendingPackaging);

    pendingPackagingOps.push({
      deleteOne: {
        filter: {_id: pendingPackaging._id}
      }
    });
  }

  if (!pendingPackaging)
  {
    return {
      response: {
        result: 'nothingToDeliver',
        setCarts: []
      }
    };
  }

  whOrdersOps.push({
    updateMany: {
      filter: {_id: {$in: pendingPackaging.whOrders}},
      update: {
        $set: {
          distStatus: 'started',
          packStatus: 'started'
        }
      }
    }
  });

  pendingPackaging.whOrders.forEach(whOrderId =>
  {
    whOrdersResult.updated.push({
      _id: whOrderId,
      ...whOrdersOps[0].updateMany.update.$set
    });
  });

  pendingComponentsResult.added.forEach(document =>
  {
    pendingComponentsOps.push({insertOne: {document}});
  });

  linesResult.updated.forEach(line =>
  {
    linesOps.push({
      updateOne: {
        filter: {_id: line._id},
        update: {$set: line}
      }
    });
  });

  deliveredOrdersResult.added.forEach(document =>
  {
    deliveredOrdersOps.push({insertOne: {document}});
  });

  const setCarts = await WhSetCart
    .find({_id: {$in: pendingPackaging.setCarts}})
    .sort({startTime: 1})
    .lean()
    .session(session)
    .exec();
  const deliveringBy = event.data.whUser;
  const whOrderIds = new Set();

  event.data.setCarts = WhEvent.setCarts({remaining: setCarts});

  setCarts.forEach(setCart =>
  {
    setCart.deliveringBy = deliveringBy;

    const update = {
      status: 'delivering',
      deliveringBy,
      deliveringAt: now,
      users: WhSetCart.collectUsers(setCart)
    };

    Object.assign(setCart, update);

    setCartsResult.updated.push(setCart);

    setCartsOps.push({
      updateOne: {
        filter: {_id: setCart._id},
        update: {$set: update}
      }
    });

    WhEvent.lines(setCart, event.data.lines);

    setCart.orders.forEach(whSetCartOrder =>
    {
      if (!whOrderIds.has(whSetCartOrder.whOrder))
      {
        event.data.orders.push({
          whOrder: whSetCartOrder.whOrder,
          sapOrder: whSetCartOrder.sapOrder,
          date: setCart.date,
          set: setCart.set
        });

        whOrderIds.add(whSetCartOrder.whOrder);
      }
    });
  });

  // Write operations
  const [eventsResult] = await Promise.all([
    WhEvent.record(event, session),
    whOrdersOps.length ? WhOrder.collection.bulkWrite(whOrdersOps, {session}) : null,
    pendingPackagingOps.length ? WhPendingPackaging.collection.bulkWrite(pendingPackagingOps, {session}) : null,
    pendingComponentsOps.length ? WhPendingComponents.collection.bulkWrite(pendingComponentsOps, {session}) : null,
    setCartsOps.length ? WhSetCart.collection.bulkWrite(setCartsOps, {session}) : null,
    linesOps.length ? WhLine.collection.bulkWrite(linesOps, {session}) : null,
    deliveredOrdersOps.length ? WhDeliveredOrder.collection.bulkWrite(deliveredOrdersOps, {session}) : null
  ]);

  await session.commitTransaction();

  const messages = [{
    topic: `${WhOrder.TOPIC_PREFIX}.updated`,
    message: whOrdersResult
  }, {
    topic: `${WhSetCart.TOPIC_PREFIX}.updated`,
    message: setCartsResult
  }];

  if (pendingPackagingOps.length)
  {
    messages.push({
      topic: `${WhPendingPackaging.TOPIC_PREFIX}.updated`,
      message: pendingPackagingResult
    });
  }

  if (pendingComponentsOps.length)
  {
    messages.push({
      topic: `${WhPendingComponents.TOPIC_PREFIX}.updated`,
      message: pendingComponentsResult
    });
  }

  if (linesOps.length)
  {
    messages.push({
      topic: `${WhLine.TOPIC_PREFIX}.updated`,
      message: linesResult
    });
  }

  if (deliveredOrdersOps.length)
  {
    messages.push({
      topic: `${WhDeliveredOrder.TOPIC_PREFIX}.updated`,
      message: deliveredOrdersOps
    });
  }

  return {
    response: {
      result: 'deliveryStarted',
      setCarts,
      user: whUser
    },
    results: [
      eventsResult
    ],
    messages
  };
};
