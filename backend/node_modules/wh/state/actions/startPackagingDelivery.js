// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

module.exports = async (app, module, {data, user, whUser, session}) =>
{
  const {
    OldWhEvent: WhEvent,
    OldWhOrder: WhOrder,
    OldWhSetCart: WhSetCart,
    OldWhPendingPackaging: WhPendingPackaging
  } = module;

  const {
    kind
  } = data;
  const now = new Date();
  const whOrdersResult = {
    updated: []
  };
  const pendingPackagingResult = {
    deleted: []
  };
  const setCartsResult = {
    updated: []
  };
  const event = {
    type: 'deliveryStarted',
    time: now,
    user,
    data: {
      kind,
      whUser: WhEvent.whUser(whUser),
      orders: [],
      lines: new Set(),
      setCarts: null
    }
  };
  const whOrdersOps = [];
  const pendingPackagingOps = [];
  const setCartsOps = [];

  const pendingPackaging = await WhPendingPackaging
    .findOne({})
    .sort({_id: 1})
    .lean()
    .session(session)
    .exec();

  if (!pendingPackaging)
  {
    return {
      response: {
        result: 'nothingToDeliver',
        setCarts: []
      }
    };
  }

  pendingPackagingResult.deleted.push(pendingPackaging);

  pendingPackagingOps.push({
    deleteOne: {
      filter: {_id: pendingPackaging._id}
    }
  });

  whOrdersOps.push({
    updateMany: {
      filter: {_id: {$in: pendingPackaging.whOrders}},
      update: {
        $set: {
          distStatus: 'started',
          packStatus: 'started'
        }
      }
    }
  });

  pendingPackaging.whOrders.forEach(whOrderId =>
  {
    whOrdersResult.updated.push({
      _id: whOrderId,
      ...whOrdersOps[0].updateMany.update.$set
    });
  });

  const setCarts = await WhSetCart
    .find({_id: {$in: pendingPackaging.setCarts}})
    .sort({startTime: 1})
    .lean()
    .session(session)
    .exec();
  const deliveringBy = event.data.whUser;
  const whOrderIds = new Set();

  event.data.setCarts = WhEvent.setCarts({remaining: setCarts});

  setCarts.forEach(setCart =>
  {
    setCart.deliveringBy = deliveringBy;

    const update = {
      status: 'delivering',
      deliveringBy,
      deliveringAt: now,
      users: WhSetCart.collectUsers(setCart)
    };

    Object.assign(setCart, update);

    setCartsResult.updated.push(setCart);

    setCartsOps.push({
      updateOne: {
        filter: {_id: setCart._id},
        update: {$set: update}
      }
    });

    WhEvent.lines(setCart, event.data.lines);

    setCart.orders.forEach(whSetCartOrder =>
    {
      if (!whOrderIds.has(whSetCartOrder.whOrder))
      {
        event.data.orders.push({
          whOrder: whSetCartOrder.whOrder,
          sapOrder: whSetCartOrder.sapOrder,
          date: setCart.date,
          set: setCart.set
        });

        whOrderIds.add(whSetCartOrder.whOrder);
      }
    });
  });

  // Write operations
  const [eventsResult] = await Promise.all([
    WhEvent.record(event, session),
    whOrdersOps.length ? WhOrder.collection.bulkWrite(whOrdersOps, {session}) : null,
    pendingPackagingOps.length ? WhPendingPackaging.collection.bulkWrite(pendingPackagingOps, {session}) : null,
    setCartsOps.length ? WhSetCart.collection.bulkWrite(setCartsOps, {session}) : null
  ]);

  await session.commitTransaction();

  return {
    response: {
      result: 'deliveryStarted',
      setCarts,
      user: whUser
    },
    results: [
      eventsResult
    ],
    messages: [{
      topic: `${WhOrder.TOPIC_PREFIX}.updated`,
      message: whOrdersResult
    }, {
      topic: `${WhPendingPackaging.TOPIC_PREFIX}.updated`,
      message: pendingPackagingResult
    }, {
      topic: `${WhSetCart.TOPIC_PREFIX}.updated`,
      message: setCartsResult
    }]
  };
};
