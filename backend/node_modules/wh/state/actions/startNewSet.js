// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const {ObjectId} = require('mongoose').Types;
const moment = require('moment');
const shifts = require('util/shifts');

module.exports = async (app, module, {data, user, session}) =>
{
  const {
    OldWhOrder: WhOrder,
    OldWhEvent: WhEvent,
    OldWhDowntime: WhDowntime,
    OldWhUser: WhUser,
    OldWhLine: WhLine,
    OldWhPendingSetAssign: WhPendingSetAssign
  } = module;

  const {
    whUser,
    downtimeReason,
    downtimeComment,
    personnelId,
    forceLine
  } = data;

  if (whUser.func === 'packer'
    || whUser.func === 'platformer'
    || whUser.func === 'painter')
  {
    throw app.createError(`Func cannot start new sets.`, 'NO_PENDING_ORDERS', 400);
  }

  const now = new Date();
  const minDowntimeDuration = (module.state.settings.minPickupDowntime || 120) * 1000;
  const maxDowntimeDuration = (module.state.settings.maxPickupDowntime || 480) * 1000;
  const downtimeDuration = whUser.lastPickupAt ? now.getTime() - whUser.lastPickupAt.getTime() : 0;
  const downtime = downtimeDuration > minDowntimeDuration && downtimeDuration < maxDowntimeDuration;

  if (downtime && !downtimeReason)
  {
    return {
      response: {
        result: 'pickDowntimeReason',
        startedAt: whUser.lastPickupAt,
        personnelId,
        user: whUser
      }
    };
  }

  const availableLines = await findAvailableLines();

  if (!availableLines.size)
  {
    throw app.createError('No valid, pending orders.', 'NO_PENDING_ORDERS', 400);
  }

  const {pendingOrder, ignoredCandidates} = await findNextPendingOrder(availableLines);

  if (!pendingOrder)
  {
    if (!ignoredCandidates.length)
    {
      throw app.createError('No valid, pending orders.', 'NO_PENDING_ORDERS', 400);
    }

    return await handleIgnoredLines(ignoredCandidates, whUser);
  }

  const [setOrders, nextSetId] = await Promise.all([
    findMorePendingOrders(pendingOrder),
    findNextSetId(pendingOrder.date)
  ]);

  const withPicklist = {$in: [], $set: {}};
  const withoutPicklist = {$in: [], $set: {}};
  const event = {
    type: 'newSetStarted',
    time: now,
    user,
    data: {
      whUser: WhEvent.whUser(whUser),
      orders: null,
      lines: WhEvent.lines(setOrders[0]),
      downtime: null
    }
  };

  let downtimeId = null;

  if (downtimeReason)
  {
    downtimeId = new ObjectId();

    event.data.downtime = {
      id: downtimeId.toString(),
      reason: downtimeReason
    };
  }

  const mrps = new Set();

  setOrders.forEach(whOrder =>
  {
    const picklistDone = whOrder.picklistDone === 'success' || whOrder.picklistDone === 'progress';
    const {$in, $set} = picklistDone ? withPicklist : withoutPicklist;

    mrps.add(whOrder.mrp);
    $in.push(whOrder._id);

    $set.status = whOrder.status = 'started';
    $set.set = whOrder.set = nextSetId;
    $set.startedAt = whOrder.startedAt = now;
    $set.picklistFunc = whOrder.picklistFunc = whUser.func;
    $set.users = whOrder.users = [whUser._id];

    if (!picklistDone)
    {
      $set.picklistDone = whOrder.picklistDone = 'pending';
    }

    const func = whOrder.funcs.find(f => f._id === whUser.func);
    const funcI = whOrder.funcs.indexOf(func);

    $set[`funcs.${funcI}.user`] = func.user = event.data.whUser;
    $set[`funcs.${funcI}.startedAt`] = func.startedAt = now;
    $set[`funcs.${funcI}.status`] = func.status = 'picklist';
  });

  event.data.orders = WhEvent.orders(setOrders);

  const whOrdersOps = [];

  [withPicklist, withoutPicklist].forEach(({$in, $set}) =>
  {
    if ($in.length)
    {
      whOrdersOps.push({
        updateMany: {
          filter: {_id: {$in}},
          update: {$set}
        }
      });
    }
  });

  await WhLine.lockLines(setOrders[0].lines);

  let pendingSetAssign = null;

  if (forceLine)
  {
    pendingSetAssign = {
      date: setOrders[0].date,
      set: setOrders[0].set,
      fmx: false,
      kitter: false,
      packer: false,
      platformer: false,
      painter: false
    };

    pendingSetAssign[whUser.func] = true;
  }

  const [eventsResults, downtimeResults, lineResults] = await Promise.all([
    WhEvent.record([event], session),
    WhDowntime.createDowntime({
      _id: downtimeId,
      reason: downtimeReason,
      startedAt: whUser.lastPickupAt,
      user: event.data.whUser,
      comment: downtimeComment,
      session
    }),
    WhLine.startNewSet(setOrders, session),
    WhUser.collection.updateOne({_id: whUser._id}, {$set: {lastPickupAt: now}}, {session}),
    WhOrder.collection.bulkWrite(whOrdersOps, {session}),
    !pendingSetAssign ? null : WhPendingSetAssign.collection.insertOne(pendingSetAssign, {session})
  ]);

  await session.commitTransaction();

  setImmediate(async () =>
  {
    try
    {
      await module.state.printLabels(setOrders, 1, whUser.func);
    }
    catch (err)
    {
      module.error(err, `Failed to print labels after starting a new set.`);
    }
  });

  return {
    response: {
      result: 'newSetStarted',
      orders: setOrders,
      user: whUser
    },
    results: [
      eventsResults,
      downtimeResults,
      lineResults
    ],
    messages: [
      {
        topic: `${WhOrder.TOPIC_PREFIX}.updated`,
        message: {updated: setOrders}
      },
      {
        topic: 'old.wh.newSetStarted',
        message: {
          date: pendingOrder.date,
          set: nextSetId,
          mrps: Array.from(mrps)
        }
      }
    ]
  };

  async function findAvailableLines()
  {
    const maxSetsPerLine = module.state.settings.maxSetsPerLine || 2;
    const conditions = {};

    if (forceLine)
    {
      conditions._id = forceLine;
    }

    const allLines = await WhLine.find(conditions).lean().exec();
    const redirLines = new Map();
    const availableLines = new Map();

    allLines.forEach(line =>
    {
      if (line.redirLine)
      {
        redirLines.set(line._id, line.redirLine);
      }

      if (forceLine || line.pickup.total.sets < maxSetsPerLine)
      {
        availableLines.set(line._id, line);
      }
    });

    availableLines.forEach(line =>
    {
      const redirLine = redirLines.get(line);

      if (redirLine && !availableLines.has(redirLine))
      {
        availableLines.delete(line);
      }
    });

    return availableLines;
  }

  async function findNextPendingOrder(availableLines)
  {
    const {ignorePsStatus, enabledMrps} = module.state.settings;
    let {availableTimeThreshold} = module.state.settings;

    if (!availableTimeThreshold)
    {
      availableTimeThreshold = 0;
    }
    else
    {
      availableTimeThreshold *= 60 * 1000;
    }

    const lineIds = Array.from(availableLines.keys());
    const conditions = {
      status: 'pending',
      date: {
        $gte: moment.utc().startOf('day').subtract(7, 'days').toDate()
      },
      'lines._id': {$in: lineIds}
    };

    if (Array.isArray(ignorePsStatus) && ignorePsStatus.length)
    {
      conditions.psStatus = {$nin: ignorePsStatus};
    }

    if (Array.isArray(enabledMrps) && enabledMrps.length)
    {
      conditions.mrp = {$in: enabledMrps};
    }

    const pendingLines = await WhOrder
      .aggregate([
        {$match: conditions},
        {$group: {
          _id: '$lines._id',
          startTime: {$min: '$startTime'}
        }}
      ])
      .hint({status: 1, date: -1})
      .exec();

    if (!pendingLines.length)
    {
      throw app.createError('No valid, pending orders.', 'NO_PENDING_ORDERS', 400);
    }

    const candidateLines = new Map();
    const currentPlan = shifts.getCurrentDate(true).valueOf();

    pendingLines.forEach(pendingLine =>
    {
      pendingLine._id.forEach(lineId =>
      {
        const availableLine = availableLines.get(lineId);

        if (!availableLine)
        {
          return;
        }

        if (!candidateLines.has(lineId))
        {
          const availableTime = availableLine.pickup.total.time + availableLine.available.time;

          candidateLines.set(lineId, {
            line: availableLine,
            startTime: Number.MAX_SAFE_INTEGER,
            availableTime,
            adjustedAvailableTime: availableTime < availableTimeThreshold ? 0 : availableTime,
            startedPlan: new Date(Math.max(availableLine.startedPlan.getTime(), currentPlan)),
            orderPlan: null
          });
        }

        const candidateLine = candidateLines.get(lineId);

        candidateLine.startTime = Math.min(candidateLine.startTime, pendingLine.startTime.getTime());
      });
    });

    const ignoredCandidates = [];

    candidateLines.forEach(candidate =>
    {
      candidate.orderPlan = shifts.getPlanDate(candidate.startTime, true).toDate();

      if (candidate.orderPlan > candidate.startedPlan)
      {
        ignoredCandidates.push(candidate);
        candidateLines.delete(candidate.line._id);
      }
    });

    if (!candidateLines.size)
    {
      return {
        pendingOrder: null,
        ignoredCandidates
      };
    }

    const sortedCandidates = Array.from(candidateLines.values()).sort((a, b) =>
    {
      let cmp = a.adjustedAvailableTime - b.adjustedAvailableTime;

      if (!cmp)
      {
        cmp = a.startTime - b.startTime;

        if (!cmp)
        {
          cmp = a.availableTime - b.availableTime;

          if (!cmp)
          {
            cmp = a.line._id.localeCompare(b.line._id, undefined, {numeric: true, ignorePunctuation: true});
          }
        }
      }

      return cmp;
    });

    const bestCandidate = sortedCandidates[0];

    conditions['lines._id'] = bestCandidate.line._id;

    const pendingOrder = await WhOrder
      .findOne(conditions)
      .sort({startTime: 1})
      .lean()
      .hint({status: 1, 'lines._id': 1, startTime: 1})
      .session(session)
      .exec();

    if (!pendingOrder)
    {
      return {
        pendingOrder: null,
        ignoredCandidates
      };
    }

    return {
      pendingOrder,
      ignoredCandidates: []
    };
  }

  async function findMorePendingOrders(pendingOrder)
  {
    const whSettings = module.state.settings;

    const groupDuration = (whSettings.groupDuration || 2) * 3600 * 1000;
    const minSetDuration = (whSettings.minSetDuration || 120) * 60 * 1000;
    const maxSetDuration = (whSettings.maxSetDuration || 120) * 60 * 1000;
    const maxSetDifference = (whSettings.maxSetDifference || 120) * 60 * 1000;
    const maxSetSize = whSettings.maxSetSize || 5;

    const conditions = {
      date: pendingOrder.date,
      line: pendingOrder.line
    };

    if (whSettings.pendingOnly)
    {
      conditions.status = 'pending';
    }
    else
    {
      conditions.startedAt = {$gte: pendingOrder.startedAt};
    }

    if (Array.isArray(whSettings.ignorePsStatus) && whSettings.ignorePsStatus.length)
    {
      conditions.psStatus = {$nin: whSettings.ignorePsStatus};
    }

    const whOrders = await WhOrder
      .find(conditions)
      .sort({startTime: 1})
      .lean()
      .session(session)
      .exec();

    const setOrders = [];
    let setDuration = 0;
    let lastFinishTime = 0;

    while (whOrders.length && setOrders.length < maxSetSize)
    {
      const whOrder = whOrders.shift();

      if (whOrder.status !== 'pending')
      {
        lastFinishTime = whOrder.finishTime;

        continue;
      }

      // Stop: the time difference between orders is too big.
      if (setOrders.length
        && (whOrder.startTime - lastFinishTime > maxSetDifference))
      {
        break;
      }

      const orderDuration = whOrder.finishTime - whOrder.startTime;

      // Order fits in the group's boundaries or it's the first order.
      if (setOrders.length === 0
        || (setDuration + orderDuration <= groupDuration))
      {
        setDuration += orderDuration;
        lastFinishTime = whOrder.finishTime;

        setOrders.push(whOrder);

        continue;
      }

      // Min set duration exceeded, don't extend.
      if (setDuration > minSetDuration)
      {
        break;
      }

      // Max set duration exceeded, ignore.
      if (setDuration + orderDuration > maxSetDuration)
      {
        continue;
      }

      // Extend set.
      setDuration += orderDuration;
      lastFinishTime = whOrder.finishTime;

      setOrders.push(whOrder);
    }

    return setOrders;
  }

  async function findNextSetId(date)
  {
    const result = await WhOrder
      .aggregate([
        {$match: {date}},
        {$group: {_id: null, set: {$max: '$set'}}}
      ])
      .session(session)
      .exec();

    if (result && result.length)
    {
      return (result[0].set || 0) + 1;
    }

    return 1;
  }

  async function handleIgnoredLines(ignoredCandidates, user)
  {
    const {ignorePsStatus, enabledMrps} = module.state.settings;
    const unpaintedPsStatus = Array.isArray(ignorePsStatus)
      ? ignorePsStatus.filter(s => s !== 'cancelled')
      : [];
    const currentPlan = shifts.getCurrentDate(true).toDate();

    const lineMrpConditions = {
      status: 'pending',
      date: {$gte: currentPlan}
    };

    let unpaintedLinesConditions = null;

    if (unpaintedPsStatus.length)
    {
      unpaintedLinesConditions = {
        status: 'pending',
        date: currentPlan,
        psStatus: {$in: unpaintedPsStatus}
      };
    }

    if (Array.isArray(enabledMrps) && enabledMrps.length)
    {
      lineMrpConditions.mrp = {$in: enabledMrps};

      if (unpaintedLinesConditions)
      {
        unpaintedLinesConditions.mrp = {$in: enabledMrps};
      }
    }

    const [lineMrpList, unpaintedLineList] = await Promise.all([
      WhOrder.aggregate([
        {$match: lineMrpConditions},
        {$unwind: '$lines'},
        {$group: {
          _id: '$lines._id',
          mrps: {$addToSet: '$mrp'}
        }}
      ]).hint({status: 1, date: -1}).exec(),
      !unpaintedLinesConditions ? [] : WhOrder.aggregate([
        {$match: unpaintedLinesConditions},
        {$unwind: '$lines'},
        {$group: {
          _id: '$lines._id',
          count: {$sum: 1}
        }}
      ]).hint({status: 1, date: -1}).exec()
    ]);
    const lineMrpMap = new Map(lineMrpList.map(d => [d._id, d.mrps]));
    const unpaintedLineMap = new Map(unpaintedLineList.map(d => [d._id, d.count]));
    const ignoredLines = [];

    ignoredCandidates.forEach(candidate =>
    {
      ignoredLines.push({
        _id: candidate.line._id,
        startedPlan: candidate.startedPlan,
        orderPlan: candidate.orderPlan,
        startTime: new Date(candidate.startTime),
        mrps: lineMrpMap.get(candidate.line._id) || [],
        unpaintedOrders: unpaintedLineMap.get(candidate.line._id) || 0
      });

      unpaintedLineMap.delete(candidate.line._id);
    });

    return {
      response: {
        result: 'ignoredLines',
        ignoredLines,
        unpaintedLines: Array.from(unpaintedLineMap.keys()),
        user
      }
    };
  }
};
