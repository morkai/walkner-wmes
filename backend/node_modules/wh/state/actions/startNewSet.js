// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const {ObjectId} = require('mongoose').Types;
const moment = require('moment');

module.exports = async (app, module, {data, user, session}) =>
{
  const {
    OldWhOrder: WhOrder,
    OldWhEvent: WhEvent,
    OldWhDowntime: WhDowntime,
    OldWhUser: WhUser,
    OldWhLine: WhLine
  } = module;

  const {
    whUser,
    date,
    downtimeReason,
    downtimeComment,
    personnelId
  } = data;

  if (whUser.func === 'packer' || whUser.func === 'platformer')
  {
    throw app.createError(`Func cannot start new sets.`, 'NO_PENDING_ORDERS', 400);
  }

  const now = new Date();
  const minDowntimeDuration = (module.state.settings.minPickupDowntime || 120) * 1000;
  const maxDowntimeDuration = (module.state.settings.maxPickupDowntime || 480) * 1000;
  const downtimeDuration = whUser.lastPickupAt ? now.getTime() - whUser.lastPickupAt.getTime() : 0;
  const downtime = downtimeDuration > minDowntimeDuration && downtimeDuration < maxDowntimeDuration;

  if (downtime && !downtimeReason)
  {
    return {
      response: {
        result: 'pickDowntimeReason',
        startedAt: whUser.lastPickupAt,
        personnelId,
        user: whUser
      }
    };
  }

  const redirLines = await findRedirLines();
  const availableLines = await findAvailableLines(redirLines);

  const pendingOrder = await findNextPendingOrder(date, [], availableLines);

  const [setOrders, nextSetId] = await Promise.all([
    findMorePendingOrders(pendingOrder),
    findNextSetId(pendingOrder.date)
  ]);

  const withPicklist = {$in: [], $set: {}};
  const withoutPicklist = {$in: [], $set: {}};
  const event = {
    type: 'newSetStarted',
    time: now,
    user,
    data: {
      whUser: WhEvent.whUser(whUser),
      orders: null,
      lines: WhEvent.lines(setOrders[0]),
      downtime: null
    }
  };

  let downtimeId = null;

  if (downtimeReason)
  {
    downtimeId = new ObjectId();

    event.data.downtime = {
      id: downtimeId.toString(),
      reason: downtimeReason
    };
  }

  const mrps = new Set();

  setOrders.forEach(whOrder =>
  {
    const picklistDone = whOrder.picklistDone === 'success' || whOrder.picklistDone === 'progress';
    const {$in, $set} = picklistDone ? withPicklist : withoutPicklist;

    mrps.add(whOrder.mrp);
    $in.push(whOrder._id);

    $set.status = whOrder.status = 'started';
    $set.set = whOrder.set = nextSetId;
    $set.startedAt = whOrder.startedAt = now;
    $set.picklistFunc = whOrder.picklistFunc = whUser.func;
    $set.users = whOrder.users = [whUser._id];

    if (!picklistDone)
    {
      $set.picklistDone = whOrder.picklistDone = 'pending';
    }

    const func = whOrder.funcs.find(f => f._id === whUser.func);
    const funcI = whOrder.funcs.indexOf(func);

    $set[`funcs.${funcI}.user`] = func.user = event.data.whUser;
    $set[`funcs.${funcI}.startedAt`] = func.startedAt = now;
    $set[`funcs.${funcI}.status`] = func.status = 'picklist';
  });

  event.data.orders = WhEvent.orders(setOrders);

  const writeOperations = [];

  [withPicklist, withoutPicklist].forEach(({$in, $set}) =>
  {
    if ($in.length)
    {
      writeOperations.push({
        updateMany: {
          filter: {_id: {$in}},
          update: {$set}
        }
      });
    }
  });

  await WhLine.lockLines(setOrders[0].lines);

  const [eventsResults, downtimeResults, lineResults] = await Promise.all([
    WhEvent.record([event], session),
    WhDowntime.createDowntime({
      _id: downtimeId,
      reason: downtimeReason,
      startedAt: whUser.lastPickupAt,
      user: event.data.whUser,
      comment: downtimeComment,
      session
    }),
    WhLine.startNewSet(setOrders, session),
    WhUser.collection.updateOne({_id: whUser._id}, {$set: {lastPickupAt: now}}, {session}),
    WhOrder.collection.bulkWrite(writeOperations, {session})
  ]);

  await session.commitTransaction();

  setImmediate(async () =>
  {
    try
    {
      await module.state.printLabels(setOrders, 1, whUser.func);
    }
    catch (err)
    {
      module.error(err, `Failed to print labels after starting a new set.`);
    }
  });

  return {
    response: {
      result: 'newSetStarted',
      orders: setOrders,
      user: whUser
    },
    results: [
      eventsResults,
      downtimeResults,
      lineResults
    ],
    messages: [
      {
        topic: `${WhOrder.TOPIC_PREFIX}.updated`,
        message: {updated: setOrders}
      },
      {
        topic: 'old.wh.newSetStarted',
        message: {
          date: pendingOrder.date,
          set: nextSetId,
          mrps: Array.from(mrps)
        }
      }
    ]
  };

  async function findAvailableLines(redirLines)
  {
    const results = await WhLine
      .aggregate([
        {$match: {
          'pickup.sets': {$lt: module.state.settings.maxSetsPerLine || 2}
        }},
        {$sort: {
          'pickup.time': 1
        }},
        {$group: {
          _id: null,
          lines: {$addToSet: '$_id'}
        }}
      ]);

    if (!results || !results.length)
    {
      return [];
    }

    const availableLines = results[0].lines;

    if (!redirLines.size)
    {
      return availableLines;
    }

    return availableLines.filter(line =>
    {
      const redirLine = redirLines.get(line);

      return !redirLine || availableLines.includes(redirLine);
    });
  }

  async function findRedirLines()
  {
    const lines = await WhLine
      .find({redirLine: {$ne: null}})
      .select({redirLine: 1})
      .lean()
      .session(session)
      .exec();

    const redirLines = new Map();

    lines.forEach(line =>
    {
      redirLines.set(line._id, line.redirLine);
    });

    return redirLines;
  }

  async function tryFindNextPendingOrderForNextLine(date, problemLines, availableLines, ignore)
  {
    try
    {
      return await tryFindNextPendingOrder(date, problemLines.shift()._id, ignore);
    }
    catch (err)
    {
      if (err.code === 'NO_PENDING_ORDERS')
      {
        if (problemLines.length)
        {
          return await tryFindNextPendingOrderForNextLine(date, problemLines, availableLines, ignore);
        }

        return await tryFindNextPendingOrder(date, availableLines, ignore);
      }

      throw err;
    }
  }

  async function tryFindNextPendingOrder(date, line, ignore)
  {
    const conditions = {
      status: 'pending',
      date: {$gte: moment.utc().subtract(7, 'days').startOf('day').toDate()}
    };

    if (!module.state.settings.ignorePsStatus)
    {
      conditions.psStatus = {$in: ['unknown', 'finished']};
    }

    if (line)
    {
      conditions['lines._id'] = Array.isArray(line) ? {$in: line} : line;
    }

    if (ignore.length)
    {
      conditions._id = {$nin: ignore};
    }

    const enabledMrps = module.state.settings.enabledMrps || [];

    if (Array.isArray(enabledMrps) && enabledMrps.length)
    {
      conditions.mrp = {$in: enabledMrps};
    }

    const whOrder = await WhOrder
      .findOne(conditions)
      .sort({startTime: 1, line: 1})
      .lean()
      .hint({status: 1, date: -1})
      .session(session)
      .exec();

    if (!whOrder)
    {
      throw app.createError('No valid, pending orders.', 'NO_PENDING_ORDERS', 400);
    }

    return whOrder;
  }

  async function findNextPendingOrder(date, problemLines, availableLines)
  {
    if (problemLines.length)
    {
      return await tryFindNextPendingOrderForNextLine(date, problemLines, availableLines, []);
    }

    return await tryFindNextPendingOrder(date, availableLines, []);
  }

  async function findMorePendingOrders(pendingOrder)
  {
    const whSettings = module.state.settings;

    const groupDuration = (whSettings.groupDuration || 2) * 3600 * 1000;
    const minSetDuration = (whSettings.minSetDuration || 120) * 60 * 1000;
    const maxSetDuration = (whSettings.maxSetDuration || 120) * 60 * 1000;
    const maxSetDifference = (whSettings.maxSetDifference || 120) * 60 * 1000;
    const maxSetSize = whSettings.maxSetSize || 5;

    const conditions = {
      status: 'pending',
      date: pendingOrder.date,
      line: pendingOrder.line
    };

    if (!whSettings.ignorePsStatus)
    {
      conditions.psStatus = {$in: ['unknown', 'finished']};
    }

    const whOrders = await WhOrder
      .find(conditions)
      .sort({startTime: 1})
      .lean()
      .session(session)
      .exec();

    const setOrders = [];
    let setDuration = 0;

    while (whOrders.length && setOrders.length < maxSetSize)
    {
      const whOrder = whOrders.shift();
      const orderDuration = whOrder.finishTime - whOrder.startTime;

      // Stop: the time difference between orders is too big.
      if (setOrders.length
        && (whOrder.startTime - setOrders[setOrders.length - 1].finishTime > maxSetDifference))
      {
        break;
      }

      // Order fits in the group's boundaries or it's the first order.
      if (setOrders.length === 0
        || (setDuration + orderDuration <= groupDuration))
      {
        setDuration += orderDuration;

        setOrders.push(whOrder);

        continue;
      }

      // Min set duration exceeded, don't extend.
      if (setDuration > minSetDuration)
      {
        break;
      }

      // Max set duration exceeded, ignore.
      if (setDuration + orderDuration > maxSetDuration)
      {
        continue;
      }

      // Extend set.
      setDuration += orderDuration;

      setOrders.push(whOrder);
    }

    return setOrders;
  }

  async function findNextSetId(date)
  {
    const result = await WhOrder
      .aggregate([
        {$match: {date}},
        {$group: {_id: null, set: {$max: '$set'}}}
      ])
      .session(session)
      .exec();

    if (result && result.length)
    {
      return (result[0].set || 0) + 1;
    }

    return 1;
  }
};
