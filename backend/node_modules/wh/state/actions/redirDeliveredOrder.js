// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const moment = require('moment');
const {ObjectId} = require('mongoose').Types;
const jsonDeepEqual = require('util/jsonDeepEqual');

exports.session = true;

exports.execute = async (app, module, {data, user, session}) =>
{
  const {
    Order,
    ProdShiftOrder,
    OldWhDeliveredOrder: WhDeliveredOrder,
    OldWhLine: WhLine,
    OldWhEvent: WhEvent
  } = module;

  const events = [];
  const deliveredOrdersResult = {
    added: [],
    updated: [],
    messages: []
  };
  const linesResult = {
    added: [],
    messages: []
  };

  if (typeof data.targetQty !== 'number' || data.targetQty < 1)
  {
    throw app.createError('Invalid target quantity.', 'INPUT', 400);
  }

  if (typeof data.pceTime !== 'number' || data.pceTime < 1000)
  {
    throw app.createError('Invalid PCE time.', 'INPUT', 400);
  }

  if (data.sourceLine === data.targetLine)
  {
    throw app.createError('Invalid lines.', 'INPUT', 400);
  }

  const sapOrder = await Order
    .findById(data.sapOrder)
    .select({scheduledStartDate: 1})
    .lean()
    .session(session)
    .exec();

  if (!sapOrder)
  {
    throw app.createError('Invalid SAP order.', 'INPUT', 400);
  }

  const lineIds = [data.targetLine];

  if (data.sourceLine)
  {
    lineIds.unshift(data.sourceLine);
  }

  await WhLine.lockLines(lineIds);

  const lines = await WhLine
    .find({_id: {$in: lineIds}})
    .session(session)
    .exec();

  const sourceLine = lines.find(l => l._id === data.sourceLine);

  if (data.sourceLine && !sourceLine)
  {
    throw app.createError('Invalid source line.', 'INPUT', 400);
  }

  let targetLine = lines.find(l => l._id === data.targetLine);

  if (!targetLine)
  {
    targetLine = new WhLine({_id: data.targetLine});
    targetLine.$session(session);

    await targetLine.save();

    linesResult.added.push(targetLine.toJSON());

    linesResult.messages.push({
      topic: `${WhLine.TOPIC_PREFIX}.updated`,
      message: {added: linesResult.added}
    });
  }

  const sourceDeliveredOrders = !sourceLine ? [] : await WhDeliveredOrder
    .find({
      sapOrder: sapOrder._id,
      line: sourceLine._id
    })
    .sort({startTime: -1})
    .lean()
    .session(session)
    .exec();

  const time = new Date();
  const redirEvent = {
    type: 'deliveredOrderRedired',
    user,
    time,
    data: {
      orders: [],
      lines: lineIds,
      sourceQtyTodo: 0,
      sourceQtyDone: 0,
      targetQtyTodo: 0,
      targetQtyDone: 0
    }
  };

  if (sourceDeliveredOrders.length)
  {
    const eventProps = ['qtyTodo', 'qtyDone', 'qtyRemaining', 'status'];
    const deliveredOrderEditedEvents = new Map();
    let qtyDone = 0;
    let qtyRemaining = data.targetQty;

    sourceDeliveredOrders.forEach(deliveredOrder =>
    {
      redirEvent.data.sourceQtyTodo += deliveredOrder.qtyTodo;
      redirEvent.data.sourceQtyDone += deliveredOrder.qtyDone;

      qtyDone += deliveredOrder.qtyDone;

      const editEvent = {
        type: 'deliveredOrderEdited',
        user,
        time,
        data: {
          orders: [{
            whOrder: deliveredOrder.whOrder,
            sapOrder: deliveredOrder.sapOrder,
            date: deliveredOrder.date,
            set: deliveredOrder.set
          }],
          lines: [deliveredOrder.line],
          oldDeliveredOrder: _.pick(deliveredOrder, eventProps),
          newDeliveredOrder: null
        }
      };

      deliveredOrderEditedEvents.set(deliveredOrder, editEvent);

      redirEvent.data.orders.push(editEvent.data.orders[0]);

      if (qtyRemaining > 0)
      {
        const qtyDiff = Math.min(deliveredOrder.qtyTodo, qtyRemaining);

        qtyRemaining -= qtyDiff;
        deliveredOrder.qtyTodo -= qtyDiff;
      }
    });

    for (let i = sourceDeliveredOrders.length - 1; i >= 0; --i)
    {
      const deliveredOrder = sourceDeliveredOrders[i];
      const qtyDiff = Math.min(deliveredOrder.qtyTodo, qtyDone);

      qtyDone -= qtyDiff;
      deliveredOrder.qtyDone = qtyDiff;
      deliveredOrder.qtyRemaining = deliveredOrder.qtyTodo - deliveredOrder.qtyDone;
      deliveredOrder.status = deliveredOrder.qtyRemaining === 0
        ? 'done'
        : (deliveredOrder.status === 'blocked' ? 'blocked' : 'todo');

      const event = deliveredOrderEditedEvents.get(deliveredOrder);

      event.data.newDeliveredOrder = _.pick(deliveredOrder, eventProps);

      if (!jsonDeepEqual(event.data.oldDeliveredOrder, event.data.newDeliveredOrder))
      {
        events.push(event);

        deliveredOrdersResult.updated.push({
          _id: deliveredOrder._id,
          ...event.data.newDeliveredOrder
        });
      }
    }
  }

  const targetDeliveredOrder = {
    _id: new ObjectId(),
    status: 'todo',
    line: targetLine._id,
    redirLine: null,
    qtyTodo: data.targetQty,
    qtyDone: 0,
    qtyRemaining: data.targetQty,
    pceTime: data.pceTime,
    sapOrder: sapOrder._id,
    whOrder: null,
    date: moment(sapOrder.scheduledStartDate).utc(true).toDate(),
    set: 0,
    startTime: moment().utc(true).toDate()
  };

  const psos = await ProdShiftOrder
    .find({
      orderId: targetDeliveredOrder.sapOrder,
      prodLine: targetDeliveredOrder.line,
      quantityDone: {$gt: 0}
    })
    .select({
      _id: 0,
      quantityDone: 1
    })
    .lean()
    .session(session)
    .exec();

  psos.forEach(pso =>
  {
    targetDeliveredOrder.qtyDone += pso.quantityDone;
  });

  if (targetDeliveredOrder.qtyDone > targetDeliveredOrder.qtyTodo)
  {
    targetDeliveredOrder.qtyDone = targetDeliveredOrder.qtyTodo;
  }

  targetDeliveredOrder.qtyRemaining = targetDeliveredOrder.qtyTodo - targetDeliveredOrder.qtyDone;

  if (targetDeliveredOrder.qtyRemaining === 0)
  {
    targetDeliveredOrder.status = 'done';
  }

  redirEvent.data.targetQtyTodo = targetDeliveredOrder.qtyTodo;
  redirEvent.data.targetQtyDone = targetDeliveredOrder.qtyDone;

  if (!redirEvent.data.orders.length)
  {
    redirEvent.data.orders.push({
      whOrder: targetDeliveredOrder.whOrder,
      sapOrder: targetDeliveredOrder.sapOrder,
      date: targetDeliveredOrder.date,
      set: targetDeliveredOrder.set
    });
  }

  events.push(redirEvent);

  deliveredOrdersResult.added.push(targetDeliveredOrder);

  const deliveredOrderOps = deliveredOrdersResult.updated.map(u => ({
    updateOne: {
      filter: {_id: u._id},
      update: {$set: u}
    }
  }));

  deliveredOrdersResult.added.forEach(document =>
  {
    deliveredOrderOps.push({
      insertOne: {document}
    });
  });

  await WhDeliveredOrder.collection.bulkWrite(deliveredOrderOps, {session});

  const [sourceLineResult, targetLineResult, eventsResult] = await Promise.all([
    !sourceLine ? null : WhLine.recount(sourceLine._id, false, true, session),
    WhLine.recount(targetLine._id, false, true, session),
    WhEvent.record(events, session)
  ]);

  deliveredOrdersResult.messages.push({
    topic: `${WhDeliveredOrder.TOPIC_PREFIX}.updated`,
    message: {
      added: deliveredOrdersResult.added,
      updated: deliveredOrdersResult.updated
    }
  });

  await session.commitTransaction();

  return {
    results: [
      eventsResult,
      linesResult,
      sourceLineResult,
      targetLineResult,
      deliveredOrdersResult
    ]
  };
};
