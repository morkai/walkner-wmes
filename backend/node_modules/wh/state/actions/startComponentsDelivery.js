// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const moment = require('moment');
const {ObjectId} = require('mongoose').Types;

module.exports = async (app, module, {data, user, whUser, session}) =>
{
  const {
    OldWhEvent: WhEvent,
    OldWhOrder: WhOrder,
    OldWhSetCart: WhSetCart,
    OldWhLine: WhLine,
    OldWhPendingComponents: WhPendingComponents,
    OldWhPendingPackaging: WhPendingPackaging,
    OldWhDeliveredOrder: WhDeliveredOrder
  } = module;

  const {
    kind,
    pendingDelivery,
    forceLine
  } = data;
  const now = new Date();
  const minTimeForDelivery = (module.state.settings.minTimeForDelivery || 45) * 60 * 1000;
  const maxDeliveryStartTime = (module.state.settings.maxDeliveryStartTime || 60) * 60 * 1000;
  const maxSetCartsPerDelivery = module.state.settings.maxSetCartsPerDelivery || 3;

  const pendingComponentsResult = {
    deleted: [],
    added: [],
    messages: []
  };
  const pendingPackagingResult = {
    added: [],
    messages: []
  };
  const deliveredOrdersResult = {
    added: [],
    messages: []
  };
  const linesResult = {
    updated: [],
    messages: []
  };
  const whOrdersResult = {
    updated: [],
    messages: []
  };
  const setCartsResult = {
    updated: [],
    messages: []
  };
  const event = {
    type: 'deliveryStarted',
    time: now,
    user,
    data: {
      kind,
      whUser: WhEvent.whUser(whUser),
      orders: [],
      lines: new Set(),
      setCarts: null
    }
  };

  let pendingSets = await findPendingSets(forceLine, pendingComponentsResult);

  if (pendingDelivery)
  {
    pendingSets = pendingSets.filter(pendingSet => pendingSet.packCarts.length > 0);
  }

  // Get at most max carts from the pending deliveries
  const setCarts = [];
  const usedPendingSets = [];

  for (const pendingSet of pendingSets)
  {
    const pendingSetCarts = pendingSet.fifoCarts.splice(0, maxSetCartsPerDelivery - setCarts.length);

    // Include carts from different sets only if they fit fully
    if (setCarts.length && pendingSet.fifoCarts.length)
    {
      break;
    }

    usedPendingSets.push(pendingSet);

    for (const pendingSetCart of pendingSetCarts)
    {
      setCarts.push(pendingSetCart);
    }

    // Full set delivered: mark the pending delivery for deletion
    if (!pendingSet.fifoCarts.length)
    {
      pendingComponentsResult.deleted.push({_id: pendingSet.pendingDelivery._id});
    }

    // Max reached: ignore the rest of pending deliveries
    if (setCarts.length === maxSetCartsPerDelivery)
    {
      break;
    }
  }

  // Max not yet reached: try to fill
  if (setCarts.length < maxSetCartsPerDelivery)
  {
    const availableLines = forceLine ? [forceLine] : await findAvailableLines(minTimeForDelivery);
    const workingLines = forceLine ? [forceLine] : findWorkingLines(availableLines);
    const remainingSetCartCount = setCarts.length ? (maxSetCartsPerDelivery - setCarts.length) : 999;
    const availableSetCarts = await findAvailableSetCarts(
      kind,
      forceLine,
      availableLines,
      workingLines,
      remainingSetCartCount,
      maxDeliveryStartTime,
      moment(now).utc(true).valueOf()
    );
    const lineToSets = mapLineToSets(availableSetCarts);
    const remainingSetCarts = findRemainingSetCarts(availableLines, lineToSets, pendingComponentsResult);
    const newOrderSets = await findNewOrderSets(remainingSetCarts, setCarts);
    const allNewWhOrders = await findAllNewWhOrders(newOrderSets);
    const blockedLineOrders = await findBlockedLineOrders(allNewWhOrders);
    const lineStats = createDeliveredOrders(allNewWhOrders, blockedLineOrders, deliveredOrdersResult);

    await updateLines(lineStats, linesResult);
  }

  if (!setCarts.length)
  {
    return {
      response: {
        result: 'nothingToDeliver',
        setCarts: []
      }
    };
  }

  // Apply pending delivery operations
  const pendingComponentsOps = [];

  if (pendingComponentsResult.deleted.length)
  {
    pendingComponentsOps.push({
      deleteMany: {
        filter: {_id: {$in: pendingComponentsResult.deleted.map(d => d._id)}}
      }
    });
  }

  pendingComponentsResult.added.forEach(pendingComponents =>
  {
    pendingComponentsOps.push({
      insertOne: {
        document: pendingComponents
      }
    });
  });

  // Apply delivered orders operations
  const deliveredOrdersOps = [];

  deliveredOrdersResult.added.forEach(deliveredOrder =>
  {
    deliveredOrdersOps.push({
      insertOne: {
        document: deliveredOrder
      }
    });
  });

  // Apply lines operations
  const linesOps = [];

  linesResult.updated.forEach(line =>
  {
    linesOps.push({
      updateOne: {
        filter: {_id: line._id},
        update: {$set: line}
      }
    });
  });

  // Apply set carts & orders operations
  setCarts.sort((a, b) => a.startTime - b.startTime);

  let whOrderIds = new Set();
  const setCartsOps = [];
  const whOrdersOps = [{
    updateMany: {
      filter: {_id: {$in: []}},
      update: {$set: {
        distStatus: 'started',
        fifoStatus: 'started'
      }}
    }
  }];
  const deliveringBy = {id: whUser._id, label: whUser.label};

  event.data.setCarts = WhEvent.setCarts({remaining: setCarts});

  setCarts.forEach(setCart =>
  {
    setCart.deliveringBy = deliveringBy;

    const update = {
      status: 'delivering',
      deliveringBy,
      deliveringAt: now,
      users: WhSetCart.collectUsers(setCart)
    };

    Object.assign(setCart, update);

    setCartsResult.updated.push(setCart);

    setCartsOps.push({
      updateOne: {
        filter: {_id: setCart._id},
        update: {$set: update}
      }
    });

    WhEvent.lines(setCart, event.data.lines);

    setCart.orders.forEach(whSetCartOrder =>
    {
      const whOrderId = whSetCartOrder.whOrder;

      if (whOrderIds.has(whOrderId))
      {
        return;
      }

      event.data.orders.push({
        whOrder: whOrderId,
        sapOrder: whSetCartOrder.sapOrder,
        date: setCart.date,
        set: setCart.set
      });

      whOrderIds.add(whOrderId);

      whOrdersOps[0].updateMany.filter._id.$in.push(whOrderId);

      whOrdersResult.updated.push({
        _id: whOrderId,
        distStatus: 'started',
        fifoStatus: 'started'
      });
    });
  });

  // Create pending packaging deliveries
  whOrderIds = Array.from(whOrderIds);

  const [allPackagingCarts, pendingPackagingDeliveries] = await Promise.all([
    WhSetCart
      .find({
        kind: 'packaging',
        status: 'completed',
        'orders.whOrder': {$in: whOrderIds}
      })
      .select({_id: 1, 'orders.whOrder': 1})
      .hint({'orders.whOrder': 1})
      .lean()
      .session(session)
      .exec(),
    WhPendingPackaging
      .find({whOrders: {$in: whOrderIds}})
      .select({setCarts: 1})
      .lean()
      .session(session)
      .exec()
  ]);

  const oldPackagingCarts = new Set();

  pendingPackagingDeliveries.forEach(pendingPackaging =>
  {
    pendingPackaging.setCarts.forEach(setCartId =>
    {
      oldPackagingCarts.add(setCartId.toString());
    });
  });

  const pendingPackaging = {
    _id: new ObjectId(),
    setCarts: [],
    whOrders: new Set()
  };
  const pendingPackagingOps = [];

  if (pendingDelivery && !allPackagingCarts.length && usedPendingSets.length)
  {
    usedPendingSets.forEach(pendingSet =>
    {
      pendingSet.packCarts.forEach(setCart =>
      {
        allPackagingCarts.push(setCart);
      });
    });
  }

  allPackagingCarts.forEach(setCart =>
  {
    if (!oldPackagingCarts.has(setCart._id.toString()))
    {
      setCart.orders.forEach(({whOrder}) => pendingPackaging.whOrders.add(whOrder));
      pendingPackaging.setCarts.push(setCart._id);
    }
  });

  if (pendingPackaging.setCarts.length)
  {
    pendingPackaging.whOrders = Array.from(pendingPackaging.whOrders);

    pendingPackagingOps.push({
      insertOne: {
        document: pendingPackaging
      }
    });

    pendingPackagingResult.added.push(pendingPackaging);
  }

  if (pendingDelivery)
  {
    return {
      response: {
        pendingComponentsResult,
        pendingPackagingResult,
        deliveredOrdersResult,
        linesResult,
        whOrdersResult,
        setCartsResult
      }
    };
  }

  // Write operations
  const [eventsResult] = await Promise.all([
    WhEvent.record(event, session),
    pendingComponentsOps.length ? WhPendingComponents.collection.bulkWrite(pendingComponentsOps, {session}) : null,
    pendingPackagingOps.length ? WhPendingPackaging.collection.bulkWrite(pendingPackagingOps, {session}) : null,
    deliveredOrdersOps.length ? WhDeliveredOrder.collection.bulkWrite(deliveredOrdersOps, {session}) : null,
    linesOps.length ? WhLine.collection.bulkWrite(linesOps, {session}) : null,
    whOrdersOps.length ? WhOrder.collection.bulkWrite(whOrdersOps, {session}) : null,
    setCartsOps.length ? WhSetCart.collection.bulkWrite(setCartsOps, {session}) : null
  ]);

  // Create messages
  if (pendingComponentsOps.length)
  {
    pendingComponentsResult.messages.push({
      topic: `${WhPendingComponents.TOPIC_PREFIX}.updated`,
      message: {
        deleted: pendingComponentsResult.deleted,
        added: pendingComponentsResult.added
      }
    });
  }

  if (pendingPackagingOps.length)
  {
    pendingPackagingResult.messages.push({
      topic: `${WhPendingPackaging.TOPIC_PREFIX}.updated`,
      message: {
        added: pendingPackagingResult.added
      }
    });
  }

  deliveredOrdersResult.messages.push({
    topic: `${WhDeliveredOrder.TOPIC_PREFIX}.updated`,
    message: {
      added: deliveredOrdersResult.added
    }
  });

  linesResult.messages.push({
    topic: `${WhLine.TOPIC_PREFIX}.updated`,
    message: {
      updated: linesResult.updated
    }
  });

  whOrdersResult.messages.push({
    topic: `${WhOrder.TOPIC_PREFIX}.updated`,
    message: {
      updated: whOrdersResult.updated
    }
  });

  setCartsResult.messages.push({
    topic: `${WhSetCart.TOPIC_PREFIX}.updated`,
    message: {
      updated: setCartsResult.updated
    }
  });

  await session.commitTransaction();

  return {
    response: {
      result: 'deliveryStarted',
      setCarts,
      user: whUser
    },
    results: [
      eventsResult,
      pendingComponentsResult,
      pendingPackagingResult,
      deliveredOrdersResult,
      linesResult,
      whOrdersResult,
      setCartsResult
    ]
  };

  async function findPendingSets(line, pendingComponentsResult)
  {
    // Check if there are any pending sets for delivery
    const pendingComponents = await WhPendingComponents
      .find()
      .sort({_id: 1})
      .lean()
      .session(session)
      .exec();

    // Find carts from the pending sets that are awaiting delivery
    const pendingSets = [];
    let pendingCount = 0;

    for (const pendingDelivery of pendingComponents)
    {
      const setCarts = await WhSetCart
        .find({
          status: 'completed',
          date: pendingDelivery.date,
          set: pendingDelivery.set
        })
        .sort({startTime: 1})
        .hint({status: 1, date: -1})
        .lean()
        .session(session)
        .exec();
      const fifoCarts = setCarts.filter(setCart => setCart.kind === 'components');

      // No more carts: delete pending delivery
      if (!fifoCarts.length)
      {
        pendingComponentsResult.deleted.push(pendingDelivery);

        continue;
      }

      // Ignore set carts not for the forced line
      if (line)
      {
        const setCartLines = new Set();

        fifoCarts.forEach(setCart =>
        {
          setCart.lines.forEach(line => setCartLines.add(line));
        });

        if (!setCartLines.has(line))
        {
          continue;
        }
      }

      const packCarts = setCarts.filter(setCart => setCart.kind === 'packaging');

      pendingSets.push({
        pendingDelivery,
        fifoCarts,
        packCarts
      });

      pendingCount += fifoCarts.length;

      // Max reached: ignore the rest of pending deliveries
      if (pendingCount >= maxSetCartsPerDelivery)
      {
        break;
      }
    }

    return pendingSets;
  }

  async function findAvailableLines(minTimeForDelivery)
  {
    const availableLines = await WhLine
      .find({'components.time': {$lt: minTimeForDelivery}})
      .select({_id: 1})
      .sort({'components.time': 1})
      .lean()
      .session(session)
      .exec();

    return availableLines.map(l => l._id);
  }

  function findWorkingLines(availableLines)
  {
    const production = app[module.config.productionId];

    if (!production || !availableLines.length)
    {
      return [];
    }

    return availableLines.filter(lineId =>
    {
      const lineState = production.getProdLineState(lineId);

      return !!lineState && lineState.getCurrentOrder() !== null;
    });
  }

  async function findAvailableSetCarts(
    kind,
    forcedLine,
    availableLines,
    workingLines,
    maxCartCount,
    maxDeliveryStartTime,
    now)
  {
    const availableSetCarts = [];

    if (!availableLines.length)
    {
      return availableSetCarts;
    }

    const allAvailableSetCarts = await WhSetCart
      .aggregate([
        {$match: {
          status: 'completed',
          lines: {$in: availableLines},
          kind
        }},
        {$group: {
          _id: {
            line: '$line',
            date: '$date',
            set: '$set'
          },
          carts: {
            $addToSet: {
              _id: '$_id',
              startTime: '$startTime',
              lines: '$lines'
            }
          }
        }}
      ])
      .hint({status: 1, date: -1})
      .session(session)
      .exec();

    allAvailableSetCarts.forEach(lineSetCarts =>
    {
      const carts = [];
      let startTime = Number.MAX_SAFE_INTEGER;

      lineSetCarts.carts.sort((a, b) => a.startTime - b.startTime);

      lineSetCarts.carts.forEach(cart =>
      {
        const cartStartTime = cart.startTime.getTime();

        if (forcedLine
          || (cartStartTime - now) < maxDeliveryStartTime
          || isAnyLineWorking(cart.lines, workingLines))
        {
          startTime = Math.min(cartStartTime, startTime);

          carts.push(cart);
        }
      });

      if (!carts.length)
      {
        return;
      }

      availableSetCarts.push({
        _id: lineSetCarts._id,
        carts,
        startTime
      });
    });

    availableSetCarts.sort((a, b) => a.startTime - b.startTime);

    return availableSetCarts;
  }

  function isAnyLineWorking(lines, workingLines)
  {
    return lines.some(line => workingLines.includes(line));
  }

  function mapLineToSets(availableSetCarts)
  {
    const lineToSets = new Map();

    // Group sets by line
    availableSetCarts.forEach(lineSetCarts =>
    {
      if (!lineToSets.has(lineSetCarts._id.line))
      {
        lineToSets.set(lineSetCarts._id.line, []);
      }

      lineToSets.get(lineSetCarts._id.line).push({
        date: lineSetCarts._id.date,
        set: lineSetCarts._id.set,
        carts: lineSetCarts.carts.sort((a, b) => a.startTime - b.startTime)
      });
    });

    return lineToSets;
  }

  function findRemainingSetCarts(availableLines, lineToSets, pendingComponentsResult)
  {
    const remainingSetCarts = [];
    const usedSetCarts = new Set();
    let done = false;

    setCarts.forEach(setCart => usedSetCarts.add(setCart._id.toString()));

    for (const line of availableLines)
    {
      const lineSets = lineToSets.get(line);

      if (!lineSets)
      {
        continue;
      }

      for (const lineSet of lineSets)
      {
        const remainingSetCartCount = setCarts.length || remainingSetCarts.length
          ? (maxSetCartsPerDelivery - setCarts.length - remainingSetCarts.length)
          : 999;

        if (lineSet.carts.length > remainingSetCartCount)
        {
          break;
        }

        while (lineSet.carts.length)
        {
          const setCartId = lineSet.carts.shift()._id;
          const usedId = setCartId.toString();

          // Ignore possible duplicates due to line groups
          if (usedSetCarts.has(usedId))
          {
            continue;
          }

          remainingSetCarts.push(setCartId);
          usedSetCarts.add(usedId);

          if (setCarts.length + remainingSetCarts.length === maxSetCartsPerDelivery)
          {
            done = true;

            break;
          }
        }

        // Mark the set as pending delivery if there are any carts remaining
        if (lineSet.carts.length)
        {
          pendingComponentsResult.added.push({
            _id: new ObjectId(),
            date: lineSet.date,
            set: lineSet.set
          });
        }

        if (done)
        {
          return remainingSetCarts;
        }
      }
    }

    return remainingSetCarts;
  }

  async function findNewOrderSets(remainingSetCarts, setCarts)
  {
    const newOrderSets = new Map();

    if (!remainingSetCarts.length)
    {
      return newOrderSets;
    }

    const newSetCarts = await WhSetCart
      .find({_id: {$in: remainingSetCarts}})
      .lean()
      .session(session)
      .exec();

    newSetCarts.forEach(setCart =>
    {
      setCarts.push(setCart);

      const orderSetKey = `${setCart.date.getTime()}:${setCart.set}`;

      if (!newOrderSets.has(orderSetKey))
      {
        newOrderSets.set(orderSetKey, {
          set: setCart.set,
          date: setCart.date
        });
      }
    });

    return newOrderSets;
  }

  async function findAllNewWhOrders(newOrderSets)
  {
    if (!newOrderSets.size)
    {
      return [];
    }

    return await WhOrder
      .find({
        $or: Array.from(newOrderSets.values())
      })
      .select({
        order: 1,
        lines: 1,
        date: 1,
        set: 1,
        startTime: 1
      })
      .hint({set: 1, date: -1})
      .lean()
      .session(session)
      .exec();
  }

  async function findBlockedLineOrders(allNewWhOrders)
  {
    const blockedLineOrders = new Set();

    if (!allNewWhOrders.length)
    {
      return blockedLineOrders;
    }

    const blockedDeliveredOrders = await WhDeliveredOrder
      .find({
        sapOrder: {$in: allNewWhOrders.map(o => o.order)},
        status: 'blocked'
      })
      .select({
        sapOrder: 1,
        line: 1
      })
      .lean()
      .session(session)
      .exec();

    blockedDeliveredOrders.forEach(deliveredOrder =>
    {
      blockedLineOrders.add(`${deliveredOrder.line}:${deliveredOrder.sapOrder}`);
    });

    return blockedLineOrders;
  }

  function createDeliveredOrders(allNewWhOrders, blockedLineOrders, deliveredOrdersResult)
  {
    const lineStats = new Map();

    allNewWhOrders.forEach(whOrder =>
    {
      whOrder.lines.forEach(whOrderLine =>
      {
        if (!lineStats.has(whOrderLine._id))
        {
          lineStats.set(whOrderLine._id, {
            sets: new Set(),
            qty: 0,
            time: 0
          });
        }

        const line = lineStats.get(whOrderLine._id);

        line.sets.add(`${whOrder.date.getTime()}:${whOrder.set}`);

        line.qty += whOrderLine.qty;
        line.time += whOrderLine.qty * whOrderLine.pceTime;

        deliveredOrdersResult.added.push({
          _id: new ObjectId(),
          status: blockedLineOrders.has(`${whOrderLine._id}:${whOrder.order}`) ? 'blocked' : 'todo',
          line: whOrderLine._id,
          redirLine: null,
          qtyTodo: whOrderLine.qty,
          qtyDone: 0,
          qtyRemaining: whOrderLine.qty,
          pceTime: whOrderLine.pceTime,
          sapOrder: whOrder.order,
          whOrder: whOrder._id,
          date: whOrder.date,
          set: whOrder.set,
          startTime: whOrder.startTime
        });
      });
    });

    return lineStats;
  }

  async function updateLines(lineStats, linesResult)
  {
    if (!lineStats.size)
    {
      return;
    }

    const lineIds = Array.from(lineStats.keys());

    await WhLine.lockLines(lineIds);

    const whLines = !lineStats.size ? [] : (await WhLine
      .find({_id: {$in: lineIds}})
      .lean()
      .session(session)
      .exec());

    whLines.forEach(whLine =>
    {
      const stats = lineStats.get(whLine._id);

      stats.sets = stats.sets.size;

      whLine.pickup.sets = Math.max(0, whLine.pickup.sets - stats.sets);
      whLine.pickup.qty = Math.max(0, whLine.pickup.qty - stats.qty);
      whLine.pickup.time = Math.max(0, whLine.pickup.time - stats.time);

      whLine[kind].qty += stats.qty;
      whLine[kind].time += stats.time;

      linesResult.updated.push({
        _id: whLine._id,
        pickup: whLine.pickup,
        [kind]: whLine[kind]
      });
    });
  }
};
