// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const {ObjectId} = require('mongoose').Types;
const shifts = require('util/shifts');

exports.session = true;

exports.execute = async (app, module, {data, user, session}) =>
{
  const {
    ProdLine,
    OldWhEvent: WhEvent,
    OldWhLine: WhLine,
    OldWhOrder: WhOrder,
    OldWhSetCart: WhSetCart,
    OldWhDeliveredOrder: WhDeliveredOrder
  } = module;

  const linesResult = {
    added: [],
    updated: []
  };
  const deliveredOrdersResult = {
    added: [],
    updated: []
  };
  const setCartsResult = {
    updated: []
  };
  const ordersResult = {
    updated: []
  };

  const [sourceLine, targetLine] = await redirLines(
    String(data.sourceLine),
    String(data.targetLine)
  );

  await Promise.all([
    data.redirDelivered ? redirDeliveredOrders(sourceLine, targetLine) : null,
    redirSetCarts(sourceLine, targetLine),
    redirPickupOrders(sourceLine, targetLine)
  ]);

  const linesOps = [];
  const deliveredOrdersOps = [];
  const setCartsOps = [];
  const ordersOps = [];

  linesResult.added.forEach(document => linesOps.push({
    insertOne: {document}
  }));

  linesResult.updated.forEach(update => linesOps.push({
    updateOne: {
      filter: {_id: update._id},
      update: {$set: update}
    }
  }));

  deliveredOrdersResult.added.forEach(document => deliveredOrdersOps.push({
    insertOne: {document}
  }));

  deliveredOrdersResult.updated.forEach(update => deliveredOrdersOps.push({
    updateOne: {
      filter: {_id: update._id},
      update: {$set: update}
    }
  }));

  setCartsResult.updated.forEach(update => setCartsOps.push({
    updateOne: {
      filter: {_id: update._id},
      update: {$set: update}
    }
  }));

  ordersResult.updated.forEach(update => ordersOps.push({
    updateOne: {
      filter: {_id: update._id},
      update: {$set: update}
    }
  }));

  const [eventsResult] = await Promise.all([
    WhEvent.record({
      type: 'lineRedirStarted',
      user,
      time: new Date(),
      data: {
        lines: [sourceLine._id, targetLine._id],
        redirDelivered: !!data.redirDelivered
      }
    }, session),
    WhLine.collection.bulkWrite(linesOps, {session}),
    !deliveredOrdersOps.length ? null : WhDeliveredOrder.collection.bulkWrite(deliveredOrdersOps, {session}),
    !setCartsOps.length ? null : WhSetCart.collection.bulkWrite(setCartsOps, {session}),
    !ordersOps.length ? null : WhOrder.collection.bulkWrite(ordersOps, {session})
  ]);

  const [sourceLineResult, targetLineResult] = await Promise.all([
    WhLine.recount(sourceLine._id, true, true, session),
    WhLine.recount(targetLine._id, true, true, session)
  ]);

  if (linesResult.updated.length)
  {
    Object.assign(linesResult.updated[0], sourceLineResult.updated[0]);
  }
  else
  {
    linesResult.updated.push(sourceLineResult.updated[0]);
  }

  if (linesResult.added.length)
  {
    Object.assign(linesResult.added[0], targetLineResult.updated[0]);
  }
  else
  {
    linesResult.updated.push(targetLineResult.updated[0]);
  }

  await session.commitTransaction();

  return {
    response: {},
    results: [
      eventsResult
    ],
    messages: [
      {topic: `${WhDeliveredOrder.TOPIC_PREFIX}.updated`, message: deliveredOrdersResult},
      {topic: `${WhSetCart.TOPIC_PREFIX}.updated`, message: setCartsResult},
      {topic: `${WhOrder.TOPIC_PREFIX}.updated`, message: ordersResult},
      {topic: `${WhLine.TOPIC_PREFIX}.updated`, message: linesResult}
    ]
  };

  async function redirLines(sourceLineId, targetLineId)
  {
    if (sourceLineId === targetLineId)
    {
      throw app.createError('Same lines.', 'SAME_LINES', 400);
    }

    const lineIds = [sourceLineId, targetLineId];

    await WhLine.lockLines(lineIds);

    const redirLine = await WhLine
      .findOne({redirLine: sourceLineId})
      .select({_id: 1})
      .lean()
      .exec();

    if (redirLine)
    {
      throw app.createError('Source line already a target.', 'LINE_REDIRECTED', 400, {
        line: redirLine._id,
        redirLine: sourceLineId
      });
    }

    const lines = await WhLine
      .find({_id: {$in: lineIds}})
      .lean()
      .session(session)
      .exec();

    const sourceLine = lines.find(l => l._id === sourceLineId);

    if (!sourceLine)
    {
      throw app.createError('Unknown source line.', 'UNKNOWN_SOURCE_LINE', 400);
    }

    if (sourceLine.redirLine)
    {
      throw app.createError('Source line already redirected.', 'LINE_REDIRECTED', 400, {
        line: sourceLine._id,
        redirLine: sourceLine.redirLine
      });
    }

    let targetLine = lines.find(l => l._id === targetLineId);

    if (!targetLine)
    {
      const prodLine = await ProdLine
        .findOne({_id: targetLineId, deactivatedAt: null})
        .select({_id: 1})
        .lean()
        .exec();

      if (!prodLine)
      {
        throw app.createError('Invalid target line.', 'INVALID_TARGET_LINE', 400);
      }

      targetLine = new WhLine({_id: targetLineId});

      linesResult.added.push(targetLine);
    }

    if (targetLine.redirLine)
    {
      throw app.createError('Target line already redirected.', 'LINE_REDIRECTED', 400, {
        line: targetLine._id,
        redirLine: targetLine.redirLine
      });
    }

    linesResult.updated.push({
      _id: sourceLine._id,
      redirLine: targetLineId
    });

    return [sourceLine, targetLine];
  }

  async function redirDeliveredOrders(sourceLine, targetLine)
  {
    const sourceDeliveredOrders = await WhDeliveredOrder
      .find({
        line: sourceLine._id,
        status: {$in: ['todo', 'blocked']}
      })
      .lean()
      .session(session)
      .exec();

    sourceDeliveredOrders.forEach(sourceDeliveredOrder =>
    {
      if (sourceDeliveredOrder.qtyDone === 0)
      {
        deliveredOrdersResult.updated.push({
          _id: sourceDeliveredOrder._id,
          line: targetLine._id,
          redirLine: sourceLine._id
        });
      }
      else
      {
        const targetDeliveredOrder = new WhDeliveredOrder({
          ...sourceDeliveredOrder,
          _id: new ObjectId(),
          qtyTodo: sourceDeliveredOrder.qtyTodo - sourceDeliveredOrder.qtyDone,
          qtyDone: 0,
          qtyRemaining: sourceDeliveredOrder.qtyTodo - sourceDeliveredOrder.qtyDone,
          line: targetLine._id,
          redirLine: sourceLine._id
        });

        deliveredOrdersResult.added.push(targetDeliveredOrder);

        deliveredOrdersResult.updated.push({
          _id: sourceDeliveredOrder._id,
          status: 'done',
          qtyTodo: sourceDeliveredOrder.qtyDone,
          qtyRemaining: 0
        });
      }
    });
  }

  async function redirSetCarts(sourceLine, targetLine)
  {
    const setCarts = await WhSetCart
      .find({
        status: {$in: ['completing', 'completed']},
        lines: sourceLine._id
      })
      .select({
        line: 1,
        lines: 1,
        redirLine: 1,
        redirLines: 1
      })
      .lean()
      .session(session)
      .exec();

    setCarts.forEach(setCart =>
    {
      if (!setCart.redirLine)
      {
        setCart.redirLine = setCart.line;
        setCart.redirLines = setCart.lines;
      }

      if (setCart.lines.length === 1)
      {
        setCart.line = targetLine._id;
      }

      setCart.lines = setCart.lines.map(line => line === sourceLine._id ? targetLine._id : line);

      setCartsResult.updated.push(setCart);
    });
  }

  async function redirPickupOrders(sourceLine, targetLine)
  {
    const orders = await WhOrder
      .find({
        distStatus: 'pending',
        'lines._id': sourceLine._id,
        date: {$gte: shifts.getCurrentDate(true).subtract(7, 'days').toDate()}
      })
      .select({
        line: 1,
        lines: 1,
        redirLine: 1,
        redirLines: 1
      })
      .lean()
      .session(session)
      .exec();

    orders.forEach(order =>
    {
      if (!order.redirLine)
      {
        order.redirLine = order.line;
        order.redirLines = order.lines.map(line => line._id);
      }

      if (order.lines.length === 1)
      {
        order.line = targetLine._id;
      }

      order.lines.forEach(line =>
      {
        if (line._id === sourceLine._id)
        {
          line._id = targetLine._id;
        }
      });

      ordersResult.updated.push(order);
    });
  }
};
