// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

exports.session = true;

exports.execute = async (app, module, {data, user, session}) =>
{
  const {
    OldWhEvent: WhEvent,
    OldWhOrder: WhOrder,
    OldWhSetCart: WhSetCart,
    OldWhLine: WhLine,
    OldWhPendingComponents: WhPendingComponents
  } = module;

  const conditions = {};

  if (data.cancel)
  {
    conditions.status = {$ne: 'cancelled'};
  }

  if (data.orders)
  {
    if (!Array.isArray(data.orders) || data.orders.length !== 1)
    {
      throw app.createError('Invalid orders.', 'INPUT', 400);
    }

    conditions._id = {$in: data.orders};
  }
  else
  {
    conditions.set = data.set;
    conditions.date = data.date;
  }

  const whOrders = await WhOrder
    .find(conditions)
    .session(session)
    .exec();

  if (!whOrders.length)
  {
    return {response: {orders: whOrders}};
  }

  const $set = {
    status: data.cancel ? 'cancelled' : 'pending',
    distStatus: 'pending',
    fifoStatus: 'pending',
    packStatus: 'pending',
    problem: '',
    set: null,
    startedAt: null,
    finishedAt: null,
    picklistFunc: null,
    picklistDone: 'pending',
    users: [],
    funcs: whOrders[0].funcs.map(func =>
    {
      return {
        _id: func._id,
        user: null,
        startedAt: null,
        finishedAt: null,
        status: 'pending',
        picklist: 'pending',
        pickup: 'pending',
        carts: [],
        problemArea: '',
        comment: ''
      };
    })
  };
  const time = new Date();
  const event = {
    type: data.cancel ? 'ordersCancelled' : 'ordersReset',
    time,
    user,
    data: {
      orders: WhEvent.orders(whOrders)
    }
  };

  for (const whOrder of whOrders)
  {
    Object.assign(whOrder, $set);
  }

  const results = [];

  const [eventsResults] = await Promise.all([
    WhEvent.record(event, session),
    WhOrder.collection.updateMany({_id: {$in: whOrders.map(o => o._id)}}, {$set}, {session})
  ]);

  results.push(eventsResults);

  if (data.orders)
  {
    const setCartsResults = await WhSetCart.deleteByWhOrder(whOrders[0]);
    const [lineResults, setResults] = await Promise.all([
      WhLine.recountPickupByWhOrder(whOrders[0]),
      whOrders[0].finalizeSet(setCartsResults)
    ]);

    if (!setResults.hasRemainingOrders)
    {
      results.push(await WhPendingComponents.deleteBySet(whOrders[0].date, whOrders[0].set));
    }

    results.push(setCartsResults, lineResults, setResults);
  }
  else
  {
    const [setCartsResults, lineResults, pendingComponentsResults] = await Promise.all([
      WhSetCart.deleteBySet(data.date, data.set, session),
      WhLine.recountPickupByWhOrder(whOrders[0]),
      WhPendingComponents.deleteBySet(data.date, data.set, session)
    ]);

    results.push(
      setCartsResults,
      lineResults,
      pendingComponentsResults
    );
  }

  await session.commitTransaction();

  const leanWhOrders = whOrders.map(whOrder => whOrder.toJSON());

  return {
    response: {
      orders: leanWhOrders
    },
    results,
    messages: [{
      topic: `${WhOrder.TOPIC_PREFIX}.updated`,
      message: {updated: leanWhOrders}
    }]
  };
};
