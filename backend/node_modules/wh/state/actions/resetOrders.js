// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

exports.session = true;

exports.execute = async (app, module, {data, user, session}) =>
{
  const {
    OldWhEvent: WhEvent,
    OldWhDeliveredOrder: WhDeliveredOrder,
    OldWhOrder: WhOrder,
    OldWhSetCart: WhSetCart,
    OldWhLine: WhLine,
    OldWhPendingSetAssign: WhPendingSetAssign
  } = module;

  const conditions = {};

  if (data.finish)
  {
    data.cancel = true;
  }

  if (data.cancel)
  {
    conditions.status = {$ne: 'cancelled'};
  }

  if (data.orders)
  {
    if (!Array.isArray(data.orders) || data.orders.length !== 1)
    {
      throw app.createError('Invalid orders.', 'INPUT', 400);
    }

    conditions._id = {$in: data.orders};
  }
  else
  {
    conditions.set = data.set;
    conditions.date = data.date;
  }

  const whOrders = await WhOrder
    .find(conditions)
    .session(session)
    .exec();

  if (!whOrders.length)
  {
    return {response: {orders: whOrders}};
  }

  const time = new Date();
  const finish = data.finish;
  const event = {
    type: finish ? 'ordersFinished' : data.cancel ? 'ordersCancelled' : 'ordersReset',
    time,
    user,
    data: {
      orders: WhEvent.orders(whOrders)
    }
  };

  const date = whOrders[0].date;
  const set = whOrders[0].set;

  const $set = {
    status: data.cancel ? 'cancelled' : 'pending',
    distStatus: 'pending',
    fifoStatus: 'pending',
    packStatus: 'pending',
    psDistStatus: 'pending',
    setDistStarted: false,
    forceDelivery: false,
    problem: '',
    set: null,
    startedAt: null,
    finishedAt: null,
    picklistFunc: null,
    picklistDone: 'pending',
    users: [],
    funcs: whOrders[0].funcs.map(func =>
    {
      return {
        _id: func._id,
        user: null,
        startedAt: null,
        finishedAt: null,
        status: 'pending',
        picklist: 'pending',
        pickup: 'pending',
        carts: [],
        problemArea: '',
        comment: ''
      };
    })
  };

  const whOrderOps = [];
  const whOrderIds = [];

  for (const whOrder of whOrders)
  {
    whOrderIds.push(whOrder._id);

    if (finish)
    {
      continue;
    }

    const update = {...$set};

    whOrderOps.push({
      updateOne: {
        filter: {_id: whOrder._id},
        update: {$set: update}
      }
    });

    if (whOrder.forcedRedir)
    {
      const $set = {
        forcedRedir: null,
        line: whOrder.redirLine,
        lines: whOrder.lines,
        redirLine: whOrder.forcedRedir.redirLine,
        redirLines: whOrder.forcedRedir.redirLines
      };

      whOrder.redirLines.forEach((lineId, i) =>
      {
        whOrder.lines[i]._id = lineId;
      });

      Object.assign(whOrder, $set);
      Object.assign(update, $set);

      // Check if the original line is still redirected
      if (whOrder.redirLines.length)
      {
        const rediredLineIds = new Set();

        whOrder.redirLines.forEach((lineId, i) =>
        {
          if (whOrder.lines[i]._id !== lineId)
          {
            rediredLineIds.add(lineId);
          }
        });

        if (rediredLineIds.size)
        {
          const rediredLines = await WhLine
            .find({_id: {$in: Array.from(rediredLineIds)}})
            .select({redirLine: 1})
            .lean()
            .session(session)
            .exec();
          const lineToRedir = new Map();

          rediredLines.forEach(line =>
          {
            if (line.redirLine)
            {
              lineToRedir.set(line._id, line.redirLine);
            }
          });

          whOrder.redirLines.forEach((origLineId, i) =>
          {
            if (lineToRedir.has(origLineId))
            {
              whOrder.redirLines[i] = lineToRedir.get(origLineId);
            }
          });

          if (whOrder.redirLines.every((lineId, i) => lineId === whOrder.lines[i]._id))
          {
            update.redirLine = null;
            update.redirLines = [];

            if (whOrder.lines.length === 1)
            {
              update.line = whOrder.lines[0]._id;
            }
          }
        }
      }
      // Check if the original line was redirected in the meantime
      else
      {
        const origLineIds = new Set();

        whOrder.lines.forEach(lineId =>
        {
          origLineIds.add(lineId);
        });

        if (origLineIds.size)
        {
          const rediredLines = await WhLine
            .find({_id: {$in: Array.from(origLineIds)}})
            .select({redirLine: 1})
            .lean()
            .session(session)
            .exec();
          const lineToRedir = new Map();

          rediredLines.forEach(line =>
          {
            if (line.redirLine)
            {
              lineToRedir.set(line._id, line.redirLine);
            }
          });

          if (lineToRedir.size)
          {
            update.redirLine = whOrder.line;
            update.redirLines = whOrder.lines.map(l => l._id);

            whOrder.lines.forEach(whOrderLine =>
            {
              if (lineToRedir.has(whOrderLine._id))
              {
                whOrderLine._id = lineToRedir.get(whOrderLine._id);
              }
            });

            if (whOrder.lines.length === 1)
            {
              update.line = whOrder.lines[0]._id;
            }

            update.lines = whOrder.lines;
          }
        }
      }
    }

    Object.assign(whOrder, update);
  }

  const results = [];

  const [deliveredOrders, eventsResults] = await Promise.all([
    WhDeliveredOrder
      .find({whOrder: {$in: whOrderIds}})
      .select({
        quantityTodo: 1,
        quantityDone: 1
      })
      .lean()
      .session(session)
      .exec(),
    WhEvent.record(event, session),
    whOrderOps.length ? WhOrder.collection.bulkWrite(whOrderOps, {session}) : null
  ]);

  results.push(eventsResults);

  const deliveredOrdersResults = {
    deleted: [],
    updated: []
  };
  const deliveredOrdersOps = [];

  if (finish)
  {
    deliveredOrders.forEach(deliveredOrder =>
    {
      if (deliveredOrder.qtyDone >= deliveredOrder.quantityTodo)
      {
        return;
      }

      deliveredOrder.quantityDone = deliveredOrder.quantityTodo;
      deliveredOrder.qtyRemaining = 0;
      deliveredOrder.status = 'done';

      deliveredOrdersResults.updated.push(deliveredOrder);
    });
  }
  else
  {
    deliveredOrders.forEach(deliveredOrder =>
    {
      deliveredOrdersResults.deleted.push({_id: deliveredOrder._id});
    });
  }

  if (deliveredOrdersResults.deleted.length)
  {
    deliveredOrdersOps.push({
      deleteMany: {
        filter: {_id: {$in: deliveredOrdersResults.deleted.map(o => o._id)}}
      }
    });
  }

  deliveredOrdersResults.updated.forEach(update =>
  {
    deliveredOrdersOps.push({
      updateOne: {
        filter: {_id: update._id},
        update: {$set: update}
      }
    });
  });

  if (finish && !deliveredOrdersOps.length)
  {
    return {response: {orders: whOrders}};
  }

  if (data.orders)
  {
    const [setCartsResults] = await Promise.all([
      finish ? null : WhSetCart.deleteByWhOrder(whOrders[0]),
      deliveredOrdersOps.length
        ? WhDeliveredOrder.collection.bulkWrite(deliveredOrdersOps, {session})
        : null
    ]);

    const [lineResults, setResults] = await Promise.all([
      WhLine.recountByWhOrder(whOrders[0], !finish, deliveredOrdersOps.length > 0),
      finish ? null : WhOrder.finalizeSet(date, set, setCartsResults, session)
    ]);

    results.push(
      setCartsResults,
      lineResults,
      setResults
    );
  }
  else
  {
    const [setCartsResults] = await Promise.all([
      finish ? null : WhSetCart.deleteBySet(data.date, data.set, session),
      deliveredOrdersOps.length
        ? WhDeliveredOrder.collection.bulkWrite(deliveredOrdersOps, {session})
        : null,
      WhPendingSetAssign.collection.deleteMany({date: data.date, set: data.set}, {session})
    ]);

    const lineResults = await WhLine.recountByWhOrder(whOrders[0], !finish, deliveredOrdersOps.length > 0);

    results.push(
      setCartsResults,
      lineResults
    );
  }

  await session.commitTransaction();

  const orders = whOrders.map(whOrder => whOrder.toJSON());

  if (!finish)
  {
    results.push({
      updated: orders,
      messages: [{
        topic: `${WhOrder.TOPIC_PREFIX}.updated`,
        message: {updated: orders}
      }]
    });
  }

  return {
    response: {orders},
    results
  };
};
