// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const {ObjectId} = require('mongoose').Types;

module.exports = async (app, module, {data, user, session}) =>
{
  const {
    OldWhOrder: WhOrder,
    OldWhEvent: WhEvent,
    OldWhDowntime: WhDowntime,
    OldWhUser: WhUser,
    OldWhPendingSetAssign: WhPendingSetAssign
  } = module;

  const {
    whUser,
    activeOrder,
    downtimeReason,
    downtimeComment,
    personnelId,
    pendingSetAssign
  } = data;

  if (!activeOrder.set)
  {
    throw app.createError('Invalid set.', 'STATE', 500);
  }

  const now = new Date();
  const minDowntimeDuration = (module.state.settings.minPickupDowntime || 120) * 1000;
  const maxDowntimeDuration = (module.state.settings.maxPickupDowntime || 480) * 60 * 1000;
  const downtimeDuration = whUser.lastPickupAt ? now.getTime() - whUser.lastPickupAt.getTime() : 0;
  const downtime = downtimeDuration > minDowntimeDuration && downtimeDuration < maxDowntimeDuration;

  if (downtime && !downtimeReason)
  {
    return {
      response: {
        result: 'pickDowntimeReason',
        startedAt: whUser.lastPickupAt,
        personnelId,
        user: whUser
      }
    };
  }

  const whOrders = await WhOrder
    .find({
      date: activeOrder.date,
      set: activeOrder.set
    })
    .sort({startTime: 1})
    .lean()
    .session(session)
    .exec();

  const event = {
    type: 'assignedToSet',
    user,
    time: now,
    data: {
      whUser: WhEvent.whUser(whUser),
      orders: WhEvent.orders(whOrders),
      lines: WhEvent.lines(whOrders[0]),
      downtime: null
    }
  };

  let downtimeId = null;

  if (downtimeReason)
  {
    downtimeId = new ObjectId();

    event.data.downtime = {
      id: downtimeId.toString(),
      reason: downtimeReason
    };
  }

  const whOrdersOps = [];
  const funcI = WhOrder.FUNCS_IDX[whUser.func];

  whOrders.forEach(whOrder =>
  {
    const $set = {};

    $set.users = whOrder.users = whOrder.users.concat([whUser._id]);

    const func = whOrder.funcs[funcI];

    $set[`funcs.${funcI}.user`] = func.user = event.data.whUser;
    $set[`funcs.${funcI}.startedAt`] = func.startedAt = now;

    if (func._id === 'platformer' || func._id === 'painter')
    {
      if (func.picklist === 'ignore')
      {
        $set[`funcs.${funcI}.finishedAt`] = func.finishedAt = now;
      }
      else if (func.status === 'pending')
      {
        $set[`funcs.${funcI}.status`] = func.status = 'pickup';
        $set[`funcs.${funcI}.picklist`] = func.picklist = 'require';
      }
    }
    else if (func.status === 'pending')
    {
      $set[`funcs.${funcI}.status`] = func.status = 'picklist';
    }

    whOrdersOps.push({
      updateOne: {
        filter: {_id: whOrder._id},
        update: {$set}
      }
    });
  });

  let pendingSetAssignOp = null;

  if (pendingSetAssign)
  {
    pendingSetAssign[whUser.func] = true;

    if (WhOrder.FUNCS.every(f => pendingSetAssign[f] === true))
    {
      pendingSetAssignOp = WhPendingSetAssign.collection.deleteOne({_id: pendingSetAssign._id}, {session});
    }
    else
    {
      pendingSetAssignOp = WhPendingSetAssign.collection.updateOne(
        {_id: pendingSetAssign._id},
        {$set: {[whUser.func]: true}},
        {session}
      );
    }
  }

  const [eventsResults, downtimeResults] = await Promise.all([
    WhEvent.record(event, session),
    WhDowntime.createDowntime({
      _id: downtimeId,
      reason: downtimeReason,
      startedAt: whUser.lastPickupAt,
      user: event.data.whUser,
      comment: downtimeComment,
      session
    }),
    WhUser.collection.updateOne({_id: whUser._id}, {$set: {lastPickupAt: now}}, {session}),
    WhOrder.collection.bulkWrite(whOrdersOps, {session}),
    pendingSetAssignOp
  ]);

  await session.commitTransaction();

  if (whUser.func === 'painter')
  {
    setImmediate(tryPrintPsPicklist, whOrders, 1);
  }

  return {
    response: {
      result: 'assignedToSet',
      orders: whOrders,
      user: whUser
    },
    results: [
      eventsResults,
      downtimeResults
    ],
    messages: [{
      topic: `${WhOrder.TOPIC_PREFIX}.updated`,
      message: {updated: whOrders}
    }]
  };

  async function tryPrintPsPicklist(whOrders, retryCount)
  {
    try
    {
      await module.state.printPsPicklist(whOrders);
    }
    catch (err)
    {
      if (retryCount < 3 && err.code && err.code.includes('FAILURE'))
      {
        return setTimeout(tryPrintPsPicklist, 1000 * retryCount, whOrders, retryCount + 1);
      }

      module.error(err, `Failed to print PS picklist after set assignment.`);
    }
  }
};
