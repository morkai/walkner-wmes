// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const continueSet = require('./continueSet');
const assignSet = require('./assignSet');
const startNewSet = require('./startNewSet');

module.exports = async (app, module, {data, user, whUser, session}) =>
{
  const {
    OldWhLine: WhLine,
    OldWhOrder: WhOrder,
    OldWhPendingSetAssign: WhPendingSetAssign
  } = module;

  const {
    date,
    downtimeReason,
    downtimeComment,
    personnelId,
    forceLine,
    redirLine,
    forceDelivery
  } = data;

  const funcIndex = WhOrder.FUNCS_IDX[whUser.func];

  if (funcIndex == null)
  {
    throw app.createError('Invalid function.', 'INVALID_FUNC', 400);
  }

  const assignedOrder = await WhOrder
    .findOne({
      status: {$in: ['started', 'problem']},
      [`funcs.${funcIndex}.user.id`]: whUser._id,
      [`funcs.${funcIndex}.status`]: {$nin: ['problem', 'finished']}
    })
    .sort({startedAt: 1})
    .hint({status: 1, 'funcs.user.id': 1})
    .lean()
    .session(session)
    .exec();

  if (assignedOrder)
  {
    if (forceLine)
    {
      throw app.createError('Cannot force a new set for line: already assigned.', 'FORCE_SET_ASSIGNED', 400, {
        forceLine,
        assignedOrder,
        whUser
      });
    }

    return await continueSet(app, module, {
      data: {assignedOrder, whUser},
      user,
      session
    });
  }

  if (!forceLine)
  {
    const [activeOrder, pendingSetAssign] = await findActiveOrder();

    if (activeOrder)
    {
      return await assignSet(app, module, {
        data: {
          activeOrder,
          whUser,
          downtimeReason,
          downtimeComment,
          personnelId,
          pendingSetAssign
        },
        user,
        session
      });
    }
  }

  return await startNewSet(app, module, {
    data: {
      date,
      whUser,
      downtimeReason,
      downtimeComment,
      personnelId,
      forceLine,
      redirLine,
      forceDelivery
    },
    user,
    session
  });

  async function findActiveOrder()
  {
    const pendingSetAssigns = await WhPendingSetAssign
      .find({[whUser.func]: false})
      .sort({_id: 1})
      .lean()
      .session(session)
      .exec();

    if (whUser.func === 'painter')
    {
      return await findActiveOrderForPainter(pendingSetAssigns);
    }

    if (whUser.func === 'platformer')
    {
      return await findActiveOrderForPlatformer(pendingSetAssigns);
    }

    return await findActiveOrderForOthers(pendingSetAssigns);
  }

  async function findActiveOrderForOthers(pendingSetAssigns)
  {
    const conditions = {
      status: {$in: ['started', 'problem']},
      [`funcs.${funcIndex}.user`]: {$type: 'null'},
      picklistDone: {$ne: 'failure'}
    };

    if (pendingSetAssigns.length)
    {
      const whOrders = await WhOrder
        .find({
          ...conditions,
          $or: pendingSetAssigns.map(p =>
          {
            return {
              set: p.set,
              date: p.date
            };
          })
        })
        .select({_id: 0, date: 1, set: 1})
        .lean()
        .session(session)
        .exec();

      const sets = new Map();

      whOrders.forEach(whOrder =>
      {
        sets.set(`${whOrder.set}:${whOrder.date.getTime()}`, whOrder);
      });

      for (let i = 0; i < pendingSetAssigns.length; ++i)
      {
        const pendingSetAssign = pendingSetAssigns[i];
        const set = sets.get(`${pendingSetAssign.set}:${pendingSetAssign.date.getTime()}`);

        if (set)
        {
          return [set, pendingSetAssign];
        }
      }
    }

    const whOrders = await WhOrder
      .find(conditions)
      .select({_id: 0, date: 1, set: 1})
      .sort({startedAt: 1})
      .limit(1)
      .lean()
      .session(session)
      .exec();

    return [whOrders.length ? whOrders[0] : null, null];
  }

  async function findActiveOrderForPlatformer(pendingSetAssigns)
  {
    const availableLines = await WhOrder
      .aggregate([
        {$match: {
          status: {$in: ['started', 'problem']},
          [`funcs.${funcIndex}.user`]: {$type: 'null'},
          picklistDone: {$ne: 'failure'},
          [`funcs.${WhOrder.FUNCS_IDX.fmx}.pickup`]: 'success',
          [`funcs.${WhOrder.FUNCS_IDX.kitter}.status`]: 'finished'
        }},
        {$unwind: '$lines'},
        {$group: {
          _id: '$lines._id',
          sets: {$addToSet: {
            date: '$date',
            set: '$set',
            startedAt: '$startedAt'
          }}
        }}
      ])
      .exec();

    if (!availableLines.length)
    {
      return [null, null];
    }

    if (pendingSetAssigns.length)
    {
      const sets = new Map();

      availableLines.forEach(availableLine =>
      {
        availableLine.sets.forEach(set =>
        {
          sets.set(`${set.set}:${set.date.getTime()}`, set);
        });
      });

      for (let i = 0; i < pendingSetAssigns.length; ++i)
      {
        const pendingSetAssign = pendingSetAssigns[i];
        const set = sets.get(`${pendingSetAssign.set}:${pendingSetAssign.date.getTime()}`);

        if (set)
        {
          return [set, pendingSetAssign];
        }
      }
    }

    const lines = await WhLine
      .find({_id: {$in: availableLines.map(l => l._id)}})
      .select({_id: 1})
      .sort({'available.time': 1})
      .limit(1)
      .lean()
      .exec();

    if (!lines.length)
    {
      return [null, null];
    }

    const {sets} = availableLines.find(l => l._id === lines[0]._id);

    sets.sort((a, b) => a.startedAt - b.startedAt);

    return [sets[0], null];
  }

  async function findActiveOrderForPainter(pendingSetAssigns)
  {
    const {psPickupStatus, psPickupReadyFuncs} = module.state.settings;

    const $project = {
      _id: 0,
      date: 1,
      set: 1,
      psStatus: 1,
      picklistDone: 1,
      startedAt: 1
    };
    const $and = [
      {$in: ['$psStatus', Array.isArray(psPickupStatus) ? psPickupStatus : []]}
    ];

    if (Array.isArray(psPickupReadyFuncs))
    {
      psPickupReadyFuncs.forEach(funcId =>
      {
        const funcI = WhOrder.FUNCS_IDX[funcId];

        if (typeof funcI === 'number')
        {
          $project[funcId] = {
            $arrayElemAt: ['$funcs', funcI]
          };

          $and.push({
            $eq: [`$${funcId}.status`, 'finished']
          });
        }
      });
    }

    const pipeline = [
      {$match: {
        status: {$in: ['started', 'problem']},
        [`funcs.${WhOrder.FUNCS_IDX.painter}.user`]: {$type: 'null'},
        picklistDone: {$ne: 'failure'},
        psStatus: {$ne: 'unknown'}
      }},
      {$project},
      {$group: {
        _id: {
          date: '$date',
          set: '$set'
        },
        startedAt: {$min: '$startedAt'},
        all: {$sum: 1},
        ready: {$sum: {$cond: {
          if: {$and},
          then: 1,
          else: 0
        }}},
        picklistDone: {$sum: {$cond: {
          if: {$eq: ['$picklistDone', 'success']},
          then: 1,
          else: 0
        }}}
      }},
      {$match: {
        $and: [
          {$expr: {$eq: ['$picklistDone', '$all']}},
          {$expr: {$eq: ['$ready', '$all']}}
        ]
      }}
    ];

    if (!pendingSetAssigns.length)
    {
      pipeline.push(
        {$sort: {startedAt: 1}},
        {$limit: 1}
      );
    }

    pipeline.push({$project: {
      _id: 0,
      date: '$_id.date',
      set: '$_id.set',
      startedAt: '$startedAt'
    }});

    const whOrders = await WhOrder
      .aggregate(pipeline)
      .session(session)
      .exec();

    if (pendingSetAssigns.length)
    {
      const sets = new Map();

      whOrders.forEach(whOrder =>
      {
        sets.set(`${whOrder.set}:${whOrder.date.getTime()}`, whOrder);
      });

      for (let i = 0; i < pendingSetAssigns.length; ++i)
      {
        const pendingSetAssign = pendingSetAssigns[i];
        const set = sets.get(`${pendingSetAssign.set}:${pendingSetAssign.date.getTime()}`);

        if (set)
        {
          return [set, pendingSetAssign];
        }
      }

      whOrders.sort((a, b) => a.startedAt - b.startedAt);
    }

    return [whOrders.length ? whOrders[0] : null, null];
  }
};
