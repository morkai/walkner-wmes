// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const continueSet = require('./continueSet');
const assignSet = require('./assignSet');
const startNewSet = require('./startNewSet');

module.exports = async (app, module, {data, user, whUser, session}) =>
{
  const {
    OldWhOrder: WhOrder
  } = module;

  const {
    date,
    downtimeReason,
    downtimeComment,
    personnelId,
    forceLine
  } = data;

  const funcIndex = WhOrder.FUNCS_IDX[whUser.func];

  if (funcIndex == null)
  {
    throw app.createError('Invalid function.', 'INVALID_FUNC', 400);
  }

  const findAssignedOrder = WhOrder
    .findOne({
      status: 'started',
      [`funcs.${funcIndex}.user.id`]: whUser._id,
      [`funcs.${funcIndex}.status`]: {$nin: ['problem', 'finished']}
    })
    .sort({group: 1, line: 1, startTime: 1})
    .hint({status: 1, 'funcs.user.id': 1})
    .lean()
    .session(session)
    .exec();

  let findActiveOrder = null;

  if (!forceLine)
  {
    if (whUser.func === 'painter')
    {
      findActiveOrder = WhOrder
        .aggregate([
          {$match: {
            status: 'started',
            [`funcs.${WhOrder.FUNCS_IDX.painter}.user`]: {$type: 'null'},
            psStatus: {$ne: 'unknown'}
          }},
          {$project: {
            _id: 0,
            date: 1,
            set: 1,
            psStatus: 1,
            fmx: {$arrayElemAt: ['$funcs', 0]},
            kitter: {$arrayElemAt: ['$funcs', 1]},
            platformer: {$arrayElemAt: ['$funcs', 2]},
            packer: {$arrayElemAt: ['$funcs', 3]}
          }},
          {$group: {
            _id: {
              date: '$date',
              set: '$set'
            },
            minStartTime: {$min: '$startTime'},
            all: {$sum: 1},
            ready: {$sum: {$cond: {
              if: {
                $and: [
                  {$in: ['$psStatus', module.state.settings.psPickupStatus || []]},
                  {$eq: [`$fmx.status`, 'finished']},
                  {$eq: [`$kitter.status`, 'finished']},
                  {$eq: [`$platformer.status`, 'finished']},
                  {$eq: [`$packer.status`, 'finished']}
                ]
              },
              then: 1,
              else: 0
            }}}
          }},
          {$match: {$expr: {$eq: ['$ready', '$all']}}},
          {$sort: {minStartTime: 1}},
          {$limit: 1},
          {$project: {
            _id: 0,
            date: '$_id.date',
            set: '$_id.set'
          }}
        ])
        .hint({status: 1, date: -1})
        .session(session)
        .exec();
    }
    else
    {
      const activeOrderConditions = {
        status: 'started',
        [`funcs.${funcIndex}.user`]: {$type: 'null'}
      };

      if (whUser.func === 'platformer')
      {
        activeOrderConditions[`funcs.${WhOrder.FUNCS_IDX.fmx}.pickup`] = 'success';
        activeOrderConditions[`funcs.${WhOrder.FUNCS_IDX.kitter}.status`] = 'finished';
      }
      else if (whUser.func === 'packer')
      {
        activeOrderConditions.picklistDone = 'success';
      }

      findActiveOrder = WhOrder
        .find(activeOrderConditions)
        .select({_id: 0, date: 1, set: 1})
        .sort({group: 1, line: 1, startTime: 1})
        .limit(1)
        .hint({status: 1, 'funcs.user.id': 1})
        .lean()
        .session(session)
        .exec();
    }
  }

  const [assignedOrder, activeOrder] = await Promise.all([findAssignedOrder, findActiveOrder]);

  if (assignedOrder)
  {
    if (forceLine)
    {
      throw app.createError('Cannot force a new set for line: already assigned.', 'FORCE_SET_ASSIGNED', 400, {
        forceLine,
        assignedOrder,
        whUser
      });
    }

    return await continueSet(app, module, {
      data: {assignedOrder, whUser},
      user,
      session
    });
  }

  if (activeOrder.length)
  {
    return await assignSet(app, module, {
      data: {
        activeOrder: activeOrder[0],
        whUser,
        downtimeReason,
        downtimeComment,
        personnelId
      },
      user,
      session
    });
  }

  return await startNewSet(app, module, {
    data: {
      date,
      whUser,
      downtimeReason,
      downtimeComment,
      personnelId,
      forceLine
    },
    user,
    session
  });
};
