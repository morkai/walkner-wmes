// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const continueSet = require('./continueSet');
const assignSet = require('./assignSet');
const startNewSet = require('./startNewSet');

module.exports = async (app, module, {data, user, whUser, session}) =>
{
  const {
    OldWhOrder: WhOrder
  } = module;

  const {
    date,
    downtimeReason,
    downtimeComment,
    personnelId,
    forceLine
  } = data;

  const funcIndex = WhOrder.FUNCS_IDX[whUser.func];

  if (funcIndex == null)
  {
    throw app.createError('Invalid function.', 'INVALID_FUNC', 400);
  }

  const findAssignedOrder = WhOrder
    .findOne({
      status: 'started',
      [`funcs.${funcIndex}.user.id`]: whUser._id,
      [`funcs.${funcIndex}.status`]: {$nin: ['problem', 'finished']}
    })
    .sort({group: 1, line: 1, startTime: 1})
    .hint({status: 1, 'funcs.user.id': 1})
    .lean()
    .session(session)
    .exec();

  let findActiveOrder = null;

  if (!forceLine)
  {
    if (whUser.func === 'painter')
    {
      const {psPickupStatus, psPickupReadyFuncs} = module.state.settings;

      const $project = {
        _id: 0,
        date: 1,
        set: 1,
        psStatus: 1,
        picklistDone: 1,
        startedAt: 1
      };
      const $and = [
        {$in: ['$psStatus', Array.isArray(psPickupStatus) ? psPickupStatus : []]}
      ];

      if (Array.isArray(psPickupReadyFuncs))
      {
        psPickupReadyFuncs.forEach(funcId =>
        {
          const funcI = WhOrder.FUNCS_IDX[funcId];

          if (typeof funcI === 'number')
          {
            $project[funcId] = {
              $arrayElemAt: ['$funcs', funcI]
            };

            $and.push({
              $eq: [`$${funcId}.status`, 'finished']
            });
          }
        });
      }

      const pipeline = [
        {$match: {
          status: 'started',
          [`funcs.${WhOrder.FUNCS_IDX.painter}.user`]: {$type: 'null'},
          psStatus: {$ne: 'unknown'}
        }},
        {$project},
        {$group: {
          _id: {
            date: '$date',
            set: '$set'
          },
          startedAt: {$min: '$startedAt'},
          all: {$sum: 1},
          ready: {$sum: {$cond: {
            if: {$and},
            then: 1,
            else: 0
          }}},
          picklistDone: {$sum: {$cond: {
            if: {$eq: ['$picklistDone', 'success']},
            then: 1,
            else: 0
          }}}
        }},
        {$match: {
          picklistDone: {$gt: 0},
          $expr: {$eq: ['$ready', '$all']}
        }},
        {$sort: {startedAt: 1}},
        {$limit: 1},
        {$project: {
          _id: 0,
          date: '$_id.date',
          set: '$_id.set'
        }}
      ];

      findActiveOrder = WhOrder
        .aggregate(pipeline)
        .hint({status: 1, date: -1})
        .session(session)
        .exec();
    }
    else
    {
      const activeOrderConditions = {
        status: 'started',
        [`funcs.${funcIndex}.user`]: {$type: 'null'}
      };

      if (whUser.func === 'platformer')
      {
        activeOrderConditions[`funcs.${WhOrder.FUNCS_IDX.fmx}.pickup`] = 'success';
        activeOrderConditions[`funcs.${WhOrder.FUNCS_IDX.kitter}.status`] = 'finished';
      }
      else if (whUser.func === 'packer')
      {
        activeOrderConditions.picklistDone = 'success';
      }

      findActiveOrder = WhOrder
        .find(activeOrderConditions)
        .select({_id: 0, date: 1, set: 1})
        .sort({startedAt: 1})
        .limit(1)
        .hint({status: 1, 'funcs.user.id': 1})
        .lean()
        .session(session)
        .exec();
    }
  }

  const [assignedOrder, activeOrder] = await Promise.all([findAssignedOrder, findActiveOrder]);

  if (assignedOrder)
  {
    if (forceLine)
    {
      throw app.createError('Cannot force a new set for line: already assigned.', 'FORCE_SET_ASSIGNED', 400, {
        forceLine,
        assignedOrder,
        whUser
      });
    }

    return await continueSet(app, module, {
      data: {assignedOrder, whUser},
      user,
      session
    });
  }

  if (activeOrder.length)
  {
    return await assignSet(app, module, {
      data: {
        activeOrder: activeOrder[0],
        whUser,
        downtimeReason,
        downtimeComment,
        personnelId
      },
      user,
      session
    });
  }

  return await startNewSet(app, module, {
    data: {
      date,
      whUser,
      downtimeReason,
      downtimeComment,
      personnelId,
      forceLine
    },
    user,
    session
  });
};
