// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const continueSet = require('./continueSet');
const assignSet = require('./assignSet');
const startNewSet = require('./startNewSet');

module.exports = async (app, module, {data, user, whUser, session}) =>
{
  const {
    OldWhLine: WhLine,
    OldWhOrder: WhOrder
  } = module;

  const {
    date,
    downtimeReason,
    downtimeComment,
    personnelId,
    forceLine
  } = data;

  const funcIndex = WhOrder.FUNCS_IDX[whUser.func];

  if (funcIndex == null)
  {
    throw app.createError('Invalid function.', 'INVALID_FUNC', 400);
  }

  const assignedOrder = await WhOrder
    .findOne({
      status: {$in: ['started', 'problem']},
      [`funcs.${funcIndex}.user.id`]: whUser._id,
      [`funcs.${funcIndex}.status`]: {$nin: ['problem', 'finished']}
    })
    .sort({startedAt: 1})
    .hint({status: 1, 'funcs.user.id': 1})
    .lean()
    .session(session)
    .exec();

  if (assignedOrder)
  {
    if (forceLine)
    {
      throw app.createError('Cannot force a new set for line: already assigned.', 'FORCE_SET_ASSIGNED', 400, {
        forceLine,
        assignedOrder,
        whUser
      });
    }

    return await continueSet(app, module, {
      data: {assignedOrder, whUser},
      user,
      session
    });
  }

  if (!forceLine)
  {
    const activeOrder = await findActiveOrder();

    if (activeOrder)
    {
      return await assignSet(app, module, {
        data: {
          activeOrder,
          whUser,
          downtimeReason,
          downtimeComment,
          personnelId
        },
        user,
        session
      });
    }
  }

  return await startNewSet(app, module, {
    data: {
      date,
      whUser,
      downtimeReason,
      downtimeComment,
      personnelId,
      forceLine
    },
    user,
    session
  });

  async function findActiveOrder()
  {
    if (whUser.func === 'painter')
    {
      return await findActiveOrderForPainter();
    }

    if (whUser.func === 'platformer')
    {
      return await findActiveOrderForPlatformer();
    }

    const whOrders = await WhOrder
      .find({
        status: {$in: ['started', 'problem']},
        [`funcs.${funcIndex}.user`]: {$type: 'null'},
        picklistDone: {$ne: 'failure'}
      })
      .select({_id: 0, date: 1, set: 1})
      .sort({startedAt: 1})
      .limit(1)
      .hint({status: 1, 'funcs.user.id': 1})
      .lean()
      .session(session)
      .exec();

    return whOrders.length ? whOrders[0] : null;
  }

  async function findActiveOrderForPlatformer()
  {
    const availableLines = await WhOrder
      .aggregate([
        {$match: {
          status: {$in: ['started', 'problem']},
          [`funcs.${funcIndex}.user`]: {$type: 'null'},
          picklistDone: {$ne: 'failure'},
          [`funcs.${WhOrder.FUNCS_IDX.fmx}.pickup`]: 'success',
          [`funcs.${WhOrder.FUNCS_IDX.kitter}.status`]: 'finished'
        }},
        {$unwind: '$lines'},
        {$group: {
          _id: '$lines._id',
          sets: {$push: {
            date: '$date',
            set: '$set',
            startedAt: '$startedAt'
          }}
        }}
      ])
      .hint({status: 1, 'funcs.user.id': 1})
      .exec();

    if (!availableLines.length)
    {
      return null;
    }

    const lines = await WhLine
      .find({_id: {$in: availableLines.map(l => l._id)}})
      .select({_id: 1})
      .sort({'available.time': 1})
      .limit(1)
      .lean()
      .exec();

    if (!lines.length)
    {
      return null;
    }

    const {sets} = availableLines.find(l => l._id === lines[0]._id);

    sets.sort((a, b) => a.startedAt - b.startedAt);

    return sets[0];
  }

  async function findActiveOrderForPainter()
  {
    const {psPickupStatus, psPickupReadyFuncs} = module.state.settings;

    const $project = {
      _id: 0,
      date: 1,
      set: 1,
      psStatus: 1,
      picklistDone: 1,
      startedAt: 1
    };
    const $and = [
      {$in: ['$psStatus', Array.isArray(psPickupStatus) ? psPickupStatus : []]}
    ];

    if (Array.isArray(psPickupReadyFuncs))
    {
      psPickupReadyFuncs.forEach(funcId =>
      {
        const funcI = WhOrder.FUNCS_IDX[funcId];

        if (typeof funcI === 'number')
        {
          $project[funcId] = {
            $arrayElemAt: ['$funcs', funcI]
          };

          $and.push({
            $eq: [`$${funcId}.status`, 'finished']
          });
        }
      });
    }

    const pipeline = [
      {$match: {
        status: {$in: ['started', 'problem']},
        [`funcs.${WhOrder.FUNCS_IDX.painter}.user`]: {$type: 'null'},
        picklistDone: {$ne: 'failure'},
        psStatus: {$ne: 'unknown'}
      }},
      {$project},
      {$group: {
        _id: {
          date: '$date',
          set: '$set'
        },
        startedAt: {$min: '$startTime'},
        all: {$sum: 1},
        ready: {$sum: {$cond: {
          if: {$and},
          then: 1,
          else: 0
        }}},
        picklistDone: {$sum: {$cond: {
          if: {$eq: ['$picklistDone', 'success']},
          then: 1,
          else: 0
        }}}
      }},
      {$match: {
        picklistDone: {$gt: 0},
        $expr: {$eq: ['$ready', '$all']}
      }},
      {$sort: {startedAt: 1}},
      {$limit: 1},
      {$project: {
        _id: 0,
        date: '$_id.date',
        set: '$_id.set'
      }}
    ];

    const whOrders = await WhOrder
      .aggregate(pipeline)
      .hint({status: 1, date: -1})
      .session(session)
      .exec();

    return whOrders.length ? whOrders[0] : null;
  }
};
