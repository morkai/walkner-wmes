// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

exports.session = true;

exports.execute = async (app, module, {data, user, session}) =>
{
  const {
    OldWhOrder: WhOrder,
    OldWhEvent: WhEvent,
    OldWhSetCart: WhSetCart,
    OldWhLine: WhLine
  } = module;

  const whOrder = await WhOrder
    .findById(data.whOrderId)
    .session(session)
    .exec();

  if (!whOrder)
  {
    throw app.createError(`Order not found.`, 'ORDER_NOT_FOUND', 400);
  }

  const now = new Date();
  const newValue = data.newValue;
  const oldValue = whOrder.picklistDone;
  const oldStatus = whOrder.status;
  const problem = newValue === 'failure';
  const success = newValue === 'success';

  whOrder.picklistDone = newValue;
  whOrder.distStatus = 'pending';
  whOrder.fifoStatus = 'pending';
  whOrder.packStatus = 'pending';
  whOrder.psDistStatus = 'pending';
  whOrder.setDistStarted = false;

  if (problem)
  {
    whOrder.status = 'problem';
    whOrder.problem = data.comment || '';
    whOrder.problemAt = now;
    whOrder.users = [];
  }
  else
  {
    whOrder.status = 'started';
    whOrder.problem = '';
    whOrder.problemAt = null;
  }

  let picklistFunc = null;

  whOrder.funcs.forEach(func =>
  {
    if (whOrder.picklistFunc === func._id)
    {
      picklistFunc = func;
    }

    if (success)
    {
      if (picklistFunc === func)
      {
        func.status = 'picklist';
        func.startedAt = now;
      }
      else if (func.user)
      {
        func.status = 'picklist';
      }
    }
    else if (!problem && picklistFunc === func)
    {
      func.status = 'picklist';
    }
    else
    {
      func.status = 'pending';
      func.startedAt = null;
    }

    if (problem)
    {
      func.user = null;
      func.startedAt = null;
    }

    func.finishedAt = null;
    func.picklist = 'pending';
    func.pickup = 'pending';
    func.carts = [];
    func.problemArea = '';
  });

  if (success)
  {
    const painter = whOrder.funcs[WhOrder.FUNCS_IDX.painter];

    if (whOrder.psStatus === 'unknown')
    {
      whOrder.psDistStatus = 'ignored';
      painter.status = 'finished';
      painter.picklist = 'ignore';
      painter.pickup = 'ignore';
    }
    else
    {
      painter.status = 'pickup';
      painter.picklist = 'require';
    }
  }

  const event = {
    type: 'picklistDone',
    user,
    time: new Date(),
    data: {
      func: picklistFunc && picklistFunc._id || null,
      oldValue,
      newValue,
      whUser: picklistFunc && picklistFunc.user || null,
      orders: WhEvent.orders([whOrder]),
      lines: WhEvent.lines(whOrder)
    }
  };

  const [setCartsResults, eventsResults] = await Promise.all([
    WhSetCart.deleteByWhOrder(whOrder),
    WhEvent.record(event, session),
    problem ? null : whOrder.save()
  ]);

  if (problem)
  {
    whOrder.set = null;

    await whOrder.save();
  }

  const [lineResults, setResults] = await Promise.all([
    whOrder.status !== oldStatus ? WhLine.recountByWhOrder(whOrder, true, false) : null,
    whOrder.finalizeSet(setCartsResults)
  ]);

  await session.commitTransaction();

  const leanWhOrder = whOrder.toJSON();

  if (app[module.config.ordersId] && whOrder.problem)
  {
    setImmediate(() =>
    {
      const data = {
        source: 'wh',
        comment: whOrder.problem
      };
      const userInfo = {
        ...user,
        ...(picklistFunc && picklistFunc.user || {})
      };

      app[module.config.ordersId].editOrder(whOrder.order, data, userInfo, err =>
      {
        if (err)
        {
          module.error(err, 'Failed to record order comment.');
        }
      });
    });
  }

  const messages = [{
    topic: `${WhOrder.TOPIC_PREFIX}.updated`,
    message: {updated: [leanWhOrder]}
  }];

  whOrder.checkProblemChange(oldStatus, messages);

  return {
    response: {
      order: leanWhOrder
    },
    results: [
      setCartsResults,
      eventsResults,
      lineResults,
      setResults
    ],
    messages
  };
};
