// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const moment = require('moment');
const {ObjectId} = require('mongoose').Types;
const shifts = require('util/shifts');
const resolveUser = require('./resolveUser');

exports.session = true;

exports.execute = async (app, module, {data, user, whUser, session}) =>
{
  const {
    Plan,
    OldWhEvent: WhEvent,
    OldWhOrder: WhOrder,
    OldWhSetCart: WhSetCart,
    OldWhLine: WhLine,
    OldWhDeliveredOrder: WhDeliveredOrder
  } = module;

  const {
    kind,
    forceLine,
    personnelId
  } = data;

  if (!WhSetCart.KINDS.includes(kind))
  {
    throw app.createError('Invalid kind.', 'INPUT', 400);
  }

  if (!whUser)
  {
    whUser = await resolveUser(app, module, {data, session});
  }

  const localDate = new Date();
  const utcTime = moment(localDate).utc(true).valueOf();
  const fifoDelivery = kind === 'components';
  const minTimeForDelivery = (module.state.settings.minTimeForDelivery || 45) * 60 * 1000;
  const maxDeliveryStartTime = (module.state.settings.maxDeliveryStartTime || 60) * 60 * 1000;
  const maxSetCartsPerDelivery = fifoDelivery ? (module.state.settings.maxSetCartsPerDelivery || 3) : 999;

  const setCartsToDeliver = [];

  const results = {
    deliveredOrders: {
      added: [],
      updated: [],
      messages: []
    },
    lines: {
      updated: [],
      messages: []
    },
    orders: {
      updated: [],
      messages: []
    },
    setCarts: {
      updated: [],
      messages: []
    }
  };
  const event = {
    type: 'deliveryStarted',
    time: localDate,
    user,
    data: {
      kind,
      whUser: WhEvent.whUser(whUser),
      orders: [],
      lines: new Set(),
      setCarts: null
    }
  };
  const problemLineOrders = new Set();

  await fillPendingSetCarts();

  // Fill set carts to deliver only if:
  // it is FIFO delivery and there is still space for carts
  // or it is not FIFO delivery and there were no pending carts
  if ((fifoDelivery && setCartsToDeliver.length < maxSetCartsPerDelivery)
    || (!fifoDelivery && setCartsToDeliver.length === 0))
  {
    await fillRemainingSetCarts();
  }

  if (!setCartsToDeliver.length)
  {
    return {
      response: {
        result: 'nothingToDeliver'
      }
    };
  }

  await unblockDeliveredOrders();

  // Create operations
  const ops = {
    deliveredOrders: [],
    lines: [],
    setCarts: [],
    orders: []
  };

  results.deliveredOrders.added.forEach(document =>
  {
    ops.deliveredOrders.push({
      insertOne: {document}
    });
  });

  results.deliveredOrders.updated.forEach(update =>
  {
    ops.deliveredOrders.push({
      updateOne: {
        filter: {_id: update._id},
        update: {$set: update}
      }
    });
  });

  results.lines.updated.forEach(update =>
  {
    ops.lines.push({
      updateOne: {
        filter: {_id: update._id},
        update: {$set: update}
      }
    });
  });

  if (results.setCarts.updated.length)
  {
    const $set = {...results.setCarts.updated[0]};

    delete $set._id;

    ops.setCarts.push({
      updateMany: {
        filter: {_id: {$in: results.setCarts.updated.map(u => u._id)}},
        update: {$set}
      }
    });
  }

  const distStatusProp = WhOrder.DIST_STATUS_PROPS[kind];

  ops.orders.push({
    updateMany: {
      filter: {_id: {$in: []}},
      update: {$set: {
        distStatus: 'started',
        [distStatusProp]: 'started'
      }}
    }
  });

  setCartsToDeliver.sort((a, b) =>
  {
    let cmp = a.line.localeCompare(b.line, undefined, {numeric: true, ignorePunctuation: true});

    if (!cmp)
    {
      cmp = a.startTime - b.startTime;
    }

    return cmp;
  });

  event.data.setCarts = WhEvent.setCarts({remaining: setCartsToDeliver});

  const deliveringBy = {id: whUser._id, label: whUser.label};
  const whOrderIds = new Set();

  setCartsToDeliver.forEach(setCart =>
  {
    setCart.deliveringBy = deliveringBy;

    const update = {
      status: 'delivering',
      pending: false,
      deliveringBy,
      deliveringAt: localDate,
      users: WhSetCart.collectUsers(setCart)
    };

    Object.assign(setCart, update);

    results.setCarts.updated.push(setCart);

    ops.setCarts.push({
      updateOne: {
        filter: {_id: setCart._id},
        update: {$set: update}
      }
    });

    WhEvent.lines(setCart, event.data.lines);

    setCart.orders.forEach(whSetCartOrder =>
    {
      const whOrderId = whSetCartOrder.whOrder;

      if (whOrderIds.has(whOrderId))
      {
        return;
      }

      whOrderIds.add(whOrderId);

      event.data.orders.push({
        whOrder: whOrderId,
        sapOrder: whSetCartOrder.sapOrder,
        date: setCart.date,
        set: setCart.set
      });

      ops.orders[0].updateMany.filter._id.$in.push(whOrderId);

      results.orders.updated.push({
        _id: whOrderId,
        ...ops.orders[0].updateMany.update.$set
      });
    });
  });

  // Write operations
  const [eventsResult] = await Promise.all([
    WhEvent.record(event, session),
    ops.deliveredOrders.length ? WhDeliveredOrder.collection.bulkWrite(ops.deliveredOrders, {session}) : null,
    ops.lines.length ? WhLine.collection.bulkWrite(ops.lines, {session}) : null,
    ops.orders.length ? WhOrder.collection.bulkWrite(ops.orders, {session}) : null,
    ops.setCarts.length ? WhSetCart.collection.bulkWrite(ops.setCarts, {session}) : null
  ]);

  // Create messages
  results.deliveredOrders.messages.push({
    topic: `${WhDeliveredOrder.TOPIC_PREFIX}.updated`,
    message: {
      added: results.deliveredOrders.added,
      updated: results.deliveredOrders.updated
    }
  });

  results.lines.messages.push({
    topic: `${WhLine.TOPIC_PREFIX}.updated`,
    message: {
      updated: results.lines.updated
    }
  });

  results.orders.messages.push({
    topic: `${WhOrder.TOPIC_PREFIX}.updated`,
    message: {
      updated: results.orders.updated
    }
  });

  results.setCarts.messages.push({
    topic: `${WhSetCart.TOPIC_PREFIX}.updated`,
    message: {
      updated: results.setCarts.updated
    }
  });

  await session.commitTransaction();

  return {
    response: {
      result: 'deliveryStarted',
      setCarts: setCartsToDeliver,
      user: whUser,
      personnelId
    },
    results: [
      eventsResult,
      ...Object.values(results)
    ]
  };

  function resolveSetId(setCart)
  {
    return `${setCart.date.getTime()}:${setCart.set}`;
  }

  async function fillPendingSetCarts()
  {
    const conditions = {
      status: 'completed',
      pending: true,
      kind
    };

    if (forceLine)
    {
      conditions.lines = forceLine;
    }

    const allPendingSetCarts = await WhSetCart
      .find(conditions)
      .sort({startTime: 1})
      .hint({status: 1, date: -1})
      .lean()
      .session(session)
      .exec();

    const setToCarts = new Map();

    allPendingSetCarts.forEach(setCart =>
    {
      const setId = resolveSetId(setCart);

      if (!setToCarts.has(setId))
      {
        setToCarts.set(setId, []);
      }

      setToCarts.get(setId).push(setCart);
    });

    const groupedPendingSetCarts = Array.from(setToCarts.values());

    while (groupedPendingSetCarts.length > 0)
    {
      const pendingSetCarts = groupedPendingSetCarts.shift();

      // Do not include FIFO carts from other sets if they don't fit fully
      if (fifoDelivery
        && setCartsToDeliver.length > 0
        && (setCartsToDeliver.length + pendingSetCarts.length) > maxSetCartsPerDelivery)
      {
        continue;
      }

      while (pendingSetCarts.length > 0 && setCartsToDeliver.length < maxSetCartsPerDelivery)
      {
        const pendingSetCart = pendingSetCarts.shift();

        setCartsToDeliver.push(pendingSetCart);
      }

      if (!fifoDelivery || pendingSetCarts.length > 0)
      {
        break;
      }
    }
  }

  async function fillRemainingSetCarts()
  {
    const availableLines = await findAvailableLines();
    const workingLines = findWorkingLines(availableLines);
    const availableSetCarts = await findAvailableSetCarts(availableLines, workingLines);
    const lineToSets = mapLineToSets(availableSetCarts);
    const remainingSetCarts = findRemainingSetCarts(availableLines, lineToSets);
    const newOrderSets = await findNewOrderSets(remainingSetCarts);
    const allNewWhOrders = await findAllNewWhOrders(newOrderSets);
    const lineStats = createDeliveredOrders(allNewWhOrders);

    await Promise.all([
      updateLines(lineStats),
      updateAllPendingSetCarts(newOrderSets)
    ]);
  }

  async function findAvailableLines()
  {
    const conditions = {};

    if (forceLine)
    {
      conditions._id = forceLine;
    }
    else
    {
      conditions['available.time'] = {$lt: minTimeForDelivery};
    }

    const list = await WhLine
      .find(conditions)
      .lean()
      .session(session)
      .exec();

    const map = new Map();

    list.forEach(l => map.set(l._id, l));

    return map;
  }

  function findWorkingLines(availableLines)
  {
    if (forceLine)
    {
      return [forceLine];
    }

    const production = app[module.config.productionId];
    const workingLines = [];

    if (!production || !availableLines.size)
    {
      return workingLines;
    }

    availableLines.forEach(whLine =>
    {
      const lineState = production.getProdLineState(whLine._id);

      if (!!lineState && lineState.getCurrentOrder() !== null)
      {
        workingLines.push(whLine._id);
      }
    });

    return workingLines;
  }

  async function findAvailableSetCarts(availableLines, workingLines)
  {
    const availableSetCarts = [];

    if (!availableLines.size)
    {
      return availableSetCarts;
    }

    const [allAvailableSetCarts, planStats] = await Promise.all([
      findAllAvailableSetCarts(availableLines),
      findPlanStats()
    ]);

    const workingPlans = new Map();

    allAvailableSetCarts.forEach(lineSetCarts =>
    {
      const pending = lineSetCarts.carts.some(cart =>
      {
        return forceLine
          || (cart.startTime.getTime() - utcTime) < maxDeliveryStartTime
          || isAnyLineWorking(cart.lines, workingLines)
          || isTimeForDelivery(cart.lines, cart.startTime, availableLines, planStats, workingPlans);
      });

      if (!pending)
      {
        return;
      }

      const carts = [];
      let startTime = Number.MAX_SAFE_INTEGER;

      lineSetCarts.carts.sort((a, b) => a.startTime - b.startTime);

      lineSetCarts.carts.forEach(cart =>
      {
        startTime = Math.min(cart.startTime.getTime(), startTime);

        carts.push(cart);
      });

      availableSetCarts.push({
        _id: lineSetCarts._id,
        carts,
        startTime
      });
    });

    availableSetCarts.sort((a, b) => a.startTime - b.startTime);

    return availableSetCarts;
  }

  function findAllAvailableSetCarts(availableLines)
  {
    const pipeline = [
      {
        $match: {
          status: 'completed',
          pending: false,
          lines: {$in: Array.from(availableLines.keys())},
          kind
        }
      },
      {
        $group: {
          _id: {
            line: '$line',
            date: '$date',
            set: '$set'
          },
          carts: {
            $addToSet: {
              _id: '$_id',
              startTime: '$startTime',
              lines: '$lines',
              cart: '$cart'
            }
          }
        }
      }
    ];

    return WhSetCart
      .aggregate(pipeline)
      .session(session)
      .exec();
  }

  async function findPlanStats()
  {
    const plans = await Plan
      .find({
        _id: {$gte: shifts.getPlanDate(utcTime, true).subtract(7, 'days').toDate()}
      })
      .select({
        'stats.startAt': 1
      })
      .lean()
      .session(session)
      .exec();

    const planStats = new Map();

    plans.forEach(plan =>
    {
      planStats.set(plan._id.valueOf(), {
        date: plan._id,
        workingShifts: plan.stats.map(shift => !!shift.startAt)
      });
    });

    return planStats;
  }

  function isAnyLineWorking(lines, workingLines)
  {
    return lines.some(line => workingLines.includes(line));
  }

  function isTimeForDelivery(cartLines, cartStartTime, availableLines, planStats, workingPlans)
  {
    const minStartTimeHour = 6;
    const maxStartTimeHour = minStartTimeHour + maxDeliveryStartTime / 60000 / 60;

    return cartLines.some(lineId =>
    {
      const whLine = availableLines.get(lineId);

      if (!whLine)
      {
        return false;
      }

      const startTimeHour = cartStartTime.getUTCHours();

      if (startTimeHour < minStartTimeHour || startTimeHour >= maxStartTimeHour)
      {
        return false;
      }

      const workingPlan = getFirstWorkingPlanBefore(cartStartTime.getTime(), planStats, workingPlans);

      if (!workingPlan)
      {
        return false;
      }

      const endOfWork = moment.utc(workingPlan.date.getTime());

      for (let shiftNo = 3; shiftNo > 0; --shiftNo)
      {
        if (workingPlan.workingShifts[shiftNo])
        {
          endOfWork.hours(shifts.SHIFT_START_HOUR[shiftNo]);

          break;
        }
      }

      endOfWork.add(shifts.SHIFT_LENGTH * 3600 * 1000 - maxDeliveryStartTime, 'ms');

      return utcTime >= endOfWork.valueOf();
    });
  }

  function getFirstWorkingPlanBefore(ts, planStats, workingPlans)
  {
    if (workingPlans.has(ts))
    {
      return workingPlans.get(ts);
    }

    const m = moment.utc(ts).startOf('day');

    do
    {
      const plan = planStats.get(m.subtract(24, 'hours').valueOf());

      if (!plan)
      {
        workingPlans.set(ts, null);

        return null;
      }

      if (plan.workingShifts[0])
      {
        workingPlans.set(ts, plan);

        return plan;
      }
    }
    while (true); // eslint-disable-line no-constant-condition
  }

  function mapLineToSets(availableSetCarts)
  {
    const lineToSets = new Map();

    availableSetCarts.forEach(lineSetCarts =>
    {
      if (!lineToSets.has(lineSetCarts._id.line))
      {
        lineToSets.set(lineSetCarts._id.line, []);
      }

      lineToSets.get(lineSetCarts._id.line).push({
        date: lineSetCarts._id.date,
        set: lineSetCarts._id.set,
        carts: lineSetCarts.carts
      });
    });

    return lineToSets;
  }

  function findRemainingSetCarts(availableLines, lineToSets)
  {
    const remainingSetCarts = [];
    const usedSetCarts = new Set();

    setCartsToDeliver.forEach(setCart => usedSetCarts.add(setCart._id.toString()));

    for (const lineId of availableLines.keys())
    {
      const lineSets = lineToSets.get(lineId);

      if (!lineSets)
      {
        continue;
      }

      while (lineSets.length)
      {
        const lineSet = lineSets.shift();
        let totalCartCount = setCartsToDeliver.length + remainingSetCarts.length;

        // Do not include FIFO carts from other sets if they don't fit fully
        if (fifoDelivery
          && totalCartCount > 0
          && (totalCartCount + lineSet.carts.length) > maxSetCartsPerDelivery)
        {
          continue;
        }

        while (lineSet.carts.length && totalCartCount < maxSetCartsPerDelivery)
        {
          const setCartId = lineSet.carts.shift()._id;
          const usedSetCartId = setCartId.toString();

          if (usedSetCarts.has(usedSetCartId))
          {
            continue;
          }

          remainingSetCarts.push(setCartId);
          usedSetCarts.add(usedSetCartId);

          totalCartCount += 1;
        }

        // Stop if:
        // it is not a FIFO delivery: only one set per packaging or paint-shop delivery
        // or the set didn't fit fully
        // or we reached the maximum
        if ((!fifoDelivery && remainingSetCarts.length)
          || lineSet.carts.length > 0
          || totalCartCount === maxSetCartsPerDelivery)
        {
          return remainingSetCarts;
        }
      }
    }

    return remainingSetCarts;
  }

  async function findNewOrderSets(remainingSetCarts)
  {
    const newOrderSets = new Map();

    if (!remainingSetCarts.length)
    {
      return newOrderSets;
    }

    const newSetCarts = await WhSetCart
      .find({_id: {$in: remainingSetCarts}})
      .lean()
      .session(session)
      .exec();

    newSetCarts.forEach(setCart =>
    {
      setCartsToDeliver.push(setCart);

      const setId = resolveSetId(setCart);

      if (!newOrderSets.has(setId))
      {
        newOrderSets.set(setId, {
          set: setCart.set,
          date: setCart.date
        });
      }
    });

    return newOrderSets;
  }

  async function findAllNewWhOrders(newOrderSets)
  {
    if (!newOrderSets.size)
    {
      return [];
    }

    const allNewWhOrders = await WhOrder
      .find({
        $or: Array.from(newOrderSets.values())
      })
      .select({
        status: 1,
        order: 1,
        lines: 1,
        date: 1,
        set: 1,
        startTime: 1
      })
      .lean()
      .session(session)
      .exec();

    allNewWhOrders.forEach(whOrder =>
    {
      if (whOrder.status !== 'problem')
      {
        return;
      }

      whOrder.lines.forEach(whOrderLine =>
      {
        problemLineOrders.add(`${whOrderLine._id}:${whOrder.order}`);
      });
    });

    return allNewWhOrders;
  }

  function createDeliveredOrders(allNewWhOrders)
  {
    const lineStats = new Map();

    allNewWhOrders.forEach(whOrder =>
    {
      whOrder.lines.forEach(whOrderLine =>
      {
        if (!lineStats.has(whOrderLine._id))
        {
          lineStats.set(whOrderLine._id, {
            sets: new Set(),
            qty: 0,
            time: 0,
            totalQty: 0,
            totalTime: 0
          });
        }

        const line = lineStats.get(whOrderLine._id);
        const blocked = problemLineOrders.has(`${whOrderLine._id}:${whOrder.order}`);

        line.sets.add(`${whOrder.date.getTime()}:${whOrder.set}`);

        line.totalQty += whOrderLine.qty;
        line.totalTime += whOrderLine.qty * whOrderLine.pceTime;

        if (!blocked)
        {
          line.qty += whOrderLine.qty;
          line.time += whOrderLine.qty * whOrderLine.pceTime;
        }

        results.deliveredOrders.added.push({
          _id: new ObjectId(),
          status: blocked ? 'blocked' : 'todo',
          line: whOrderLine._id,
          redirLine: null,
          qtyTodo: whOrderLine.qty,
          qtyDone: 0,
          qtyRemaining: whOrderLine.qty,
          pceTime: whOrderLine.pceTime,
          sapOrder: whOrder.order,
          whOrder: whOrder._id,
          date: whOrder.date,
          set: whOrder.set,
          startTime: whOrder.startTime
        });
      });
    });

    return lineStats;
  }

  async function updateLines(lineStats)
  {
    if (!lineStats.size)
    {
      return;
    }

    const lineIds = Array.from(lineStats.keys());

    await WhLine.lockLines(lineIds);

    const whLines = await WhLine
      .find({_id: {$in: lineIds}})
      .lean()
      .session(session)
      .exec();

    whLines.forEach(whLine =>
    {
      const stats = lineStats.get(whLine._id);
      const sets = stats.sets.size;

      whLine.pickup.finished.sets = Math.max(0, whLine.pickup.finished.sets - sets);
      whLine.pickup.finished.qty = Math.max(0, whLine.pickup.finished.qty - stats.totalQty);
      whLine.pickup.finished.time = Math.max(0, whLine.pickup.finished.time - stats.totalTime);
      whLine.pickup.total.sets = whLine.pickup.started.sets + whLine.pickup.finished.sets;
      whLine.pickup.total.qty = whLine.pickup.started.qty + whLine.pickup.finished.qty;
      whLine.pickup.total.time = whLine.pickup.started.time + whLine.pickup.finished.time;

      whLine.available.qty += stats.qty;
      whLine.available.time += stats.time;

      results.lines.updated.push({
        _id: whLine._id,
        pickup: whLine.pickup,
        available: whLine.available
      });
    });
  }

  async function updateAllPendingSetCarts(newOrderSets)
  {
    if (!newOrderSets.size)
    {
      return;
    }

    const pendingSetCarts = await WhSetCart
      .find({
        pending: false,
        $or: Array.from(newOrderSets.values()),
        _id: {$nin: setCartsToDeliver.map(c => c._id)}
      })
      .select({_id: 1})
      .hint({set: 1, date: -1})
      .lean()
      .exec();

    pendingSetCarts.forEach(setCart =>
    {
      setCart.pending = true;

      results.setCarts.updated.push(setCart);
    });
  }

  async function unblockDeliveredOrders()
  {
    const $or = [];
    const whOrderIds = new Set();

    setCartsToDeliver.forEach(setCart =>
    {
      setCart.orders.forEach(({whOrder, sapOrder}) =>
      {
        whOrderIds.add(whOrder);

        setCart.lines.forEach(line =>
        {
          if (!problemLineOrders.has(`${line}:${sapOrder}`))
          {
            $or.push({sapOrder, line, status: 'blocked'});
          }
        });
      });
    });

    if (!$or.length)
    {
      return;
    }

    const [problemOrders, deliveredOrders] = await Promise.all([
      WhOrder
        .find({
          _id: {$in: Array.from(whOrderIds)},
          status: 'problem'
        })
        .select({
          lines: 1,
          order: 1
        })
        .lean()
        .hint({_id: 1})
        .session(session)
        .exec(),
      WhDeliveredOrder
        .find({$or})
        .select({
          sapOrder: 1,
          line: 1,
          status: 1,
          qtyRemaining: 1,
          pceTime: 1
        })
        .lean()
        .hint({sapOrder: 1, line: 1, status: 1})
        .session(session)
        .exec()
    ]);

    if (!deliveredOrders.length)
    {
      return;
    }

    const problems = new Set();

    problemOrders.forEach(whOrder =>
    {
      whOrder.lines.forEach(whOrderLine =>
      {
        problems.add(`${whOrderLine._id}:${whOrder.order}`);
      });
    });

    const whLines = new Map();

    results.lines.updated.forEach(whLine =>
    {
      whLines.set(whLine._id, whLine);
    });

    deliveredOrders.forEach(deliveredOrder =>
    {
      if (problems.has(`${deliveredOrder.line}:${deliveredOrder.sapOrder}`))
      {
        return;
      }

      deliveredOrder.status = 'todo';

      results.deliveredOrders.updated.push(deliveredOrder);

      const whLine = whLines.get(deliveredOrder.line);

      if (whLine)
      {
        whLine.available.qty += deliveredOrder.qtyRemaining;
        whLine.available.time += deliveredOrder.qtyRemaining * deliveredOrder.pceTime;
      }
    });
  }
};
