// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const ObjectId = require('mongoose').Types.ObjectId;

exports.session = true;

exports.execute = async (app, module, {data, user, session}) =>
{
  const {
    User,
    OldWhSetCart: WhSetCart,
    OldWhOrder: WhOrder,
    OldWhUser: WhUser,
    OldWhEvent: WhEvent
  } = module;

  let whUserId = data.whUserId;

  if (!whUserId)
  {
    const personnelUser = await User
      .findOne({
        $or: [
          {personnelId: data.personnelId},
          {card: data.personnelId},
          {cardUid: data.personnelId}
        ],
        active: true
      })
      .select({_id: 1})
      .lean()
      .session(session)
      .exec();

    if (!personnelUser)
    {
      throw app.createError('User not found.', 'USER_NOT_FOUND', 400);
    }

    whUserId = personnelUser._id.toString();
  }

  const whUser = await WhUser
    .findById(whUserId)
    .lean()
    .session(session)
    .exec();

  if (!whUser)
  {
    throw app.createError('WH user not found.', 'USER_NOT_FOUND', 400);
  }

  const deliveredSetCarts = await WhSetCart
    .find({
      _id: {$in: data.setCarts},
      status: 'delivering'
    })
    .session(session)
    .lean()
    .exec();

  if (!deliveredSetCarts.length)
  {
    return {response: {setCarts: []}};
  }

  const whOrdersResult = {
    updated: [],
    messages: []
  };
  const setCartsResult = {
    updated: [],
    messages: []
  };

  const now = new Date();
  const event = {
    type: 'deliveryFinished',
    time: now,
    user,
    data: {
      whUser: WhEvent.whUser(whUser),
      setCarts: WhEvent.setCarts({remaining: deliveredSetCarts}),
      orders: [],
      lines: new Set(),
      duration: now - deliveredSetCarts[0].deliveringAt
    }
  };
  const setCartsUpdate = {
    status: 'delivered',
    deliveredAt: now,
    deliveredBy: event.data.whUser
  };
  let whOrderIds = new Set();
  let setCartIds = new Set();

  deliveredSetCarts.forEach(setCart =>
  {
    setCartsResult.updated.push({
      _id: setCart._id,
      ...setCartsUpdate
    });

    Object.assign(setCart, setCartsUpdate);

    setCartIds.add(setCart._id.toString());

    WhEvent.lines(setCart, event.data.lines);

    setCart.orders.forEach(setCartOrder =>
    {
      if (!whOrderIds.has(setCartOrder.whOrder))
      {
        event.data.orders.push({
          whOrder: setCartOrder.whOrder,
          sapOrder: setCartOrder.sapOrder,
          date: setCart.date,
          set: setCart.set
        });

        whOrderIds.add(setCartOrder.whOrder);
      }
    });
  });

  whOrderIds = Array.from(whOrderIds);
  setCartIds = Array.from(setCartIds);

  await WhSetCart.collection.updateMany(
    {_id: {$in: setCartIds.map(id => new ObjectId(id))}},
    {$set: setCartsUpdate},
    {session}
  );

  const remainingSetCarts = await WhSetCart
    .find({
      _id: {$nin: setCartIds},
      'orders.whOrder': {$in: whOrderIds}
    })
    .hint({'orders.whOrder': 1})
    .lean()
    .session(session)
    .exec();

  const whOrderToSetCarts = new Map();

  [...deliveredSetCarts, ...remainingSetCarts].forEach(setCart =>
  {
    setCart.orders.forEach(setCartOrder =>
    {
      if (!whOrderToSetCarts.has(setCartOrder.whOrder))
      {
        whOrderToSetCarts.set(setCartOrder.whOrder, []);
      }

      whOrderToSetCarts.get(setCartOrder.whOrder).push(setCart);
    });
  });

  const problemOrderList = await WhOrder
    .find({
      _id: {$in: Array.from(whOrderToSetCarts.keys())},
      status: 'problem'
    })
    .select({'funcs.status': 1})
    .lean()
    .session(session)
    .exec();
  const problemOrderMap = new Map();

  problemOrderList.forEach(whOrder => problemOrderMap.set(whOrder._id, whOrder));

  whOrderToSetCarts.forEach((setCarts, whOrderId) =>
  {
    const count = {
      components: {
        total: 0,
        completing: 0,
        completed: 0,
        delivering: 0,
        delivered: 0
      },
      packaging: {
        total: 0,
        completing: 0,
        completed: 0,
        delivering: 0,
        delivered: 0
      },
      ps: {
        total: 0,
        completing: 0,
        completed: 0,
        delivering: 0,
        delivered: 0
      }
    };

    const problemOrder = problemOrderMap.get(whOrderId);

    if (problemOrder)
    {
      const fmx = problemOrder.funcs[WhOrder.FUNCS_IDX.fmx].status;
      const kitter = problemOrder.funcs[WhOrder.FUNCS_IDX.kitter].status;
      const platformer = problemOrder.funcs[WhOrder.FUNCS_IDX.platformer].status;
      const packer = problemOrder.funcs[WhOrder.FUNCS_IDX.packer].status;
      const painter = problemOrder.funcs[WhOrder.FUNCS_IDX.painter].status;

      if (fmx === 'problem' || kitter === 'problem' || platformer === 'problem')
      {
        count.components.total += 1;
      }

      if (packer === 'problem')
      {
        count.packaging.total += 1;
      }

      if (painter === 'problem')
      {
        count.ps.total += 1;
      }
    }

    setCarts.forEach(setCart =>
    {
      count[setCart.kind].total += 1;
      count[setCart.kind][setCart.status] += 1;
    });

    const fifoStatus = resolveDistStatus(count.components);
    const packStatus = resolveDistStatus(count.packaging);
    const psDistStatus = resolveDistStatus(count.ps);

    whOrdersResult.updated.push({
      _id: whOrderId,
      fifoStatus,
      packStatus,
      psDistStatus,
      distStatus: WhOrder.resolveDistStatus(fifoStatus, packStatus, psDistStatus)
    });
  });

  const whOrdersOps = whOrdersResult.updated.map(update =>
  {
    return {
      updateOne: {
        filter: {_id: update._id},
        update: {$set: update}
      }
    };
  });

  const [eventsResult] = await Promise.all([
    WhEvent.record(event, session),
    WhOrder.collection.bulkWrite(whOrdersOps, {session})
  ]);

  await session.commitTransaction();

  whOrdersResult.messages.push({
    topic: `${WhOrder.TOPIC_PREFIX}.updated`,
    message: {
      updated: whOrdersResult.updated
    }
  });

  setCartsResult.messages.push({
    topic: `${WhSetCart.TOPIC_PREFIX}.updated`,
    message: {
      updated: setCartsResult.updated
    }
  });

  return {
    response: {
      setCarts: setCartsResult.updated
    },
    results: [
      eventsResult,
      whOrdersResult,
      setCartsResult
    ]
  };
};

function resolveDistStatus(count)
{
  if (count.total === 0)
  {
    return 'ignored';
  }

  if (count.delivered === count.total)
  {
    return 'finished';
  }

  if (count.delivered || count.delivering)
  {
    return 'started';
  }

  return 'pending';
}
