// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

exports.session = true;

exports.execute = async (app, module, {data, user, session}) =>
{
  const {
    OldWhEvent: WhEvent,
    OldWhOrder: WhOrder,
    OldWhUser: WhUser,
    OldWhSetCart: WhSetCart,
    OldWhLine: WhLine
  } = module;

  const now = new Date();
  const edit = !!data.edit;
  const newValue = data.newValue;

  if (edit && newValue !== 'success')
  {
    throw app.createError('Invalid edit.', 'INPUT', 400);
  }

  const whOrder = await WhOrder
    .findById(data.whOrderId)
    .session(session)
    .exec();

  if (!whOrder)
  {
    throw app.createError(`Order not found.`, 'INPUT', 400);
  }

  if (whOrder.distStatus !== 'pending')
  {
    throw app.createError('Order delivered.', 'STATE', 400);
  }

  const func = whOrder.funcs.find(f => f._id === data.funcId);

  if (!func)
  {
    throw app.createError(`Function not found.`, 'INPUT', 400);
  }

  const oldValue = func.pickup;

  if (Array.isArray(data.carts) && data.carts.length)
  {
    const existingSetCarts = await WhSetCart
      .aggregate([
        {$match: {
          status: {$in: ['completing', 'completed', 'delivering']},
          kind: WhSetCart.FUNC_TO_KIND[func._id],
          cart: {$in: data.carts}
        }},
        {$project: {
          plan: {
            date: '$date',
            set: '$set'
          },
          cart: 1
        }},
        {$match: {
          plan: {$ne: {
            date: whOrder.date,
            set: whOrder.set
          }}
        }}
      ])
      .hint({status: 1, date: -1})
      .session(session)
      .exec();

    if (existingSetCarts.length)
    {
      throw app.createError('Cart already used.', 'INPUT', 400, {
        setCarts: existingSetCarts
      });
    }
  }

  const event = {
    type: 'pickup',
    user,
    time: now,
    data: {
      edit,
      func: func._id,
      oldValue,
      newValue,
      whUser: func.user,
      orders: WhEvent.orders([whOrder]),
      lines: WhEvent.lines(whOrder),
      setCarts: null,
      problemArea: null,
      comment: null
    }
  };

  switch (newValue)
  {
    case 'pending':
    {
      func.status = 'pickup';
      func.pickup = newValue;
      func.carts = [];
      func.problemArea = '';
      func.comment = '';
      func.finishedAt = null;

      break;
    }

    case 'success':
    {
      const carts = !Array.isArray(data.carts) ? [] : data.carts.filter(v => typeof v === 'string' && v.length < 10);

      if (!carts.length)
      {
        throw app.createError('Invalid carts.', 'INPUT', 400);
      }

      func.status = 'finished';
      func.pickup = newValue;
      func.carts = carts;
      func.problemArea = '';
      func.comment = '';

      if (!edit)
      {
        func.finishedAt = now;
      }

      if (func._id === 'platformer')
      {
        [
          whOrder.funcs[WhOrder.FUNCS_IDX.fmx],
          whOrder.funcs[WhOrder.FUNCS_IDX.kitter]
        ].forEach(f =>
        {
          if (f.status !== 'finished')
          {
            whOrder.resetFunc(f._id, {
              status: 'finished',
              picklist: 'require',
              pickup: 'success'
            });
          }
        });
      }

      break;
    }

    case 'failure':
    {
      if (typeof data.problemArea !== 'string' || !data.problemArea.length)
      {
        throw app.createError('Invalid problem area.', 'INPUT', 400);
      }

      if (typeof data.comment !== 'string')
      {
        throw app.createError('Invalid comment.', 'INPUT', 400);
      }

      func.status = 'problem';
      func.pickup = newValue;
      func.carts = [];
      func.problemArea = data.problemArea;
      func.comment = data.comment;
      func.finishedAt = now;

      event.data.problemArea = data.problemArea;
      event.data.comment = data.comment;

      break;
    }

    default:
      throw app.createError(`Invalid picklist status.`, 'INPUT', 400);
  }

  if (func._id === 'fmx' || func._id === 'kitter')
  {
    whOrder.resetPlatformer();
  }

  const oldStatus = whOrder.status;

  if (!edit)
  {
    whOrder.finalizeOrder();
  }

  const [setCartsResults] = await Promise.all([
    WhSetCart.updateByFunc(whOrder, func._id, false),
    !edit && func.user && (newValue === 'success' || newValue === 'failure')
      ? WhUser.collection.updateOne({_id: func.user.id}, {$set: {lastPickupAt: now}}, {session})
      : null,
    whOrder.save()
  ]);

  event.data.setCarts = WhEvent.setCarts(setCartsResults, whOrder);

  if (event.data.setCarts.length === 0 && func.carts.length)
  {
    event.data.setCarts = func.carts.map(cart => ({
      id: null,
      kind: WhSetCart.FUNC_TO_KIND[func._id],
      cart
    }));
  }

  const [lineResults, setResults, eventsResults] = await Promise.all([
    whOrder.status !== oldStatus || oldStatus === 'problem' ? WhLine.recountByWhOrder(whOrder, true, false) : null,
    whOrder.finalizeSet(setCartsResults),
    data.recordEvent !== false ? WhEvent.record(event, session) : null
  ]);

  await session.commitTransaction();

  const leanWhOrder = whOrder.toJSON();

  if (app[module.config.ordersId] && event.data.comment)
  {
    setImmediate(() =>
    {
      const data = {
        source: 'wh',
        comment: event.data.comment
      };
      const userInfo = {
        ...user,
        ...func.user
      };

      app[module.config.ordersId].editOrder(whOrder.order, data, userInfo, err =>
      {
        if (err)
        {
          module.error(err, 'Failed to record order comment.');
        }
      });
    });
  }

  const messages = [{
    topic: `${WhOrder.TOPIC_PREFIX}.updated`,
    message: {updated: [leanWhOrder]}
  }];

  whOrder.checkProblemChange(oldStatus, messages);

  return {
    response: {
      order: leanWhOrder
    },
    results: [
      setCartsResults,
      eventsResults,
      lineResults,
      setResults
    ],
    messages
  };
};
