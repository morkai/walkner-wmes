// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const pickup = require('./pickup');

exports.detached = true;

exports.session = true;

exports.execute = async (app, module, {data, user, session}) =>
{
  const {
    OldWhEvent: WhEvent,
    OldWhOrder: WhOrder,
    OldWhSetCart: WhSetCart
  } = module;

  const now = new Date();

  const whOrder = await WhOrder
    .findById(data.whOrderId)
    .session(session)
    .exec();

  if (!whOrder)
  {
    throw app.createError(`Order not found.`, 'INPUT', 400);
  }

  if (!data.funcId === 'lp10')
  {
    throw app.createError('Invalid function.', 'INPUT', 400);
  }

  const carts = !Array.isArray(data.carts) ? [] : data.carts.filter(v => typeof v === 'string' && v.length < 10);

  if (!carts.length)
  {
    throw app.createError('Invalid carts.', 'INPUT', 400);
  }

  const func = whOrder.funcs[WhOrder.FUNCS_IDX[data.funcId]];

  if (!func)
  {
    throw app.createError('Invalid function', 'INPUT', 400);
  }

  if (func._id === 'platformer' && func.status === 'pickup')
  {
    // Allow setting carts for the Platformer after solving other problems
  }
  else if (whOrder.status !== 'problem')
  {
    throw app.createError('Invalid order status.', 'STATE', 400);
  }

  if (func._id === 'platformer' && func.status === 'pickup')
  {
    // Allow setting carts for the Platformer after solving other problems
  }
  else if (func.status !== 'problem')
  {
    throw app.createError('Invalid function status.', 'STATE', 400);
  }

  let setDelivered = whOrder.distStatus !== 'pending';

  if (!setDelivered)
  {
    const deliveredWhOrder = await WhOrder
      .findOne({
        set: whOrder.set,
        date: whOrder.date,
        distStatus: {$ne: 'pending'}
      })
      .select({_id: 1})
      .lean()
      .session(session)
      .exec();

    setDelivered = !!deliveredWhOrder;
  }

  if (!setDelivered)
  {
    const pickupResult = await pickup.execute(app, module, {
      data: {
        whOrderId: whOrder._id,
        funcId: func._id,
        newValue: 'success',
        carts: carts,
        edit: false,
        recordEvent: false
      },
      user,
      session
    });

    return {
      results: pickupResult.results,
      messages: pickupResult.messages
    };
  }

  func.status = 'finished';
  func.pickup = 'success';
  func.carts = carts;
  func.finishedAt = now;
  func.problemArea = '';
  func.comment = '';

  if (func._id === 'fmx' || func._id === 'kitter')
  {
    whOrder.resetPlatformer();
  }
  else if (func._id === 'platformer')
  {
    [
      whOrder.funcs[WhOrder.FUNCS_IDX.fmx],
      whOrder.funcs[WhOrder.FUNCS_IDX.kitter]
    ].forEach(f =>
    {
      if (f.status !== 'finished')
      {
        whOrder.resetFunc(f._id, {
          status: 'finished',
          picklist: 'require',
          pickup: 'success',
          finishedAt: now
        });
      }
    });
  }

  const oldStatus = whOrder.status;

  whOrder.finalizeOrder();

  let [setCartsResults] = await Promise.all([
    WhSetCart.updateByFunc(whOrder, func._id, true),
    whOrder.save()
  ]);

  if (!setCartsResults)
  {
    setCartsResults = {
      deleted: [],
      added: [],
      updated: [],
      remaining: [],
      messages: []
    };
  }

  const event = {
    type: 'problemSolved',
    time: now,
    user,
    data: {
      func: func._id,
      orders: WhEvent.orders([whOrder]),
      lines: WhEvent.lines(whOrder),
      setCarts: WhEvent.setCarts(setCartsResults, whOrder)
    }
  };

  const [lineResults, setResults, eventsResults] = await Promise.all([
    WhOrder.finalizeSet(whOrder.date, whOrder.set, setCartsResults, session),
    WhEvent.record(event, session)
  ]);

  await session.commitTransaction();

  const messages = [{
    topic: `${WhOrder.TOPIC_PREFIX}.updated`,
    message: {updated: [whOrder.toJSON()]}
  }];

  whOrder.checkProblemChange(oldStatus, messages);

  return {
    results: [
      eventsResults,
      setCartsResults,
      lineResults,
      setResults
    ],
    messages
  };
};
