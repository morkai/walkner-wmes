// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const ObjectId = require('mongoose').Types.ObjectId;

exports.session = true;

exports.execute = async (app, module, {data, user, session}) =>
{
  const {
    User,
    OldWhSetCart: WhSetCart,
    OldWhOrder: WhOrder,
    OldWhUser: WhUser,
    OldWhEvent: WhEvent
  } = module;

  let whUserId = data.whUserId;

  if (!whUserId)
  {
    const personnelUser = await User
      .findOne({
        $or: [
          {personellId: data.personnelId},
          {card: data.personnelId},
          {cardUid: data.personnelId}
        ]
      })
      .select({_id: 1})
      .lean()
      .session(session)
      .exec();

    if (!personnelUser)
    {
      throw app.createError('User not found.', 'USER_NOT_FOUND', 400);
    }

    whUserId = personnelUser._id.toString();
  }

  const whUser = await WhUser
    .findById(whUserId)
    .lean()
    .session(session)
    .exec();

  if (!whUser)
  {
    throw app.createError('WH user not found.', 'USER_NOT_FOUND', 400);
  }

  const deliveredSetCarts = await WhSetCart
    .find({
      _id: {$in: data.setCarts},
      status: 'delivering'
    })
    .session(session)
    .lean()
    .exec();

  if (!deliveredSetCarts.length)
  {
    return {response: {setCarts: []}};
  }

  const whOrdersResult = {
    updated: [],
    messages: []
  };
  const setCartsResult = {
    updated: [],
    messages: []
  };

  const now = new Date();
  const setCartsUpdate = {
    status: 'delivered',
    deliveredAt: now,
    deliveredBy: {id: whUser._id, label: whUser.label}
  };
  let whOrderIds = new Set();
  let setCartIds = new Set();

  deliveredSetCarts.forEach(setCart =>
  {
    setCartsResult.updated.push({
      _id: setCart._id,
      ...setCartsUpdate
    });

    Object.assign(setCart, setCartsUpdate);

    setCartIds.add(setCart._id.toString());

    setCart.orders.forEach(setCartOrder =>
    {
      whOrderIds.add(setCartOrder.whOrder);
    });
  });

  whOrderIds = Array.from(whOrderIds);
  setCartIds = Array.from(setCartIds);

  const [whOrderList] = await Promise.all([
    WhOrder
      .find({_id: {$in: whOrderIds}})
      .lean()
      .session(session)
      .exec(),
    WhSetCart.collection.updateMany(
      {_id: {$in: setCartIds.map(id => new ObjectId(id))}},
      {$set: setCartsUpdate},
      {session}
    )
  ]);

  const whOrderMap = new Map();
  const whOrderToSetCarts = new Map();

  whOrderList.forEach(whOrder => whOrderMap.set(whOrder._id, whOrder));

  const remainingSetCarts = await WhSetCart
    .find({
      _id: {$nin: setCartIds},
      'orders.whOrder': {$in: whOrderIds}
    })
    .hint({'orders.whOrder': 1})
    .lean()
    .session(session)
    .exec();

  [...deliveredSetCarts, ...remainingSetCarts].forEach(setCart =>
  {
    setCart.orders.forEach(setCartOrder =>
    {
      if (!whOrderToSetCarts.has(setCartOrder.whOrder))
      {
        whOrderToSetCarts.set(setCartOrder.whOrder, []);
      }

      whOrderToSetCarts.get(setCartOrder.whOrder).push(setCart);
    });
  });

  whOrderToSetCarts.forEach((setCarts, whOrderId) =>
  {
    const whOrder = whOrderMap.get(whOrderId);

    const count = {
      components: {
        total: 0,
        completing: 0,
        completed: 0,
        delivering: 0,
        delivered: 0
      },
      packaging: {
        total: 0,
        completing: 0,
        completed: 0,
        delivering: 0,
        delivered: 0
      }
    };

    setCarts.forEach(setCart =>
    {
      count[setCart.kind].total += 1;
      count[setCart.kind][setCart.status] += 1;
    });

    whOrder.fifoStatus = resolveDistStatus(count.components);
    whOrder.packStatus = resolveDistStatus(count.packaging);
    whOrder.distStatus = WhOrder.resolveDistStatus(whOrder.fifoStatus, whOrder.packStatus);

    whOrdersResult.updated.push({
      _id: whOrder._id,
      distStatus: whOrder.distStatus,
      fifoStatus: whOrder.fifoStatus,
      packStatus: whOrder.packStatus
    });
  });

  const whOrdersOps = whOrdersResult.updated.map(update =>
  {
    return {
      updateOne: {
        filter: {_id: update._id},
        update: {$set: update}
      }
    };
  });

  const [eventsResult] = await Promise.all([
    WhEvent.record([{
      type: 'deliveryFinished',
      time: now,
      user,
      order: null,
      data: {
        user: whUser,
        setCarts: deliveredSetCarts.map(setCart =>
        {
          return {
            _id: setCart._id.toString(),
            kind: setCart.kind,
            date: setCart.date,
            set: setCart.set,
            line: setCart.line,
            cart: setCart.cart,
            duration: setCart.deliveredAt - setCart.deliveringAt
          };
        })
      }
    }], session),
    WhOrder.collection.bulkWrite(whOrdersOps, {session})
  ]);

  await session.commitTransaction();

  whOrdersResult.messages.push({
    topic: `${WhOrder.TOPIC_PREFIX}.updated`,
    message: {
      updated: whOrdersResult.updated
    }
  });

  setCartsResult.messages.push({
    topic: `${WhSetCart.TOPIC_PREFIX}.updated`,
    message: {
      updated: setCartsResult.updated
    }
  });

  return {
    response: {
      setCarts: setCartsResult.updated
    },
    results: [
      eventsResult,
      whOrdersResult,
      setCartsResult
    ]
  };
};

function resolveDistStatus(count)
{
  if (count.delivered === count.total)
  {
    return 'finished';
  }

  if (count.delivered || count.delivering)
  {
    return 'started';
  }

  return 'pending';
}
