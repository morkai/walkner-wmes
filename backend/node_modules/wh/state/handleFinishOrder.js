// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const locks = require('util/locks');

module.exports = async (app, module, lineId, finishedPsoIds) =>
{
  const {
    OldWhLine: WhLine,
    OldWhDeliveredOrder: WhDeliveredOrder,
    ProdShiftOrder
  } = module;

  const orderToQtyDone = {};

  try
  {
    const finishedPsos = await ProdShiftOrder
      .find({
        _id: {$in: finishedPsoIds},
        quantityDone: {$gt: 0}
      })
      .select({_id: 0, orderId: 1})
      .lean()
      .exec();

    if (!finishedPsos.length)
    {
      return;
    }

    finishedPsos.forEach(pso =>
    {
      orderToQtyDone[pso.orderId] = 0;
    });

    const allPsos = await ProdShiftOrder
      .find({
        orderId: {$in: Object.keys(orderToQtyDone)},
        prodLine: lineId,
        quantityDone: {$gt: 0}
      })
      .select({_id: 0, orderId: 1, quantityDone: 1})
      .lean()
      .exec();

    if (!allPsos.length)
    {
      return;
    }

    allPsos.forEach(pso =>
    {
      orderToQtyDone[pso.orderId] += pso.quantityDone;
    });
  }
  catch (err)
  {
    return module.error(err, `Failed to calc total quantity done.`, {lineId});
  }

  const releaseLock = await locks.createAsync(`${WhLine.TOPIC_PREFIX}.${lineId}`);

  let session = null;

  try
  {
    session = await WhLine.startSession();
    session.startTransaction();

    const deliveredOrders = await WhDeliveredOrder
      .find({
        sapOrder: {$in: Object.keys(orderToQtyDone)},
        line: lineId
      })
      .sort({startTime: 1})
      .lean()
      .session(session)
      .exec();

    const updated = [];

    deliveredOrders.forEach(o =>
    {
      const oldQtyDone = o.qtyDone;

      o.qtyDone = Math.min(
        o.qtyTodo,
        Math.max(0, orderToQtyDone[o.sapOrder])
      );

      o.qtyRemaining = o.qtyTodo - o.qtyDone;

      orderToQtyDone[o.sapOrder] -= o.qtyDone;

      if (o.qtyDone !== oldQtyDone)
      {
        updated.push({
          _id: o._id,
          status: o.qtyRemaining === 0 ? 'done' : (o.status === 'blocked' ? 'blocked' : 'todo'),
          qtyDone: o.qtyDone,
          qtyRemaining: o.qtyRemaining
        });
      }
    });

    let messages = [];

    if (updated.length)
    {
      const deliveredOrderOps = updated.map(u => ({
        updateOne: {
          filter: {_id: u._id},
          update: {$set: u}
        }
      }));

      await WhDeliveredOrder.collection.bulkWrite(deliveredOrderOps, {session});

      const lineResult = await WhLine.recountAvailable(lineId, session);

      messages = messages.concat(lineResult.messages, [{
        topic: `${WhDeliveredOrder.TOPIC_PREFIX}.updated`,
        message: {
          updated
        }
      }]);
    }

    await session.commitTransaction();

    messages.forEach(m =>
    {
      app.broker.publish(m.topic, m.message, m.meta);
    });
  }
  catch (err)
  {
    await module.state.abortTransaction(session);

    module.error(err, `Failed to finish orders.`, {lineId, finishedPsoIds});

    module.state.scheduleLineRecount(lineId);
  }

  if (session)
  {
    session.endSession();
  }

  releaseLock();
};
