// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const jsonDeepEqual = require('util/jsonDeepEqual');
const shifts = require('util/shifts');

module.exports = async (app, module) =>
{
  const {
    Plan,
    PlanSettings,
    OldWhLine: WhLine
  } = module;

  try
  {
    const lineList = await WhLine.find().select({_id: 1, mrps: 1, nextShiftAt: 1}).lean().exec();
    const lineMap = new Map();

    lineList.forEach(line =>
    {
      lineMap.set(line._id, {
        mrps: line.mrps || [],
        nextShiftAt: line.nextShiftAt ? line.nextShiftAt.getTime() : null
      });
    });

    const lineIds = Array.from(lineMap.keys());
    const currentDate = shifts.getCurrentDate(true).toDate();
    const nextShiftAt = shifts.getCurrentShiftInfo().moment.add(shifts.SHIFT_LENGTH, 'hours').utc(true).toDate();

    const [lineMrpList, nextShifts] = await Promise.all([
      PlanSettings.aggregate([
        {$match: {_id: {$gte: currentDate}}},
        {$unwind: '$lines'},
        {$match: {'lines._id': {$in: lineIds}}},
        {$unwind: '$lines.mrpPriority'},
        {$group: {
          _id: '$lines._id',
          mrps: {$addToSet: '$lines.mrpPriority'}
        }}
      ]),
      Plan.aggregate([
        {$match: {_id: {$gte: currentDate}}},
        {$project: {lines: 1}},
        {$unwind: '$lines'},
        {$match: {
          'lines._id': {$in: lineIds}
        }},
        {$unwind: '$lines.orders'},
        {$match: {
          'lines.orders.startAt': {$gte: nextShiftAt}
        }},
        {$group: {
          _id: '$lines._id',
          startAt: {$min: '$lines.orders.startAt'}
        }}
      ]).exec()
    ]);

    lineMrpList.forEach(lineMrp =>
    {
      const line = lineMap.get(lineMrp._id);

      lineMrp.mrps.sort((a, b) => a.localeCompare(b, undefined, {numeric: true, ignorePunctuation: true}));

      if (jsonDeepEqual(line.mrps, lineMrp.mrps))
      {
        delete line.mrps;
      }
      else
      {
        line.mrps = lineMrp.mrps;
      }
    });

    const noNextShiftLines = new Set(lineIds);

    nextShifts.forEach(nextShift =>
    {
      const line = lineMap.get(nextShift._id);
      const oldNextShiftAt = line.nextShiftAt;
      const newNextShiftAt = nextShift.startAt.getTime();

      noNextShiftLines.delete(nextShift._id);

      if (newNextShiftAt === oldNextShiftAt)
      {
        delete line.nextShiftAt;
      }
      else
      {
        line.nextShiftAt = nextShift.startAt;
      }
    });

    noNextShiftLines.forEach(id =>
    {
      lineMap.get(id).nextShiftAt = null;
    });

    const updated = [];
    const ops = [];

    lineMap.forEach((changes, id) =>
    {
      if (!Object.keys(changes).length)
      {
        return;
      }

      updated.push({
        _id: id,
        ...changes
      });
      ops.push({
        updateOne: {
          filter: {_id: id},
          update: {$set: changes}
        }
      });
    });

    if (!updated.length)
    {
      return;
    }

    await WhLine.collection.bulkWrite(ops);

    app.broker.publish(`${WhLine.TOPIC_PREFIX}.updated`, {updated});
  }
  catch (err)
  {
    module.error(err, 'Failed to update plan info for lines.');
  }
};
