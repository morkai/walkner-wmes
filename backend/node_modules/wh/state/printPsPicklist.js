// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const fs = require('fs');
const step = require('h5.step');
const moment = require('moment');
const ejs = require('ejs');

const templateFile = `${__dirname}/../templates/psPicklist.pl.ejs`;
const template = ejs.compile(fs.readFileSync(templateFile, 'utf8'), {
  cache: true,
  filename: templateFile,
  compileDebug: false,
  rmWhitespace: true
});

module.exports = async (app, module, whOrders, options) =>
{
  const {
    settings,
    html2pdf,
    Printer,
    Order,
    PaintShopOrder,
    PaintShopEvent,
    PaintShopIgnoredComponent,
    DrillingOrder,
    DrillingEvent,
    OldWhOrder: WhOrder
  } = module;

  const groupedWhOrders = new Map();

  whOrders.forEach(whOrder =>
  {
    if (!groupedWhOrders.has(whOrder.order))
    {
      groupedWhOrders.set(whOrder.order, {
        orders: [],
        qty: 0
      });
    }

    const group = groupedWhOrders.get(whOrder.order);

    group.orders.push(whOrder);
    group.qty += whOrder.qty;
  });

  return new Promise((resolve, reject) =>
  {
    step(
      function()
      {
        settings.findValue('paintShop.workCenters', this.parallel());
        settings.findValue('drilling.workCenters', this.parallel());
      },
      function(err, psWorkCenters, drillWorkCenters)
      {
        if (err)
        {
          return this.skip(err);
        }

        const workCenters = new Set();

        if (Array.isArray(psWorkCenters) && psWorkCenters.length)
        {
          psWorkCenters.forEach(wc => workCenters.add(wc));
        }

        if (Array.isArray(drillWorkCenters) && drillWorkCenters.length)
        {
          drillWorkCenters.forEach(wc => workCenters.add(wc));
        }

        Printer
          .findOne({tags: `wh/psPicklist`})
          .lean()
          .exec(this.parallel());

        const orderIds = Array.from(groupedWhOrders.keys());

        Order
          .find({
            $or: [
              {
                _id: {$in: orderIds},
                statuses: {$nin: Order.DELETED_STATUSES}
              },
              {
                leadingOrder: {$in: orderIds},
                'operations.workCenter': {$in: Array.from(workCenters)},
                statuses: {$nin: Order.DELETED_STATUSES}
              }
            ]
          })
          .select({
            leadingOrder: 1,
            name: 1,
            nc12: 1,
            qty: 1,
            bom: 1
          })
          .lean()
          .exec(this.parallel());
      },
      function(err, printer, sapOrders)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!printer)
        {
          return this.skip(app.createError(`No wh/psPicklist printer!`, 'NO_PRINTER'));
        }

        this.printer = printer;
        this.sapOrders = sapOrders;

        const orderIds = new Set(groupedWhOrders.keys());

        sapOrders.forEach(sapOrder => orderIds.add(sapOrder._id));

        PaintShopOrder
          .find({order: {$in: Array.from(orderIds)}})
          .select({
            order: 1,
            qty: 1,
            unit: 1,
            nc12: 1,
            name: 1,
            childOrders: 1
          })
          .lean()
          .exec(this.parallel());

        DrillingOrder
          .find({
            order: {$in: Array.from(orderIds)},
            painted: false
          })
          .select({
            order: 1,
            qty: 1,
            unit: 1,
            nc12: 1,
            name: 1,
            childOrders: 1
          })
          .lean()
          .exec(this.parallel());
      },
      function(err, psOrders, drillOrders)
      {
        if (err)
        {
          return this.skip(err);
        }

        this.psOrders = psOrders;
        this.drillOrders = drillOrders;

        if (psOrders.length)
        {
          PaintShopEvent
            .find({
              order: {$in: psOrders.map(o => o._id)},
              'data.comment': {$exists: true, $type: 'string', $ne: ''}
            })
            .select({
              order: 1,
              'data.comment': 1
            })
            .lean()
            .exec(this.parallel());
        }
        else
        {
          setImmediate(this.parallel(), null, []);
        }

        if (drillOrders.length)
        {
          DrillingEvent
            .find({
              order: {$in: psOrders.map(o => o._id)},
              'data.comment': {$exists: true, $type: 'string', $ne: ''}
            })
            .select({
              order: 1,
              'data.comment': 1
            })
            .lean()
            .exec(this.parallel());
        }
        else
        {
          setImmediate(this.parallel(), null, []);
        }
      },
      function(err, psEvents, drillEvents)
      {
        if (err)
        {
          return this.skip(app.createError(
            `Failed to find PS picklist print data: ${err.message}`,
            'DB_FAILURE'
          ));
        }

        const groupedSapOrders = new Map();
        const groupedPsOrders = new Map();
        const groupedEvents = new Map();
        const paintNames = new Map();
        const usedComponents = new Set();
        const sapOrderMap = new Map();
        const psOrderMap = new Map();
        const drillOrderMap = new Map();
        const idToNo = new Map();
        const noToLeadingNo = new Map();

        this.psOrders.forEach(psOrder =>
        {
          idToNo.set(psOrder._id, psOrder.order);
          psOrderMap.set(psOrder.order, psOrder);
        });

        this.drillOrders.forEach(drillOrder =>
        {
          idToNo.set(drillOrder._id, drillOrder.order);
          drillOrderMap.set(drillOrder.order, drillOrder);
        });

        this.sapOrders.forEach(sapOrder =>
        {
          sapOrderMap.set(sapOrder._id, sapOrder);

          if (!sapOrder.leadingOrder)
          {
            sapOrder.leadingOrder = sapOrder._id;
          }

          sapOrder.isLeadingOrder = sapOrder._id === sapOrder.leadingOrder;

          noToLeadingNo.set(sapOrder._id, sapOrder.leadingOrder);

          if (!groupedSapOrders.has(sapOrder.leadingOrder))
          {
            groupedSapOrders.set(sapOrder.leadingOrder, []);
          }

          groupedSapOrders.get(sapOrder.leadingOrder).push(sapOrder);
        });

        psEvents.forEach(psEvent =>
        {
          const orderNo = idToNo.get(psEvent.order);
          const leadingNo = noToLeadingNo.get(orderNo);

          if (!groupedEvents.has(leadingNo))
          {
            groupedEvents.set(leadingNo, []);
          }

          groupedEvents.get(leadingNo).push(psEvent.data.comment);
        });

        drillEvents.forEach(drillEvent =>
        {
          const orderNo = idToNo.get(drillEvent.order);
          const leadingNo = noToLeadingNo.get(orderNo);

          if (!groupedEvents.has(leadingNo))
          {
            groupedEvents.set(leadingNo, []);
          }

          groupedEvents.get(leadingNo).push(drillEvent.data.comment);
        });

        this.drillOrders.forEach(drillOrder =>
        {
          drillOrder.drilling = true;

          drillOrder.childOrders.forEach(childOrder =>
          {
            childOrder.components.unshift({
              nc12: '000000000000',
              name: 'DRILLING W/O PAINT',
              qty: 1,
              unit: 'G'
            });
          });

          this.psOrders.push(drillOrder);
        });

        this.psOrders.forEach(psOrder =>
        {
          const leadingNo = noToLeadingNo.get(psOrder.order);

          if (!groupedPsOrders.has(leadingNo))
          {
            const leadingOrder = sapOrderMap.get(leadingNo);

            if (!leadingOrder)
            {
              return;
            }

            groupedPsOrders.set(leadingNo, {
              psOrder: psOrderMap.get(leadingNo) || drillOrderMap.get(leadingNo) || {
                _id: '',
                order: leadingNo,
                nc12: leadingOrder.nc12,
                name: leadingOrder.name,
                qty: leadingOrder.qty
              },
              byPaint: new Map(),
              comments: groupedEvents.get(leadingNo) || []
            });
          }

          const {byPaint} = groupedPsOrders.get(leadingNo);
          const sapOrders = psOrder.drilling ? null : groupedSapOrders.get(leadingNo);

          if (sapOrders)
          {
            psOrder.childOrders = sapOrders
              .filter(sapOrder => !sapOrder.isLeadingOrder)
              .map(sapOrder =>
              {
                return {
                  deleted: false,
                  qty: sapOrder.qty,
                  components: sapOrder.bom
                };
              });
          }

          psOrder.childOrders.forEach(childOrder =>
          {
            if (childOrder.deleted)
            {
              return;
            }

            const childOrderPaints = [];

            childOrder.components.forEach(component =>
            {
              if (component.unit === 'G' || component.unit === 'KG')
              {
                paintNames.set(component.nc12, component.name);
                childOrderPaints.push(component.nc12);
              }
            });

            if (childOrderPaints.length === 0)
            {
              return;
            }

            childOrderPaints.sort();

            const paintKey = childOrderPaints.join(' ');

            childOrder.components.forEach(component =>
            {
              usedComponents.add(component.nc12);

              if (paintNames.has(component.nc12))
              {
                return;
              }

              if (!byPaint.has(paintKey))
              {
                byPaint.set(paintKey, {
                  paints: childOrderPaints,
                  components: new Map()
                });
              }

              const {components} = byPaint.get(paintKey);

              if (!components.has(component.nc12))
              {
                components.set(component.nc12, {
                  drilling: !!psOrder.drilling,
                  nc12: component.nc12,
                  name: component.name,
                  unit: component.unit,
                  qtyPerPce: (component.qty / childOrder.qty) * (childOrder.qty / psOrder.qty)
                });
              }
            });
          });
        });

        this.groupedPsOrders = groupedPsOrders;
        this.paintNames = paintNames;

        PaintShopIgnoredComponent
          .find({
            _id: Array.from(usedComponents),
            mrps: whOrders[0].mrp
          })
          .select({_id: 1})
          .lean()
          .exec(this.parallel());
      },
      function(err, ignoredComponents)
      {
        if (err)
        {
          return this.skip(err);
        }

        ignoredComponents = new Set(ignoredComponents.map(c => c._id));

        const orders = [];

        groupedWhOrders.forEach((whOrderGroup, orderNo) =>
        {
          const psOrderGroup = this.groupedPsOrders.get(orderNo);

          if (!psOrderGroup)
          {
            return;
          }

          const carts = new Set();

          whOrderGroup.orders.forEach(whOrder =>
          {
            whOrder.funcs[WhOrder.FUNCS_IDX.painter].carts.forEach(cart =>
            {
              carts.add(cart);
            });
          });

          const order = {
            carts: Array.from(carts),
            lines: [],
            comments: psOrderGroup.comments
          };

          orders.push(order);

          order.lines.push({
            type: 'order',
            orderNo,
            nc12: psOrderGroup.psOrder.nc12,
            qty: whOrderGroup.qty.toLocaleString(),
            unit: 'PCE',
            name: psOrderGroup.psOrder.name,
            ignored: false
          });

          Array.from(psOrderGroup.byPaint.keys()).sort().forEach(paintKey =>
          {
            const {paints, components} = psOrderGroup.byPaint.get(paintKey);

            paints.forEach(paintCode =>
            {
              if (paintCode === '000000000000')
              {
                return;
              }

              order.lines.push({
                type: 'paint',
                orderNo: '',
                nc12: paintCode,
                qty: '',
                unit: '',
                name: this.paintNames.get(paintCode),
                ignored: false
              });
            });

            components.forEach(component =>
            {
              order.lines.push({
                type: component.drilling ? 'drilled' : 'painted',
                orderNo: '',
                nc12: component.nc12,
                qty: component.qtyPerPce * whOrderGroup.qty,
                unit: component.unit,
                name: component.name,
                ignored: ignoredComponents.has(component.nc12)
              });
            });
          });
        });

        const whUserOrder = whOrders.find(whOrder => !!whOrder.funcs[WhOrder.FUNCS_IDX.painter].user);
        const renderTemplate = app.options.env === 'production'
          ? template
          : ejs.compile(fs.readFileSync(templateFile, 'utf8'), {
            cache: false,
            filename: templateFile,
            compileDebug: true,
            rmWhitespace: true
          });
        const html = renderTemplate({
          date: moment.utc(whOrders[0].date).format('L'),
          set: (whOrders[0].set || -1).toString(),
          mrp: whOrders[0].mrp,
          line: whOrders[0].line,
          user: whUserOrder ? whUserOrder.funcs[WhOrder.FUNCS_IDX.painter].user.label : '',
          orders
        });
        const options = {
          orientation: 'portrait',
          format: 'A4',
          margin: {
            top: '0mm',
            right: '0mm',
            bottom: '0mm',
            left: '0mm'
          }
        };

        html2pdf.generatePdf(html, options, this.parallel());
      },
      function(err, result)
      {
        if (err)
        {
          return this.skip(app.createError(
            `Failed to generate PS picklist PDF: ${err.message}`,
            'GENERATE_FAILURE'
          ));
        }

        if (options && options.print === false)
        {
          return this.done(resolve, html2pdf.getPdfFilePath(result.hash));
        }

        html2pdf.printPdf(result.hash, this.printer, '', this.next());
      },
      function(err)
      {
        if (err)
        {
          return this.skip(app.createError(
            `Failed to print PS picklist PDF: ${err.message}`,
            'PRINT_FAILURE'
          ));
        }
      },
      function(err)
      {
        if (err)
        {
          return reject(err);
        }

        resolve();
      }
    );
  });
};
