// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const moment = require('moment');
const jsonDeepEqual = require('util/jsonDeepEqual');

module.exports = (app, module) =>
{
  const {
    OldWhEvent: WhEvent,
    OldWhLine: WhLine,
    OldWhOrder: WhOrder
  } = module;

  const AT = Symbol();
  const NOW_EVENTS = {
    newSetStarted: true,
    assignedToSet: true
  };
  const SCHEDULE_EVENTS = {
    picklistDone: true,
    picklist: true,
    pickup: true,
    ordersCancelled: true,
    ordersReset: true,
    problemSolved: true,
    deliveryStarted: true,
    lineRedirStarted: true,
    lineRedirStopped: true,
    deliveredOrderEdited: true
  };

  const pickupStatus = {
    updatedAt: 0,
    funcs: {
      fmx: false,
      kitter: false,
      platformer: false,
      packer: false
    }
  };
  let updateTimer = null;
  let updating = false;
  let updateAgain = false;

  app.broker.subscribe(`${WhEvent.TOPIC_PREFIX}.updated`, handleEvents);
  app.broker.subscribe(`${WhLine.TOPIC_PREFIX}.updated`, () => scheduleUpdate(2000));

  return {
    scheduleUpdate,
    updateNow,
    get: () => pickupStatus
  };

  function scheduleUpdate(maxDiff)
  {
    const now = Date.now();

    if (updateTimer && updateTimer[AT] < (now + maxDiff))
    {
      return;
    }

    clearTimeout(updateTimer);
    updateTimer = null;

    const diff = now - pickupStatus.updatedAt;

    if (diff >= maxDiff)
    {
      updateNow();
    }
    else
    {
      const delay = maxDiff - diff;

      updateTimer = setTimeout(updateNow, delay);
      updateTimer[AT] = now + delay;
    }
  }

  async function updateNow()
  {
    clearTimeout(updateTimer);
    updateTimer = null;

    if (updating)
    {
      updateAgain = true;

      return;
    }

    updating = true;

    try
    {
      const availableLines = await findAvailableLines();

      const pendingConditions = {
        status: 'pending',
        date: {
          $gte: moment.utc().startOf('day').subtract(7, 'days').toDate()
        },
        'lines._id': {$in: availableLines}
      };

      if (!module.state.settings.ignorePsStatus)
      {
        pendingConditions.psStatus = {$in: ['unknown', 'finished']};
      }

      const enabledMrps = module.state.settings.enabledMrps || [];

      if (Array.isArray(enabledMrps) && enabledMrps.length)
      {
        pendingConditions.mrp = {$in: enabledMrps};
      }

      const [fmx, kitter, platformer, packer] = await Promise.all([
        WhOrder
          .findOne({
            $or: [
              pendingConditions,
              {
                status: 'started',
                [`funcs.${WhOrder.FUNCS_IDX.fmx}.user`]: {$type: 'null'}
              }
            ]
          })
          .select({_id: 1})
          .lean()
          .exec(),
        WhOrder
          .findOne({
            $or: [
              pendingConditions,
              {
                status: 'started',
                [`funcs.${WhOrder.FUNCS_IDX.kitter}.user`]: {$type: 'null'}
              }
            ]
          })
          .select({_id: 1})
          .lean()
          .exec(),
        WhOrder
          .findOne({
            status: 'started',
            [`funcs.${WhOrder.FUNCS_IDX.platformer}.user`]: {$type: 'null'},
            [`funcs.${WhOrder.FUNCS_IDX.fmx}.pickup`]: 'success',
            [`funcs.${WhOrder.FUNCS_IDX.kitter}.status`]: 'finished'
          })
          .select({_id: 1})
          .lean()
          .exec(),
        WhOrder
          .findOne({
            status: 'started',
            [`funcs.${WhOrder.FUNCS_IDX.packer}.user`]: {$type: 'null'},
            picklistDone: 'success'
          })
          .select({_id: 1})
          .lean()
          .exec()
      ]);

      const newFuncs = {
        fmx: !!fmx,
        kitter: !!kitter,
        platformer: !!platformer,
        packer: !!packer
      };

      pickupStatus.updatedAt = Date.now();

      if (!jsonDeepEqual(pickupStatus.funcs, newFuncs))
      {
        pickupStatus.funcs = newFuncs;

        app.broker.publish(`old.wh.pickupStatus.updated`, pickupStatus);
      }
    }
    catch (err)
    {
      module.error(err, 'Failed to update pickup status.');
    }

    updating = false;

    if (updateAgain)
    {
      updateAgain = false;

      updateNow();
    }
    else
    {
      scheduleUpdate(30000);
    }
  }

  async function findAvailableLines()
  {
    const maxSetsPerLine = module.state.settings.maxSetsPerLine || 2;
    const allLines = await WhLine
      .find()
      .select({pickup: 1, redirLine: 1})
      .lean()
      .exec();
    const redirLines = new Map();
    const availableLines = new Set();

    allLines.forEach(line =>
    {
      if (line.redirLine)
      {
        redirLines.set(line._id, line.redirLine);
      }

      if (line.pickup.sets < maxSetsPerLine)
      {
        availableLines.add(line._id);
      }
    });

    availableLines.forEach(line =>
    {
      const redirLine = redirLines.get(line);

      if (redirLine && !availableLines.has(redirLine))
      {
        availableLines.delete(line);
      }
    });

    return Array.from(availableLines);
  }

  function handleEvents({added})
  {
    let schedule = false;
    let now = false;

    for (const event of added)
    {
      if (NOW_EVENTS[event.type])
      {
        now = true;

        break;
      }

      if (SCHEDULE_EVENTS[event.type])
      {
        schedule = true;
      }
    }

    if (now)
    {
      updateNow();
    }
    else if (schedule)
    {
      scheduleUpdate(1000);
    }
  }
};
