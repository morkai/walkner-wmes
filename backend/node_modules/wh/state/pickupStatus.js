// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const moment = require('moment');
const jsonDeepEqual = require('util/jsonDeepEqual');

module.exports = (app, module) =>
{
  const {
    OldWhEvent: WhEvent,
    OldWhLine: WhLine,
    OldWhOrder: WhOrder
  } = module;

  const AT = Symbol();
  const NOW_EVENTS = {
    newSetStarted: true,
    assignedToSet: true
  };
  const SCHEDULE_EVENTS = {
    picklistDone: true,
    picklist: true,
    pickup: true,
    ordersCancelled: true,
    ordersReset: true,
    problemSolved: true,
    deliveryStarted: true,
    lineRedirStarted: true,
    lineRedirStopped: true,
    deliveredOrderEdited: true
  };
  const SCHEDULE_SETTINGS = {
    'wh.planning.ignorePsStatus': true,
    'wh.planning.psPickupStatus': true,
    'wh.planning.enabledMrps': true,
    'wh.planning.maxSetsPerLine': true
  };

  const pickupStatus = {
    updatedAt: 0,
    funcs: {
      fmx: false,
      kitter: false,
      platformer: false,
      packer: false,
      painter: false
    }
  };
  let updateTimer = null;
  let updating = false;
  let updateAgain = false;

  app.broker.subscribe(`${WhEvent.TOPIC_PREFIX}.updated`, handleEvents);
  app.broker.subscribe(`${WhLine.TOPIC_PREFIX}.updated`, () => scheduleUpdate(2000));
  app.broker.subscribe(`${WhOrder.TOPIC_PREFIX}.updated.psStatus`, () => scheduleUpdate(2000));
  app.broker.subscribe(`settings.updated.wh.planning.*`, onSettingUpdated);

  setInterval(updateNow, 10000);

  return {
    scheduleUpdate,
    updateNow,
    get: () => pickupStatus
  };

  function scheduleUpdate(maxDiff)
  {
    const now = Date.now();

    if (updateTimer && updateTimer[AT] < (now + maxDiff))
    {
      return;
    }

    clearTimeout(updateTimer);
    updateTimer = null;

    const diff = now - pickupStatus.updatedAt;

    if (diff >= maxDiff)
    {
      updateNow();
    }
    else
    {
      const delay = maxDiff - diff;

      updateTimer = setTimeout(updateNow, delay);
      updateTimer[AT] = now + delay;
    }
  }

  async function updateNow()
  {
    clearTimeout(updateTimer);
    updateTimer = null;

    if (updating)
    {
      updateAgain = true;

      return;
    }

    updating = true;

    try
    {
      const availableLines = await findAvailableLines();

      const pendingConditions = {
        status: 'pending',
        date: {
          $gte: moment.utc().startOf('day').subtract(7, 'days').toDate()
        },
        'lines._id': {$in: availableLines}
      };

      const {ignorePsStatus, enabledMrps} = module.state.settings;

      if (Array.isArray(ignorePsStatus) && ignorePsStatus.length)
      {
        pendingConditions.psStatus = {$nin: ignorePsStatus};
      }

      if (Array.isArray(enabledMrps) && enabledMrps.length)
      {
        pendingConditions.mrp = {$in: enabledMrps};
      }

      const [fmx, kitter, platformer, packer, painter] = await Promise.all([
        checkFmxStatus(pendingConditions),
        checkKitterStatus(pendingConditions),
        checkPlatformerStatus(),
        checkPackerStatus(),
        checkPainterStatus()
      ]);

      const newFuncs = {
        fmx,
        kitter,
        platformer,
        packer,
        painter
      };

      pickupStatus.updatedAt = Date.now();

      if (!jsonDeepEqual(pickupStatus.funcs, newFuncs))
      {
        pickupStatus.funcs = newFuncs;

        app.broker.publish(`old.wh.pickupStatus.updated`, pickupStatus);
      }
    }
    catch (err)
    {
      module.error(err, 'Failed to update pickup status.');
    }

    updating = false;

    if (updateAgain)
    {
      updateAgain = false;

      updateNow();
    }
    else
    {
      scheduleUpdate(30000);
    }
  }

  async function checkFmxStatus(pendingConditions)
  {
    const whOrder = await WhOrder
      .findOne({
        $or: [
          pendingConditions,
          {
            status: {$in: ['started', 'problem']},
            [`funcs.${WhOrder.FUNCS_IDX.fmx}.user`]: {$type: 'null'},
            picklistDone: {$ne: 'failure'}
          }
        ]
      })
      .select({_id: 1})
      .hint({status: 1, date: -1})
      .lean()
      .exec();

    return !!whOrder;
  }

  async function checkKitterStatus(pendingConditions)
  {
    const whOrder = await WhOrder
      .findOne({
        $or: [
          pendingConditions,
          {
            status: {$in: ['started', 'problem']},
            [`funcs.${WhOrder.FUNCS_IDX.kitter}.user`]: {$type: 'null'},
            picklistDone: {$ne: 'failure'}
          }
        ]
      })
      .select({_id: 1})
      .hint({status: 1, date: -1})
      .lean()
      .exec();

    return !!whOrder;
  }

  async function checkPlatformerStatus()
  {
    const whOrder = await WhOrder
      .findOne({
        status: {$in: ['started', 'problem']},
        [`funcs.${WhOrder.FUNCS_IDX.platformer}.user`]: {$type: 'null'},
        [`funcs.${WhOrder.FUNCS_IDX.fmx}.pickup`]: 'success',
        [`funcs.${WhOrder.FUNCS_IDX.kitter}.status`]: 'finished',
        picklistDone: {$ne: 'failure'}
      })
      .select({_id: 1})
      .hint({status: 1, date: -1})
      .lean()
      .exec();

    return !!whOrder;
  }

  async function checkPackerStatus()
  {
    const whOrder = await WhOrder
      .findOne({
        status: {$in: ['started', 'problem']},
        [`funcs.${WhOrder.FUNCS_IDX.packer}.user`]: {$type: 'null'},
        picklistDone: {$ne: 'failure'}
      })
      .select({_id: 1})
      .hint({status: 1, date: -1})
      .lean()
      .exec();

    return !!whOrder;
  }

  async function checkPainterStatus()
  {
    const {psPickupStatus, psPickupReadyFuncs} = module.state.settings;

    const $project = {
      _id: 0,
      date: 1,
      set: 1,
      psStatus: 1,
      picklistDone: 1
    };
    const $and = [
      {$in: ['$psStatus', Array.isArray(psPickupStatus) ? psPickupStatus : []]}
    ];

    if (Array.isArray(psPickupReadyFuncs))
    {
      psPickupReadyFuncs.forEach(funcId =>
      {
        const funcI = WhOrder.FUNCS_IDX[funcId];

        if (typeof funcI === 'number')
        {
          $project[funcId] = {
            $arrayElemAt: ['$funcs', funcI]
          };

          $and.push({
            $eq: [`$${funcId}.status`, 'finished']
          });
        }
      });
    }

    const whOrders = await WhOrder
      .aggregate([
        {$match: {
          status: {$in: ['started', 'problem']},
          [`funcs.${WhOrder.FUNCS_IDX.painter}.user`]: {$type: 'null'},
          picklistDone: {$ne: 'failure'},
          psStatus: {$ne: 'unknown'}
        }},
        {$project},
        {$group: {
          _id: {
            date: '$date',
            set: '$set'
          },
          all: {$sum: 1},
          ready: {$sum: {$cond: {
            if: {$and},
            then: 1,
            else: 0
          }}},
          picklistDone: {$sum: {$cond: {
            if: {$eq: ['$picklistDone', 'success']},
            then: 1,
            else: 0
          }}}
        }},
        {$match: {
          $and: [
            {$expr: {$eq: ['$picklistDone', '$all']}},
            {$expr: {$eq: ['$ready', '$all']}}
          ]
        }},
        {$limit: 1},
        {$project: {_id: 1}}
      ])
      .hint({status: 1, date: -1})
      .exec();

    return whOrders.length === 1;
  }

  async function findAvailableLines()
  {
    const maxSetsPerLine = module.state.settings.maxSetsPerLine || 2;
    const allLines = await WhLine
      .find()
      .select({pickup: 1, redirLine: 1})
      .lean()
      .exec();
    const redirLines = new Map();
    const availableLines = new Set();

    allLines.forEach(line =>
    {
      if (line.redirLine)
      {
        redirLines.set(line._id, line.redirLine);
      }

      if (line.pickup.total.sets < maxSetsPerLine
        || module.state.pendingPriorityLines.includes(line._id))
      {
        availableLines.add(line._id);
      }
    });

    availableLines.forEach(line =>
    {
      const redirLine = redirLines.get(line);

      if (redirLine && !availableLines.has(redirLine))
      {
        availableLines.delete(line);
      }
    });

    return Array.from(availableLines);
  }

  function handleEvents({added})
  {
    let schedule = false;
    let now = false;

    for (const event of added)
    {
      if (NOW_EVENTS[event.type])
      {
        now = true;

        break;
      }

      if (SCHEDULE_EVENTS[event.type])
      {
        schedule = true;
      }
    }

    if (now)
    {
      updateNow();
    }
    else if (schedule)
    {
      scheduleUpdate(1000);
    }
  }

  function onSettingUpdated(setting)
  {
    if (SCHEDULE_SETTINGS[setting.id])
    {
      scheduleUpdate(5000);
    }
  }
};
