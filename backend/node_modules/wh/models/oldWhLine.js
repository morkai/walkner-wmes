// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

exports.name = 'OldWhLine';

exports.setUp = (app, mongoose) =>
{
  const number = {type: Number, default: 0};
  const lineSchema = new mongoose.Schema({
    _id: String,
    pickup: {
      started: {
        sets: number,
        qty: number,
        time: number
      },
      finished: {
        sets: number,
        qty: number,
        time: number
      },
      total: {
        sets: number,
        qty: number,
        time: number
      }
    },
    available: {
      qty: number,
      time: number
    },
    redirLine: {
      type: String,
      default: null
    },
    nextShiftAt: {
      type: Date,
      default: null
    },
    startedPlan: {
      type: Date,
      default: () => new Date(0)
    },
    mrps: [String]
  }, {
    id: false,
    minimize: false,
    versionKey: false
  });

  lineSchema.statics.TOPIC_PREFIX = 'old.wh.lines';
  lineSchema.statics.BROWSE_LIMIT = 1000;

  lineSchema.statics.lockLines = function(lines)
  {
    const WhLine = this;

    const locks = lines.map(lineOrId =>
    {
      const id = lineOrId._id || lineOrId;

      return id ? app.wh.state.lock(`${WhLine.TOPIC_PREFIX}.${id}`) : null;
    });

    return Promise.all(locks);
  };

  lineSchema.statics.startNewSet = async function(setOrders, session)
  {
    const WhLine = this;

    const result = {
      updated: [],
      messages: []
    };

    const lineList = await WhLine
      .find({_id: {$in: setOrders[0].lines.map(({_id}) => _id)}})
      .lean()
      .session(session)
      .exec();
    const lineMap = new Map();
    const operations = [];

    lineList.forEach(line =>
    {
      result.updated.push(line);

      lineMap.set(line._id, line);

      operations.push({
        updateOne: {
          filter: {_id: line._id},
          update: {$set: {
            pickup: line.pickup
          }}
        }
      });

      line.pickup.started.sets += 1;
      line.pickup.total.sets += 1;
    });

    setOrders.forEach(whOrder =>
    {
      whOrder.lines.forEach(whOrderLine =>
      {
        const line = lineMap.get(whOrderLine._id);

        line.pickup.started.qty += whOrderLine.qty;
        line.pickup.started.time += whOrderLine.qty * whOrderLine.pceTime;
        line.pickup.total.qty += whOrderLine.qty;
        line.pickup.total.time += whOrderLine.qty * whOrderLine.pceTime;
      });
    });

    await WhLine.collection.bulkWrite(operations, {session});

    result.messages.push({
      topic: `${WhLine.TOPIC_PREFIX}.updated`,
      message: {
        updated: result.updated
      }
    });

    return result;
  };

  lineSchema.statics.recountByWhOrder = async function(whOrder, recountPickup, recountAvailable)
  {
    const WhLine = this;

    await WhLine.lockLines(whOrder.lines);

    return Promise.all(
      whOrder.lines.map(
        whOrderLine => WhLine.recount(whOrderLine._id, recountPickup, recountAvailable, whOrder.$session())
      )
    );
  };

  lineSchema.statics.recount = async function(lineId, recountPickup, recountAvailable, session)
  {
    const WhLine = this;
    const WhOrder = mongoose.model('OldWhOrder');
    const WhDeliveredOrder = mongoose.model('OldWhDeliveredOrder');

    const result = {
      updated: [],
      messages: []
    };

    const [whLine, whOrders, whDeliveredOrders] = await Promise.all([
      WhLine
        .findById(lineId)
        .lean()
        .session(session)
        .exec(),
      !recountPickup ? null : WhOrder
        .find({
          distStatus: 'pending',
          'lines._id': lineId,
          status: {$in: ['started', 'problem', 'finished']},
          set: {$ne: null}
        })
        .select({
          _id: 0,
          status: 1,
          date: 1,
          set: 1,
          lines: 1,
          'funcs.status': 1
        })
        .lean()
        .session(session)
        .exec(),
      !recountAvailable ? null : WhDeliveredOrder
        .find({
          line: lineId,
          status: 'todo'
        })
        .select({_id: 0, qtyRemaining: 1, pceTime: 1})
        .lean()
        .session(session)
        .exec()
    ]);

    if (!whLine)
    {
      return result;
    }

    const {pickup, available} = whLine;
    const $set = {};

    if (recountPickup)
    {
      const sets = new Map();

      whOrders.forEach(whOrder =>
      {
        const whOrderLine = whOrder.lines.find(({_id}) => _id === whLine._id);

        if (!whOrderLine)
        {
          return;
        }

        const key = `${whOrder.date.getTime()}:${whOrder.set}`;

        if (!sets.has(key))
        {
          sets.set(key, {
            started: 0,
            finished: 0,
            orders: []
          });
        }

        if (whOrder.status === 'problem')
        {
          whOrder.status = whOrder.funcs.every(func => func.status === 'problem' || func.status === 'finished')
            ? 'finished'
            : 'started';
        }

        const set = sets.get(key);

        set[whOrder.status] += 1;
        set.orders.push(whOrderLine);
      });

      Object.keys(pickup).forEach(status =>
      {
        Object.keys(pickup[status]).forEach(counter =>
        {
          pickup[status][counter] = 0;
        });
      });

      sets.forEach(set =>
      {
        const status = set.started ? 'started' : 'finished';

        pickup.total.sets += 1;
        pickup[status].sets += 1;

        set.orders.forEach(({qty, pceTime}) =>
        {
          pickup.total.qty += qty;
          pickup.total.time += qty * pceTime;
          pickup[status].qty += qty;
          pickup[status].time += qty * pceTime;
        });
      });

      $set.pickup = pickup;
    }

    if (recountAvailable)
    {
      available.qty = 0;
      available.time = 0;

      whDeliveredOrders.forEach(whDeliveredOrder =>
      {
        available.qty += whDeliveredOrder.qtyRemaining;
        available.time += whDeliveredOrder.qtyRemaining * whDeliveredOrder.pceTime;
      });

      $set.available = available;
    }

    await WhLine.collection.updateOne({_id: whLine._id}, {$set}, {session});

    result.updated.push(whLine);

    result.messages.push({
      topic: `${WhLine.TOPIC_PREFIX}.updated`,
      message: {
        updated: result.updated
      }
    });

    return result;
  };

  lineSchema.statics.recountPickup = async function(lineId, session)
  {
    return await this.recount(lineId, true, false, session);
  };

  lineSchema.statics.recountAvailable = async function(lineId, session)
  {
    return await this.recount(lineId, false, true, session);
  };

  mongoose.model(exports.name, lineSchema);
};
