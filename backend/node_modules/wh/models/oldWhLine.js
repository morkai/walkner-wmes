// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

exports.name = 'OldWhLine';

exports.setUp = (app, mongoose) =>
{
  const number = {type: Number, default: 0};
  const lineSchema = new mongoose.Schema({
    _id: String,
    pickup: {
      sets: number,
      qty: number,
      time: number
    },
    components: {
      qty: number,
      time: number
    },
    packaging: {
      qty: number,
      time: number
    },
    redirLine: {
      type: String,
      default: null
    },
    nextShiftAt: {
      type: Date,
      default: null
    },
    startedPlan: {
      type: Date,
      default: () => new Date(0)
    }
  }, {
    id: false,
    minimize: false,
    versionKey: false
  });

  lineSchema.statics.TOPIC_PREFIX = 'old.wh.lines';
  lineSchema.statics.BROWSE_LIMIT = 1000;

  lineSchema.statics.lockLines = function(lines)
  {
    const WhLine = this;

    const locks = lines.map(lineOrId =>
    {
      const id = lineOrId._id || lineOrId;

      return app.wh.state.lock(`${WhLine.TOPIC_PREFIX}.${id}`);
    });

    return Promise.all(locks);
  };

  lineSchema.statics.startNewSet = async function(setOrders, session)
  {
    const WhLine = this;

    const result = {
      updated: [],
      messages: []
    };

    const lineList = await WhLine
      .find({_id: {$in: setOrders[0].lines.map(({_id}) => _id)}})
      .lean()
      .session(session)
      .exec();
    const lineMap = new Map();
    const operations = [];

    lineList.forEach(line =>
    {
      result.updated.push(line);

      lineMap.set(line._id, line);

      operations.push({
        updateOne: {
          filter: {_id: line._id},
          update: {$set: {
            pickup: line.pickup
          }}
        }
      });

      line.pickup.sets += 1;
    });

    setOrders.forEach(whOrder =>
    {
      whOrder.lines.forEach(whOrderLine =>
      {
        const line = lineMap.get(whOrderLine._id);

        line.pickup.qty += whOrderLine.qty;
        line.pickup.time += whOrderLine.qty * whOrderLine.pceTime;
      });
    });

    await WhLine.collection.bulkWrite(operations, {session});

    result.messages.push({
      topic: `${WhLine.TOPIC_PREFIX}.updated`,
      message: {
        updated: result.updated
      }
    });

    return result;
  };

  lineSchema.statics.recountPickupByWhOrder = async function(whOrder)
  {
    const WhLine = this;

    await WhLine.lockLines(whOrder.lines);

    return Promise.all(
      whOrder.lines.map(
        whOrderLine => WhLine.recountPickup(whOrderLine._id, whOrder.$session())
      )
    );
  };

  lineSchema.statics.recount = async function(lineId, recountPickup, recountComponents, session)
  {
    const WhLine = this;
    const WhOrder = mongoose.model('OldWhOrder');
    const WhDeliveredOrder = mongoose.model('OldWhDeliveredOrder');

    const result = {
      updated: [],
      messages: []
    };

    const [whLine, whOrders, whDeliveredOrders] = await Promise.all([
      WhLine
        .findById(lineId)
        .lean()
        .session(session)
        .exec(),
      !recountPickup ? null : WhOrder
        .find({
          distStatus: 'pending',
          'lines._id': lineId,
          status: {$in: ['started', 'finished', 'problem']}
        })
        .select({_id: 0, status: 1, date: 1, set: 1, lines: 1})
        .lean()
        .session(session)
        .exec(),
      !recountComponents ? null : WhDeliveredOrder
        .find({
          line: lineId,
          status: 'todo'
        })
        .select({_id: 0, qtyRemaining: 1, pceTime: 1})
        .lean()
        .session(session)
        .exec()
    ]);

    if (!whLine)
    {
      return result;
    }

    const {pickup, components} = whLine;
    const $set = {};

    if (recountPickup)
    {
      const sets = new Map();

      whOrders.forEach(whOrder =>
      {
        const whOrderLine = whOrder.lines.find(({_id}) => _id === whLine._id);

        if (!whOrderLine)
        {
          return;
        }

        const key = `${whOrder.date.getTime()}:${whOrder.set}`;

        if (!sets.has(key))
        {
          sets.set(key, {problem: false, orders: []});
        }

        const set = sets.get(key);

        set.orders.push(whOrderLine);

        if (whOrder.status === 'problem')
        {
          set.problem = true;
        }
      });

      pickup.sets = 0;
      pickup.qty = 0;
      pickup.time = 0;

      sets.forEach(set =>
      {
        if (set.problem)
        {
          return;
        }

        pickup.sets += 1;

        set.orders.forEach(({qty, pceTime}) =>
        {
          pickup.qty += qty;
          pickup.time += qty * pceTime;
        });
      });

      $set.pickup = pickup;
    }

    if (recountComponents)
    {
      components.qty = 0;
      components.time = 0;

      whDeliveredOrders.forEach(whDeliveredOrder =>
      {
        components.qty += whDeliveredOrder.qtyRemaining;
        components.time += whDeliveredOrder.qtyRemaining * whDeliveredOrder.pceTime;
      });

      $set.components = components;
    }

    await WhLine.collection.updateOne({_id: whLine._id}, {$set}, {session});

    result.updated.push(whLine);

    result.messages.push({
      topic: `${WhLine.TOPIC_PREFIX}.updated`,
      message: {
        updated: result.updated
      }
    });

    return result;
  };

  lineSchema.statics.recountPickup = async function(lineId, session)
  {
    return await this.recount(lineId, true, false, session);
  };

  lineSchema.statics.recountComponents = async function(lineId, session)
  {
    return await this.recount(lineId, false, true, session);
  };

  mongoose.model(exports.name, lineSchema);
};
