// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const moment = require('moment');
const shifts = require('util/shifts');

exports.name = 'OldWhLine';

exports.setUp = (app, mongoose) =>
{
  const number = {type: Number, default: 0};
  const lineSchema = new mongoose.Schema({
    _id: String,
    pickup: {
      started: {
        sets: number,
        qty: number,
        time: number
      },
      finished: {
        sets: number,
        qty: number,
        time: number
      },
      total: {
        sets: number,
        qty: number,
        time: number
      }
    },
    available: {
      qty: number,
      time: number
    },
    redirLine: {
      type: String,
      default: null
    },
    nextShiftAt: {
      type: Date,
      default: null
    },
    startedPlan: {
      type: Date,
      default: () => new Date(0)
    },
    planDone: {
      type: Boolean,
      default: false
    },
    mrps: [String]
  }, {
    id: false,
    minimize: false,
    versionKey: false
  });

  lineSchema.statics.TOPIC_PREFIX = 'old.wh.lines';
  lineSchema.statics.BROWSE_LIMIT = 1000;

  lineSchema.statics.lockLines = function(lines)
  {
    const WhLine = this;

    lines = Array.from(new Set(lines.map(lineOrId => lineOrId._id || lineOrId)));

    return Promise.all(lines.map(id =>
    {
      return id ? app.wh.state.lock(`${WhLine.TOPIC_PREFIX}.${id}`) : null;
    }));
  };

  lineSchema.statics.startNewSet = async function(setOrders, session)
  {
    const WhLine = this;
    const WhOrder = mongoose.model('OldWhOrder');

    const result = {
      updated: [],
      messages: []
    };

    const lineIds = Array.from(new Set(setOrders[0].lines.map(({_id}) => _id)));

    const lineList = await WhLine
      .find({_id: {$in: lineIds}})
      .lean()
      .session(session)
      .exec();
    const lineMap = new Map();
    const operations = new Map();
    const planDonePromises = [];
    const today = shifts.getCurrentDate(true);

    lineList.forEach(line =>
    {
      result.updated.push(line);

      lineMap.set(line._id, line);

      operations.set(line._id, {
        updateOne: {
          filter: {_id: line._id},
          update: {$set: {
            pickup: line.pickup
          }}
        }
      });

      line.pickup.started.sets += 1;
      line.pickup.total.sets += 1;

      const startedPlan = line.startedPlan < today.valueOf() ? today : moment.utc(line.startedPlan);

      planDonePromises.push(
        WhOrder
          .findOne({
            status: 'pending',
            'lines._id': line._id,
            date: {
              $gte: startedPlan.clone().subtract(7, 'days').toDate(),
              $lte: startedPlan.toDate()
            },
            _id: {$nin: setOrders.map(setOrder => setOrder._id)}
          })
          .select({
            _id: 1
          })
          .lean()
          .session(session)
          .exec()
      );
    });

    const planDoneOrders = await Promise.all(planDonePromises);

    planDoneOrders.forEach((whOrder, i) =>
    {
      const line = lineList[i];
      const planDone = !whOrder;

      if (planDone === line.planDone)
      {
        return;
      }

      const update = operations.get(line._id).updateOne.update.$set;

      update.planDone = planDone;
      line.planDone = planDone;
    });

    setOrders.forEach(whOrder =>
    {
      whOrder.lines.forEach(whOrderLine =>
      {
        const line = lineMap.get(whOrderLine._id);

        line.pickup.started.qty += whOrderLine.qty;
        line.pickup.started.time += whOrderLine.qty * whOrderLine.pceTime;
        line.pickup.total.qty += whOrderLine.qty;
        line.pickup.total.time += whOrderLine.qty * whOrderLine.pceTime;
      });
    });

    await WhLine.collection.bulkWrite(Array.from(operations.values()), {session});

    result.messages.push({
      topic: `${WhLine.TOPIC_PREFIX}.updated`,
      message: {
        updated: result.updated
      }
    });

    return result;
  };

  lineSchema.statics.recountByWhOrder = async function(whOrder, recountPickup, recountAvailable)
  {
    const WhLine = this;
    const lines = Array.from(new Set(whOrder.lines.map(whOrderLine => whOrderLine._id)));

    await WhLine.lockLines(lines);

    return Promise.all(
      lines.map(
        lineId => WhLine.recount(lineId, recountPickup, recountAvailable, whOrder.$session())
      )
    );
  };

  lineSchema.statics.recount = async function(lineId, recountPickup, recountAvailable, session)
  {
    const WhLine = this;
    const WhOrder = mongoose.model('OldWhOrder');
    const WhDeliveredOrder = mongoose.model('OldWhDeliveredOrder');

    const result = {
      updated: [],
      messages: []
    };

    if (!recountPickup && !recountAvailable)
    {
      return result;
    }

    const [whLine, whOrders, whDeliveredOrders] = await Promise.all([
      WhLine
        .findById(lineId)
        .lean()
        .session(session)
        .exec(),
      !recountPickup ? null : WhOrder
        .find({
          distStatus: 'pending',
          'lines._id': lineId,
          status: {$in: ['started', 'problem', 'finished']},
          set: {$ne: null},
          setDistStarted: false
        })
        .select({
          _id: 0,
          status: 1,
          date: 1,
          set: 1,
          lines: 1,
          'funcs.status': 1
        })
        .lean()
        .session(session)
        .exec(),
      !recountAvailable ? null : WhDeliveredOrder
        .find({
          line: lineId,
          status: 'todo'
        })
        .select({_id: 0, qtyRemaining: 1, pceTime: 1})
        .lean()
        .session(session)
        .exec()
    ]);

    if (!whLine)
    {
      return result;
    }

    const {pickup, available} = whLine;
    const $set = {};

    const today = shifts.getCurrentDate(true);
    const startedPlan = whLine.startedPlan < today.valueOf() ? today : moment.utc(whLine.startedPlan.getTime());
    const pendingOrder = await WhOrder
      .findOne({
        status: 'pending',
        'lines._id': lineId,
        date: {
          $gte: startedPlan.clone().subtract(7, 'days').toDate(),
          $lte: startedPlan.toDate()
        }
      })
      .select({_id: 1})
      .lean()
      .session(session)
      .exec();
    const planDone = !pendingOrder;

    if (planDone !== whLine.planDone)
    {
      whLine.planDone = planDone;
      $set.planDone = planDone;
    }

    if (recountPickup)
    {
      const sets = new Map();

      whOrders.forEach(whOrder =>
      {
        const whOrderLine = whOrder.lines.find(({_id}) => _id === whLine._id);

        if (!whOrderLine)
        {
          return;
        }

        const key = `${whOrder.date.getTime()}:${whOrder.set}`;

        if (!sets.has(key))
        {
          sets.set(key, {
            started: 0,
            finished: 0,
            orders: []
          });
        }

        if (whOrder.status === 'problem')
        {
          whOrder.status = whOrder.funcs.every(func => func.status === 'problem' || func.status === 'finished')
            ? 'finished'
            : 'started';
        }

        const set = sets.get(key);

        set[whOrder.status] += 1;
        set.orders.push(whOrderLine);
      });

      Object.keys(pickup).forEach(status =>
      {
        Object.keys(pickup[status]).forEach(counter =>
        {
          pickup[status][counter] = 0;
        });
      });

      sets.forEach(set =>
      {
        const status = set.started ? 'started' : 'finished';

        pickup.total.sets += 1;
        pickup[status].sets += 1;

        set.orders.forEach(({qty, pceTime}) =>
        {
          pickup.total.qty += qty;
          pickup.total.time += qty * pceTime;
          pickup[status].qty += qty;
          pickup[status].time += qty * pceTime;
        });
      });

      $set.pickup = pickup;
    }

    if (recountAvailable)
    {
      available.qty = 0;
      available.time = 0;

      whDeliveredOrders.forEach(whDeliveredOrder =>
      {
        available.qty += whDeliveredOrder.qtyRemaining;
        available.time += whDeliveredOrder.qtyRemaining * whDeliveredOrder.pceTime;
      });

      $set.available = available;
    }

    await WhLine.collection.updateOne({_id: whLine._id}, {$set}, {session});

    result.updated.push(whLine);

    result.messages.push({
      topic: `${WhLine.TOPIC_PREFIX}.updated`,
      message: {
        updated: result.updated
      }
    });

    return result;
  };

  lineSchema.statics.recountPickup = async function(lineId, session)
  {
    return await this.recount(lineId, true, false, session);
  };

  lineSchema.statics.recountAvailable = async function(lineId, session)
  {
    return await this.recount(lineId, false, true, session);
  };

  lineSchema.statics.prepareLines = async function(lines)
  {
    const Plan = mongoose.model('Plan');

    const shiftInfo = shifts.getCurrentShiftInfo(true);
    const planDate = shifts.getPlanDate(shiftInfo.time, true).toDate();
    const plannedLineSet = new Set();
    const plannedLineList = await Plan.aggregate([
      {$match: {_id: planDate}},
      {$unwind: '$lines'},
      {$match: {
        [`lines.shiftData.${shiftInfo.no - 1}.orderCount`]: {$gt: 0}
      }},
      {$project: {_id: '$lines._id'}}
    ]);

    plannedLineList.forEach(line => plannedLineSet.add(line._id));

    lines.forEach(line =>
    {
      line.planned = plannedLineSet.has(line._id);
      line.working = !!app.wh && !!app.wh.state.getLineWorkStatus(line._id);
    });

    return lines;
  };

  mongoose.model(exports.name, lineSchema);
};
