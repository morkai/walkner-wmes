// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

exports.name = 'OldWhEvent';

exports.setUp = (app, mongoose) =>
{
  const eventSchema = new mongoose.Schema({
    type: {
      type: String,
      required: true
    },
    time: {
      type: Date,
      required: true
    },
    user: {
      type: {},
      required: true
    },
    objects: [String],
    data: {}
  }, {
    id: false,
    minimize: false,
    versionKey: false
  });

  eventSchema.statics.TOPIC_PREFIX = 'old.wh.events';
  eventSchema.statics.BROWSE_LIMIT = 100;

  eventSchema.index({time: -1});
  eventSchema.index({type: 1, time: -1});
  eventSchema.index({objects: 1, time: -1});
  eventSchema.index({'user.id': 1, time: -1});

  eventSchema.statics.whUser = function(whUser)
  {
    if (whUser && whUser._id)
    {
      return {
        id: whUser._id,
        label: whUser.label,
        func: whUser.func || null
      };
    }

    return null;
  };

  eventSchema.statics.setCarts = function(setCartsResults, whOrder)
  {
    if (!setCartsResults)
    {
      return [];
    }

    const setCarts = [];

    if (Array.isArray(setCartsResults.remaining))
    {
      setCartsResults.remaining.forEach(setCart =>
      {
        setCarts.push({
          id: setCart._id.toString(),
          kind: setCart.kind,
          cart: setCart.cart
        });
      });
    }
    else
    {
      if (Array.isArray(setCartsResults.added))
      {
        setCartsResults.added.forEach(setCart =>
        {
          setCarts.push({
            id: setCart._id.toString(),
            kind: setCart.kind,
            cart: setCart.cart
          });
        });
      }

      if (Array.isArray(setCartsResults.updated))
      {
        setCartsResults.updated.forEach(setCart =>
        {
          if (!whOrder || !Array.isArray(setCart.orders) || setCart.orders.some(o => o.whOrder === whOrder._id))
          {
            setCarts.push({
              id: setCart._id.toString(),
              kind: setCart.kind,
              cart: setCart.cart
            });
          }
        });
      }
    }

    return setCarts;
  };

  eventSchema.statics.orders = function(whOrders)
  {
    return whOrders.map(o =>
    {
      return {
        whOrder: o._id,
        sapOrder: o.order,
        date: o.date,
        set: o.set
      };
    });
  };

  eventSchema.statics.lines = function(model, set)
  {
    const lines = set || new Set();

    if (model.line)
    {
      lines.add(model.line);
    }

    if (Array.isArray(model.lines))
    {
      model.lines.forEach(line =>
      {
        lines.add(line._id || line.id || line);
      });
    }

    if (Array.isArray(model.redirLines))
    {
      model.redirLines.forEach(line =>
      {
        lines.add(line._id || line.id || line);
      });
    }

    return set ? undefined : Array.from(lines);
  };

  eventSchema.statics.record = function(events, session)
  {
    const WhEvent = this;

    if (!Array.isArray(events))
    {
      events = [events];
    }

    events.forEach(event =>
    {
      event.objects = collectObjects(event);
    });

    return WhEvent.insertMany(events, {session, lean: true}).then(() => ({
      added: events,
      messages: [{
        topic: `${WhEvent.TOPIC_PREFIX}.updated`,
        message: {added: events}
      }]
    }));
  };

  function collectObjects({objects, user, data})
  {
    if (!objects)
    {
      objects = new Set();
    }
    else if (Array.isArray(objects))
    {
      objects = new Set(objects);
    }

    if (user && user.id)
    {
      objects.add(user.id);
    }

    ['whUser', 'downtime'].forEach(prop =>
    {
      if (data[prop])
      {
        objects.add(data[prop].id);
      }
    });

    ['lines', 'redirLines', 'setCarts'].forEach(prop =>
    {
      if (data[prop] instanceof Set)
      {
        data[prop] = Array.from(data[prop]);
      }

      if (Array.isArray(data[prop]))
      {
        data[prop].forEach(item =>
        {
          if (typeof item === 'string')
          {
            objects.add(item);
          }
          else if (item.id)
          {
            objects.add(item.id.toString());
          }
          else if (item._id)
          {
            objects.add(item._id.toString());

            if (item.date && item.set)
            {
              const date = item.date.toISOString().substring(0, 10);

              objects.add(date);
              objects.add(`${date}-${item.set}`);
            }
          }
        });
      }
    });

    if (Array.isArray(data.orders))
    {
      data.orders.forEach(o =>
      {
        objects.add(o.whOrder);
        objects.add(o.sapOrder);

        if (o.date && o.set)
        {
          const date = o.date.toISOString().substring(0, 10);

          objects.add(date);
          objects.add(`${date}-${o.set}`);
        }
      });
    }

    return Array.from(objects);
  }

  mongoose.model(exports.name, eventSchema);
};
