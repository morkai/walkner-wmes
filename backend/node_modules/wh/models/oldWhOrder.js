// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

exports.name = 'OldWhOrder';

exports.setUp = (app, mongoose) =>
{
  const FUNCS = ['fmx', 'kitter', 'packer'];

  const orderFuncSchema = new mongoose.Schema({
    _id: {
      type: String,
      enum: FUNCS
    },
    user: {},
    startedAt: Date,
    finishedAt: Date,
    status: {
      type: String,
      enum: ['pending', 'picklist', 'pickup', 'problem', 'finished'],
      default: 'pending'
    },
    picklist: {
      type: String,
      enum: ['pending', 'require', 'ignore'],
      default: 'pending'
    },
    pickup: {
      type: String,
      enum: ['pending', 'success', 'failure', 'ignore'],
      default: 'pending'
    },
    carts: [String],
    problemArea: String,
    comment: String
  }, {
    minimize: false
  });

  const orderLineSchema = new mongoose.Schema({
    _id: String,
    qty: Number,
    pceTime: Number
  }, {
    minimize: false
  });

  const orderSchema = new mongoose.Schema({
    _id: String,
    status: {
      type: String,
      enum: ['pending', 'started', 'finished', 'problem', 'cancelled'],
      default: 'pending'
    },
    distStatus: {
      type: String,
      enum: ['pending', 'started', 'finished'],
      default: 'pending'
    },
    fifoStatus: {
      type: String,
      enum: ['pending', 'started', 'finished', 'ignored'],
      default: 'pending'
    },
    packStatus: {
      type: String,
      enum: ['pending', 'started', 'finished', 'ignored'],
      default: 'pending'
    },
    psStatus: String,
    problem: String,
    order: String,
    mrp: String,
    group: Number,
    line: String,
    lines: [orderLineSchema],
    redirLine: String,
    redirLines: [String],
    set: Number,
    startedAt: Date,
    finishedAt: Date,
    date: Date,
    qty: Number,
    startTime: Date,
    finishTime: Date,
    picklistFunc: {
      type: String,
      enum: [null].concat(FUNCS)
    },
    picklistDone: {
      type: String,
      enum: ['pending', 'progress', 'success', 'failure'],
      default: 'pending'
    },
    funcs: [orderFuncSchema],
    users: [String]
  }, {
    id: false,
    minimize: false,
    versionKey: false
  });

  orderSchema.statics.TOPIC_PREFIX = 'old.wh.orders';
  orderSchema.statics.BROWSE_LIMIT = 2000;
  orderSchema.statics.FUNCS = FUNCS;

  orderSchema.index({date: -1});
  orderSchema.index({set: 1, date: -1});
  orderSchema.index({line: 1, date: -1});
  orderSchema.index({'lines._id': 1, date: -1});
  orderSchema.index({status: 1, date: -1});
  orderSchema.index({distStatus: 1, 'lines._id': 1, date: -1});
  orderSchema.index({psStatus: 1, date: -1});
  orderSchema.index({order: 1});
  orderSchema.index({'funcs.user.id': 1, 'funcs.status': 1, 'funcs.finishedAt': 1});

  orderSchema.statics.resolveDistStatus = function(fifoStatus, packStatus)
  {
    const distStatus = [fifoStatus, packStatus];

    if (distStatus.includes('started'))
    {
      return 'started';
    }

    if (distStatus.every(s => s === 'finished' || s === 'ignored'))
    {
      return 'finished';
    }

    if (distStatus.some(s => s === 'finished'))
    {
      return 'started';
    }

    return 'pending';
  };

  orderSchema.statics.finalizeSet = async function(date, set, setCartsResults, session)
  {
    const WhOrder = mongoose.model('OldWhOrder');
    const WhSetCart = mongoose.model('OldWhSetCart');

    const result = {
      hasRemainingOrders: false,
      messages: []
    };

    const incompleteOrder = await WhOrder
      .findOne({
        date,
        set,
        status: {$in: ['pending', 'started', 'problem']}
      })
      .select({_id: 1})
      .lean()
      .session(session)
      .exec();

    result.hasRemainingOrders = !!incompleteOrder;

    const oldSetCartStatus = incompleteOrder ? 'completed' : 'completing';
    const newSetCartStatus = incompleteOrder ? 'completing' : 'completed';

    const setCarts = await WhSetCart
      .find({
        date,
        set,
        status: oldSetCartStatus
      })
      .lean()
      .session(session)
      .exec();

    if (!setCarts.length)
    {
      return result;
    }

    const setCartIds = [];

    setCarts.forEach(setCart =>
    {
      setCartIds.push(setCart._id);

      setCart.status = newSetCartStatus;

      const updatedSetCart = setCartsResults.updated.find(d => d._id.equals(setCart._id))
        || setCartsResults.added.find(d => d._id.equals(setCart._id));

      if (updatedSetCart)
      {
        updatedSetCart.kind = setCart.kind;
        updatedSetCart.status = newSetCartStatus;
      }
      else
      {
        setCartsResults.updated.push(setCart);
      }
    });

    await WhSetCart.collection.updateMany(
      {_id: {$in: setCartIds}},
      {$set: {status: newSetCartStatus}},
      {session}
    );

    if (!setCartsResults.messages.length)
    {
      setCartsResults.messages.push({
        topic: `${WhSetCart.TOPIC_PREFIX}.updated`,
        message: {
          deleted: setCartsResults.deleted,
          updated: setCartsResults.updated,
          added: setCartsResults.added
        }
      });
    }

    return result;
  };

  orderSchema.methods.finalizeOrder = function()
  {
    let anyProblem = this.picklistDone === 'failure';
    let allFinished = true;

    this.funcs.forEach(func =>
    {
      if (func.status === 'problem')
      {
        anyProblem = true;
      }

      if (func.status !== 'finished')
      {
        allFinished = false;
      }
    });

    if (anyProblem)
    {
      this.status = 'problem';
      this.finishedAt = new Date();
    }
    else if (allFinished)
    {
      this.status = 'finished';
      this.finishedAt = new Date();
    }
    else
    {
      this.status = 'started';
      this.finishedAt = null;
    }

    this.distStatus = this.constructor.resolveDistStatus(this.fifoStatus, this.packStatus);
  };

  orderSchema.methods.finalizeSet = function(setCartsResults)
  {
    return this.constructor.finalizeSet(this.date, this.set, setCartsResults, this.$session());
  };

  mongoose.model(exports.name, orderSchema);
};
