// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

exports.name = 'OldWhOrder';

exports.setUp = (app, mongoose) =>
{
  const FUNCS = ['fmx', 'kitter', 'packer'];

  const whOrderFuncSchema = new mongoose.Schema({
    _id: {
      type: String,
      enum: FUNCS
    },
    user: {},
    startedAt: Date,
    finishedAt: Date,
    status: {
      type: String,
      enum: ['pending', 'picklist', 'pickup', 'problem', 'finished'],
      default: 'pending'
    },
    picklist: {
      type: String,
      enum: ['pending', 'require', 'ignore'],
      default: 'pending'
    },
    pickup: {
      type: String,
      enum: ['pending', 'success', 'failure', 'ignore'],
      default: 'pending'
    },
    carts: [Number],
    problemArea: String,
    comment: String
  }, {
    minimize: false
  });

  const whOrderLineSchema = new mongoose.Schema({
    _id: String,
    qty: Number,
    pceTime: Number
  }, {
    minimize: false
  });

  const whOrderSchema = new mongoose.Schema({
    _id: String,
    status: {
      type: String,
      enum: ['pending', 'started', 'finished', 'problem', 'cancelled'],
      default: 'pending'
    },
    distStatus: {
      type: String,
      enum: ['pending', 'started', 'finished'],
      default: 'pending'
    },
    fifoStatus: {
      type: String,
      enum: ['pending', 'started', 'finished'],
      default: 'pending'
    },
    packStatus: {
      type: String,
      enum: ['pending', 'started', 'finished'],
      default: 'pending'
    },
    psStatus: String,
    problem: String,
    order: String,
    mrp: String,
    group: Number,
    line: String,
    lines: [whOrderLineSchema],
    set: Number,
    startedAt: Date,
    finishedAt: Date,
    date: Date,
    qty: Number,
    startTime: Date,
    finishTime: Date,
    picklistFunc: {
      type: String,
      enum: [null].concat(FUNCS)
    },
    picklistDone: {
      type: String,
      enum: ['pending', 'progress', 'success', 'failure'],
      default: 'pending'
    },
    funcs: [whOrderFuncSchema],
    users: [String]
  }, {
    id: false,
    minimize: false
  });

  whOrderSchema.statics.TOPIC_PREFIX = 'old.wh.orders';
  whOrderSchema.statics.BROWSE_LIMIT = 2000;
  whOrderSchema.statics.FUNCS = FUNCS;

  whOrderSchema.index({date: -1});
  whOrderSchema.index({line: 1, date: -1});
  whOrderSchema.index({'lines._id': 1, date: -1});
  whOrderSchema.index({status: 1, date: -1});
  whOrderSchema.index({distStatus: 1, 'lines._id': 1, date: -1});
  whOrderSchema.index({psStatus: 1, date: -1});
  whOrderSchema.index({order: 1});
  whOrderSchema.index({'funcs.user.id': 1, 'funcs.status': 1, 'funcs.finishedAt': 1});

  whOrderSchema.methods.finalizeOrder = function()
  {
    let anyProblem = this.picklistDone === 'failure';
    let allFinished = true;

    this.funcs.forEach(func =>
    {
      if (func.status === 'problem')
      {
        anyProblem = true;
      }

      if (func.status !== 'finished')
      {
        allFinished = false;
      }
    });

    if (anyProblem)
    {
      this.status = 'problem';
      this.finishedAt = new Date();
    }
    else if (allFinished)
    {
      this.status = 'finished';
      this.finishedAt = new Date();
    }
    else
    {
      this.status = 'started';
      this.finishedAt = null;
    }

    const distStatus = [this.fifoStatus, this.packStatus];

    if (distStatus.includes('started'))
    {
      this.distStatus = 'started';
    }
    else if (distStatus.every(s => s === 'finished'))
    {
      this.distStatus = 'finished';
    }
    else if (distStatus.some(s => s === 'finished'))
    {
      this.distStatus = 'started';
    }
    else
    {
      this.distStatus = 'pending';
    }
  };

  whOrderSchema.methods.finalizeSet = async function(setCartsResults)
  {
    const WhOrder = mongoose.model('OldWhOrder');
    const WhSetCart = mongoose.model('OldWhSetCart');

    const result = {
      messages: []
    };

    const incompleteOrder = await WhOrder
      .findOne({
        date: this.date,
        set: this.set,
        status: {$in: ['pending', 'started']}
      })
      .select({_id: 1})
      .lean()
      .session(this.$session())
      .exec();

    const oldSetCartStatus = incompleteOrder ? 'completed' : 'completing';
    const newSetCartStatus = incompleteOrder ? 'completing' : 'completed';

    const setCarts = await WhSetCart
      .find({
        date: this.date,
        set: this.set,
        status: oldSetCartStatus
      })
      .select({_id: 1})
      .lean()
      .session(this.$session())
      .exec();

    if (!setCarts.length)
    {
      return result;
    }

    const setCartIds = [];

    setCarts.forEach(setCart =>
    {
      setCartIds.push(setCart._id);

      const updatedSetCart = setCartsResults.updated.find(d => d._id.equals(setCart._id))
        || setCartsResults.added.find(d => d._id.equals(setCart._id));

      if (updatedSetCart)
      {
        updatedSetCart.status = newSetCartStatus;
      }
      else
      {
        setCartsResults.updated.push({
          _id: setCart._id,
          status: newSetCartStatus
        });
      }
    });

    await WhSetCart.collection.updateMany(
      {_id: {$in: setCartIds}},
      {$set: {status: newSetCartStatus}},
      {session: this.$session()}
    );

    return result;
  };

  mongoose.model(exports.name, whOrderSchema);
};
