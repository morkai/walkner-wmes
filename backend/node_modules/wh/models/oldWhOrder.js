// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

exports.name = 'OldWhOrder';

exports.setUp = (app, mongoose) =>
{
  const FUNCS_IDX = {
    fmx: 0,
    kitter: 1,
    platformer: 2,
    packer: 3,
    painter: 4
  };
  const FUNCS = Object.keys(FUNCS_IDX);
  const DIST_STATUS_PROPS = {
    components: 'fifoStatus',
    packaging: 'packStatus',
    ps: 'psDistStatus'
  };

  const orderFuncSchema = new mongoose.Schema({
    _id: {
      type: String,
      enum: FUNCS
    },
    user: {},
    startedAt: Date,
    finishedAt: Date,
    status: {
      type: String,
      enum: ['pending', 'picklist', 'pickup', 'problem', 'finished'],
      default: 'pending'
    },
    picklist: {
      type: String,
      enum: ['pending', 'require', 'ignore'],
      default: 'pending'
    },
    pickup: {
      type: String,
      enum: ['pending', 'success', 'failure', 'ignore'],
      default: 'pending'
    },
    carts: [String],
    problemArea: String,
    comment: String
  }, {
    minimize: false
  });

  const orderLineSchema = new mongoose.Schema({
    _id: String,
    qty: Number,
    pceTime: Number,
    startTime: Date,
    finishTime: Date
  }, {
    minimize: false
  });

  const orderSchema = new mongoose.Schema({
    _id: String,
    status: {
      type: String,
      enum: ['pending', 'started', 'finished', 'problem', 'cancelled'],
      default: 'pending'
    },
    distStatus: {
      type: String,
      enum: ['pending', 'started', 'finished'],
      default: 'pending'
    },
    fifoStatus: {
      type: String,
      enum: ['pending', 'started', 'finished', 'ignored'],
      default: 'pending'
    },
    packStatus: {
      type: String,
      enum: ['pending', 'started', 'finished', 'ignored'],
      default: 'pending'
    },
    psDistStatus: {
      type: String,
      enum: ['pending', 'started', 'finished', 'ignored'],
      default: 'pending'
    },
    setDistStarted: Boolean,
    psStatus: String,
    drilling: Boolean,
    problem: String,
    order: String,
    mrp: String,
    group: Number,
    line: String,
    lines: [orderLineSchema],
    redirLine: String,
    redirLines: [String],
    forcedRedir: {
      type: {
        redirLine: String,
        redirLines: [String]
      },
      required: false
    },
    forceDelivery: Boolean,
    set: Number,
    startedAt: Date,
    finishedAt: Date,
    problemAt: Date,
    date: Date,
    qty: Number,
    startTime: Date,
    finishTime: Date,
    picklistFunc: {
      type: String,
      enum: [null].concat(FUNCS)
    },
    picklistDone: {
      type: String,
      enum: ['pending', 'progress', 'success', 'failure'],
      default: 'pending'
    },
    funcs: [orderFuncSchema],
    users: [String]
  }, {
    id: false,
    minimize: false,
    versionKey: false
  });

  orderSchema.statics.TOPIC_PREFIX = 'old.wh.orders';
  orderSchema.statics.BROWSE_LIMIT = 2000;
  orderSchema.statics.FUNCS = FUNCS;
  orderSchema.statics.FUNCS_IDX = FUNCS_IDX;
  orderSchema.statics.DIST_STATUS_PROPS = DIST_STATUS_PROPS;

  orderSchema.index({date: -1});
  orderSchema.index({set: 1, date: -1});
  orderSchema.index({line: 1, date: -1});
  orderSchema.index({status: 1, date: -1});
  orderSchema.index({status: 1, 'funcs.user.id': 1});
  orderSchema.index({status: 1, 'lines._id': 1, startTime: 1});
  orderSchema.index({distStatus: 1, 'lines._id': 1, date: -1});
  orderSchema.index({order: 1});

  orderSchema.statics.resolveDistStatus = function(fifoStatus, packStatus, psDistStatus)
  {
    const distStatus = [fifoStatus, packStatus, psDistStatus];

    if (distStatus.includes('started'))
    {
      return 'started';
    }

    if (distStatus.every(s => s === 'ignored'))
    {
      throw app.createError('Invalid distribution status: cannot ignore all functions.', 'ALL_IGNORED', 400);
    }

    if (distStatus.includes('finished'))
    {
      if (distStatus.includes('ignored') || distStatus.every(s => s === 'finished'))
      {
        return 'finished';
      }

      return 'started';
    }

    return 'pending';
  };

  orderSchema.statics.finalizeSet = async function(date, set, setCartsResults, session)
  {
    const WhOrder = mongoose.model('OldWhOrder');
    const WhSetCart = mongoose.model('OldWhSetCart');

    const result = {
      hasRemainingOrders: false,
      messages: []
    };

    const incompleteOrder = await WhOrder
      .findOne({
        date,
        set,
        'funcs.status': {$in: ['pending', 'picklist', 'pickup']}
      })
      .select({_id: 1})
      .hint({set: 1, date: -1})
      .lean()
      .session(session)
      .exec();

    result.hasRemainingOrders = !!incompleteOrder;

    const oldSetCartStatus = incompleteOrder ? 'completed' : 'completing';
    const newSetCartStatus = incompleteOrder ? 'completing' : 'completed';

    const setCarts = await WhSetCart
      .find({
        date,
        set,
        status: oldSetCartStatus
      })
      .hint({status: 1, date: -1})
      .lean()
      .session(session)
      .exec();

    if (!setCarts.length)
    {
      return result;
    }

    const setCartIds = [];

    setCarts.forEach(setCart =>
    {
      setCartIds.push(setCart._id);

      setCart.status = newSetCartStatus;

      const updatedSetCart = setCartsResults.updated.find(d => d._id.equals(setCart._id))
        || setCartsResults.added.find(d => d._id.equals(setCart._id));

      if (updatedSetCart)
      {
        updatedSetCart.kind = setCart.kind;
        updatedSetCart.status = newSetCartStatus;
      }
      else
      {
        setCartsResults.updated.push(setCart);
      }
    });

    await WhSetCart.collection.updateMany(
      {_id: {$in: setCartIds}},
      {$set: {status: newSetCartStatus}},
      {session}
    );

    if (!setCartsResults.messages.length)
    {
      setCartsResults.messages.push({
        topic: `${WhSetCart.TOPIC_PREFIX}.updated`,
        message: {
          deleted: setCartsResults.deleted,
          updated: setCartsResults.updated,
          added: setCartsResults.added
        }
      });
    }

    return result;
  };

  orderSchema.methods.finalizeOrder = function()
  {
    let anyProblem = this.picklistDone === 'failure';
    let allFinished = true;

    this.funcs.forEach(func =>
    {
      if (func.status === 'problem')
      {
        anyProblem = true;
      }

      if (func.status !== 'finished')
      {
        allFinished = false;
      }
    });

    if (anyProblem)
    {
      const now = new Date();

      this.status = 'problem';
      this.finishedAt = now;

      if (!this.problemAt)
      {
        this.problemAt = now;
      }
    }
    else if (allFinished)
    {
      this.status = 'finished';
      this.finishedAt = new Date();
      this.problemAt = null;
    }
    else
    {
      this.status = 'started';
      this.finishedAt = null;
      this.problemAt = null;
    }

    this.distStatus = this.constructor.resolveDistStatus(
      this.fifoStatus, this.packStatus, this.psDistStatus
    );
  };

  orderSchema.methods.finalizeSet = function(setCartsResults)
  {
    return this.constructor.finalizeSet(this.date, this.set, setCartsResults, this.$session());
  };

  orderSchema.methods.resetFunc = function(funcId, data)
  {
    const func = this.funcs.find(f => f._id === funcId);

    func.status = 'pending';
    func.picklist = 'pending';
    func.pickup = 'pending';
    func.carts = [];
    func.problemArea = '';
    func.comment = '';
    func.finishedAt = null;

    Object.assign(func, data);
  };

  orderSchema.methods.resetPlatformer = function()
  {
    const fmx = this.funcs[FUNCS_IDX.fmx];
    const kitter = this.funcs[FUNCS_IDX.kitter];
    const platformer = {
      status: 'pending',
      picklist: 'pending',
      pickup: 'pending'
    };

    if (fmx.status === 'problem'
      || (kitter.status === 'problem' && fmx.status === 'finished' && fmx.picklist === 'require'))
    {
      platformer.status = 'problem';
      platformer.picklist = 'require';
      platformer.pickup = 'failure';
    }
    else if (fmx.picklist === 'ignore')
    {
      platformer.status = 'finished';
      platformer.picklist = 'ignore';
      platformer.pickup = 'ignore';
    }
    else if (fmx.status === 'finished' && fmx.picklist === 'require' && kitter.status === 'finished')
    {
      platformer.status = 'pickup';
      platformer.picklist = 'require';
    }

    this.resetFunc('platformer', platformer);
  };

  mongoose.model(exports.name, orderSchema);
};
