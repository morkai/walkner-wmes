// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const deepEqual = require('deep-equal');

exports.name = 'OldWhSetCart';

exports.setUp = (app, mongoose) =>
{
  const setCartOrder = new mongoose.Schema({
    whOrder: String,
    sapOrder: String
  }, {
    _id: false,
    minimize: false,
    versionKey: false
  });

  const setCartSchema = new mongoose.Schema({
    status: {
      type: String,
      enum: ['completed', 'delivering', 'delivered'],
      required: true
    },
    kind: {
      type: String,
      enum: ['components', 'packaging'],
      required: true
    },
    date: {
      type: Date,
      required: true
    },
    set: {
      type: Number,
      required: true
    },
    line: {
      type: String,
      required: true
    },
    cart: {
      type: Number,
      required: true
    },
    orders: [setCartOrder],
    completedAt: Date,
    completedBy: [{}],
    deliveringAt: Date,
    deliveringBy: {},
    deliveredAt: Date,
    deliveredBy: {},
    users: [String]
  }, {
    id: false,
    minimize: false,
    versionKey: false
  });

  setCartSchema.statics.TOPIC_PREFIX = 'old.wh.setCarts';
  setCartSchema.statics.BROWSE_LIMIT = 100;

  setCartSchema.index({date: -1});
  setCartSchema.index({status: 1, date: -1});
  setCartSchema.index({kind: 1, date: -1});
  setCartSchema.index({set: 1, date: -1});
  setCartSchema.index({cart: 1, date: -1});
  setCartSchema.index({line: 1, date: -1});
  setCartSchema.index({'users': 1, date: -1});
  setCartSchema.index({'orders.whOrder': 1});
  setCartSchema.index({'orders.sapOrder': 1});

  setCartSchema.statics.applyResult = async function(whOrder, result)
  {
    const WhSetCart = this;

    const operations = [];

    if (result.deleted.length)
    {
      operations.push({
        deleteMany: {
          filter: {_id: {$in: result.deleted.map(d => d._id)}}
        }
      });
    }

    result.updated.forEach(update =>
    {
      operations.push({
        updateOne: {
          filter: {_id: update._id},
          update: {$set: update}
        }
      });
    });

    result.added.forEach(document =>
    {
      operations.push({insertOne: {document}});
    });

    if (!operations.length)
    {
      return result;
    }

    await WhSetCart.collection.bulkWrite(operations, {session: whOrder.$session()});

    if (result.updated.length || result.deleted.length)
    {
      await WhSetCart.updateCompletedBy(whOrder, result);
    }

    result.messages.push({
      topic: `${WhSetCart.TOPIC_PREFIX}.updated`,
      message: {
        deleted: result.deleted,
        updated: result.updated,
        added: result.added
      }
    });

    return result;
  };

  setCartSchema.statics.updateCompletedBy = async function(whOrder, result)
  {
    const WhSetCart = this;
    const WhOrder = mongoose.model('OldWhOrder');

    const [setOrders, setCarts] = await Promise.all([
      WhOrder
        .find({date: whOrder.date, set: whOrder.set})
        .select({funcs: 1})
        .lean()
        .session(whOrder.$session())
        .exec(),
      WhSetCart
        .find({date: whOrder.date, set: whOrder.set})
        .select({kind: 1, cart: 1, completedBy: 1, deliveringBy: 1, deliveredBy: 1})
        .lean()
        .session(whOrder.$session())
        .exec()
    ]);

    if (!setOrders.length || !setCarts.length)
    {
      return;
    }

    const cartMap = new Map();
    const userMap = new Map();
    const updatedMap = new Map();

    result.updated.forEach(update => updatedMap.set(update._id.toString(), update));

    setCarts.forEach(setCart =>
    {
      cartMap.set(`${setCart.kind}:${setCart.cart}`, {
        id: setCart._id.toString(),
        _id: setCart._id,
        deliveringBy: setCart.deliveringBy,
        deliveredBy: setCart.deliveredBy,
        oldCompletedBy: setCart.completedBy.map(u => u.id).sort(),
        newCompletedBy: new Set()
      });
    });

    setOrders.forEach(setOrder =>
    {
      setOrder.funcs.forEach(func =>
      {
        if (!func.user || !func.carts)
        {
          return;
        }

        const kind = func._id === 'packer' ? 'packaging' : 'components';

        func.carts.forEach(cartNo =>
        {
          const cart = cartMap.get(`${kind}:${cartNo}`);

          if (!cart)
          {
            return;
          }

          cart.newCompletedBy.add(func.user.id);
          userMap.set(func.user.id, func.user);
        });
      });
    });

    const operations = [];

    cartMap.forEach(cart =>
    {
      const newCompletedBy = Array.from(cart.newCompletedBy).sort();

      if (deepEqual(cart.oldCompletedBy, newCompletedBy))
      {
        return;
      }

      const completedBy = newCompletedBy.map(userId => userMap.get(userId));
      const users = WhSetCart.collectUsers(completedBy, cart.deliveringBy, cart.deliveredBy);

      if (updatedMap.has(cart.id))
      {
        const update = updatedMap.get(cart.id);

        update.completedBy = completedBy;
        update.users = users;
      }
      else
      {
        result.updated.push({
          _id: cart._id,
          completedBy,
          users
        });
      }

      operations.push({
        updateOne: {
          filter: {_id: cart._id},
          update: {$set: {completedBy, users}}
        }
      });
    });

    if (operations.length)
    {
      await WhSetCart.collection.bulkWrite(operations, {session: whOrder.$session()});
    }
  };

  setCartSchema.statics.deleteByWhOrder = async function(whOrder)
  {
    const WhSetCart = this;

    const result = {
      deleted: [],
      updated: [],
      added: [],
      messages: []
    };

    const setCarts = await WhSetCart
      .find({'orders.whOrder': whOrder._id})
      .select({kind: 1, cart: 1, orders: 1})
      .lean()
      .session(whOrder.$session())
      .exec();

    if (!setCarts.length)
    {
      return result;
    }

    setCarts.forEach(setCart =>
    {
      setCart.orders = setCart.orders.filter(o => o.whOrder !== whOrder._id);

      if (setCart.orders.length)
      {
        result.updated.push({
          _id: setCart._id,
          orders: setCart.orders
        });
      }
      else
      {
        result.deleted.push({
          _id: setCart._id
        });
      }
    });

    return await WhSetCart.applyResult(whOrder, result);
  };

  setCartSchema.statics.collectUsers = async function(completedBy, deliveringBy, deliveredBy)
  {
    const users = new Set();

    if (Array.isArray(completedBy))
    {
      completedBy.forEach(u =>
      {
        if (u.id)
        {
          users.add(u.id);
        }
      });
    }

    if (deliveringBy && deliveringBy.id)
    {
      users.add(deliveringBy.id);
    }

    if (deliveredBy && deliveredBy.id)
    {
      users.add(deliveredBy.id);
    }

    return Array.from(users);
  };

  setCartSchema.statics.updateByFunc = async function(whOrder, funcId)
  {
    const WhSetCart = this;

    const result = {
      deleted: [],
      updated: [],
      added: [],
      messages: []
    };

    const func = whOrder.funcs.find(func => func._id === funcId);
    const kind = funcId === 'packer' ? 'packaging' : 'components';
    const remainingCarts = new Set(func.carts);
    const usedCarts = new Set(
      kind === 'packaging'
        ? whOrder.funcs[2].carts
        : whOrder.funcs[0].carts.concat(whOrder.funcs[1].carts)
    );
    const setCarts = await WhSetCart
      .find({
        date: whOrder.date,
        set: whOrder.set,
        kind
      })
      .select({cart: 1, orders: 1, completedBy: 1, deliveringBy: 1, deliveredBy: 1})
      .lean()
      .session(whOrder.$session())
      .exec();

    setCarts.forEach(setCart =>
    {
      remainingCarts.delete(setCart.cart);

      // Cart already used in another order: update
      if (setCart.orders.every(o => o.whOrder !== whOrder._id))
      {
        setCart.orders.push({
          whOrder: whOrder._id,
          sapOrder: whOrder.order
        });

        result.updated.push({
          _id: setCart._id,
          orders: setCart.orders
        });

        return;
      }

      // Remove carts that are no longer used
      const oldSize = setCart.orders.length;

      setCart.orders = setCart.orders.filter(o => o.whOrder !== whOrder._id || usedCarts.has(setCart.cart));

      // No change: keep
      if (oldSize === setCart.orders.length)
      {
        // Cart assigned to the same order by another func
        if (func.user
          && func.carts.includes(setCart.cart)
          && !setCart.completedBy.some(u => u.id === func.user.id))
        {
          const completedBy = setCart.completedBy.concat(func.user);

          result.updated.push({
            _id: setCart._id,
            completedBy: completedBy,
            users: WhSetCart.collectUsers(completedBy, setCart.deliveringBy, setCart.deliveredBy)
          });
        }

        // Cart unassigned from the same order by another func
        if (func.user
          && !func.carts.includes(setCart.cart)
          && setCart.completedBy.some(u => u.id === func.user.id))
        {
          const completedBy = setCart.completedBy.filter(u => u.id !== func.user.id);

          result.updated.push({
            _id: setCart._id,
            completedBy,
            users: WhSetCart.collectUsers(completedBy, setCart.deliveringBy, setCart.deliveredBy)
          });
        }

        return;
      }

      // Removed from this order but still available in another: update
      if (setCart.orders.length)
      {
        result.updated.push({
          _id: setCart._id,
          orders: setCart.orders
        });

        return;
      }

      // Removed from this one and only order: delete
      result.deleted.push({
        _id: setCart._id
      });
    });

    // Add remaining carts
    remainingCarts.forEach(cart =>
    {
      result.added.push({
        _id: new mongoose.Types.ObjectId(),
        status: 'completed',
        kind,
        date: whOrder.date,
        set: whOrder.set,
        line: whOrder.line,
        cart,
        orders: [{
          whOrder: whOrder._id,
          sapOrder: whOrder.order
        }],
        completedAt: func.finishedAt,
        completedBy: !func.user ? [] : [func.user],
        deliveringAt: null,
        deliveringBy: null,
        deliveredAt: null,
        deliveredBy: null,
        users: func.user ? [func.user.id] : []
      });
    });

    return await WhSetCart.applyResult(whOrder, result);
  };

  setCartSchema.statics.deleteBySet = async function(date, set, session)
  {
    const WhSetCart = this;

    const result = {
      deleted: [],
      updated: [],
      added: [],
      messages: []
    };

    const setCarts = await WhSetCart
      .find({set, date})
      .select({_id: 1})
      .lean()
      .session(session)
      .exec();

    if (!setCarts.length)
    {
      return result;
    }

    await WhSetCart.collection.deleteMany({_id: {$in: setCarts.map(c => c._id)}}, {session});

    result.deleted = setCarts;

    result.messages.push({
      topic: `${WhSetCart.TOPIC_PREFIX}.updated`,
      message: {
        deleted: result.deleted,
        updated: result.updated,
        added: result.added
      }
    });

    return result;
  };

  mongoose.model(exports.name, setCartSchema);
};
