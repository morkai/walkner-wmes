// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const jsonDeepEqual = require('util/jsonDeepEqual');

exports.name = 'OldWhSetCart';

exports.setUp = (app, mongoose) =>
{
  const FUNC_TO_KIND = {
    fmx: 'components',
    kitter: 'components',
    platformer: 'components',
    packer: 'packaging',
    painter: 'ps'
  };
  const KINDS = ['components', 'packaging', 'ps'];

  const setCartOrder = new mongoose.Schema({
    whOrder: String,
    sapOrder: String,
    startTime: Date,
    finishTime: Date,
    qty: Number
  }, {
    _id: false,
    minimize: false,
    versionKey: false
  });

  const setCartSchema = new mongoose.Schema({
    status: {
      type: String,
      enum: ['completing', 'completed', 'delivering', 'delivered'],
      required: true
    },
    pending: {
      type: Boolean,
      default: false
    },
    kind: {
      type: String,
      enum: KINDS,
      required: true
    },
    date: {
      type: Date,
      required: true
    },
    set: {
      type: Number,
      required: true
    },
    line: {
      type: String,
      required: true
    },
    lines: [String],
    redirLine: String,
    redirLines: [String],
    startTime: Date,
    cart: {
      type: String,
      required: true
    },
    orders: [setCartOrder],
    completedAt: Date,
    completedBy: [{}],
    deliveringAt: Date,
    deliveringBy: {},
    deliveredAt: Date,
    deliveredBy: {},
    users: [String]
  }, {
    id: false,
    minimize: false,
    versionKey: false
  });

  setCartSchema.statics.TOPIC_PREFIX = 'old.wh.setCarts';
  setCartSchema.statics.BROWSE_LIMIT = 1000;
  setCartSchema.statics.FUNC_TO_KIND = FUNC_TO_KIND;
  setCartSchema.statics.KINDS = KINDS;

  setCartSchema.index({date: -1});
  setCartSchema.index({status: 1, date: -1});
  setCartSchema.index({kind: 1, date: -1});
  setCartSchema.index({set: 1, date: -1});
  setCartSchema.index({cart: 1, date: -1});
  setCartSchema.index({line: 1, date: -1});
  setCartSchema.index({'users': 1, date: -1});
  setCartSchema.index({'orders.whOrder': 1});
  setCartSchema.index({'orders.sapOrder': 1});

  setCartSchema.statics.applyResult = async function(whOrder, result)
  {
    const WhSetCart = this;

    const operations = [];

    if (Array.isArray(result.deleted) && result.deleted.length)
    {
      operations.push({
        deleteMany: {
          filter: {_id: {$in: result.deleted.map(d => d._id)}}
        }
      });
    }

    if (Array.isArray(result.updated))
    {
      result.updated.forEach(update =>
      {
        operations.push({
          updateOne: {
            filter: {_id: update._id},
            update: {$set: update}
          }
        });
      });
    }

    if (Array.isArray(result.added))
    {
      result.added.forEach(document =>
      {
        operations.push({insertOne: {document}});
      });
    }

    if (!operations.length)
    {
      return result;
    }

    await WhSetCart.collection.bulkWrite(operations, {session: whOrder.$session()});

    if (result.updated.length || result.deleted.length)
    {
      await WhSetCart.updateCompletedBy(whOrder, result);
    }

    result.messages.push({
      topic: `${WhSetCart.TOPIC_PREFIX}.updated`,
      message: {
        deleted: result.deleted,
        added: result.added,
        updated: result.updated
      }
    });

    return result;
  };

  setCartSchema.statics.updateCompletedBy = async function(whOrder, result)
  {
    const WhSetCart = this;
    const WhOrder = mongoose.model('OldWhOrder');

    const [setOrders, setCarts] = await Promise.all([
      WhOrder
        .find({date: whOrder.date, set: whOrder.set})
        .select({funcs: 1})
        .lean()
        .session(whOrder.$session())
        .exec(),
      WhSetCart
        .find({date: whOrder.date, set: whOrder.set})
        .select({
          kind: 1,
          cart: 1,
          completedBy: 1,
          deliveringBy: 1,
          deliveredBy: 1
        })
        .lean()
        .session(whOrder.$session())
        .exec()
    ]);

    if (!setOrders.length || !setCarts.length)
    {
      return;
    }

    const cartMap = new Map();
    const userMap = new Map();
    const updatedMap = new Map();

    result.updated.forEach(update => updatedMap.set(update._id.toString(), update));

    setCarts.forEach(setCart =>
    {
      cartMap.set(`${setCart.kind}:${setCart.cart}`, {
        id: setCart._id.toString(),
        _id: setCart._id,
        cart: setCart.cart,
        deliveringBy: setCart.deliveringBy,
        deliveredBy: setCart.deliveredBy,
        oldCompletedBy: setCart.completedBy.map(u => u.id).sort(),
        newCompletedBy: new Set()
      });
    });

    setOrders.forEach(setOrder =>
    {
      setOrder.funcs.forEach(func =>
      {
        if (!func.user || !func.carts)
        {
          return;
        }

        const kind = FUNC_TO_KIND[func._id];

        func.carts.forEach(cartNo =>
        {
          const cart = cartMap.get(`${kind}:${cartNo}`);

          if (!cart)
          {
            return;
          }

          cart.newCompletedBy.add(func.user.id);
          userMap.set(func.user.id, func.user);
        });
      });
    });

    const operations = [];

    cartMap.forEach(cart =>
    {
      const newCompletedBy = Array.from(cart.newCompletedBy).sort();

      if (jsonDeepEqual(cart.oldCompletedBy, newCompletedBy))
      {
        return;
      }

      const completedBy = newCompletedBy.map(userId => userMap.get(userId));
      const users = WhSetCart.collectUsers(completedBy, cart.deliveringBy, cart.deliveredBy);

      if (updatedMap.has(cart.id))
      {
        const update = updatedMap.get(cart.id);

        update.cart = cart.cart;
        update.completedBy = completedBy;
        update.users = users;
      }
      else
      {
        result.updated.push({
          _id: cart._id,
          cart: cart.cart,
          completedBy,
          users
        });
      }

      operations.push({
        updateOne: {
          filter: {_id: cart._id},
          update: {$set: {completedBy, users}}
        }
      });
    });

    if (operations.length)
    {
      await WhSetCart.collection.bulkWrite(operations, {session: whOrder.$session()});
    }
  };

  setCartSchema.statics.deleteByWhOrder = async function(whOrder)
  {
    const WhSetCart = this;

    const result = {
      deleted: [],
      added: [],
      updated: [],
      messages: []
    };

    const setCarts = await WhSetCart
      .find({'orders.whOrder': whOrder._id})
      .select({
        kind: 1,
        cart: 1,
        orders: 1
      })
      .hint({'orders.whOrder': 1})
      .lean()
      .session(whOrder.$session())
      .exec();

    if (!setCarts.length)
    {
      return result;
    }

    setCarts.forEach(setCart =>
    {
      setCart.orders = setCart.orders.filter(o => o.whOrder !== whOrder._id);

      if (setCart.orders.length)
      {
        const minStartTime = setCart.orders.reduce(
          (startTime, o) => Math.min(startTime, +o.startTime),
          Number.MAX_SAFE_INTEGER
        );

        result.updated.push({
          _id: setCart._id,
          kind: setCart.kind,
          cart: setCart.cart,
          orders: setCart.orders,
          startTime: new Date(minStartTime)
        });
      }
      else
      {
        result.deleted.push({
          _id: setCart._id
        });
      }
    });

    return await WhSetCart.applyResult(whOrder, result);
  };

  setCartSchema.statics.collectUsers = function(completedBy, deliveringBy, deliveredBy)
  {
    if (completedBy && completedBy._id)
    {
      deliveredBy = completedBy.deliveredBy;
      deliveringBy = completedBy.deliveringBy;
      completedBy = completedBy.completedBy;
    }

    const users = new Set();

    if (Array.isArray(completedBy))
    {
      completedBy.forEach(u =>
      {
        if (u.id)
        {
          users.add(u.id);
        }
      });
    }

    if (deliveringBy && deliveringBy.id)
    {
      users.add(deliveringBy.id);
    }

    if (deliveredBy && deliveredBy.id)
    {
      users.add(deliveredBy.id);
    }

    return Array.from(users);
  };

  setCartSchema.statics.updateByFunc = async function(whOrder, funcId, setDelivered)
  {
    const WhSetCart = this;
    const WhOrder = mongoose.model('OldWhOrder');

    const result = {
      deleted: [],
      added: [],
      updated: [],
      remaining: [],
      messages: []
    };

    const kind = FUNC_TO_KIND[funcId];
    let func = null;

    if (kind === 'components')
    {
      const fmx = whOrder.funcs[WhOrder.FUNCS_IDX.fmx];
      const kitter = whOrder.funcs[WhOrder.FUNCS_IDX.kitter];
      const platformer = whOrder.funcs[WhOrder.FUNCS_IDX.platformer];

      if (fmx.pickup === 'ignore')
      {
        func = kitter;
      }
      else
      {
        func = platformer;
      }
    }
    else
    {
      func = whOrder.funcs[WhOrder.FUNCS_IDX[funcId]];
    }

    if (!func)
    {
      throw app.createError('Cannot update set carts by func: invalid func.', 'INPUT', 500);
    }

    const remainingCarts = new Set(func.carts);
    const usedCarts = new Set(func.carts);
    const conditions = {
      set: whOrder.set,
      date: whOrder.date,
      kind
    };

    if (setDelivered)
    {
      conditions.deliveringAt = {$type: 'null'};
    }

    const setCarts = await WhSetCart
      .find(conditions)
      .select({
        kind: 1,
        cart: 1,
        orders: 1,
        completedBy: 1,
        deliveringBy: 1,
        deliveredBy: 1
      })
      .hint({set: 1, date: -1})
      .lean()
      .session(whOrder.$session())
      .exec();

    setCarts.forEach(setCart =>
    {
      remainingCarts.delete(setCart.cart);

      // Cart already used in another order: update
      if (usedCarts.has(setCart.cart) && setCart.orders.every(o => o.whOrder !== whOrder._id))
      {
        setCart.orders.push({
          whOrder: whOrder._id,
          sapOrder: whOrder.order,
          startTime: whOrder.startTime,
          finishTime: whOrder.finishTime
        });

        setCart.startTime = new Date(setCart.orders.reduce(
          (startTime, o) => Math.min(startTime, +o.startTime),
          Number.MAX_SAFE_INTEGER
        ));

        result.updated.push({
          _id: setCart._id,
          kind,
          cart: setCart.cart,
          orders: setCart.orders,
          startTime: setCart.startTime
        });

        result.remaining.push(setCart);

        return;
      }

      // Remove carts that are no longer used
      const oldSize = setCart.orders.length;

      setCart.orders = setCart.orders.filter(o => o.whOrder !== whOrder._id || usedCarts.has(setCart.cart));

      // No change: keep
      if (oldSize === setCart.orders.length)
      {
        // Cart assigned to the same order by another func
        if (func.user
          && func.carts.includes(setCart.cart)
          && !setCart.completedBy.some(u => u.id === func.user.id))
        {
          const completedBy = setCart.completedBy.concat(func.user);

          result.updated.push({
            _id: setCart._id,
            kind,
            cart: setCart.cart,
            completedBy: completedBy,
            users: WhSetCart.collectUsers(completedBy, setCart.deliveringBy, setCart.deliveredBy)
          });

          result.remaining.push(setCart);
        }
        // Cart unassigned from the same order by another func
        else if (func.user
          && !func.carts.includes(setCart.cart)
          && setCart.completedBy.some(u => u.id === func.user.id))
        {
          const completedBy = setCart.completedBy.filter(u => u.id !== func.user.id);

          result.updated.push({
            _id: setCart._id,
            kind,
            cart: setCart.cart,
            completedBy,
            users: WhSetCart.collectUsers(completedBy, setCart.deliveringBy, setCart.deliveredBy)
          });
        }
        // No changes
        else
        {
          result.remaining.push(setCart);
        }

        return;
      }

      // Removed from this order but still available in another: update
      if (setCart.orders.length)
      {
        setCart.startTime = new Date(setCart.orders.reduce(
          (startTime, o) => Math.min(startTime, +o.startTime),
          Number.MAX_SAFE_INTEGER
        ));

        result.updated.push({
          _id: setCart._id,
          kind,
          cart: setCart.cart,
          orders: setCart.orders,
          startTime: setCart.startTime
        });

        return;
      }

      // Removed from this one and only order: delete
      result.deleted.push({
        _id: setCart._id
      });
    });

    // Add remaining carts
    remainingCarts.forEach(cart =>
    {
      const setCart = {
        _id: new mongoose.Types.ObjectId(),
        status: 'completing',
        pending: setDelivered,
        kind,
        date: whOrder.date,
        set: whOrder.set,
        line: whOrder.line,
        lines: whOrder.lines.map(l => l._id),
        cart,
        orders: [{
          whOrder: whOrder._id,
          sapOrder: whOrder.order,
          startTime: whOrder.startTime,
          finishTime: whOrder.finishTime
        }],
        startTime: whOrder.startTime,
        completedAt: func.finishedAt,
        completedBy: !func.user ? [] : [func.user],
        deliveringAt: null,
        deliveringBy: null,
        deliveredAt: null,
        deliveredBy: null,
        users: func.user ? [func.user.id] : []
      };

      result.added.push(setCart);
      result.remaining.push(setCart);
    });

    return await WhSetCart.applyResult(whOrder, result);
  };

  setCartSchema.statics.deleteBySet = async function(date, set, session)
  {
    const WhSetCart = this;

    const result = {
      deleted: [],
      messages: []
    };

    const setCarts = await WhSetCart
      .find({set, date})
      .select({_id: 1})
      .hint({set: 1, date: -1})
      .lean()
      .session(session)
      .exec();

    if (!setCarts.length)
    {
      return result;
    }

    await WhSetCart.collection.deleteMany({_id: {$in: setCarts.map(c => c._id)}}, {session});

    result.deleted = setCarts;

    result.messages.push({
      topic: `${WhSetCart.TOPIC_PREFIX}.updated`,
      message: {
        deleted: result.deleted
      }
    });

    return result;
  };

  mongoose.model(exports.name, setCartSchema);
};
