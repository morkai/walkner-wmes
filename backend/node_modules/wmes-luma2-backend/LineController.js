// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const DEV = /msys/i.test(require('os').hostname());
const RESPONSE_TIMEOUT = 300;
const EVENT_CHECK_INTERVAL = 500;
const EVENT_REGISTER_SIZE = 1 + 2 + 1 + 1 + 2 + 1 + (DEV ? 2 : 0);
const MAX_EVENTS_PER_FRAME = 10;
const LITTLE_ENDIAN = false;
const MAX_EVENT_COUNT = 124;
const ORDER_COUNTER_ADDRESS = DEV ? 1 : 0;
const ORDER_START_ADDRESS = DEV ? 2 : 1;
const EVENT_COUNTER_ADDRESS = DEV ? 0 : 32;
const EVENT_START_ADDRESS = DEV ? 30 : 33;
const WORKSTATION_COUNT = 7;
const PROGRAM_RE = /program\s+([0-9]+)\s+/i;
const MAX_ORDER_START_DIFF = DEV ? 99999999999999 : (2 * 60 * 1000);
const DEFAULT_SETTINGS = {
  rearmShortTime: 35,
  rearmMediumTime: 100,
  inspectionTime: 91
};

const step = require('h5.step');
const modbus = require('h5.modbus');
const {BufferReader, BufferBuilder} = require('h5.buffers');
const {ObjectId} = require('mongoose').Types;
const {crc16} = require('crc');
const moment = require('moment');

module.exports = class LineController
{
  constructor(app, module, line)
  {
    this.checkEvents = this.checkEvents.bind(this);
    this.handleCheckEvents = this.handleCheckEvents.bind(this);

    this.module = module;
    this.line = line;
    this.crc16 = crc16(line._id);
    this.broker = app.broker.sandbox();
    this.logger = module.logger.create({line: line._id});
    this.master = this.createMaster();

    this.eventCheckTimer = null;
    this.eventCounter = -1;
    this.lastEventTime = 0;
    this.eventTimeCounter = 0;
  }

  destroy()
  {
    clearTimeout(this.eventCheckTimer);
    this.broker.destroy();
    this.master.destroy();
  }

  queueOrder()
  {
    const lineController = this;

    lineController.logger.info('Queueing order...');

    step(
      function()
      {
        lineController.module.ProdShiftOrder
          .find({prodLine: lineController.line._id})
          .select({
            orderId: 1,
            operationNo: 1,
            startedAt: 1,
            finishedAt: 1,
            shift: 1,
            workerCount: 1,
            laborTime: 1,
            sapTaktTime: 1,
            'orderData.name': 1
          })
          .sort({startedAt: -1})
          .limit(2)
          .lean()
          .exec(this.next());
      },
      function(err, prodShiftOrders)
      {
        if (err)
        {
          return this.skip(new Error(`Failed to find ProdShiftOrder: ${err.message}`));
        }

        if (!prodShiftOrders.length)
        {
          return this.skip(new Error('No ProdShiftOrder found.'));
        }

        this.nextPso = prodShiftOrders[0];

        if (this.nextPso.finishedAt)
        {
          return this.skip(new Error(`Next ProdShiftOrder already finished: ${this.nextPso._id}`));
        }

        if (Math.abs(Date.now() - this.nextPso.startedAt) > MAX_ORDER_START_DIFF)
        {
          return this.skip(new Error(`Next ProdShiftOrder started too long ago: ${this.nextPso._id}`));
        }

        this.prevPso = prodShiftOrders.length > 1 ? prodShiftOrders[1] : null;

        const planMoment = moment.utc();

        if (planMoment.hours() < 6)
        {
          planMoment.subtract(1, 'days');
        }

        planMoment.startOf('day');

        const pipeline = [
          {$match: {_id: planMoment.toDate()}},
          {$unwind: '$lines'},
          {$match: {'lines._id': lineController.line._id}},
          {$unwind: '$lines.orders'},
          {$match: {'lines.orders.orderNo': this.nextPso.orderId}},
          {$project: {
            quantity: '$lines.orders.quantity',
            startAt: '$lines.orders.startAt'
          }}
        ];

        lineController.module.Plan
          .aggregate(pipeline)
          .exec(this.parallel());

        lineController.module.Order
          .findById(this.nextPso.orderId)
          .select({
            qty: 1,
            qtyDone: 1,
            qtyMax: 1,
            'bom.name': 1
          })
          .lean()
          .exec(this.parallel());

        lineController.module.settings.findValues('luma2.', this.parallel());
      },
      function(err, planOrders, sapOrder, settings)
      {
        if (err)
        {
          return this.skip(new Error(`Failed to find order data: ${err.message}`));
        }

        if (!sapOrder)
        {
          return this.skip(new Error('SAP order not found.'));
        }

        settings = {
          ...DEFAULT_SETTINGS,
          settings
        };

        const workerCount = this.nextPso.workerCount || WORKSTATION_COUNT;
        const oldName = this.prevPso && this.prevPso.orderData && this.prevPso.orderData.name || '';
        const newName = this.nextPso.orderData && this.nextPso.orderData.name || '';

        this.nextOrder = {
          order: sapOrder._id,
          program: 0,
          quantity: 0,
          rearmTime: oldName === newName ? settings.rearmShortTime : settings.rearmMediumTime,
          inspectionTime: settings.inspectionTime,
          taktTime: this.nextPso.sapTaktTime || Math.ceil((this.nextPso.laborTime / 100 * 3600) / workerCount)
        };

        sapOrder.bom.forEach(component =>
        {
          const matches = component.name.match(PROGRAM_RE);

          if (matches)
          {
            this.nextOrder.program = parseInt(matches[1], 10);
          }
        });

        const shiftPlanOrder = planOrders.find(planOrder =>
        {
          const h = planOrder.startAt.getHours();
          const shift = h >= 6 && h < 14 ? 1 : h >= 14 && h < 22 ? 2 : 3;

          return shift === this.nextPso.shift;
        });
        const qtyTodo = sapOrder.qtyMax
          && sapOrder.qtyMax[this.nextPso.operationNo]
          || sapOrder.qty;
        const qtyDone = sapOrder.qtyDone
          && sapOrder.qtyDone.byOperation
          && sapOrder.qtyDone.byOperation[this.nextPso.operationNo]
          || 0;

        if (shiftPlanOrder)
        {
          this.nextOrder.quantity = shiftPlanOrder.quantity;
        }
        else if (planOrders.length)
        {
          this.nextOrder.quantity = planOrders[0].quantity;
        }
        else if (sapOrder.qtyDone && sapOrder.qtyDone.total)
        {
          this.nextOrder.quantity = qtyTodo - qtyDone;
        }
        else
        {
          this.nextOrder.quantity = qtyTodo;
        }

        lineController.logger.debug('Resolved next order.', {nextOrder: this.nextOrder});

        if (this.nextOrder.program <= 0 || this.nextOrder.program > 0xFFFF)
        {
          return this.skip(new Error(`Invalid program: ${this.nextOrder.program}`));
        }

        if (this.nextOrder.quantity <= 0)
        {
          return this.skip(new Error(`Invalid quantity: ${this.nextOrder.quantity}`));
        }

        if (this.nextOrder.taktTime <= 1)
        {
          return this.skip(new Error(`Invalid takt time: ${this.nextOrder.taktTime}`));
        }
      },
      function()
      {
        const orderBuilder = new BufferBuilder();

        orderBuilder
          .pushUInt16(this.nextOrder.program, LITTLE_ENDIAN)
          .pushUInt32(this.nextOrder.order, LITTLE_ENDIAN)
          .pushUInt16(this.nextOrder.quantity, LITTLE_ENDIAN);

        for (let i = 0; i < WORKSTATION_COUNT; ++i)
        {
          orderBuilder
            .pushUInt16(this.nextOrder.rearmTime, LITTLE_ENDIAN)
            .pushUInt16(this.nextOrder.inspectionTime, LITTLE_ENDIAN)
            .pushUInt16(this.nextOrder.taktTime, LITTLE_ENDIAN);
        }

        const orderBuffer = orderBuilder.toBuffer();

        lineController.master.writeMultipleRegisters(
          ORDER_START_ADDRESS,
          orderBuffer,
          this.next()
        );
      },
      function(err, res)
      {
        if (err)
        {
          return this.skip(new Error(`Failed to write next order: ${err.message}`));
        }

        if (res.isException())
        {
          return this.skip(new Error(`Failed to write next order: ${res}`));
        }

        lineController.master.readHoldingRegisters(ORDER_COUNTER_ADDRESS, 1, this.next());
      },
      function(err, res)
      {
        if (err)
        {
          return this.skip(new Error(`Failed to read order counter: ${err.message}`));
        }

        if (res.isException())
        {
          return this.skip(new Error(`Failed to read order counter: ${res}`));
        }

        const oldOrderCounter = res.data[LITTLE_ENDIAN ? 'readUInt16LE' : 'readUInt16BE'](0, true);
        const newOrderCounter = oldOrderCounter + 1;

        lineController.master.writeSingleRegister(
          ORDER_COUNTER_ADDRESS,
          newOrderCounter,
          this.next()
        );
      },
      function(err, res)
      {
        if (err)
        {
          return this.skip(new Error(`Failed to write order counter: ${err.message}`));
        }

        if (res.isException())
        {
          return this.skip(new Error(`Failed to write order counter: ${res}`));
        }
      },
      function(err)
      {
        if (err)
        {
          lineController.logger.warn(err, 'Failed to queue order.');
        }
        else if (this.nextOrder)
        {
          lineController.logger.info('Order queued.', {queuedOrder: this.nextOrder});

          lineController.recordEvents({
            type: 'order-queued',
            order: this.nextOrder.order,
            program: this.nextOrder.program,
            pce: this.nextOrder.quantity
          });
        }
      }
    );
  }

  createMaster()
  {
    const master = modbus.createMaster({
      transport: {
        type: 'ip',
        maxBufferLength: 1000
      },
      connection: {
        socketOptions: {
          host: this.line.host,
          port: this.line.port,
          noDelay: true
        },
        autoOpen: true,
        autoReconnect: true,
        minConnectTime: 2500,
        maxReconnectTime: 5000,
        noActivityTime: 10000,
        closeOnDestroy: true,
        suppressErrorsAfterDestroy: true
      },
      suppressTransactionErrors: true,
      retryOnException: false,
      maxConcurrentTransactions: 1,
      defaultUnit: this.line.unit,
      defaultMaxRetries: 0,
      defaultTimeout: RESPONSE_TIMEOUT
    });

    master.on('error', this.onMasterError.bind(this));
    master.on('open', this.onMasterOpen.bind(this));
    master.on('close', this.onMasterClose.bind(this));

    return master;
  }

  recordEvents(events)
  {
    const {Luma2Event} = this.module;

    const time = new Date();
    const eventTypes = new Set();
    const eventsToSave = [];
    const ctEvents = new Map();

    (Array.isArray(events) ? events : [events]).forEach(event =>
    {
      if (!event)
      {
        return;
      }

      if (!(event instanceof Luma2Event))
      {
        event = new Luma2Event({
          line: this.line._id,
          time,
          ...event
        });
      }

      eventsToSave.push(event.toJSON());
      eventTypes.add(event.type);

      if (this.isCtEvent(event))
      {
        ctEvents.set(event._id.toString(), {
          index: ctEvents.size,
          event
        });
      }
    });

    if (!eventsToSave.length)
    {
      return;
    }

    Luma2Event.insertMany(eventsToSave, {ordered: false, rawResult: true}, (err, res) =>
    {
      if (err && err.code !== 11000)
      {
        this.logger.error(err, 'Failed to record events.', {events: eventsToSave});

        return;
      }

      const count = res ? res.insertedCount : err && err.result ? err.result.nInserted : 0;

      if (count)
      {
        this.broker.publish('luma2.events.saved', {
          line: this.line._id,
          type: Array.from(eventTypes),
          count: count
        });

        this.recordCtTodos(ctEvents, err ? err.result.getWriteErrors() : []);
      }
    });
  }

  isCtEvent(event)
  {
    return event.station > 0
      && event.pce > 0
      && (event.type === 'pce-started' || event.type === 'pce-finished');
  }

  createCtTodo(event)
  {
    if (event.station <= 0 || event.pce <= 0)
    {
      return null;
    }

    if (event.type !== 'pce-started' && event.type !== 'pce-finished')
    {
      return null;
    }

    return {
      time: event.time,
      line: this.line._id,
      station: event.station,
      action: event.type,
      data: {
        orderNo: event.order,
        pce: event.pce
      }
    };
  }

  recordCtTodos(ctEvents, writeErrors)
  {
    writeErrors.forEach(writeError =>
    {
      if (writeError.code === 11000)
      {
        ctEvents.delete(writeError.getOperation()._id.toString());
      }
    });

    const ctTodos = Array.from(ctEvents.values()).sort((a, b) => a.index - b.index).map(({event}) =>
    {
      return {
        time: event.time,
        line: this.line._id,
        station: event.station,
        action: event.type,
        data: {
          orderNo: event.order,
          pce: event.pce
        }
      };
    });

    if (!ctTodos.length)
    {
      return;
    }

    this.module.CtTodo.insertMany(ctTodos, err =>
    {
      if (err)
      {
        this.logger.error(err, 'Failed to record CT todos.');
      }
      else
      {
        this.broker.publish('ct.todos.saved', {line: this.line._id});
      }
    });
  }

  onMasterError(err)
  {
    if (err.code === 'ECONNREFUSED')
    {
      this.logger.warn('Failed to connect.', {
        host: this.line.host,
        port: this.line.port
      });
    }
    else
    {
      this.logger.error(err, 'MODBUS error.');
    }
  }

  onMasterOpen()
  {
    this.logger.info('Connected.');
    this.recordEvents({type: 'connected'});
    this.scheduleEventCheck();
  }

  onMasterClose()
  {
    this.logger.warn('Disconnected.');
    this.recordEvents({type: 'disconnected'});

    this.eventCounter = -1;
    this.lastEventTime = 0;
    this.eventTimeCounter = 0;
  }

  scheduleEventCheck()
  {
    clearTimeout(this.eventCheckTimer);
    this.eventCheckTimer = setTimeout(this.checkEvents, EVENT_CHECK_INTERVAL);
  }

  checkEvents()
  {
    if (this.master.isOpen())
    {
      this.master.readHoldingRegisters(EVENT_COUNTER_ADDRESS, 1, this.handleCheckEvents);
    }
  }

  handleCheckEvents(err, res)
  {
    if (err)
    {
      this.logger.warn(err, 'Failed to read event counter.');

      this.scheduleEventCheck();

      return;
    }

    if (res.isException())
    {
      this.logger.warn(new Error(res.toString()), 'Failed to read event counter.');

      this.scheduleEventCheck();

      return;
    }

    const newEventCounter = Math.min(
      res.data[LITTLE_ENDIAN ? 'readUInt16LE' : 'readUInt16BE'](0, true),
      MAX_EVENT_COUNT
    );

    if (this.eventCounter === -1)
    {
      this.fetchAllEvents(newEventCounter);

      return;
    }

    if (newEventCounter !== 0 && newEventCounter !== this.eventCounter)
    {
      this.fetchNewEvents(newEventCounter);

      return;
    }

    this.scheduleEventCheck();
  }

  fetchAllEvents(newEventCounter)
  {
    this.readEvents(0, MAX_EVENT_COUNT, (err, events) =>
    {
      if (err)
      {
        this.logger.warn(err, 'Failed to read all events.');
      }
      else
      {
        this.recordEvents(events);

        this.eventCounter = newEventCounter;
      }

      this.scheduleEventCheck();
    });
  }

  fetchNewEvents(newEventCounter)
  {
    // Event overflow
    if (newEventCounter < this.eventCounter)
    {
      // Read to the end
      this.readEvents(this.eventCounter, MAX_EVENT_COUNT - this.eventCounter, (err, events) =>
      {
        if (err)
        {
          return this.handleEventFetchFailure(err);
        }

        this.recordEvents(events);

        // Read remaining from the beginning
        this.readEvents(0, newEventCounter, (err, events) =>
        {
          if (err)
          {
            return this.handleEventFetchFailure(err);
          }

          this.recordEvents(events);

          this.eventCounter = newEventCounter;

          this.scheduleEventCheck();
        });
      });
    }
    else
    {
      // Read the difference
      this.readEvents(this.eventCounter, newEventCounter - this.eventCounter, (err, events) =>
      {
        if (err)
        {
          return this.handleEventFetchFailure(err);
        }

        this.recordEvents(events);

        this.eventCounter = newEventCounter;

        this.scheduleEventCheck();
      });
    }
  }

  handleEventFetchFailure(err)
  {
    this.logger.warn(err, 'Failed to read events.');

    this.scheduleEventCheck();
  }

  readEvents(startingEvent, eventCount, done)
  {
    if (eventCount === 0)
    {
      return done(null, []);
    }

    const batchCount = Math.ceil(eventCount / MAX_EVENTS_PER_FRAME);
    const steps = [];
    let remainingEventCount = eventCount;

    steps.push(function()
    {
      this.events = [];
    });

    for (let i = 0; i < batchCount; ++i)
    {
      eventCount = remainingEventCount <= MAX_EVENTS_PER_FRAME ? remainingEventCount : MAX_EVENTS_PER_FRAME;

      const startingAddress = EVENT_START_ADDRESS + EVENT_REGISTER_SIZE * startingEvent;
      const quantity = eventCount * EVENT_REGISTER_SIZE;

      steps.push(this.createReadBatchStep(startingAddress, quantity));

      remainingEventCount -= eventCount;
      startingEvent += eventCount;
    }

    steps.push(function(err)
    {
      done(err, this.events);
    });

    step(steps);
  }

  createReadBatchStep(startingAddress, quantity)
  {
    const lineController = this;
    const {Luma2Event} = lineController.module;

    return function(err)
    {
      if (err)
      {
        return this.skip(err);
      }

      if (!lineController.master.isOpen())
      {
        return this.skip(new Error('No MODBUS connection.'));
      }

      const next = this.next();

      lineController.master.readHoldingRegisters(startingAddress, quantity, (err, res) =>
      {
        if (err)
        {
          return next(err);
        }

        const reader = new BufferReader(res.data);
        const events = [];

        while (reader.length)
        {
          const type = reader.shiftUInt16(LITTLE_ENDIAN);
          const weight = Luma2Event.WEIGHTS[Luma2Event.TYPES[type]] || 0;
          const eventData = {
            type,
            weight,
            time: reader.shiftUInt32(LITTLE_ENDIAN) * 1000,
            station: reader.shiftUInt16(LITTLE_ENDIAN),
            program: reader.shiftUInt16(LITTLE_ENDIAN),
            order: reader.shiftUInt32(LITTLE_ENDIAN),
            pce: reader.shiftUInt16(LITTLE_ENDIAN)
          };

          if (DEV)
          {
            reader.skip(4);
          }

          if (eventData.type > 0)
          {
            events.push(eventData);
          }
        }

        events.sort((a, b) =>
        {
          if (a.time === b.time)
          {
            return a.weight - b.weight;
          }

          return a.time - b.time;
        });

        events.forEach(eventData =>
        {
          if (eventData.time === lineController.lastEventTime)
          {
            lineController.eventTimeCounter += 1;
            eventData.time += lineController.eventTimeCounter;
          }
          else
          {
            lineController.lastEventTime = eventData.time;
            lineController.eventTimeCounter = 0;
          }

          this.events.push(lineController.createEvent(eventData));
        });

        next();
      });
    };
  }

  createEvent(data)
  {
    const {Luma2Event} = this.module;
    const time = data.time / 1000;
    const s = Math.floor(time);
    const ms = Math.round((time % 1) * 1000);

    return new Luma2Event({
      _id: new ObjectId(Buffer.from([
        (s >> 24) & 0xff,
        (s >> 16) & 0xff,
        (s >> 8) & 0xff,
        s & 0xff,
        (ms >> 8) & 0xff,
        ms & 0xff,
        (this.crc16 >> 8) & 0xff,
        this.crc16 & 0xff,
        data.type,
        data.station,
        (data.pce >> 8) & 0xff,
        data.pce & 0xff
      ])),
      line: this.line._id,
      type: Luma2Event.TYPES[data.type] || data.type.toString(),
      time: new Date(data.time),
      station: data.station,
      program: data.program,
      order: data.order,
      pce: data.pce
    });
  }
};
