// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');
const util = require('../reports/util');

exports.models = [
  require('./models/oshTalk'),
  require('kaizen/models/kaizenSection'),
  require('kaizen/models/kaizenTopic'),
  require('user/models/user')
];

exports.report = (app, module, options, done) =>
{
  const {
    User,
    KaizenSection,
    KaizenTopic,
    OshTalk
  } = module;

  const groupProperty = 'date';
  const results = {
    options,
    categories: {},
    sections: {},
    topics: {},
    users: {},
    totals: createGroup(),
    groups: {}
  };

  let minGroupKey = Number.MAX_VALUE;
  let maxGroupKey = Number.MIN_VALUE;

  step(
    async function findDictionariesStep()
    {
      const [sections, topics] = await Promise.all([
        KaizenSection
          .find({})
          .select({name: 1})
          .lean()
          .exec(),
        KaizenTopic
          .find({})
          .select({fullName: 1})
          .lean()
          .exec()
      ]);

      sections.forEach(section =>
      {
        results.sections[section._id] = section.name;
      });

      topics.forEach(topic =>
      {
        results.topics[topic._id] = topic.fullName;
      });
    },
    function findTalksStep()
    {
      const conditions = {};
      const fields = {
        status: 1,
        date: 1,
        auditor: 1,
        section: 1,
        topics: 1,
        participants: 1
      };

      if (options.fromTime)
      {
        conditions[groupProperty] = {$gte: new Date(options.fromTime)};
      }

      if (options.toTime)
      {
        if (!conditions[groupProperty])
        {
          conditions[groupProperty] = {};
        }

        conditions[groupProperty].$lt = new Date(options.toTime);
      }

      if (options.sections.length === 1)
      {
        conditions.section = options.sections[0];
      }
      else if (options.sections.length)
      {
        conditions.section = {$in: options.sections};
      }

      if (options.auditor)
      {
        conditions['auditor.id'] = options.auditor;
      }

      const stream = OshTalk.find(conditions).select(fields).lean().cursor();
      const next = _.once(this.next());

      stream.on('error', next);
      stream.on('end', next);
      stream.on('data', handleTalk);
    },
    function finalizeStep(err)
    {
      if (err)
      {
        return this.skip(err);
      }

      const createNextGroupKey = util.createCreateNextGroupKey(options.interval);
      const groups = [];
      let groupKey = minGroupKey;

      while (groupKey <= maxGroupKey)
      {
        groups.push(results.groups[groupKey] || groupKey);

        groupKey = createNextGroupKey(groupKey);
      }

      results.groups = groups;

      _.forEach([
        'countBySection',
        'topics',
        'auditors',
        'participants'
      ], sortTotals);
    },
    function sendResultsStep(err)
    {
      done(err, results);
    }
  );

  function createGroup(key)
  {
    return {
      key: key,
      count: 0,
      countBySection: {},
      topics: {},
      auditors: {},
      participants: {}
    };
  }

  function handleTalk(talk)
  {
    const auditor = User.transliterateName(talk.auditor.label);
    const totals = results.totals;
    const groupKey = util.createGroupKey(options.interval, talk[groupProperty], false);
    let group = results.groups[groupKey];

    if (groupKey < minGroupKey)
    {
      minGroupKey = groupKey;
    }

    if (groupKey > maxGroupKey)
    {
      maxGroupKey = groupKey;
    }

    if (!group)
    {
      group = results.groups[groupKey] = createGroup(groupKey);
    }

    results.users[auditor] = talk.auditor.label;

    if (!results.sections[talk.section])
    {
      results.sections[talk.section] = talk.section;
    }

    inc('count', talk.section);
    incGroup('auditors', auditor);

    talk.topics.forEach(topic =>
    {
      incGroup('topics', topic);
    });

    talk.participants.forEach(u =>
    {
      const participant = User.transliterateName(u.label);

      results.users[participant] = u.label;

      incGroup('participants', participant);
    });

    function inc(metricKey, section, category)
    {
      totals[metricKey] += 1;
      group[metricKey] += 1;

      if (section)
      {
        incGroup(`${metricKey}BySection`, section);
      }

      if (category)
      {
        incGroup(`${metricKey}ByCategory`, category);
      }
    }

    function incGroup(metricKey, id)
    {
      if (!totals[metricKey][id])
      {
        totals[metricKey][id] = 0;
      }

      if (!group[metricKey][id])
      {
        group[metricKey][id] = 0;
      }

      totals[metricKey][id] += 1;
      group[metricKey][id] += 1;
    }
  }

  function sortTotals(property)
  {
    const totals = [];

    _.forEach(results.totals[property], (value, key) =>
    {
      totals.push([key, value]);
    });

    results.totals[property] = totals.sort((a, b) => b[1] - a[1]);
  }
};
