// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const step = require('h5.step');

module.exports = (app, module) =>
{
  const {
    express,
    user,
    BrowserError
  } = module;

  const canView = user.auth('SUPER');
  const canAdd = user.auth('LOCAL', 'USER');
  const canUpdate = canView;

  express.get('/logs/browserErrors', canView, express.crud.browseRoute.bind(null, app, BrowserError));
  express.get('/logs/browserErrors/:id', canView, express.crud.readRoute.bind(null, app, BrowserError));
  express.post('/logs/browserErrors', canAdd, addBrowserError);
  express.put('/logs/browserErrors/:id', canUpdate, express.crud.editRoute.bind(null, app, BrowserError));
  express.post('/logs/browserErrors/:id;resolve', canUpdate, resolveBrowserError);

  function addBrowserError(req, res, next)
  {
    const browserError = new BrowserError({
      time: new Date(),
      user: user.createUserInfo(req.session.user, req),
      headers: req.headers,
      versions: req.body.versions,
      browser: req.body.browser,
      error: req.body.error
    });

    browserError.save((err) =>
    {
      if (err)
      {
        return next(err);
      }

      res.sendStatus(204);

      app.broker.publish('logs.browserErrors.saved', {
        errors: [browserError.toJSON()]
      });
    });
  }

  function resolveBrowserError(req, res, next)
  {
    step(
      function()
      {
        BrowserError.findById(req.params.id, {error: 1}).lean().exec(this.next());
      },
      function(err, browserError)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!browserError)
        {
          return this.skip();
        }

        const conditions = {
          resolved: false
        };

        if (browserError.error.stack.length)
        {
          conditions['error.stack.0'] = browserError.error.stack[0];
        }
        else
        {
          conditions['error.message'] = browserError.error.message;
          conditions['error.stack'] = {$size: 0};
        }

        BrowserError.find(conditions, {_id: 1}).exec(this.next());
      },
      function(err, browserErrors)
      {
        if (err)
        {
          return this.skip(err);
        }

        const ids = browserErrors.map(({_id}) => _id);

        setImmediate(this.parallel(), null, ids);

        BrowserError.updateMany({_id: {$in: ids}}, {$set: {resolved: true}}, this.parallel());
      },
      function(err, errors)
      {
        if (err)
        {
          return next(err);
        }

        res.sendStatus(204);

        if (errors && errors.length)
        {
          app.broker.publish('logs.browserErrors.resolved', {errors});
        }
      }
    );
  }
};
