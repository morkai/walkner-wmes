// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const fs = require('fs');
const step = require('h5.step');
const ejs = require('ejs');
const moment = require('moment');
const {ObjectId} = require('mongoose').Types;
const {formatDuration} = require('util/dateFormatter');

module.exports = (app, module) =>
{
  const {mailSender, User, DpCode, DpWorker, DpJob, DpOrder} = module;
  const logger = module.logger.create({submodule: 'notifier'});

  const emailTemplateFile = `${__dirname}/templates/notifier.email.pl.ejs`;
  const renderEmail = ejs.compile(fs.readFileSync(emailTemplateFile, 'utf8'), {
    cache: true,
    filename: emailTemplateFile,
    compileDebug: false,
    rmWhitespace: true
  });

  app.broker.subscribe(`${DpJob.TOPIC_PREFIX}.updated`, onJobUpdated);

  function onJobUpdated({updated})
  {
    (updated || []).forEach(changes =>
    {
      if (changes.status === 'finished' || changes.status === 'cancelled')
      {
        checkJob(changes._id);
      }
    });
  }

  function checkJob(jobId)
  {
    step(
      function()
      {
        DpJob
          .findById(jobId)
          .lean()
          .exec(this.next());
      },
      function(err, job)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!job || !job.notify.length)
        {
          return this.skip();
        }

        if (job.status === 'finished' || job.status === 'cancelled')
        {
          notifyJob(job, this.next());
        }
      },
      function(err)
      {
        if (err)
        {
          logger.error(err, `Failed to notify.`, {job: jobId});
        }
      }
    );
  }

  function notifyJob(job, done)
  {
    step(
      function()
      {
        DpCode
          .find({_id: {$in: job.codes}})
          .lean()
          .exec(this.parallel());

        DpWorker
          .findById(job.worker)
          .lean()
          .exec(this.parallel());

        const usersToNotify = new Map();

        job.notify.forEach(user =>
        {
          usersToNotify.set(user.id, new ObjectId(user.id));
        });

        User
          .find({
            _id: {$in: Array.from(usersToNotify.values())},
            email: /@/
          })
          .select({
            email: 1
          })
          .lean()
          .exec(this.parallel());
      },
      function(err, codes, worker, users)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!codes.length || !worker || !users.length)
        {
          return this.skip();
        }

        setImmediate(this.parallel(), null, codes);
        setImmediate(this.parallel(), null, worker);
        setImmediate(this.parallel(), null, users.map(u => u.email));

        const pipeline = [
          {$match: {job: job._id}},
          {$group: {
            _id: null,
            all: {$sum: 1},
            changes: {$sum: {$cond: {
              if: {$eq: ['$changed', true]},
              then: 1,
              else: 0
            }}},
            errors: {$sum: {$cond: {
              if: {$ne: ['$error', '']},
              then: 1,
              else: 0
            }}}
          }}
        ];

        DpOrder.aggregate(pipeline, this.parallel());
      },
      function(err, codes, worker, recipients, stats)
      {
        if (err)
        {
          return this.skip(err);
        }

        stats = stats[0] || {all: 0, changes: 0, errors: 0};

        let subject = `[WMES] [Dummy paint] `;

        if (job.stage === 'cancelled')
        {
          subject += `Podmiana farb anulowana`;
        }
        else if (stats.all === 0)
        {
          subject += `Podmiana farb zakończona bez zmian`;
        }
        else if (stats.errors === 0)
        {
          subject += `Podmiana farb zakończona pomyślnie`;
        }
        else
        {
          subject += `Podmiana farb zakończona z błędami`;
        }

        subject += `[${job._id.split('-').pop()}]`;

        const templateData = {
          urlPrefix: app.options.emailUrlPrefix,
          codes,
          worker,
          stats,
          job: {
            _id: job._id,
            createdAt: moment(job.createdAt).format('LLLL'),
            duration: formatDuration(moment(job.updatedAt).diff(job.createdAt) / 1000, true, false)
          }
        };

        const mailOptions = {
          to: recipients,
          replyTo: recipients,
          subject,
          html: renderEmail(templateData)
        };

        mailSender.send(mailOptions, this.next());
      },
      done
    );
  }
};
