// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const uuid = require('uuid');
const axios = require('axios');
const {createAsync: createLock} = require('util/locks');
const updaters = require('./updaters');

module.exports = (app, module) =>
{
  const {
    User,
    DpWorker,
    DpJob,
    DpOrder
  } = module;

  module.jobs = {
    startJob,
    updateJob,
    cancelJob,
    finishJob,
    startRemoteJob
  };

  app.broker.subscribe('app.started', () => setInterval(cancelJobs, 60000)).setLimit(1);

  async function startJob(data, createdBy)
  {
    const locks = [];
    const createdAt = new Date();
    const job = new DpJob({
      _id: uuid(),
      createdBy,
      createdAt,
      updatedBy: createdBy,
      updatedAt: createdAt,
      lastSeenAt: createdAt,
      codes: Array.isArray(data.codes) ? data.codes.filter(v => /^[0-9]{12}$/.test(v)) : [],
      orders: Array.isArray(data.orders) ? data.orders.filter(v => /^[0-9]{9}$/.test(v)) : [],
      worker: data.worker,
      status: 'inProgress',
      notify: data.notify || []
    });

    if (!job.codes.length && !job.orders.length)
    {
      throw app.createError('No codes or orders.', 'INPUT', 400);
    }

    try
    {
      locks.push(await createLock(`${DpJob.TOPIC_PREFIX}.startJob`));

      const worker = await DpWorker
        .findOne({_id: job.worker})
        .lean()
        .exec();

      if (!worker)
      {
        throw app.createError('Unknown worker.', 'INPUT', 400);
      }

      if (worker.lastSeenAt < (createdAt.getTime() - 5 * 60 * 1000))
      {
        throw app.createError('Offline worker.', 'WORKER_OFFLINE', 400);
      }

      if (job.codes.length)
      {
        const inProgressJob = await DpJob
          .findOne({
            status: 'inProgress',
            codes: {$in: job.codes}
          })
          .lean()
          .exec();

        if (inProgressJob)
        {
          throw app.createError('Code in progress.', 'CODE_IN_PROGRESS', 400, {
            newJob: job.toJSON(),
            inProgressJob
          });
        }
      }

      const inProgressJob = await DpJob
        .findOne({
          status: 'inProgress',
          worker: job.worker
        })
        .lean()
        .exec();

      if (inProgressJob)
      {
        throw app.createError('Worker in progress.', 'WORKER_IN_PROGRESS', 400, {inProgressJob});
      }

      await startRemoteJob(job, {
        name: 'dpLo',
        variant: 'WMES_DP_LO',
        scriptTimeout: 60 * 60 * 1000,
        components: job.codes
      });

      await job.save();

      const leanJob = job.toJSON();

      app.broker.publish(`${DpJob.TOPIC_PREFIX}.updated`, {
        added: [leanJob]
      });

      return leanJob;
    }
    catch (err)
    {
      throw err;
    }
    finally
    {
      locks.forEach(release => release());
    }
  }

  async function startRemoteJob(localJob, remoteJob)
  {
    const worker = await DpWorker
      .findById(localJob.worker)
      .select({
        user: 1,
        port: 1
      })
      .lean()
      .exec();

    if (!worker)
    {
      throw app.createError('Unknown worker.', 'INPUT', 400);
    }

    const user = await User
      .findById(worker.user.id)
      .select({apiKey: 1})
      .lean()
      .exec();

    if (!user)
    {
      throw app.createError('Unknown worker user.', 'INPUT', 400);
    }

    remoteJob.schedule = undefined;
    remoteJob.reportOnFailure = 0;
    remoteJob.waitForResult = false;
    remoteJob.workerJobId = localJob._id;
    remoteJob.sendResult = {
      method: 'POST',
      url: new URL(`/dummyPaint/jobs/${localJob._id};update`, module.config.baseUrl).toString(),
      headers: {
        'x-api-key': user.apiKey
      },
      body: {}
    };

    const res = await axios({
      method: 'POST',
      url: `http://${worker.user.ip}:${worker.port}/sapGui/jobs;run`,
      data: {
        secretKey: user.apiKey,
        job: remoteJob
      },
      timeout: 10000,
      validateStatus: null,
      proxy: false
    });

    if (res.status !== 200 && res.status !== 204)
    {
      const message = res.data && res.data.error && res.data.error.message || 'Invalid remote job response status.';

      throw app.createError(message, 'REMOTE_JOB_FAILURE', 400, {
        response: {
          status: res.status,
          statusText: res.statusText,
          data: res.data
        }
      });
    }

    return res;
  }

  async function updateJob(jobId, sapJobName, error, output, updater)
  {
    const locks = [await createLock(`${DpJob.TOPIC_PREFIX}.${jobId}`)];

    try
    {
      if (error)
      {
        return await cancelJob(jobId, error);
      }

      if (!updaters[sapJobName])
      {
        throw app.createError('Invalid SAP job name.', 'INPUT', 400, {
          jobId,
          sapJobName
        });
      }

      const job = await DpJob
        .findById(jobId)
        .lean()
        .exec();

      if (!job)
      {
        throw app.createError('Unknown job.', 'INPUT', 404, {
          jobId
        });
      }

      if (job.status !== 'inProgress')
      {
        throw app.createError('Job already finished.', 'STATE', 400, {
          jobId,
          jobStatus: job.status
        });
      }

      return await updaters[sapJobName](app, module, job, output, updater);
    }
    catch (err)
    {
      throw err;
    }
    finally
    {
      locks.forEach(release => release());
    }
  }

  async function cancelJobs()
  {
    const locks = [];

    try
    {
      locks.push(await createLock(`${DpJob}.cancelJobs`));

      const jobsToCancel = await DpJob
        .find({
          status: 'inProgress',
          lastSeenAt: {$lt: new Date(Date.now() - 5 * 60 * 1000)}
        })
        .select({_id: 1})
        .lean()
        .exec();

      for (const job of jobsToCancel)
      {
        locks.push(await createLock(`${DpJob.TOPIC_PREFIX}.${job._id}`));

        await cancelJob(job._id);
      }
    }
    catch (err)
    {
      module.error(err, 'Failed to cancel jobs.');
    }
    finally
    {
      locks.forEach(release => release());
    }
  }

  async function cancelJob(jobId, error)
  {
    const job = await DpJob
      .findOne({
        _id: jobId,
        status: 'inProgress'
      })
      .lean()
      .exec();

    if (!job)
    {
      return;
    }

    module.debug('Cancelling a job...', {
      jobId,
      lastSeenAt: job.lastSeenAt
    });

    const ops = [];

    job.status = 'cancelled';
    job.updatedAt = new Date();
    job.updatedBy = {id: null, label: 'System'};

    ops.push(DpJob.collection.updateOne({_id: job._id}, {$set: {
      status: job.status,
      updatedAt: job.updatedAt,
      updatedBy: job.updatedBy
    }}));

    const orders = await DpOrder
      .find({job: job._id})
      .select({
        _id: 1,
        dummyNc12: 1,
        createdAt: 1
      })
      .lean()
      .exec();

    if (orders.length)
    {
      const $set = {
        error: error || 'CANCELLED',
        stage: 'cancelled',
        updatedAt: job.updatedAt,
        updatedBy: job.updatedBy
      };

      ops.push(DpOrder.collection.updateMany({job: job._id}, {$set}));

      orders.forEach(order =>
      {
        Object.assign(order, $set);
      });
    }

    await Promise.all(ops);

    app.broker.publish(`${DpJob.TOPIC_PREFIX}.updated`, {
      updated: [job]
    });

    if (orders.length)
    {
      app.broker.publish(`${DpOrder.TOPIC_PREFIX}.updated`, {
        updated: orders
      });
    }
  }

  async function finishJob(jobId, updatedBy)
  {
    const job = await DpJob
      .findOne({
        _id: jobId,
        status: 'inProgress'
      })
      .lean()
      .exec();

    if (!job)
    {
      return;
    }

    module.debug('Finishing a job...', {jobId, updatedBy});

    const ops = [];

    job.status = 'finished';
    job.updatedAt = new Date();
    job.updatedBy = updatedBy;

    ops.push(DpJob.collection.updateOne({_id: job._id}, {$set: {
      status: job.status,
      updatedAt: job.updatedAt,
      updatedBy: job.updatedBy
    }}));

    const orders = await DpOrder
      .find({job: job._id})
      .select({
        _id: 1,
        dummyNc12: 1,
        createdAt: 1
      })
      .lean()
      .exec();

    if (orders.length)
    {
      const $set = {
        stage: 'finished',
        updatedAt: job.updatedAt,
        updatedBy: job.updatedBy
      };

      ops.push(DpOrder.collection.updateMany({job: job._id}, {$set}));

      orders.forEach(order =>
      {
        Object.assign(order, $set);
      });
    }

    await Promise.all(ops);

    app.broker.publish(`${DpJob.TOPIC_PREFIX}.updated`, {
      updated: [job]
    });

    if (orders.length)
    {
      app.broker.publish(`${DpOrder.TOPIC_PREFIX}.updated`, {
        updated: orders
      });
    }
  }
};
