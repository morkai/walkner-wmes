// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const dpBom = require('./dpBom');

module.exports = async (app, module, job, output, updatedBy) =>
{
  const {
    DpCode,
    DpOrder
  } = module;

  const leadingOrders = JSON.parse(output);

  if (!_.isPlainObject(leadingOrders))
  {
    throw app.createError('Invalid job output.', 'INPUT', 400);
  }

  if (_.isEmpty(leadingOrders))
  {
    module.debug('dpLo found no leading orders.', {jobId: job._id});

    return await module.jobs.finishJob(job._id, updatedBy);
  }

  const newOrdersMap = new Map();
  const childOrderNos = [];
  const createdAt = new Date();
  let leadingCount = 0;
  let childCount = 0;

  _.forEach(leadingOrders, (childOrders, leadingNo) =>
  {
    leadingCount += 1;

    childOrders.forEach(childOrder =>
    {
      childCount += 1;

      childOrderNos.push(childOrder.no);

      newOrdersMap.set(childOrder.no, {
        _id: childOrder.no,
        nc12: childOrder.nc12,
        name: childOrder.name,
        leadingNo,
        leadingNc12: '',
        leadingName: '',
        salesNo: '',
        salesItem: '',
        paintSource: '',
        productFamily: '',
        paintFamily: '',
        paintCategory: '',
        paintCode: '',
        dummyNc12: job.codes.length === 1 ? job.codes[0] : '',
        paintNc12: '',
        paintName: '',
        changed: false,
        error: '',
        stage: job.codes.length === 1 ? 'dpBom' : 'dpLo',
        job: job._id,
        createdAt,
        updatedAt: createdAt,
        updatedBy: updatedBy
      });
    });
  });

  module.debug('dpLo found leading orders.', {jobId: job._id, leadingCount, childCount});

  const ordersResult = {
    added: null,
    updated: []
  };

  const oldOrdersList = await DpOrder
    .find({_id: {$in: childOrderNos}})
    .lean()
    .exec();

  oldOrdersList.forEach(oldOrder =>
  {
    const newOrder = newOrdersMap.get(oldOrder._id);

    ordersResult.updated.push(newOrder);

    newOrdersMap.delete(oldOrder._id);
  });

  ordersResult.added = Array.from(newOrdersMap.values());

  const ordersOps = [];

  ordersResult.added.forEach(document =>
  {
    ordersOps.push({
      insertOne: {document}
    });
  });

  if (ordersResult.added.length)
  {
    ordersOps.push({
      insertMany: {
        documents: ordersResult.added
      }
    });
  }

  ordersResult.updated.forEach(update =>
  {
    ordersOps.push({
      updateOne: {
        filter: {_id: update._id},
        update: {$set: update}
      }
    });
  });

  await DpOrder.collection.bulkWrite(ordersOps);

  app.broker.publish(`${DpOrder.TOPIC_PREFIX}.updated`, ordersResult);

  if (job.codes.length !== 1)
  {
    module.debug('dpLo starting dpBom because of multiple codes.', {jobId: job._id, codes: job.codes});

    const codes = await DpCode
      .find({})
      .select({_id: 1})
      .lean()
      .exec();

    await module.jobs.startRemoteJob(job, {
      name: 'dpBom',
      scriptTimeout: 20 * 60 * 1000,
      orders: childOrderNos,
      components: codes.map(c => c._id)
    });

    return;
  }

  module.debug('dpLo going straight to dpBom because of a single code.', {jobId: job._id, codes: job.codes});

  return await dpBom(app, module, job, '{}', updatedBy);
};
