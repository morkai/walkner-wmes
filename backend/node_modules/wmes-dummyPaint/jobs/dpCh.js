// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const paint = require('./paint');

module.exports = async (app, module, job, output, updatedBy) =>
{
  const {
    settings,
    DpFamily,
    DpOrder
  } = module;

  const salesOrders = JSON.parse(output);

  if (!_.isPlainObject(salesOrders))
  {
    throw app.createError('Invalid job output.', 'INPUT', 400);
  }

  if (_.isEmpty(salesOrders))
  {
    return await module.jobs.finishJob(job, updatedBy);
  }

  const ordersResult = {
    updated: []
  };
  const ordersOps = [];
  const stage = 'dpCh';
  const updatedAt = new Date();

  const orders = await DpOrder
    .find({
      salesNo: {$in: Object.keys(salesOrders)},
      job: job._id
    })
    .select({
      dummyNc12: 1,
      salesNo: 1,
      salesItem: 1
    })
    .lean()
    .exec();

  let [nonAkzoCategories, nonRalCharacteristics] = await Promise.all([
    settings.findValue('dummyPaint.nonAkzoCategories'),
    settings.findValue('dummyPaint.nonRalCharacteristics')
  ]);

  if (!Array.isArray(nonAkzoCategories))
  {
    nonAkzoCategories = [];
  }

  if (!Array.isArray(nonRalCharacteristics))
  {
    nonRalCharacteristics = [];
  }

  const pfamToOrders = new Map();

  orders.forEach(order =>
  {
    const {error, items} = salesOrders[order.salesNo];

    ordersResult.updated.push(order);

    order.stage = stage;
    order.updatedAt = updatedAt;
    order.updatedBy = updatedBy;

    if (error)
    {
      order.error = error;

      return;
    }

    const item = items[order.salesItem] || {};

    if (item.error)
    {
      order.error = item.error;

      return;
    }

    const {config} = item;

    if (_.isEmpty(config))
    {
      return;
    }

    if (!config.PFAM)
    {
      order.error = 'NO_PFAM_CONFIG';

      return;
    }

    order.productFamily = config.PFAM;

    if (!pfamToOrders.has(order.productFamily))
    {
      pfamToOrders.set(order.productFamily, []);
    }

    pfamToOrders.get(order.productFamily).push(order);

    if (!config.CLR)
    {
      order.error = 'NO_CLR_CONFIG';

      return;
    }

    order.paintSource = 'CFG';
    order.paintCategory = config.CLR;

    const paintCodeProp = nonRalCharacteristics.includes(order.paintCategory) ? order.paintCategory : 'RAL';
    const paintCode = config[paintCodeProp];

    if (!paintCode)
    {
      order.error = 'NO_PAINT_CODE_CONFIG';

      return;
    }

    order.paintCode = paintCode;

    if (!nonAkzoCategories.includes(order.paintCategory))
    {
      order.paintFamily = 'AKZO';
    }
  });

  const families = await DpFamily
    .find({_id: {$in: Array.from(pfamToOrders.keys())}})
    .lean()
    .exec();

  families.forEach(family =>
  {
    pfamToOrders.get(family._id).forEach(order =>
    {
      if (!order.paintFamily)
      {
        order.paintFamily = family.paintFamily;
      }
    });
  });

  ordersResult.updated.forEach(update =>
  {
    ordersOps.push({
      updateOne: {
        filter: {_id: update._id},
        update: {$set: update}
      }
    });
  });

  if (ordersOps.length)
  {
    await DpOrder.collection.bulkWrite(ordersOps);

    app.broker.publish(`${DpOrder.TOPIC_PREFIX}.updated`, ordersResult);
  }

  const result = await DpOrder
    .aggregate([
      {$match: {
        job: job._id,
        paintCode: '',
        error: ''
      }},
      {$group: {
        _id: null,
        nc12s: {$addToSet: '$leadingNc12'}
      }}
    ])
    .exec();

  if (result.length === 1)
  {
    const {nc12s} = result[0];

    await module.jobs.startRemoteJob(job, {
      name: 'dpClr',
      scriptTimeout: 20 * nc12s.length * 1000,
      nc12s
    });

    return;
  }

  return await paint(app, module, job, updatedBy);
};
