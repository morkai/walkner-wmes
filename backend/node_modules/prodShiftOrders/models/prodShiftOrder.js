// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const {mapOperations} = require('production/logEntryHandlers/util');
const median = require('util/median');

exports.name = 'ProdShiftOrder';

exports.setUp = (app, mongoose) =>
{
  const orderLossSchema = new mongoose.Schema({
    reason: {
      type: String,
      ref: 'LossReason',
      required: true
    },
    label: {
      type: String,
      required: true,
      trim: true
    },
    count: {
      type: Number,
      required: true,
      min: 1
    }
  }, {
    _id: false
  });

  const psoSchema = new mongoose.Schema({
    _id: {
      type: String,
      required: true,
      trim: true
    },
    prodShift: {
      type: String,
      ref: 'ProdShift',
      default: null
    },
    pressWorksheet: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'PressWorksheet',
      default: null
    },
    division: {
      type: String,
      ref: 'Division',
      default: null
    },
    subdivision: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Subdivision',
      default: null
    },
    mrpControllers: [{
      type: 'String',
      ref: 'MrpController'
    }],
    prodFlow: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'ProdFlow',
      default: null
    },
    workCenter: {
      type: String,
      ref: 'WorkCenter',
      default: null
    },
    prodLine: {
      type: String,
      ref: 'ProdLine',
      required: true
    },
    date: {
      type: Date,
      trim: true
    },
    shift: {
      type: Number,
      min: 1,
      max: 3,
      required: true
    },
    subdivisionType: {
      type: String,
      default: 'assembly'
    },
    mechOrder: {
      type: Boolean,
      required: true
    },
    orderId: {
      type: String,
      required: true
    },
    operationNo: {
      type: String,
      required: true
    },
    orderData: {},
    laborTime: {
      type: Number,
      default: 0
    },
    laborSetupTime: {
      type: Number,
      default: 0
    },
    machineTime: {
      type: Number,
      default: 0
    },
    machineSetupTime: {
      type: Number,
      default: 0
    },
    workerCount: {
      type: Number,
      default: 0,
      min: 0
    },
    totalQuantity: {
      type: Number,
      default: 0,
      min: 0
    },
    quantityDone: {
      type: Number,
      default: 0,
      min: 0
    },
    quantityLost: {
      type: Number,
      default: 0,
      min: 0
    },
    losses: {
      type: [orderLossSchema],
      default: null
    },
    creator: {},
    startedAt: {
      type: Date,
      required: true
    },
    finishedAt: {
      type: Date,
      default: null
    },
    totalDuration: {
      type: Number,
      default: 0
    },
    workDuration: {
      type: Number,
      default: 0
    },
    opWorkDuration: {
      type: Number,
      default: 0
    },
    downtimeDuration: {
      type: Number,
      default: 0
    },
    breakDuration: {
      type: Number,
      default: 0
    },
    master: {},
    leader: {},
    operator: {},
    operators: [{}],
    notes: {
      type: String,
      default: ''
    },
    spigot: {},
    sapTaktTime: {
      type: Number,
      default: 0
    },
    lastTaktTime: {
      type: Number,
      default: 0
    },
    avgTaktTime: {
      type: Number,
      default: 0
    }
  }, {
    id: false,
    minimize: false
  });

  psoSchema.statics.TOPIC_PREFIX = 'prodShiftOrders';
  psoSchema.statics.BROWSE_LIMIT = 2000;

  psoSchema.index({prodShift: 1});
  psoSchema.index({pressWorksheet: 1});
  psoSchema.index({orderId: 1});
  psoSchema.index({startedAt: -1});
  psoSchema.index({finishedAt: -1});
  psoSchema.index({division: 1, startedAt: -1});
  psoSchema.index({subdivision: 1, startedAt: -1});
  psoSchema.index({mrpControllers: 1, startedAt: -1});
  psoSchema.index({prodFlow: 1, startedAt: -1});
  psoSchema.index({workCenter: 1, startedAt: -1});
  psoSchema.index({prodLine: 1, startedAt: -1});
  psoSchema.index({'orderData.mrp': 1, startedAt: -1});
  psoSchema.index({'orderData.nc12': 1, startedAt: -1});
  psoSchema.index({'orderData.bom.nc12': 1, startedAt: -1});
  psoSchema.index({'orderData.bom.item': 1, startedAt: -1});

  psoSchema.pre('save', function(next)
  {
    this._wasNew = this.isNew;

    if (this.isModified('quantityDone') || this.isModified('losses'))
    {
      this.recountTotals();
    }

    if (this.isModified('orderData'))
    {
      this.prepareOrderData();
    }

    if (!this._wasNew && (this.isModified('operationNo') || this.isModified('orderData')))
    {
      this.copyOperationData();
    }

    this._changes = this.modifiedPaths();

    next();
  });

  psoSchema.post('save', function(doc)
  {
    if (app.production.recreating)
    {
      return;
    }

    if (doc._wasNew)
    {
      app.broker.publish(`prodShiftOrders.created.${doc.prodLine}`, doc.toJSON());
    }
    else if (Array.isArray(doc._changes) && doc._changes.length)
    {
      const changes = {_id: doc._id};

      doc._changes.forEach(modifiedPath =>
      {
        if (!modifiedPath.includes('.'))
        {
          changes[modifiedPath] = doc.get(modifiedPath);
        }
      });
      doc._changes = null;

      app.broker.publish(`prodShiftOrders.updated.${doc._id}`, changes);
    }
  });

  psoSchema.post('remove', function(doc)
  {
    if (app.production.recreating)
    {
      return;
    }

    app.broker.publish(`prodShiftOrders.removed.${doc.prodLine}`, doc.toJSON());
  });

  psoSchema.statics.calcDurations = function(prodShiftOrder, prodDowntimes)
  {
    prodShiftOrder.totalDuration = Math.max(0, (prodShiftOrder.finishedAt - prodShiftOrder.startedAt) / 3600000);
    prodShiftOrder.breakDuration = 0;
    prodShiftOrder.downtimeDuration = 0;

    _.forEach(prodDowntimes, function(prodDowntime)
    {
      const duration = (prodDowntime.finishedAt - prodDowntime.startedAt) / 3600000;

      if (duration > 0)
      {
        const reason = app.downtimeReasons.modelsById[prodDowntime.reason];
        const property = reason && reason.type === 'break' ? 'breakDuration' : 'downtimeDuration';

        prodShiftOrder[property] += duration;
      }
    });

    prodShiftOrder.workDuration = prodShiftOrder.totalDuration - prodShiftOrder.breakDuration;
  };

  psoSchema.statics.copyOperationData = function(prodShiftOrder, operations)
  {
    prodShiftOrder.laborTime = 0;
    prodShiftOrder.laborSetupTime = 0;
    prodShiftOrder.machineTime = 0;
    prodShiftOrder.machineSetupTime = 0;

    if (!prodShiftOrder.operationNo)
    {
      return;
    }

    if (Array.isArray(operations))
    {
      operations = mapOperations(operations);
    }
    else if (!operations)
    {
      operations = prodShiftOrder.orderData ? prodShiftOrder.orderData.operations : null;
    }

    if (!operations)
    {
      return;
    }

    const operation = operations[prodShiftOrder.operationNo];

    if (!operation)
    {
      return;
    }

    if (!app.orders || !app.orders.getGroupedOperations)
    {
      prodShiftOrder.laborTime = operation.laborTime > 0 ? operation.laborTime : 0;
      prodShiftOrder.laborSetupTime = operation.laborSetupTime > 0 ? operation.laborSetupTime : 0;
      prodShiftOrder.machineTime = operation.machineTime > 0 ? operation.machineTime : 0;
      prodShiftOrder.machineSetupTime = operation.machineSetupTime > 0 ? operation.machineSetupTime : 0;

      return;
    }

    app.orders.getGroupedOperations(operations, prodShiftOrder.operationNo).forEach(operation =>
    {
      prodShiftOrder.laborTime += operation.laborTime > 0 ? operation.laborTime : 0;
      prodShiftOrder.laborSetupTime += operation.laborSetupTime > 0 ? operation.laborSetupTime : 0;
      prodShiftOrder.machineTime += operation.machineTime > 0 ? operation.machineTime : 0;
      prodShiftOrder.machineSetupTime += operation.machineSetupTime > 0 ? operation.machineSetupTime : 0;
    });
  };

  psoSchema.statics.getOperation = function(pso)
  {
    return pso.orderData && pso.orderData.operations && pso.orderData.operations[pso.operationNo] || null;
  };

  psoSchema.statics.getTaktTimeCoeff = function(pso)
  {
    return psoSchema.statics.getWcTaktTimeCoeff(
      pso.orderData && pso.orderData.taktTimeCoeff,
      psoSchema.statics.getOperation(pso)
    );
  };

  // Check frontend/app/prodShiftOrders/ProdShiftOrder.js#getWcTaktTimeCoeff
  psoSchema.statics.getWcTaktTimeCoeff = function(wcToCoeff, operation)
  {
    if (!wcToCoeff || !operation)
    {
      return 1;
    }

    return wcToCoeff[operation.workCenter + '/' + operation.no]
      || wcToCoeff['*' + '/' + operation.no]
      || wcToCoeff[operation.workCenter]
      || wcToCoeff['*']
      || 1;
  };

  psoSchema.methods.getOperation = function()
  {
    return psoSchema.statics.getOperation(this);
  };

  psoSchema.methods.getTaktTimeCoeff = function()
  {
    return psoSchema.statics.getTaktTimeCoeff(this);
  };

  psoSchema.methods.isEditable = function()
  {
    return this.finishedAt !== null && this.pressWorksheet === null;
  };

  psoSchema.methods.prepareOrderData = function()
  {
    if (this.orderData.planOrderGroups)
    {
      this.orderData.planOrderGroup = this.orderData.planOrderGroups[this.prodLine] || null;
      delete this.orderData.planOrderGroups;
    }
  };

  psoSchema.methods.copyOperationData = function(operations)
  {
    this.constructor.copyOperationData(this, operations);
  };

  psoSchema.methods.recountTotals = function()
  {
    if (Array.isArray(this.losses) && this.losses.length === 1 && this.losses[0] === null)
    {
      this.losses = null;
    }

    this.quantityLost = !Array.isArray(this.losses)
      ? 0
      : this.losses.reduce((sum, loss) => sum + (loss && typeof loss.count === 'number' ? loss.count : 0), 0);
    this.totalQuantity = this.quantityDone + this.quantityLost;
  };

  psoSchema.methods.recalcDurations = function(save, done)
  {
    this.totalDuration = 0;
    this.workDuration = 0;
    this.downtimeDuration = 0;
    this.breakDuration = 0;

    if (!this.finishedAt)
    {
      return save ? this.save(done) : done();
    }

    const conditions = {
      prodShiftOrder: this._id,
      finishedAt: {$ne: null}
    };
    const fields = {
      reason: 1,
      startedAt: 1,
      finishedAt: 1
    };
    const prodShiftOrder = this;

    mongoose.model('ProdDowntime').find(conditions, fields).lean().exec(function(err, prodDowntimes)
    {
      if (err)
      {
        return done(err);
      }

      prodShiftOrder.constructor.calcDurations(prodShiftOrder, prodDowntimes);

      if (save)
      {
        prodShiftOrder.save(done);
      }
      else
      {
        done();
      }
    });
  };

  psoSchema.methods.recalcCycleTime = function(done)
  {
    this.orderData.cycleTime = null;

    const conditions = {
      'order.pso': this._id
    };
    const fields = {
      station: 1,
      'durations.work': 1
    };
    const order = {
      'durations.work': 1
    };

    mongoose.model('CtPce').find(conditions).select(fields).sort(order).lean().exec((err, ctPces) =>
    {
      if (err)
      {
        return done(err);
      }

      if (!ctPces.length)
      {
        return done();
      }

      const minCycleTime = 1001;
      const maxCycleTime = this.sapTaktTime > 0 ? (this.sapTaktTime * 10 * 1000) : (8 * 3600 * 1000);
      const cycleTime = this.orderData.cycleTime = {
        med: [[]],
        sum: [0],
        avg: [0],
        cnt: [0],
        min: [Number.MAX_SAFE_INTEGER],
        max: [Number.MIN_SAFE_INTEGER]
      };

      ctPces.forEach(ctPce =>
      {
        const workDuration = ctPce.durations.work;

        if (workDuration < minCycleTime || workDuration > maxCycleTime)
        {
          return;
        }

        const s = ctPce.station;

        if (cycleTime.med[s] === undefined)
        {
          cycleTime.med[s] = [];
          cycleTime.sum[s] = 0;
          cycleTime.avg[s] = 0;
          cycleTime.cnt[s] = 0;
          cycleTime.min[s] = Number.MAX_SAFE_INTEGER;
          cycleTime.max[s] = Number.MIN_SAFE_INTEGER;
        }

        cycleTime.med[0].push(workDuration);
        cycleTime.med[s].push(workDuration);
        cycleTime.sum[0] += workDuration;
        cycleTime.sum[s] += workDuration;
        cycleTime.avg[0] += workDuration;
        cycleTime.avg[s] += workDuration;
        cycleTime.cnt[0] += 1;
        cycleTime.cnt[s] += 1;
        cycleTime.min[0] = Math.min(cycleTime.min[0], workDuration);
        cycleTime.min[s] = Math.min(cycleTime.min[s], workDuration);
        cycleTime.max[0] = Math.max(cycleTime.max[0], workDuration);
        cycleTime.max[s] = Math.max(cycleTime.max[s], workDuration);
      });

      for (let s = 0; s < cycleTime.med.length; ++s)
      {
        if (cycleTime.med[s] === undefined)
        {
          cycleTime.med[s] = 0;
          cycleTime.sum[s] = 0;
          cycleTime.avg[s] = 0;
          cycleTime.cnt[s] = 0;
          cycleTime.min[s] = 0;
          cycleTime.max[s] = 0;

          continue;
        }

        cycleTime.med[s] = Math.round(median(cycleTime.med[s], true));
        cycleTime.avg[s] = Math.round(cycleTime.avg[s] / cycleTime.cnt[s]);

        if (cycleTime.min[s] === Number.MAX_SAFE_INTEGER)
        {
          cycleTime.min[s] = 0;
        }

        if (cycleTime.max[s] === Number.MIN_SAFE_INTEGER)
        {
          cycleTime.max[s] = 0;
        }
      }

      this.markModified('orderData.cycleTime');

      done();
    });
  };

  mongoose.model(exports.name, psoSchema);
};
