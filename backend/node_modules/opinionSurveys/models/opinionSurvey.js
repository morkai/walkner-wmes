// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const moment = require('moment');

const LANG = {
  pl: {
    HEADER: `Badanie OPINIA`,
    COMPANY: `{COMPANY}`,
    FOOTER: `Wszelkie prawa zastrzeżone przez {COMPANY}.<br>Powielanie w całości lub w częściach bez zgody właściciela jest zabronione.`,
    COMMENT: `<strong>Dodatkowe uwagi, komentarze, które Twoim zdaniem, powinny być przeanalizowane przez kierownictwo w&nbsp;ramach badania OPINIA</strong> (sposób prowadzenia badania, zawartość ankiety, działania po badaniu, itp.):`,
    METRICS: `Metryczka`,
    HELP: `zamaluj odpowiednie kółko:`,
    EMPLOYER: `Jestem pracownikiem:`,
    SUPERIOR: `Mój przełożony to:`,
    SURVEY: `Ankieta`,
    WARNING: `<strong>UWAGA:</strong> Na poniższe pytania prosimy odpowiadać <u>w perspektywie swojego miejsca pracy</u>,<br>np. centrum produkcyjne/magazyn komponentów.`,
    NO: `Lp.`,
    QUESTION: `Pytanie`,
    DONT_AGREE: `Nie zgadzam<br>się`,
    WHATEVER: `Nie mam<br>zdania`,
    AGREE: `Zgadzam<br>się`,
    PRINT_VERSION: `Wersja do druku`,
    THANKS: `Dziękujemy za wypełnienie ankiety!`,
    NO_SURVEY: `Aktualnie nie jest przeprowadzane żadne badanie.`
  },
  ua: {
    HEADER: `Обстеження OPINIA`,
    COMPANY: `{COMPANY}`,
    FOOTER: `Всі права захищені {COMPANY}.<br>Повторне відтворення повністю або частково без згоди власника заборонено.`,
    COMMENT: `<strong>Додаткові правки, коментарі, які на вашу думку, повинні бути проаналізовані керівництвом в&nbsp;рамках дослідження OPINIA</strong> (спосіб проведення дослідження, контент анкети,  дії після дослідження і тд.):`,
    METRICS: `Вихідні дані`,
    HELP: `замалюй відповідне коло:`,
    EMPLOYER: `Я є працівником:`,
    SUPERIOR: `Мій керівник – це:`,
    SURVEY: `Опитувальник`,
    WARNING: `<strong>УВАГА:</strong> на подальші питання просимо відповідати <u>з перспективи свого місця роботи</u>, напр. виробничий центр/склад.`,
    NO: `№`,
    QUESTION: `Питання`,
    DONT_AGREE: `Не<br>погоджуюсь`,
    WHATEVER: `Не<br>знаю`,
    AGREE: `Погоджуюсь`,
    PRINT_VERSION: `Версія для друку`,
    THANKS: `Дякуємо за завершення опитування!`,
    NO_SURVEY: `В даний час дослідження не проводиться.`
  }
};
const COMPANY = {
  ketrzyn: {
    pl: `Kętrzyn`,
    ua: `Ketrzyn`
  },
  pila: {
    pl: `Piła`,
    ua: `Pila`
  }
};

exports.name = 'OpinionSurvey';

exports.setUp = (app, mongoose) =>
{
  const opinionSurveyEmployerSchema = new mongoose.Schema({
    _id: {
      type: String,
      required: true
    },
    full: {
      type: String,
      required: true
    },
    short: {
      type: String,
      required: true
    }
  }, {
    id: false
  });

  const opinionSurveySuperiorSchema = new mongoose.Schema({
    _id: {
      type: String,
      required: true
    },
    full: {
      type: String,
      required: true
    },
    short: {
      type: String,
      required: true
    },
    division: {
      type: String,
      required: true
    }
  }, {
    id: false
  });

  const opinionSurveyQuestionSchema = new mongoose.Schema({
    _id: {
      type: String,
      required: true
    },
    full: {
      type: String,
      required: true
    },
    short: {
      type: String,
      required: true
    }
  }, {
    id: false
  });

  const opinionSurveyEmployeeCountSchema = new mongoose.Schema({
    division: {
      type: String,
      required: true
    },
    employer: {
      type: String,
      required: true
    },
    count: {
      type: Number,
      required: true,
      min: 0
    }
  }, {
    _id: false
  });

  const opinionSurveySchema = new mongoose.Schema({
    _id: {
      type: String,
      required: true
    },
    template: {
      type: String,
      enum: ['ketrzyn', 'pila'],
      default: 'ketrzyn'
    },
    startDate: {
      type: Date,
      required: true
    },
    endDate: {
      type: Date,
      required: true
    },
    label: {
      type: String,
      required: true
    },
    company: {
      type: String,
      required: true
    },
    intro: {
      type: String,
      default: ''
    },
    employer: {
      type: String,
      default: ''
    },
    superior: {
      type: String,
      default: ''
    },
    showDivision: {
      type: Boolean,
      default: true
    },
    employers: [opinionSurveyEmployerSchema],
    superiors: [opinionSurveySuperiorSchema],
    questions: [opinionSurveyQuestionSchema],
    employeeCount: [opinionSurveyEmployeeCountSchema],
    lang: {}
  }, {
    id: false,
    minimize: false
  });

  opinionSurveySchema.statics.TOPIC_PREFIX = 'opinionSurveys.surveys';

  opinionSurveySchema.pre('save', function(next)
  {
    if (this.isModified('employers') || this.isModified('superiors'))
    {
      this.serializeEmployees();
    }

    next();
  });

  opinionSurveySchema.statics.translate = function(survey, divisions, language, preview)
  {
    if (survey)
    {
      survey.superiors.forEach(superior =>
      {
        const division = divisions.find(d => d._id === superior.division);

        if (division)
        {
          superior.division = division.short;
        }
      });
    }

    const momentLocale = language === 'ua' ? 'uk' : language;
    const templateData = {
      cache: false,
      LANG: {...LANG.pl, ...LANG[language]},
      moment: (date) => moment(date).locale(momentLocale),
      referrals: null,
      questions: [],
      language,
      survey
    };

    if (survey && !preview && survey.lang && survey.lang[language])
    {
      Object.keys(survey.lang[language]).forEach(prop =>
      {
        if (Array.isArray(survey[prop]))
        {
          survey[prop].forEach((v, i) =>
          {
            Object.assign(survey[prop][i], survey.lang[language][prop][i]);
          });
        }
        else
        {
          survey[prop] = survey.lang[language][prop];
        }
      });
    }

    const companyLang = survey && COMPANY[survey.template] || COMPANY.ketrzyn;
    const company = survey && survey.company || companyLang[language] || companyLang.pl;

    Object.keys(templateData.LANG).forEach(k =>
    {
      templateData.LANG[k] = templateData.LANG[k].replace('{COMPANY}', company);
    });

    if (templateData.survey)
    {
      if (templateData.survey.employer)
      {
        templateData.LANG.EMPLOYER = templateData.survey.employer;
      }

      if (templateData.survey.superior)
      {
        templateData.LANG.SUPERIOR = templateData.survey.superior;
      }
    }

    templateData.referrals = null;
    templateData.questions = (survey ? survey.questions : []).filter(q =>
    {
      if (/referral/i.test(q._id))
      {
        templateData.referrals = q;

        return false;
      }

      return true;
    });

    const superiorCount = survey ? survey.superiors.length : 0;

    if (superiorCount <= 5)
    {
      templateData.superiorColumnLength = 5;
    }
    else if (superiorCount <= 12)
    {
      templateData.superiorColumnLength = Math.ceil(superiorCount / 2);
    }
    else
    {
      templateData.superiorColumnLength = Math.ceil(superiorCount / 3);
    }

    if (templateData.superiorColumnLength > 6)
    {
      templateData.superiorColumnLength = 6;
    }

    if (survey)
    {
      this.prepareIntro(survey);
    }

    return templateData;
  };

  opinionSurveySchema.statics.prepareIntro = function(opinionSurvey)
  {
    let intro = opinionSurvey.intro.trim();

    if (!/<p.*?>/.test(intro))
    {
      intro = intro.split('\n').map(line => `<p>${line.trim()}</p>`).join('\n');
    }

    opinionSurvey.intro = intro;
  };

  opinionSurveySchema.methods.serializeEmployees = function()
  {
    const oldValues = {};
    const newValues = [];

    _.forEach(this.employeeCount, function(employeeCount)
    {
      oldValues[employeeCount.division + employeeCount.employer] = employeeCount.count;
    });

    const employers = this.employers;

    _.forEach(_.uniq(_.map(this.superiors, 'division')), function(divisionId)
    {
      _.forEach(employers, function(employer)
      {
        newValues.push({
          division: divisionId,
          employer: employer._id,
          count: oldValues[divisionId + employer._id] || 0
        });
      });
    });

    this.employeeCount = newValues;
  };

  mongoose.model(exports.name, opinionSurveySchema);
};
