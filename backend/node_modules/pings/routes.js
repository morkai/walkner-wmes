// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const moment = require('moment');

module.exports = (app, module) =>
{
  const {express, user, Ping} = module;

  const canView = user.auth('LOCAL', 'SUPER');
  const canManage = user.auth('SUPER');

  express.options('/ping', setPingHeaders, (req, res) => res.end());

  express.get('/ping', setPingHeaders, (req, res) => res.format({
    text: () =>
    {
      res.send('pong');
    },
    json: () =>
    {
      res.json('pong');
    }
  }));

  express.get('/pings', canView, express.crud.browseRoute.bind(null, app, Ping));

  express.delete('/pings', canManage, deletePings);

  express.get('/pings;by-app', canView, aggregate.bind(null, {
    _id: {$ifNull: ['$headers.x-wmes-app', '']},
    min: {$min: '$time'},
    max: {$max: '$time'},
    sum: {$sum: 1},
    ip: {$addToSet: '$user.ip'}
  }));
  express.get('/pings;by-ip', canView, aggregate.bind(null, {
    _id: '$user.ip',
    min: {$min: '$time'},
    max: {$max: '$time'},
    sum: {$sum: 1},
    app: {$addToSet: {$ifNull: ['$headers.x-wmes-app', '']}}
  }));
  express.get('/pings;by-user', canView, aggregate.bind(null, {
    _id: '$user.id',
    min: {$min: '$time'},
    max: {$max: '$time'},
    sum: {$sum: 1},
    ip: {$addToSet: '$user.ip'},
    app: {$addToSet: {$ifNull: ['$headers.x-wmes-app', '']}}
  }));

  function setPingHeaders(req, res, next)
  {
    res.set('Access-Control-Allow-Origin', '*');
    res.set('Access-Control-Allow-Methods', 'GET');
    res.set('Access-Control-Allow-Headers', req.headers['access-control-request-headers'] || '');

    next();
  }

  function deletePings(req, res, next)
  {
    const days = +req.query.days;

    if (isNaN(days) || days < 1)
    {
      return next(app.createError('Invalid days.', 'INPUT', 400));
    }

    Ping.deleteMany({time: moment().startOf('day').subtract(days, 'days').toDate}, err =>
    {
      if (err)
      {
        return next(err);
      }

      res.sendStatus(204);
    });
  }

  function aggregate($group, req, res, next)
  {
    const unit = req.query.unit || 'hours';
    const time = +req.query.time || 8;

    const pipeline = [
      {
        $match: {
          time: {$gte: moment().startOf(unit).subtract(time, unit).toDate()}
        }
      },
      {$group}
    ];

    Ping.aggregate(pipeline, (err, results) =>
    {
      if (err)
      {
        return next(err);
      }

      res.json(results);
    });
  }
};
