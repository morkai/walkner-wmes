// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const fs = require('fs');
const _ = require('lodash');
const ejs = require('ejs');
const moment = require('moment');

const SUBJECTS = {
  nearMiss: {
    new: entry => `Nowe ZPW: ${entry.rid} [REAGUJ] [ZPW]`,
    inProgress: entry => `ZPW do realizacji: ${entry.rid} [REAGUJ] [ZPW]`,
    finished: entry => `ZPW zakończone: ${entry.rid} [REAGUJ] [ZPW]`,
    paused: entry => `ZPW wstrzymane: ${entry.rid} [REAGUJ] [ZPW]`,
    cancelled: entry => `ZPW anulowane: ${entry.rid} [REAGUJ] [ZPW]`
  },
  kaizen: {
    new: entry => `Nowy kaizen: ${entry.rid} [REAGUJ] [KAIZEN]`,
    inProgress: entry => `Kaizen do realizacji: ${entry.rid} [REAGUJ] [KAIZEN]`,
    verification: entry => `Kaizen do weryfikacji: ${entry.rid} [REAGUJ] [KAIZEN]`,
    finished: entry => `Kaizen zakończony: ${entry.rid} [REAGUJ] [KAIZEN]`,
    paused: entry => `Kaizen wstrzymany: ${entry.rid} [REAGUJ] [KAIZEN]`,
    cancelled: entry => `Kaizen anulowany: ${entry.rid} [REAGUJ] [KAIZEN]`
  },
  action: {
    new: entry => `Nowa akcja: ${entry.rid} [REAGUJ] [AKCJE]`,
    inProgress: entry => `Akcja do realizacji: ${entry.rid} [REAGUJ] [AKCJE]`,
    verification: entry => `Akcja do weryfikacji: ${entry.rid} [REAGUJ] [AKCJE]`,
    finished: entry => `Akcja zakończona: ${entry.rid} [REAGUJ] [AKCJE]`,
    paused: entry => `Akcja wstrzymana: ${entry.rid} [REAGUJ] [AKCJE]`,
    cancelled: entry => `Akcja anulowana: ${entry.rid} [REAGUJ] [AKCJE]`
  }
};

module.exports = (app, module) =>
{
  const {
    mailSender,
    User,
    OshKind,
    OshNearMiss,
    OshKaizen,
    OshAction
  } = module;

  const logger = module.logger.create({submodule: 'notifier'});

  const TEMPLATES = {
    nearMiss: ejs.compile(fs.readFileSync(`${__dirname}/templates/notifier/nearMiss.pl.ejs`, 'utf8'), {
      cache: true,
      compileDebug: false,
      rmWhitespace: true
    }),
    kaizen: ejs.compile(fs.readFileSync(`${__dirname}/templates/notifier/kaizen.pl.ejs`, 'utf8'), {
      cache: true,
      compileDebug: false,
      rmWhitespace: true
    }),
    action: ejs.compile(fs.readFileSync(`${__dirname}/templates/notifier/action.pl.ejs`, 'utf8'), {
      cache: true,
      compileDebug: false,
      rmWhitespace: true
    })
  };
  const NAMES = {
    status: {
      new: 'Nowe',
      inProgress: 'Realizacja',
      verification: 'Weryfikacja',
      finished: 'Zakończone',
      paused: 'Wstrzymane',
      cancelled: 'Anulowane'
    },
    priority: {
      0: 'Niski',
      1: 'Normalny',
      2: 'Wysoki',
      3: 'Krytyczny'
    },
    resolution: {
      unspecified: 'brak działań',
      action: 'powrót do standardu',
      kaizen: 'usprawnienie'
    }
  };
  const DICTIONARIES = {
    company: {model: module.DICTIONARIES.companies.model},
    division: {model: module.DICTIONARIES.divisions.model},
    workplace: {model: module.DICTIONARIES.workplaces.model},
    department: {model: module.DICTIONARIES.departments.model},
    building: {model: module.DICTIONARIES.buildings.model},
    location: {model: module.DICTIONARIES.locations.model},
    station: {model: module.DICTIONARIES.stations.model},
    kind: {model: module.DICTIONARIES.kinds.model},
    activityKind: {model: module.DICTIONARIES.activityKinds.model},
    observationKind: {model: module.DICTIONARIES.observationKinds.model},
    observationCategory: {model: module.DICTIONARIES.observationCategories.model},
    eventCategory: {model: module.DICTIONARIES.eventCategories.model},
    reasonCategory: {model: module.DICTIONARIES.reasonCategories.model},
    rootCauseCategory: {model: module.DICTIONARIES.rootCauseCategories.model},
    kaizenCategory: {model: module.DICTIONARIES.kaizenCategories.model}
  };

  Object.keys(DICTIONARIES).forEach(key =>
  {
    const topicPrefix = DICTIONARIES[key].model.TOPIC_PREFIX;

    app.broker.subscribe(`${topicPrefix}.*`, () =>
    {
      DICTIONARIES[key] = {};
    });
  });

  app.broker.subscribe(`${OshNearMiss.TOPIC_PREFIX}.added`, message =>
  {
    handleNearMissAdded(message.model);
  });

  app.broker.subscribe(`${OshNearMiss.TOPIC_PREFIX}.edited`, message =>
  {
    handleNearMissEdited(message.model);
  });

  app.broker.subscribe(`${OshKaizen.TOPIC_PREFIX}.added`, message =>
  {
    handleKaizenAdded(message.model);
  });

  app.broker.subscribe(`${OshKaizen.TOPIC_PREFIX}.edited`, message =>
  {
    handleKaizenEdited(message.model);
  });

  app.broker.subscribe(`${OshAction.TOPIC_PREFIX}.added`, message =>
  {
    handleActionAdded(message.model);
  });

  app.broker.subscribe(`${OshAction.TOPIC_PREFIX}.edited`, message =>
  {
    handleActionEdited(message.model);
  });

  async function handleNearMissAdded(entry)
  {
    try
    {
      const recipients = new Set(entry.coordinators.map(u => u.id));

      recipients.delete(entry.creator.id);

      await notifyNearMiss(entry, recipients, SUBJECTS.nearMiss[entry.status]);
    }
    catch (err)
    {
      logger.error(err, `Failed to notify about a new near miss.`, {
        rid: entry.rid
      });
    }
  }

  async function handleNearMissEdited(entry)
  {
    const change = _.last(entry.changes);
    const statusChange = change.data.status;
    const newCoordinators = change.data.coordinators && change.data.coordinators[1].added || [];
    const newImplementer = change.data.implementer && change.data.implementer[1] || null;
    const recipientList = [];

    newCoordinators.forEach(u => recipientList.push(u));

    if (newImplementer)
    {
      recipientList.push(newImplementer);
    }

    if (statusChange)
    {
      recipientList.push(entry.creator);

      if (entry.implementer)
      {
        recipientList.push(entry.implementer);
      }

      if (statusChange[1] === 'finished' && entry.acceptor)
      {
        recipientList.push(entry.acceptor);
      }
    }

    const recipientSet = new Set(recipientList.map(u => u.id));

    recipientSet.delete(change.user.id);

    if (!recipientSet.size)
    {
      return;
    }

    try
    {
      await notifyNearMiss(entry, recipientSet, SUBJECTS.nearMiss[entry.status]);
    }
    catch (err)
    {
      logger.error(err, `Failed to notify about a near miss edit.`, {
        rid: entry.rid
      });
    }
  }

  async function handleKaizenAdded(entry) // eslint-disable-line
  {
    if (entry.status !== 'inProgress' || !entry.implementers.length)
    {
      return;
    }

    try
    {
      const recipients = new Set(entry.implementers.map(u => u.id));

      recipients.delete(entry.creator.id);

      await notifyKaizen(entry, recipients, SUBJECTS.kaizen[entry.status]);
    }
    catch (err)
    {
      logger.error(err, `Failed to notify about a new kaizen.`, {
        rid: entry.rid
      });
    }
  }

  async function handleKaizenEdited(entry)
  {
    const change = _.last(entry.changes);
    const statusChange = change.data.status;
    const newCoordinators = change.data.coordinators && change.data.coordinators[1].added || [];
    const newImplementers = change.data.implementers && change.data.implementers[1].added || [];
    const recipientList = [];

    newCoordinators.forEach(u => recipientList.push(u));
    newImplementers.forEach(u => recipientList.push(u));

    if (statusChange)
    {
      recipientList.push(entry.creator);

      if (entry.implementers)
      {
        entry.implementers.forEach(u => recipientList.push(u));
      }

      if (entry.acceptor
        && (statusChange[1] === 'verification' || statusChange[1] === 'finished'))
      {
        recipientList.push(entry.acceptor);
      }
    }

    const recipientSet = new Set(recipientList.map(u => u.id));

    recipientSet.delete(change.user.id);

    if (!recipientSet.size)
    {
      return;
    }

    try
    {
      await notifyKaizen(entry, recipientSet, SUBJECTS.kaizen[entry.status]);
    }
    catch (err)
    {
      logger.error(err, `Failed to notify about a kaizen edit.`, {
        rid: entry.rid
      });
    }
  }

  async function handleActionAdded(entry) // eslint-disable-line
  {
    if (entry.status !== 'inProgress' || !Array.isArray(entry.implementers) || !entry.implementers.length)
    {
      return;
    }

    try
    {
      const recipients = new Set(entry.implementers.map(u => u.id));

      recipients.delete(entry.creator.id);

      await notifyAction(entry, recipients, SUBJECTS.action[entry.status]);
    }
    catch (err)
    {
      logger.error(err, `Failed to notify about a new kaizen.`, {
        rid: entry.rid
      });
    }
  }

  async function handleActionEdited(entry)
  {
    const change = _.last(entry.changes);
    const statusChange = change.data.status;
    const newCoordinators = change.data.coordinators && change.data.coordinators[1].added || [];
    const newImplementers = change.data.implementers && change.data.implementers[1].added || [];
    const recipientList = [];

    newCoordinators.forEach(u => recipientList.push(u));
    newImplementers.forEach(u => recipientList.push(u));

    if (statusChange)
    {
      recipientList.push(entry.creator);

      if (entry.implementers)
      {
        entry.implementers.forEach(u => recipientList.push(u));
      }

      if (entry.acceptor
        && (statusChange[1] === 'verification' || statusChange[1] === 'finished'))
      {
        recipientList.push(entry.acceptor);
      }
    }

    const recipientSet = new Set(recipientList.map(u => u.id));

    recipientSet.delete(change.user.id);

    if (!recipientSet.size)
    {
      return;
    }

    try
    {
      await notifyAction(entry, recipientSet, SUBJECTS.action[entry.status]);
    }
    catch (err)
    {
      logger.error(err, `Failed to notify about a action edit.`, {
        rid: entry.rid
      });
    }
  }

  async function notifyNearMiss(entry, userIds, subject)
  {
    const lastChange = _.last(entry.changes);
    const templateData = {
      urlPrefix: app.options.emailUrlPrefix,
      entry: {
        rid: entry.rid,
        status: NAMES.status[entry.status],
        subject: entry.subject,
        creator: entry.creator.label,
        implementer: entry.implementer ? entry.implementer.label : '',
        division: entry.division,
        workplace: entry.workplace,
        department: entry.department,
        building: entry.building,
        location: entry.location,
        station: entry.station,
        eventDate: moment.utc(entry.eventDate).format('LL, LT'),
        eventCategory: entry.eventCategory,
        reasonCategory: entry.reasonCategory,
        kind: entry.kind,
        priority: NAMES.priority[entry.priority],
        problem: entry.problem,
        reason: entry.reason,
        suggestion: entry.suggestion,
        resolution: {
          ...entry.resolution,
          type: NAMES.resolution[entry.resolution.type]
        },
        comment: lastChange ? lastChange.comment : ''
      }
    };

    await assignNames(entry, templateData, [
      'division',
      'workplace',
      'department',
      'building',
      'location',
      'station',
      'eventCategory',
      'reasonCategory',
      'kind'
    ]);

    await sendEmail(userIds, subject(templateData.entry), TEMPLATES.nearMiss(templateData));
  }

  async function notifyKaizen(entry, userIds, subject)
  {
    const lastChange = _.last(entry.changes);
    const templateData = {
      urlPrefix: app.options.emailUrlPrefix,
      entry: {
        rid: entry.rid,
        status: NAMES.status[entry.status],
        subject: entry.subject,
        creator: entry.creator.label,
        implementers: entry.implementers.map(u => u.label),
        division: entry.division,
        workplace: entry.workplace,
        department: entry.department,
        building: entry.building,
        location: entry.location,
        station: entry.station,
        createdAt: moment(entry.createdAt).format('LL, LT'),
        kaizenCategory: entry.kaizenCategory,
        kind: entry.kind,
        problem: entry.problem,
        reason: entry.reason,
        suggestion: entry.suggestion,
        solution: entry.solution,
        comment: lastChange ? lastChange.comment : ''
      }
    };

    await assignNames(entry, templateData, [
      'division',
      'workplace',
      'department',
      'building',
      'location',
      'station',
      'kaizenCategory',
      'kind'
    ]);

    await sendEmail(userIds, subject(templateData.entry), TEMPLATES.kaizen(templateData));
  }

  async function notifyAction(entry, userIds, subject)
  {
    const lastChange = _.last(entry.changes);
    const templateData = {
      urlPrefix: app.options.emailUrlPrefix,
      entry: {
        rid: entry.rid,
        status: NAMES.status[entry.status],
        subject: entry.subject,
        creator: entry.creator.label,
        implementers: entry.implementers.map(u => u.label),
        division: entry.division,
        workplace: entry.workplace,
        department: entry.department,
        building: entry.building,
        location: entry.location,
        station: entry.station,
        createdAt: moment(entry.createdAt).format('LL, LT'),
        activityKind: entry.activityKind,
        kind: entry.kind,
        problem: entry.problem,
        reason: entry.reason,
        suggestion: entry.suggestion,
        solution: entry.solution,
        comment: lastChange ? lastChange.comment : ''
      }
    };

    await assignNames(entry, templateData, [
      'division',
      'workplace',
      'department',
      'building',
      'location',
      'station',
      'activityKind',
      'kind'
    ]);

    await sendEmail(userIds, subject(templateData.entry), TEMPLATES.action(templateData));
  }

  async function sendEmail(userIds, subject, html)
  {
    userIds.delete(null);
    userIds.delete(undefined);

    if (!userIds.size)
    {
      return;
    }

    const mailOptions = {
      to: new Set(),
      subject,
      html
    };

    const users = await User
      .find({
        _id: {$in: Array.from(userIds)},
        active: true
      })
      .select({email: 1})
      .lean()
      .exec();

    users.forEach(user =>
    {
      if (user.email)
      {
        mailOptions.to.add(user.email);
      }
    });

    if (!mailOptions.to.size)
    {
      return;
    }

    mailOptions.to = Array.from(mailOptions.to);

    return new Promise((resolve, reject) =>
    {
      mailSender.send(mailOptions, err =>
      {
        if (err)
        {
          reject(err);
        }
        else
        {
          resolve();
        }
      });
    });
  }

  async function assignNames(entry, templateData, props)
  {
    const names = await Promise.all(props.map(prop =>
    {
      const dict = typeof prop === 'string' ? DICTIONARIES[prop] : prop;

      return findName(dict.model, entry, dict.mapProperty || prop, dict.nameProperty, dict.idProperty);
    }));

    names.forEach((name, i) =>
    {
      templateData.entry[props[i]] = name;
    });
  }

  async function findName(Model, entry, mapProperty, nameProperty = 'longName', idProperty = null)
  {
    if (!NAMES[mapProperty])
    {
      NAMES[mapProperty] = {};
    }

    const id = entry[idProperty || mapProperty];
    const nameMap = NAMES[mapProperty];
    const multiple = _.isArray(id);

    if (multiple)
    {
      const names = [];

      _.forEach(id, id =>
      {
        if (nameMap[id])
        {
          names.push(nameMap[id]);
        }
      });

      if (names.length === id.length)
      {
        return names;
      }
    }
    else if (!id)
    {
      return '';
    }
    else if (nameMap[id])
    {
      return nameMap[id];
    }

    const conditions = {
      _id: multiple ? {$in: id} : id
    };
    const fields = {
      [nameProperty]: 1
    };

    const models = await Model.find(conditions).select(fields).lean().exec();

    if (!models.length)
    {
      return id;
    }

    if (multiple)
    {
      const names = [];

      models.forEach(model =>
      {
        const name = model[nameProperty];

        nameMap[model._id] = name;

        names.push(name);
      });

      return names;
    }

    const model = models[0];
    const name = model[nameProperty];

    nameMap[model._id] = name;

    return name;
  }
};
