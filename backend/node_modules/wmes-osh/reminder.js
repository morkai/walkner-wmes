// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const fs = require('fs');
const ejs = require('ejs');
const moment = require('moment');
const later = require('later');

const SUBJECTS = {
  daily: day => `Nowe zgłoszenia z ${day} [REAGUJ]`,
  weekly: week => `Podsumowanie zgłoszeń na ${week} [REAGUJ]`
};

module.exports = (app, module) =>
{
  const {
    mailSender,
    User,
    OshNearMiss,
    OshKaizen,
    OshAction,
    OshObservation
  } = module;

  const logger = module.logger.create({submodule: 'reminder'});

  const TEMPLATES = {
    daily: ejs.compile(fs.readFileSync(`${__dirname}/templates/reminder/daily.pl.ejs`, 'utf8'), {
      cache: true,
      compileDebug: false,
      rmWhitespace: true
    }),
    weekly: ejs.compile(fs.readFileSync(`${__dirname}/templates/reminder/weekly.pl.ejs`, 'utf8'), {
      cache: true,
      compileDebug: false,
      rmWhitespace: true
    })
  };
  const NAMES = {
    type: {
      nearMisses: 'ZPW',
      kaizens: 'Kaizen',
      actions: 'Akcje',
      observations: 'Obserwacje'
    },
    status: {
      new: 'Nowe',
      inProgress: 'Realizacja',
      verification: 'Weryfikacja',
      finished: 'Zakończone',
      paused: 'Wstrzymane',
      cancelled: 'Anulowane'
    }
  };

  let dailyTimer = null;
  let weeklyTimer = null;

  later.setInterval(() => handleDailyReminder(0), later.parse.cron('10 0 * * *'));
  later.setInterval(() => handleWeeklyReminder(0), later.parse.cron('20 0 * * 1'));

  async function handleDailyReminder(retryCounter)
  {
    clearTimeout(dailyTimer);
    dailyTimer = null;

    try
    {
      const conditions = {
        createdAt: {
          $gte: moment().startOf('day').subtract(1, 'days').toDate(),
          $lt: moment().startOf('day').toDate()
        }
      };
      const fields = {
        _id: 0,
        rid: 1,
        status: 1,
        subject: 1,
        coordinators: 1
      };
      const sort = {
        createdAt: 1
      };

      const [
        nearMisses,
        kaizens,
        actions,
        observations
      ] = await Promise.all([
        OshNearMiss.find(conditions).select(fields).sort(sort).lean().exec(),
        OshKaizen.find(conditions).select(fields).sort(sort).lean().exec(),
        OshAction.find(conditions).select(fields).sort(sort).lean().exec(),
        OshObservation.find(conditions).select(fields).sort(sort).lean().exec()
      ]);

      const usersToRemind = new Map();

      handleDailyEntries('nearMisses', usersToRemind, nearMisses);
      handleDailyEntries('kaizens', usersToRemind, kaizens);
      handleDailyEntries('actions', usersToRemind, actions);
      handleDailyEntries('observations', usersToRemind, observations);

      if (!usersToRemind.size)
      {
        return;
      }

      logger.info('Sending daily remainders...', {userCount: usersToRemind.size});

      const day = moment(conditions.createdAt).format('L');

      usersToRemind.forEach(userToRemind => sendDailyReminder(userToRemind, day));
    }
    catch (err)
    {
      logger.error(err, 'Failed the daily remainder.');

      if (retryCounter < 10)
      {
        dailyTimer = setTimeout(handleDailyReminder, 5 * 60 * 1000, retryCounter + 1);
      }
    }
  }

  function handleDailyEntries(entryType, usersToRemind, entries)
  {
    entries.forEach(entry =>
    {
      entry.status = NAMES.status[entry.status];

      entry.coordinators.forEach(user =>
      {
        if (!usersToRemind.has(user.id))
        {
          usersToRemind.set(user.id, {
            user,
            nearMisses: [],
            kaizens: [],
            actions: [],
            observations: []
          });
        }

        const userToRemind = usersToRemind.get(user.id);

        userToRemind[entryType].push(entry);
      });
    });
  }

  async function sendDailyReminder(userToRemind, day)
  {
    try
    {
      const entryTypes = [];

      Object.keys(NAMES.type).forEach(type =>
      {
        const list = userToRemind[type];

        if (list.length)
        {
          entryTypes.push({
            type,
            name: NAMES.type[type],
            list
          });
        }
      });

      const templateData = {
        urlPrefix: app.options.emailUrlPrefix,
        user: userToRemind.user.label,
        entryTypes
      };

      await sendEmail(userToRemind.user.id, SUBJECTS.daily(day), TEMPLATES.daily(templateData));
    }
    catch (err)
    {
      logger.error(err, 'Failed to send daily reminder.', {user: userToRemind.user});
    }
  }

  async function handleWeeklyReminder(retryCounter)
  {
    clearTimeout(weeklyTimer);
    weeklyTimer = null;

    try
    {
      const usersToRemind = new Map();

      await Promise.all([
        findOpenEntries(OshNearMiss, usersToRemind),
        findOpenEntries(OshKaizen, usersToRemind),
        findOpenEntries(OshAction, usersToRemind),
        findOpenEntries(OshObservation, usersToRemind)
      ]);

      if (!usersToRemind.size)
      {
        return;
      }

      logger.info('Sending weekly remainders...', {userCount: usersToRemind.size});

      const week = moment().format('YYYY-[W]WW');

      usersToRemind.forEach(userToRemind => sendWeeklyReminder(userToRemind, week));
    }
    catch (err)
    {
      logger.error(err, 'Failed the weekly remainder.');

      if (retryCounter < 10)
      {
        weeklyTimer = setTimeout(handleWeeklyReminder, 5 * 60 * 1000, retryCounter + 1);
      }
    }
  }

  function findOpenEntries(Entry, usersToRemind)
  {
    return new Promise((resolve, reject) =>
    {
      const cursor = Entry
        .find({
          status: {$in: ['new', 'inProgress', 'verification']}
        })
        .select({
          _id: 0,
          rid: 1,
          status: 1,
          subject: 1,
          creator: 1,
          acceptor: 1,
          implementer: 1,
          implementers: 1,
          coordinators: 1
        })
        .lean()
        .sort({createdAt: 1})
        .cursor({batchSize: 10});
      let done = false;

      cursor.on('error', err =>
      {
        if (done)
        {
          return;
        }

        done = false;

        reject(err);
      });

      cursor.on('end', () =>
      {
        if (done)
        {
          return;
        }

        done = true;

        resolve();
      });

      cursor.on('data', entry =>
      {
        if (done)
        {
          return;
        }

        const status = entry.status;

        entry.status = NAMES.status[status];

        switch (status)
        {
          case 'new':
          {
            mapOpenEntryToUser(usersToRemind, entry.creator, entry, Entry);
            mapOpenEntryToUsers(usersToRemind, entry.coordinators, entry, Entry);

            break;
          }

          case 'inProgress':
          {
            mapOpenEntryToUser(usersToRemind, entry.creator, entry, Entry);
            mapOpenEntryToUser(usersToRemind, entry.implementer, entry, Entry);
            mapOpenEntryToUsers(usersToRemind, entry.implementers, entry, Entry);

            if (entry.acceptor)
            {
              mapOpenEntryToUser(usersToRemind, entry.acceptor, entry, Entry);
            }

            break;
          }

          case 'verification':
          {
            mapOpenEntryToUser(usersToRemind, entry.creator, entry, Entry);
            mapOpenEntryToUser(usersToRemind, entry.implementer, entry, Entry);
            mapOpenEntryToUsers(usersToRemind, entry.implementers, entry, Entry);

            if (entry.acceptor)
            {
              mapOpenEntryToUser(usersToRemind, entry.acceptor, entry, Entry);
            }
            else
            {
              mapOpenEntryToUsers(usersToRemind, entry.coordinators, entry, Entry);
            }

            break;
          }
        }

        delete entry.creator;
        delete entry.acceptor;
        delete entry.implementer;
        delete entry.implementers;
        delete entry.coordinators;
      });
    });
  }

  function mapOpenEntryToUsers(usersToRemind, users, entry, Entry)
  {
    if (!Array.isArray(users) || !users.length)
    {
      return;
    }

    users.forEach(user => mapOpenEntryToUser(usersToRemind, user, entry, Entry));
  }

  function mapOpenEntryToUser(usersToRemind, user, entry, Entry)
  {
    if (!user)
    {
      return;
    }

    if (!usersToRemind.has(user.id))
    {
      usersToRemind.set(user.id, {
        user,
        nearMisses: new Set(),
        kaizens: new Set(),
        actions: new Set(),
        observations: new Set()
      });
    }

    const userToRemind = usersToRemind.get(user.id);

    userToRemind[Entry.RELATIONS_TYPE].add(entry);
  }

  async function sendWeeklyReminder(userToRemind, week)
  {
    try
    {
      const entryTypes = [];

      Object.keys(NAMES.type).forEach(type =>
      {
        let list = Array.from(userToRemind[type]);

        if (list.length)
        {
          let remaining = 0;

          if (list.length > 6)
          {
            list = list.splice(0, 5);
            remaining = list.length;
          }

          entryTypes.push({
            type,
            name: NAMES.type[type],
            list,
            remaining
          });
        }
      });

      const templateData = {
        urlPrefix: app.options.emailUrlPrefix,
        user: userToRemind.user.label,
        entryTypes
      };

      await sendEmail(userToRemind.user.id, SUBJECTS.weekly(week), TEMPLATES.weekly(templateData));
    }
    catch (err)
    {
      logger.error(err, 'Failed to send weekly reminder.', {user: userToRemind.user});
    }
  }

  async function sendEmail(userId, subject, html)
  {
    const mailOptions = {
      to: new Set(),
      subject,
      html
    };

    const users = await User
      .find({
        _id: userId,
        active: true,
        email: /@/
      })
      .select({
        _id: 0,
        email: 1
      })
      .lean()
      .exec();

    users.forEach(user =>
    {
      if (user.email)
      {
        mailOptions.to.add(user.email);
      }
    });

    if (!mailOptions.to.size)
    {
      return;
    }

    mailOptions.to = Array.from(mailOptions.to);

    return new Promise((resolve, reject) =>
    {
      mailSender.send(mailOptions, err =>
      {
        if (err)
        {
          reject(err);
        }
        else
        {
          resolve();
        }
      });
    });
  }
};
