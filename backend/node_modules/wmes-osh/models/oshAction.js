// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const locks = require('util/locks');
const userInfoSchema = require('user/models/userInfoSchema');
const relationSchema = require('./relationSchema');
const attachmentSchema = require('./attachmentSchema');
const userSchema = require('./userSchema');
const changeSchema = require('./changeSchema');
const decorateEntrySchema = require('./decorateEntrySchema');

exports.name = 'OshAction';

exports.setUp = (app, mongoose) =>
{
  const STATUSES = ['new', 'inProgress', 'verification', 'finished', 'paused', 'cancelled'];

  const rootCauseSchema = new mongoose.Schema({
    category: {
      type: Number,
      ref: 'OshRootCauseCategory',
      required: true
    },
    why: [String]
  }, {
    _id: false,
    minimize: false
  });

  const schema = new mongoose.Schema({
    rid: String,
    ridInc: Number,
    status: {
      type: String,
      enum: STATUSES
    },
    statusComment: {
      type: String,
      default: ''
    },
    statusUpdater: userInfoSchema,
    createdAt: {
      type: Date,
      required: true
    },
    updatedAt: {
      type: Date,
      required: true
    },
    startedAt: {
      type: Date,
      default: null
    },
    plannedAt: {
      type: Date,
      default: null
    },
    implementedAt: {
      type: Date,
      default: null
    },
    finishedAt: {
      type: Date,
      default: null
    },
    duration: {
      type: Number,
      min: 0
    },
    creator: userInfoSchema,
    updater: userInfoSchema,
    acceptor: userInfoSchema,
    solver: userInfoSchema,
    finisher: userInfoSchema,
    implementers: [userInfoSchema],
    coordinators: [userInfoSchema],
    participants: [userInfoSchema],
    division: {
      type: Number,
      ref: 'OshDivision',
      required: true
    },
    workplace: {
      type: Number,
      ref: 'OshWorkplace',
      required: true
    },
    department: {
      type: Number,
      ref: 'OshDepartment',
      required: true
    },
    building: {
      type: Number,
      ref: 'OshBuilding',
      required: true
    },
    location: {
      type: Number,
      ref: 'OshLocation',
      required: true
    },
    station: {
      type: Number,
      ref: 'OshStation',
      default: null
    },
    kind: [{
      type: Number,
      ref: 'OshKind',
      required: true
    }],
    activityKind: {
      type: Number,
      ref: 'OshActivityKind',
      required: true
    },
    subject: {
      type: String,
      required: true,
      trim: true,
      maxLength: 150
    },
    problem: {
      type: String,
      trim: true,
      maxLength: 1000,
      default: ''
    },
    reason: {
      type: String,
      trim: true,
      maxLength: 1000,
      default: ''
    },
    suggestion: {
      type: String,
      trim: true,
      maxLength: 1000,
      default: ''
    },
    solution: {
      type: String,
      trim: true,
      maxLength: 1000,
      default: ''
    },
    rootCauses: [rootCauseSchema],
    resolutions: [relationSchema],
    relations: [relationSchema],
    attachments: [attachmentSchema],
    users: [userSchema],
    changes: [changeSchema]
  }, {
    id: false,
    minimize: false
  });

  schema.statics.TOPIC_PREFIX = 'osh.actions';
  schema.statics.PRIVILEGE_PREFIX = 'OSH:ACTIONS';
  schema.statics.RID_PREFIX = 'A';
  schema.statics.STATUSES = STATUSES;
  schema.statics.RELATION_TYPE = 'action';
  schema.statics.RELATIONS_TYPE = 'actions';

  decorateEntrySchema(app, mongoose, exports.name, schema);

  schema.methods.isFinished = async function(releaseLocks, resolutions, session)
  {
    const OshAction = this.constructor;
    const OshKaizen = mongoose.model('OshKaizen');

    const typeToModel = {
      [OshAction.RELATION_TYPE]: OshAction,
      [OshKaizen.RELATION_TYPE]: OshKaizen
    };

    if (!resolutions)
    {
      resolutions = {
        action: [],
        kaizen: []
      };

      (this.resolutions || []).forEach(resolution =>
      {
        resolutions[resolution.type].push(resolution._id);
      });
    }

    if (!resolutions.action.length && !resolutions.kaizen.length)
    {
      return true;
    }

    if (releaseLocks)
    {
      for (const type of Object.keys(resolutions))
      {
        if (!resolutions[type].length)
        {
          continue;
        }

        const Entry = typeToModel[type];
        const pendingLocks = [];

        for (const id of resolutions[type])
        {
          pendingLocks.push(locks.createAsync(`${Entry.TOPIC_PREFIX}.${id}`));
        }

        releaseLocks.push(...await Promise.all(pendingLocks));
      }
    }

    for (const type of Object.keys(resolutions))
    {
      if (!resolutions[type].length)
      {
        continue;
      }

      const Entry = typeToModel[type];
      const unfinishedEntry = await Entry
        .findOne({
          _id: {$in: resolutions[type]},
          status: {$ne: 'finished'}
        })
        .select({_id: 1})
        .lean()
        .session(session)
        .exec();

      if (unfinishedEntry)
      {
        return false;
      }
    }

    return true;
  };

  return schema;
};
