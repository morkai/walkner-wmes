// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

exports.name = 'OshTarget';

exports.setUp = (app, mongoose) =>
{
  const createOrgUnit = (division = 0, workplace = 0, department = 0) => ({
    division,
    workplace,
    department,
    targets: {
      minActiveUsers: 0,
      minObservers: 0,
      minObsCardsPerObserver: 0,
      minSafeObs: 0,
      maxSafeObs: 0,
      ipr: 0,
      ips: 0,
      trc: 0,
      contact: 0
    }
  });

  const orgUnitSchema = new mongoose.Schema({
    division: {type: Number, required: true, min: 0, max: 9999},
    workplace: {type: Number, required: true, min: 0, max: 9999},
    department: {type: Number, required: true, min: 0, max: 9999},
    targets: {
      minActiveUsers: {type: Number, required: true, min: 0, max: 9999},
      minObservers: {type: Number, required: true, min: 0, max: 9999},
      minObsCardsPerObserver: {type: Number, required: true, min: 0, max: 9999},
      minSafeObs: {type: Number, required: true, min: 0, max: 9999},
      maxSafeObs: {type: Number, required: true, min: 0, max: 9999},
      ipr: {type: Number, required: true, min: 0, max: 9999},
      ips: {type: Number, required: true, min: 0, max: 9999},
      trc: {type: Number, required: true, min: 0, max: 9999},
      contact: {type: Number, required: true, min: 0, max: 9999}
    }
  }, {
    _id: false,
    minimize: false
  });

  const schema = new mongoose.Schema({
    _id: Date,
    orgUnits: [orgUnitSchema]
  }, {
    id: false,
    minimize: false,
    versionKey: false
  });

  schema.statics.TOPIC_PREFIX = 'osh.targets';
  schema.statics.BROWSE_LIMIT = 100;

  schema.statics.getActiveOrgUnits = async function()
  {
    const OshDivision = mongoose.model('OshDivision');
    const OshWorkplace = mongoose.model('OshWorkplace');
    const OshDepartment = mongoose.model('OshDepartment');

    const [divisions, workplaces, departments] = await Promise.all([
      OshDivision
        .find({active: true})
        .select({_id: 1})
        .lean()
        .exec(),
      OshWorkplace
        .find({active: true})
        .select({division: 1})
        .lean()
        .exec(),
      OshDepartment
        .find({active: true})
        .select({workplace: 1})
        .lean()
        .exec()
    ]);

    const orgUnits = {
      divisions: listToMap(divisions),
      workplaces: listToMap(workplaces),
      departments: listToMap(departments)
    };

    workplaces.forEach(workplace =>
    {
      if (!orgUnits.divisions[workplace.division])
      {
        delete orgUnits.workplaces[workplace._id];
      }
    });

    departments.forEach(department =>
    {
      if (!orgUnits.workplaces[department.workplace])
      {
        delete orgUnits.departments[department._id];
      }
    });

    return orgUnits;

    function listToMap(list)
    {
      const map = {};

      list.forEach(item =>
      {
        map[item._id] = item;
      });

      return map;
    }
  };

  schema.methods.recreate = async function(keepInactive, orgUnits)
  {
    if (orgUnits)
    {
      orgUnits = {
        divisions: {...orgUnits.divisions},
        workplaces: {...orgUnits.workplaces},
        departments: {...orgUnits.departments}
      };
    }
    else
    {
      orgUnits = await schema.statics.getActiveOrgUnits();
    }

    const newOrgUnits = keepInactive ? this.orgUnits : this.orgUnits.filter(ou =>
    {
      return (!ou.division || orgUnits.divisions[ou.division])
        && (!ou.workplace || orgUnits.workplaces[ou.workplace])
        && (!ou.department || orgUnits.departments[ou.department]);
    });
    const existingWorkplaces = new Set();
    const existingDivisions = new Set();

    newOrgUnits.forEach(ou =>
    {
      delete orgUnits.departments[ou.department];
      existingWorkplaces.add(ou.workplace);
      existingDivisions.add(ou.division);
    });

    Object.values(orgUnits.departments).forEach(department =>
    {
      const workplace = orgUnits.workplaces[department.workplace];

      if (!workplace)
      {
        return;
      }

      const division = orgUnits.divisions[workplace.division];

      if (!division)
      {
        return;
      }

      if (!existingWorkplaces.has(workplace._id))
      {
        newOrgUnits.push(createOrgUnit(division._id, workplace._id));
      }

      if (!existingWorkplaces.has(division._id))
      {
        newOrgUnits.push(createOrgUnit(division._id));
      }

      newOrgUnits.push(createOrgUnit(division._id, workplace._id, department._id));
    });

    this.orgUnits = newOrgUnits;
  };

  schema.methods.add = async function()
  {
    await this.save();

    app.broker.publish(`${schema.statics.TOPIC_PREFIX}.added`, {
      model: this,
      user: null
    });
  };

  return schema;
};
