// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const moment = require('moment');
const userInfoSchema = require('user/models/userInfoSchema');

exports.name = 'OshReward';

exports.setUp = (app, mongoose) =>
{
  const TYPE_TO_UPDATER = {
    kaizen: updateKaizen,
    observation: updateObservation
  };

  const schema = new mongoose.Schema({
    rid: String,
    type: {
      type: String,
      enum: ['kaizen', 'observation'],
      required: true
    },
    createdAt: Date,
    creator: userInfoSchema,
    subject: String,
    recipient: userInfoSchema,
    count: Number,
    amount: Number,
    paid: Boolean,
    paidAt: Date,
    payer: userInfoSchema,
    payout: mongoose.Schema.Types.ObjectId
  }, {
    id: false,
    minimize: false
  });

  schema.statics.TOPIC_PREFIX = 'osh.rewards';
  schema.statics.BROWSE_LIMIT = 100;

  schema.index({rid: 1});
  schema.index({createdAt: -1});
  schema.index({kind: 1, paid: 1});
  schema.index({paid: 1});
  schema.index({paidAt: -1});
  schema.index({'recipient.id': 1, paid: 1});

  schema.statics.updateEntry = async function({
    entry,
    createdAt,
    creator,
    recipients,
    totalAmount,
    session,
    messages = []
  })
  {
    const OshReward = this;
    const result = {
      added: [],
      updated: [],
      deleted: [],
      messages
    };

    const relationType = entry.constructor.RELATION_TYPE;
    const update = TYPE_TO_UPDATER[relationType];

    if (!update)
    {
      throw app.createError('Unsupported relation type.', 'STATE', 500, {relationType});
    }

    await update({
      OshReward,
      result,
      entry,
      createdAt,
      creator,
      recipients,
      totalAmount,
      session
    });

    const ops = [];

    result.deleted.forEach(reward =>
    {
      ops.push({deleteOne: {filter: {_id: reward._id}}});
    });

    result.added.forEach(reward =>
    {
      ops.push({insertOne: reward});
    });

    result.updated.forEach(reward =>
    {
      ops.push({
        updateOne: {
          filter: {_id: reward._id},
          update: {$set: reward}
        }
      });
    });

    if (ops.length)
    {
      await OshReward.collection.bulkWrite(ops, {session});

      result.messages.push({
        topic: `${OshReward.TOPIC_PREFIX}.updated`,
        message: {
          deleted: result.deleted,
          added: result.added,
          updated: result.updated
        }
      });
    }

    return result;
  };

  async function updateKaizen({
    OshReward,
    result,
    entry,
    createdAt,
    creator,
    recipients,
    totalAmount,
    session
  })
  {
    const existingRewards = await OshReward
      .find({rid: entry.rid})
      .lean()
      .session(session)
      .exec();

    const oldRewards = new Map();

    existingRewards.forEach(reward =>
    {
      if (reward.paid)
      {
        throw app.createError('Reward already paid out.', 'REWARD_PAID', 400);
      }

      oldRewards.set(reward.recipient.id, reward);
    });

    recipients.forEach(recipient =>
    {
      const amount = Math.round(totalAmount / recipients.length * 100) / 100;

      if (amount <= 0)
      {
        return;
      }

      const oldReward = oldRewards.get(recipient.id);

      if (oldReward)
      {
        oldRewards.delete(recipient.id);

        result.updated.push({
          _id: oldReward._id,
          createdAt,
          creator,
          recipient,
          amount
        });

        return;
      }

      result.added.push({
        _id: new mongoose.Types.ObjectId(),
        type: entry.constructor.RELATION_TYPE,
        rid: entry.rid,
        createdAt,
        creator,
        subject: entry.subject || '',
        recipient,
        count: 1,
        amount,
        paid: false,
        paidAt: null,
        payer: null,
        payout: null
      });
    });

    oldRewards.forEach(reward =>
    {
      result.deleted.push(reward);
    });
  }

  async function updateObservation({
    entry,
    createdAt,
    creator,
    recipients,
    session,
    result
  })
  {
    const User = mongoose.model('User');
    const Setting = mongoose.model('Setting');
    const OshObservation = mongoose.model('OshObservation');
    const OshReward = mongoose.model('OshReward');

    const recipient = recipients[0];
    const user = await User
      .findById(recipient.id)
      .select({privileges: 1})
      .session(session)
      .lean();
    const observer = !!user && user.privileges.includes('OSH:OBSERVER');

    const settings = await Setting.findValues('osh.rewards.observations.');
    const min = observer ? settings.observerMin : settings.userMin;
    const amount = observer ? settings.observer : settings.user;

    if (!min || !amount)
    {
      return;
    }

    const change = entry.changes[entry.changes.length - 1];
    const newMoment = moment.utc(entry.date);
    const oldMoment = change && change.data.date ? moment.utc(change.data.date[0]) : newMoment;
    const newRid = [
      OshObservation.RID_PREFIX,
      newMoment.format('YYYY'),
      `M${newMoment.format('MM').padStart(5, '0')}`
    ].join('-');
    const oldRid = [
      OshObservation.RID_PREFIX,
      oldMoment.format('YYYY'),
      `M${oldMoment.format('MM').padStart(5, '0')}`
    ].join('-');

    const todo = [{
      from: newMoment.startOf('month').clone().toDate(),
      to: newMoment.add(1, 'months').toDate(),
      rid: newRid
    }];

    if (oldRid !== newRid)
    {
      todo.push({
        from: oldMoment.startOf('month').clone().toDate(),
        to: oldMoment.add(1, 'months').toDate(),
        rid: oldRid
      });
    }

    for (const {from, to, rid} of todo)
    {
      const [countResult, existingReward] = await Promise.all([
        OshObservation
          .aggregate([
            {$match: {
              'creator.id': recipient.id,
              date: {$gte: from, $lt: to}
            }},
            {$group: {
              _id: null,
              count: {$sum: 1}
            }}
          ])
          .session(session)
          .exec(),
        OshReward
          .findOne({
            rid,
            'recipient.id': recipient.id
          })
          .lean()
          .session(session)
          .exec()
      ]);

      const count = countResult.length ? countResult[0].count : 0;

      if (count < min)
      {
        if (existingReward && !existingReward.paid)
        {
          result.deleted.push(existingReward);
        }

        continue;
      }

      if (!existingReward)
      {
        result.added.push({
          _id: new mongoose.Types.ObjectId(),
          type: entry.constructor.RELATION_TYPE,
          rid,
          createdAt,
          creator,
          subject: '',
          recipient,
          count,
          amount,
          paid: false,
          paidAt: null,
          payer: null,
          payout: null
        });

        continue;
      }

      if (count === existingReward.count && amount === existingReward.amount)
      {
        continue;
      }

      if (existingReward.paid)
      {
        if (existingReward.count !== count)
        {
          result.updated.push({
            _id: existingReward._id,
            count
          });
        }

        continue;
      }

      result.updated.push({
        _id: existingReward._id,
        createdAt,
        creator,
        recipient,
        count,
        amount
      });
    }
  }

  return schema;
};
