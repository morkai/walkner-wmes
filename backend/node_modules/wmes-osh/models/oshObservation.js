// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const locks = require('util/locks');
const userInfoSchema = require('user/models/userInfoSchema');
const relationSchema = require('./relationSchema');
const attachmentSchema = require('./attachmentSchema');
const userSchema = require('./userSchema');
const changeSchema = require('./changeSchema');
const decorateEntrySchema = require('./decorateEntrySchema');

exports.name = 'OshObservation';

exports.setUp = (app, mongoose) =>
{
  const STATUSES = ['inProgress', 'finished'];

  const observationSchema = new mongoose.Schema({
    _id: {
      type: String,
      required: true
    },
    category: {
      type: Number,
      ref: 'OshObservationCategory',
      required: true
    },
    text: {
      type: String,
      trim: true,
      required: true
    },
    safe: {
      type: Boolean,
      required: true
    },
    easy: {
      type: Boolean,
      default: null
    },
    what: {
      type: String,
      trim: true
    },
    why: {
      type: String,
      trim: true
    },
    resolution: relationSchema,
    implementer: userInfoSchema
  }, {
    _id: false,
    minimize: false
  });

  const schema = new mongoose.Schema({
    rid: String,
    ridInc: Number,
    status: {
      type: String,
      enum: STATUSES
    },
    statusComment: {
      type: String,
      default: ''
    },
    statusUpdater: userInfoSchema,
    createdAt: {
      type: Date,
      required: true
    },
    updatedAt: {
      type: Date,
      required: true
    },
    finishedAt: {
      type: Date,
      default: null
    },
    duration: {
      type: Number,
      min: 0
    },
    creator: userInfoSchema,
    updater: userInfoSchema,
    coordinators: [userInfoSchema],
    date: {
      type: Date,
      required: true
    },
    company: {
      type: Number,
      ref: 'OshCompany',
      required: true
    },
    companyName: {
      type: String,
      required: true
    },
    division: {
      type: Number,
      ref: 'OshDivision',
      required: true
    },
    workplace: {
      type: Number,
      ref: 'OshWorkplace',
      required: true
    },
    department: {
      type: Number,
      ref: 'OshDepartment',
      required: true
    },
    building: {
      type: Number,
      ref: 'OshBuilding',
      required: true
    },
    location: {
      type: Number,
      ref: 'OshLocation',
      required: true
    },
    station: {
      type: Number,
      ref: 'OshStation',
      default: null
    },
    observationKind: {
      type: Number,
      ref: 'OshObservationKind',
      required: true
    },
    behaviors: [observationSchema],
    workConditions: [observationSchema],
    attachments: [attachmentSchema],
    users: [userSchema],
    changes: [changeSchema]
  }, {
    id: false,
    minimize: false
  });

  schema.statics.TOPIC_PREFIX = 'osh.observations';
  schema.statics.PRIVILEGE_PREFIX = 'OSH:OBSERVATIONS';
  schema.statics.RID_PREFIX = 'O';
  schema.statics.STATUSES = STATUSES;
  schema.statics.RELATION_TYPE = 'observation';
  schema.statics.OBSERVATION_PROPS = ['behaviors', 'workConditions'];

  decorateEntrySchema(app, mongoose, exports.name, schema);

  schema.statics.isObservationResolvable = function(type, observation)
  {
    if (type.startsWith('b'))
    {
      return observation.safe === false && observation.easy === false;
    }

    if (type.startsWith('w'))
    {
      return observation.safe === false;
    }

    return false;
  };

  schema.methods.isFinished = async function(releaseLocks, resolutions)
  {
    const OshObservation = this.constructor;
    const OshNearMiss = mongoose.model('OshNearMiss');
    const OshKaizen = mongoose.model('OshKaizen');

    const typeToModel = {
      [OshNearMiss.RELATION_TYPE]: OshNearMiss,
      [OshKaizen.RELATION_TYPE]: OshKaizen
    };

    if (!resolutions)
    {
      resolutions = {
        nearMiss: [],
        kaizen: []
      };

      for (const type of OshObservation.OBSERVATION_PROPS)
      {
        for (const observation of this[type])
        {
          if (!OshObservation.isObservationResolvable(type, observation))
          {
            continue;
          }

          if (!observation.resolution._id)
          {
            return false;
          }

          resolutions[observation.resolution.type].push(observation.resolution._id);
        }
      }
    }

    if (!resolutions.nearMiss.length && !resolutions.kaizen.length)
    {
      return true;
    }

    if (releaseLocks)
    {
      for (const type of Object.keys(resolutions))
      {
        if (!resolutions[type].length)
        {
          continue;
        }

        const Entry = typeToModel[type];
        const pendingLocks = [];

        for (const id of resolutions[type])
        {
          pendingLocks.push(locks.createAsync(`${Entry.TOPIC_PREFIX}.${id}`));
        }

        releaseLocks.push(...await Promise.all(pendingLocks));
      }
    }

    for (const type of Object.keys(resolutions))
    {
      if (!resolutions[type].length)
      {
        continue;
      }

      const Entry = typeToModel[type];
      const unfinishedEntry = await Entry
        .findOne({
          _id: {$in: resolutions[type]},
          status: {$ne: 'finished'}
        })
        .select({_id: 1})
        .lean()
        .exec();

      if (unfinishedEntry)
      {
        return false;
      }
    }

    return true;
  };

  return schema;
};
