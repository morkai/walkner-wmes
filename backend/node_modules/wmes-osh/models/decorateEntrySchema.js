// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');
const moment = require('moment');
const autoIncrement = require('mongoose-plugin-autoinc-fix');
const lastModifiedPaths = require('h5-mongoose/plugins/lastModifiedPaths');
const jsonDeepEqual = require('util/jsonDeepEqual');

module.exports = (app, mongoose, modelName, schema) =>
{
  schema.statics.BROWSE_LIMIT = 100;

  schema.plugin(autoIncrement.plugin, {
    model: modelName,
    field: '_id',
    startAt: 1,
    incrementBy: 1
  });

  schema.plugin(lastModifiedPaths);

  schema.statics.assignNextRid = async function(entry)
  {
    if (!this.RID_PREFIX)
    {
      return;
    }

    const year = moment().startOf('year');
    const yyyy = year.format('YYYY');

    const lastEntry = await this
      .find({
        createdAt: {
          $gte: year.toDate(),
          $lt: year.clone().add(1, 'year').toDate()
        }
      })
      .select({_id: 0, ridInc: 1})
      .sort({createdAt: -1})
      .limit(1)
      .exec();

    entry.ridInc = (lastEntry.length ? lastEntry[0].ridInc : 0) + 1;
    entry.rid = `${this.RID_PREFIX}-${yyyy}-${entry.ridInc.toString().padStart(6, '0')}`;
  };

  schema.statics.resolveCoordinators = async function({kind, division})
  {
    const OshKind = mongoose.model('OshKind');
    const OshDivision = mongoose.model('OshDivision');

    const coordinators = new Map();

    const coordinatorSources = await Promise.all([
      kind ? OshKind.findById(kind).select({coordinators: 1}).lean().exec() : null,
      division ? OshDivision.findById(division).select({coordinators: 1}).lean().exec() : null
    ]);

    coordinatorSources.forEach(source =>
    {
      if (!source || !Array.isArray(source.coordinators) || !source.coordinators.length)
      {
        return;
      }

      source.coordinators.forEach(user =>
      {
        coordinators.set(user.id, user);
      });
    });

    return Array.from(coordinators.values()).sort((a, b) => a.label.localeCompare(b.label));
  };

  schema.statics.addRelation = function({model, relation, updater, updatedAt, messages})
  {
    if (model.relations.some(r => r.rid === relation.rid))
    {
      return null;
    }

    const input = {
      relations: model.relations.toObject()
    };

    input.relations.push(relation);

    if (model.edit({input, updater, updatedAt, messages}))
    {
      return model;
    }

    return null;
  };

  schema.statics.deleteRelation = function({model, relation, updater, updatedAt, messages})
  {
    const input = {
      relations: model.relations.toObject().filter(r => r.rid !== relation.rid)
    };

    if (input.relations.length === model.relations.length)
    {
      return null;
    }

    if (model.edit({input, updater, updatedAt, messages}))
    {
      return model;
    }

    return null;
  };

  schema.methods.getRelation = function()
  {
    return {
      _id: this._id,
      rid: this.rid,
      type: this.constructor.RELATION_TYPE
    };
  };

  schema.methods.isCreator = function(userId)
  {
    return this.creator.id === userId;
  };

  schema.methods.isImplementer = function(userId)
  {
    if (Array.isArray(this.implementers))
    {
      return this.implementers.some(u => u.id === userId);
    }

    return !!this.implementer && this.implementer.id === userId;
  };

  schema.methods.isCoordinator = function(userId)
  {
    return Array.isArray(this.coordinators) && this.coordinators.some(u => u.id === userId);
  };

  schema.methods.isUser = function(userId)
  {
    return this.users.some(u => u.user.id === userId);
  };

  schema.methods.canDelete = function(userId)
  {
    return this.status === 'new' && this.isCoordinator(userId);
  };

  schema.methods.updateUsers = function(changedPropertyList, updater)
  {
    const changedPropertyMap = {};
    const oldUsers = new Map();
    const newUsers = new Map();
    const subscribers = new Map();
    const usersToNotify = new Set();

    changedPropertyList.forEach(prop => changedPropertyMap[prop] = 1);

    this.users.forEach(u =>
    {
      u = u.toObject();

      if (u.roles.includes('subscriber'))
      {
        subscribers.set(u.user.id, u);
      }

      oldUsers.set(u.user.id, u);
    });

    let creator;

    if (oldUsers.has(this.creator.id))
    {
      creator = {
        ...oldUsers.get(this.creator.id),
        roles: ['creator']
      };
    }
    else
    {
      creator = {
        user: this.creator,
        roles: ['creator'],
        lastSeenAt: this.createdAt,
        notify: false,
        changes: {}
      };

      usersToNotify.add(creator.user.id);
    }

    newUsers.set(creator.user.id, creator);

    const implementers = [];

    if (this.implementer)
    {
      implementers.push(this.implementer);
    }

    if (Array.isArray(this.implementers))
    {
      implementers.push(...this.implementers);
    }

    if (Array.isArray(this.behaviors))
    {
      this.behaviors.forEach(o =>
      {
        if (o.implementer)
        {
          implementers.push(o.implementer);
        }
      });
    }

    if (Array.isArray(this.workConditions))
    {
      this.workConditions.forEach(o =>
      {
        if (o.implementer)
        {
          implementers.push(o.implementer);
        }
      });
    }

    implementers.forEach(user =>
    {
      if (newUsers.has(user.id))
      {
        newUsers.get(user.id).roles.push('implementer');

        return;
      }

      if (oldUsers.has(user.id))
      {
        newUsers.set(user.id, {
          ...oldUsers.get(user.id),
          roles: ['implementer']
        });

        return;
      }

      usersToNotify.add(user.id);

      newUsers.set(user.id, {
        user,
        roles: ['implementer'],
        lastSeenAt: null,
        notify: true,
        changes: {}
      });
    });

    (this.coordinators || []).forEach(user =>
    {
      if (newUsers.has(user.id))
      {
        newUsers.get(user.id).roles.push('coordinator');

        return;
      }

      if (oldUsers.has(user.id))
      {
        newUsers.set(user.id, {
          ...oldUsers.get(user.id),
          roles: ['coordinator']
        });

        return;
      }

      usersToNotify.add(user.id);

      newUsers.set(user.id, {
        user,
        roles: ['coordinator'],
        lastSeenAt: null,
        notify: true,
        changes: {}
      });
    });

    (this.participants || []).forEach(user =>
    {
      if (newUsers.has(user.id))
      {
        newUsers.get(user.id).roles.push('participant');

        return;
      }

      if (oldUsers.has(user.id))
      {
        newUsers.set(user.id, {
          ...oldUsers.get(user.id),
          roles: ['participant']
        });

        return;
      }

      usersToNotify.add(user.id);

      newUsers.set(user.id, {
        user,
        roles: ['participant'],
        lastSeenAt: null,
        notify: true,
        changes: {}
      });
    });

    subscribers.forEach(u =>
    {
      if (newUsers.has(u.user.id))
      {
        newUsers.get(u.user.id).roles.push('subscriber');
      }
      else
      {
        usersToNotify.add(u.user.id);

        newUsers.set(u.user.id, {
          ...u,
          roles: ['subscriber']
        });
      }
    });

    this.changes.forEach(change =>
    {
      const o = newUsers.get(change.user.id);

      if (o)
      {
        if (o.lastSeenAt < change.date)
        {
          o.lastSeenAt = change.date;
        }

        return;
      }

      usersToNotify.add(change.user.id);

      newUsers.set(change.user.id, {
        user: change.user,
        roles: ['subscriber'],
        lastSeenAt: change.date,
        notify: true,
        changes: {}
      });
    });

    newUsers.forEach(u =>
    {
      if (!u.notify)
      {
        u.notify = true;
        u.changes = changedPropertyMap;

        usersToNotify.add(u.user.id);

        return;
      }

      if (Object.keys(u.changes).length)
      {
        Object.assign(u.changes, changedPropertyMap);

        usersToNotify.add(u.user.id);
      }
    });

    const updaterUser = updater ? newUsers.get(updater.id) : null;

    if (updaterUser)
    {
      updaterUser.lastSeenAt = new Date();
      updaterUser.notify = false;
      updaterUser.changes = {};

      usersToNotify.delete(updaterUser.user.id);
    }

    newUsers.delete(null);

    this.users = Array.from(newUsers.values());

    return Array.from(usersToNotify).map(userId => ({
      userId,
      changes: newUsers.get(userId).changes
    }));
  };

  schema.methods.edit = function({input, updater, updatedAt, messages})
  {
    const notify = this.applyChanges(input, updater, updatedAt);

    if (!notify)
    {
      return notify;
    }

    const {TOPIC_PREFIX} = this.constructor;

    messages.push({
      topic: `${TOPIC_PREFIX}.edited`,
      message: {
        user: updater,
        model: this
      }
    }, {
      topic: `${TOPIC_PREFIX}.updated.${this._id}`,
      message: {
        _id: this._id,
        change: _.last(this.changes),
        notify
      }
    });

    return notify;
  };

  schema.methods.applyChanges = function(input, updater, updatedAt)
  {
    if (!updater)
    {
      updater = {
        id: null,
        label: 'System'
      };
    }

    if (!updatedAt)
    {
      updatedAt = new Date();
    }

    const changes = this.compareProperties(_.omit(input, [
      'comment',
      'implementers',
      'coordinators',
      'resolutions',
      'relations',
      'behaviors',
      'workConditions',
      'attachments'
    ]));

    this.updateImplementers(changes, input.implementers);
    this.updateCoordinators(changes, input.coordinators);
    this.updateResolutions(changes, input.resolutions);
    this.updateRelations(changes, input.relations);
    this.updateObservations(changes, input.behaviors, input.workConditions);
    this.updateAttachments(changes, input.attachments);
    this.updateDurations(changes);

    const changedProperties = Object.keys(changes);
    const comment = _.isEmpty(input.comment) || !_.isString(input.comment) ? '' : input.comment.trim();

    if (!_.isEmpty(input.comment))
    {
      changedProperties.push('comment');
    }

    if (!changedProperties.length)
    {
      return null;
    }

    if (_.isEmpty(comment) && _.isEmpty(changes))
    {
      return null;
    }

    const usersToNotify = {};

    this.updateUsers(changedProperties, updater).forEach(({userId, changes}) =>
    {
      usersToNotify[userId] = changes;
    });

    this.changes.push({
      date: updatedAt,
      user: updater,
      data: changes,
      comment
    });

    return usersToNotify;
  };

  schema.methods.compareProperties = function(input)
  {
    const changes = {};

    Object.keys(input).forEach(property =>
    {
      this.compareProperty(property, input, changes);
    });

    return changes;
  };

  schema.methods.compareProperty = function(property, input, changes)
  {
    let oldValue = this[property];
    let newValue = input[property];

    if (_.isObject(oldValue) && _.isFunction(oldValue.toObject))
    {
      oldValue = oldValue.toObject();
    }

    if (_.isObject(newValue) && _.isFunction(newValue.toObject))
    {
      newValue = newValue.toObject();
    }

    if (oldValue instanceof mongoose.Types.ObjectId)
    {
      oldValue = oldValue.toString();
    }

    if (newValue instanceof mongoose.Types.ObjectId)
    {
      newValue = newValue.toString();
    }
    else if (_.isString(newValue))
    {
      if (/(at|date)$/i.test(property))
      {
        newValue = new Date(newValue);

        if (isNaN(newValue.getTime()))
        {
          newValue = null;
        }
      }
      else if (schema.path(property).instance === 'Number')
      {
        newValue = +newValue;
      }
      else
      {
        newValue = newValue.trim();
      }
    }

    if (jsonDeepEqual(newValue, oldValue))
    {
      return false;
    }

    changes[property] = [oldValue, newValue];
    this[property] = newValue;

    return true;
  };

  schema.methods.updateList = function(changes, listProperty, newList, compare)
  {
    if (newList === undefined || this[listProperty] === undefined)
    {
      return;
    }

    const oldMap = new Map();
    const change = {
      added: [],
      edited: [],
      deleted: []
    };

    (this[listProperty] || []).forEach(c => oldMap.set(c._id || c.id, c));

    (newList || []).forEach(newItem =>
    {
      const id = newItem._id || newItem.id;
      const oldItem = oldMap.get(id);

      if (!oldItem)
      {
        change.added.push(newItem);

        return;
      }

      oldMap.delete(id);

      if (!compare(newItem, oldItem))
      {
        change.edited.push({
          ...newItem,
          old: oldItem
        });
      }
    });

    oldMap.forEach(oldItem =>
    {
      change.deleted.push(oldItem);
    });

    if (!change.added.length && !change.edited.length && !change.deleted.length)
    {
      return;
    }

    changes[listProperty] = [null, change];
    this[listProperty] = newList;
  };

  schema.methods.updateImplementers = function(changes, newList)
  {
    this.updateList(
      changes,
      'implementers',
      newList,
      (newItem, oldItem) => newItem.label === oldItem.label
    );
  };

  schema.methods.updateCoordinators = function(changes, newList)
  {
    this.updateList(
      changes,
      'coordinators',
      newList,
      (newItem, oldItem) => newItem.label === oldItem.label
    );
  };

  schema.methods.updateResolutions = function(changes, newList)
  {
    this.updateList(
      changes,
      'resolutions',
      newList,
      (newItem, oldItem) => newItem.rid === oldItem.rid
    );
  };

  schema.methods.updateRelations = function(changes, newList)
  {
    this.updateList(
      changes,
      'relations',
      newList,
      (newItem, oldItem) => newItem.rid === oldItem.rid
    );
  };

  schema.methods.updateAttachments = function(changes, newList)
  {
    this.updateList(
      changes,
      'attachments',
      newList,
      (newItem, oldItem) => newItem.name === oldItem.name && newItem.kind === oldItem.kind
    );
  };

  schema.methods.updateObservations = function(changes, newBehaviors, newWorkConditions)
  {
    this.updateList(
      changes,
      'behaviors',
      newBehaviors,
      (newItem, oldItem) => jsonDeepEqual(newItem, oldItem.toObject())
    );

    this.updateList(
      changes,
      'workConditions',
      newWorkConditions,
      (newItem, oldItem) => jsonDeepEqual(newItem, oldItem.toObject())
    );
  };

  schema.methods.updateDurations = function(changes)
  {
    if (changes.finishedAt)
    {
      this.updateDuration();
    }
  };

  schema.methods.updateDuration = function(finishedAt)
  {
    if (!finishedAt)
    {
      finishedAt = this.finishedAt || new Date();
    }

    this.duration = Math.ceil((finishedAt - this.createdAt) / 1000);
  };

  schema.statics.markAsSeen = function(filter, userId, done)
  {
    const Model = this;

    if (typeof userId !== 'string')
    {
      userId = String(userId);
    }

    const query = {
      users: {
        $elemMatch: {
          'user.id': userId,
          notify: true
        }
      }
    };

    switch (filter)
    {
      case 'all':
        break;

      case 'finished':
        query.status = 'finished';
        break;

      case 'dayOld':
        query.createdAt = {$lt: new Date(Date.now() - 24 * 3600 * 1000)};
        break;

      case 'weekOld':
        query.createdAt = {$lt: new Date(Date.now() - 7 * 24 * 3600 * 1000)};
        break;

      case 'noComment':
        query.users.$elemMatch['changes.comment'] = {$exists: false};
        break;

      default:
        query._id = {$in: filter};
        break;
    }

    step(
      function()
      {
        Model
          .find(query)
          .select({_id: 1})
          .lean()
          .exec(this.next());
      },
      function(err, entries)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (entries.length === 0)
        {
          return this.skip(null, []);
        }

        const seenIds = entries.map(e => e._id);

        setImmediate(this.parallel(), null, seenIds);

        const filter = {
          _id: {$in: seenIds}
        };
        const update = {
          $set: {
            'users.$[p].notify': false,
            'users.$[p].changes': {},
            'users.$[p].lastSeenAt': new Date()
          }
        };
        const options = {
          arrayFilters: [
            {'p.user.id': userId}
          ]
        };

        Model.collection.updateMany(filter, update, options, this.parallel());
      },
      done
    );
  };

  return schema;
};
