// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');
const moment = require('moment');
const autoIncrement = require('mongoose-plugin-autoinc-fix');
const lastModifiedPaths = require('h5-mongoose/plugins/lastModifiedPaths');
const jsonDeepEqual = require('util/jsonDeepEqual');

module.exports = (app, mongoose, modelName, schema) =>
{
  schema.statics.BROWSE_LIMIT = 100;

  schema.plugin(autoIncrement.plugin, {
    model: modelName,
    field: '_id',
    startAt: 1,
    incrementBy: 1
  });

  schema.plugin(lastModifiedPaths);

  schema.statics.assignNextRid = async function(entry)
  {
    if (!this.RID_PREFIX)
    {
      return;
    }

    const year = moment().startOf('year');
    const yyyy = year.format('YYYY');

    const lastEntry = await this
      .find({
        createdAt: {
          $gte: year.toDate(),
          $lt: year.clone().add(1, 'year').toDate()
        }
      })
      .select({_id: 0, ridInc: 1})
      .sort({createdAt: -1})
      .limit(1)
      .exec();

    entry.ridInc = (lastEntry.length ? lastEntry[0].ridInc : 0) + 1;
    entry.rid = `${this.RID_PREFIX}-${yyyy}-${entry.ridInc.toString().padStart(6, '0')}`;
  };

  schema.statics.resolveCoordinators = async function({kind, division})
  {
    const OshKind = mongoose.model('OshKind');
    const OshDivision = mongoose.model('OshDivision');

    const coordinators = new Map();

    const coordinatorSources = await Promise.all([
      OshKind.findById(kind).select({coordinators: 1}).lean().exec(),
      OshDivision.findById(division).select({coordinators: 1}).lean().exec()
    ]);

    coordinatorSources.forEach(source =>
    {
      if (!source || !Array.isArray(source.coordinators) || !source.coordinators.length)
      {
        return;
      }

      source.coordinators.forEach(user =>
      {
        coordinators.set(user.id, user);
      });
    });

    return Array.from(coordinators.values()).sort((a, b) => a.label.localeCompare(b.label));
  };

  schema.statics.addRelation = function({model, relation, updater, updatedAt, messages})
  {
    const input = {
      relations: model.relations.toObject()
    };

    input.relations.push(relation);

    if (model.edit({input, updater, updatedAt, messages}))
    {
      return model;
    }

    return null;
  };

  schema.statics.deleteRelation = function({model, relation, updater, updatedAt, messages})
  {
    const input = {
      relations: model.relations.toObject().filter(
        r => r._id !== relation._id && r.type !== relation.type
      )
    };

    if (model.edit({input, updater, updatedAt, messages}))
    {
      return model;
    }

    return null;
  };

  schema.methods.isCreator = function(userId)
  {
    return this.creator.id === userId;
  };

  schema.methods.isImplementer = function(userId)
  {
    if (this.implementers)
    {
      return this.implementers.some(u => u.id === userId);
    }

    return !!this.implementer && this.implementer.id === userId;
  };

  schema.methods.isCoordinator = function(userId)
  {
    return this.coordinators.some(u => u.id === userId);
  };

  schema.methods.isParticipant = function(userId)
  {
    return this.participants.some(p => p.user.id === userId);
  };

  schema.methods.canDelete = function(userId)
  {
    return this.status === 'new' && this.isCoordinator(userId);
  };

  schema.methods.updateParticipants = function(changedPropertyList, updater)
  {
    const changedPropertyMap = {};
    const oldParticipants = new Map();
    const newParticipants = new Map();
    const subscribers = new Map();
    const usersToNotify = new Set();

    changedPropertyList.forEach(prop => changedPropertyMap[prop] = 1);

    this.participants.forEach(participant =>
    {
      participant = participant.toObject();

      if (participant.roles.includes('subscriber'))
      {
        subscribers.set(participant.user.id, participant);
      }

      oldParticipants.set(participant.user.id, participant);
    });

    let creator;

    if (oldParticipants.has(this.creator.id))
    {
      creator = {
        ...oldParticipants.get(this.creator.id),
        roles: ['creator']
      };
    }
    else
    {
      creator = {
        user: this.creator,
        roles: ['creator'],
        lastSeenAt: this.createdAt,
        notify: false,
        changes: {}
      };

      usersToNotify.add(creator.user.id);
    }

    newParticipants.set(creator.user.id, creator);

    (this.implementer ? [this.implementer] : (this.implementers || [])).forEach(user =>
    {
      if (newParticipants.has(user.id))
      {
        newParticipants.get(user.id).roles.push('implementer');

        return;
      }

      if (oldParticipants.has(user.id))
      {
        newParticipants.set(user.id, {
          ...oldParticipants.get(user.id),
          roles: ['implementer']
        });

        return;
      }

      usersToNotify.add(user.id);

      newParticipants.set(user.id, {
        user,
        roles: ['implementer'],
        lastSeenAt: null,
        notify: true,
        changes: {}
      });
    });

    (this.coordinators || []).forEach(user =>
    {
      if (newParticipants.has(user.id))
      {
        newParticipants.get(user.id).roles.push('coordinator');

        return;
      }

      if (oldParticipants.has(user.id))
      {
        newParticipants.set(user.id, {
          ...oldParticipants.get(user.id),
          roles: ['coordinator']
        });

        return;
      }

      usersToNotify.add(user.id);

      newParticipants.set(user.id, {
        user,
        roles: ['coordinator'],
        lastSeenAt: null,
        notify: true,
        changes: {}
      });
    });

    subscribers.forEach(participant =>
    {
      if (newParticipants.has(participant.user.id))
      {
        newParticipants.get(participant.user.id).roles.push('subscriber');
      }
      else
      {
        usersToNotify.add(participant.user.id);

        newParticipants.set(participant.user.id, {
          ...participant,
          roles: ['subscriber']
        });
      }
    });

    this.changes.forEach(change =>
    {
      const participant = newParticipants.get(change.user.id);

      if (participant)
      {
        if (participant.lastSeenAt < change.date)
        {
          participant.lastSeenAt = change.date;
        }

        return;
      }

      usersToNotify.add(change.user.id);

      newParticipants.set(change.user.id, {
        user: change.user,
        roles: ['subscriber'],
        lastSeenAt: change.date,
        notify: true,
        changes: {}
      });
    });

    newParticipants.forEach(participant =>
    {
      if (!participant.notify)
      {
        participant.notify = true;
        participant.changes = changedPropertyMap;

        usersToNotify.add(participant.user.id);

        return;
      }

      if (Object.keys(participant.changes).length)
      {
        Object.assign(participant.changes, changedPropertyMap);

        usersToNotify.add(participant.user.id);
      }
    });

    const updaterParticipant = updater ? newParticipants.get(updater.id) : null;

    if (updaterParticipant)
    {
      updaterParticipant.lastSeenAt = new Date();
      updaterParticipant.notify = false;
      updaterParticipant.changes = {};

      usersToNotify.delete(updaterParticipant.user.id);
    }

    newParticipants.delete(null);

    this.participants = Array.from(newParticipants.values());

    return Array.from(usersToNotify).map(userId => ({
      userId,
      changes: newParticipants.get(userId).changes
    }));
  };

  schema.methods.edit = function({input, updater, updatedAt, messages})
  {
    const notify = this.applyChanges(input, updater, updatedAt);

    if (!notify)
    {
      return notify;
    }

    const {TOPIC_PREFIX} = this.constructor;

    messages.push({
      topic: `${TOPIC_PREFIX}.edited`,
      message: {
        user: updater,
        model: this
      }
    }, {
      topic: `${TOPIC_PREFIX}.updated.${this._id}`,
      message: {
        _id: this._id,
        change: _.last(this.changes),
        notify
      }
    });

    return notify;
  };

  schema.methods.applyChanges = function(input, updater, updatedAt)
  {
    if (!updater)
    {
      updater = {
        id: null,
        label: 'System'
      };
    }

    if (!updatedAt)
    {
      updatedAt = new Date();
    }

    const changes = this.compareProperties(_.omit(input, [
      'comment',
      'implementers',
      'coordinators',
      'relations',
      'attachments'
    ]));

    this.updateImplementers(changes, input.implementers);
    this.updateCoordinators(changes, input.coordinators);
    this.updateRelations(changes, input.relations);
    this.updateAttachments(changes, input.attachments);

    const changedProperties = Object.keys(changes);
    const comment = _.isEmpty(input.comment) || !_.isString(input.comment) ? '' : input.comment.trim();

    if (!_.isEmpty(input.comment))
    {
      changedProperties.push('comment');
    }

    if (!changedProperties.length)
    {
      return null;
    }

    if (_.isEmpty(comment) && _.isEmpty(changes))
    {
      return null;
    }

    const usersToNotify = {};

    this.updateParticipants(changedProperties, updater).forEach(({userId, changes}) =>
    {
      usersToNotify[userId] = changes;
    });

    this.changes.push({
      date: updatedAt,
      user: updater,
      data: changes,
      comment
    });

    return usersToNotify;
  };

  schema.methods.compareProperties = function(input)
  {
    const changes = {};

    Object.keys(input).forEach(property =>
    {
      this.compareProperty(property, input, changes);
    });

    return changes;
  };

  schema.methods.compareProperty = function(property, input, changes)
  {
    let oldValue = this[property];
    let newValue = input[property];

    if (_.isObject(oldValue) && _.isFunction(oldValue.toObject))
    {
      oldValue = oldValue.toObject();
    }

    if (_.isObject(newValue) && _.isFunction(newValue.toObject))
    {
      newValue = newValue.toObject();
    }

    if (oldValue instanceof mongoose.Types.ObjectId)
    {
      oldValue = oldValue.toString();
    }

    if (newValue instanceof mongoose.Types.ObjectId)
    {
      newValue = newValue.toString();
    }
    else if (_.isString(newValue))
    {
      if (property.endsWith('At') || property.endsWith('Date'))
      {
        newValue = new Date(newValue);

        if (isNaN(newValue.getTime()))
        {
          newValue = null;
        }
      }
      else if (schema.path(property).instance === 'Number')
      {
        newValue = +newValue;
      }
      else
      {
        newValue = newValue.trim();
      }
    }

    if (jsonDeepEqual(newValue, oldValue))
    {
      return false;
    }

    changes[property] = [oldValue, newValue];
    this[property] = newValue;

    return true;
  };

  schema.methods.updateList = function(changes, listProperty, newList, compare)
  {
    if (!Array.isArray(newList) || !Array.isArray(this[listProperty]))
    {
      return;
    }

    const oldMap = new Map();
    const change = {
      added: [],
      edited: [],
      deleted: []
    };

    this[listProperty].forEach(c => oldMap.set(c._id || c.id, c));

    newList.forEach(newItem =>
    {
      const id = newItem._id || newItem.id;
      const oldItem = oldMap.get(id);

      if (!oldItem)
      {
        change.added.push(newItem);

        return;
      }

      oldMap.delete(id);

      if (!compare(newItem, oldItem))
      {
        change.edited.push({
          ...newItem,
          old: oldItem
        });
      }
    });

    oldMap.forEach(oldItem =>
    {
      change.deleted.push(oldItem);
    });

    if (!change.added.length && !change.edited.length && !change.deleted.length)
    {
      return;
    }

    changes[listProperty] = [null, change];
    this[listProperty] = newList;
  };

  schema.methods.updateImplementers = function(changes, newList)
  {
    this.updateList(
      changes,
      'implementers',
      newList,
      (newItem, oldItem) => newItem.label === oldItem.label
    );
  };

  schema.methods.updateCoordinators = function(changes, newList)
  {
    this.updateList(
      changes,
      'coordinators',
      newList,
      (newItem, oldItem) => newItem.label === oldItem.label
    );
  };

  schema.methods.updateRelations = function(changes, newList)
  {
    this.updateList(
      changes,
      'relations',
      newList,
      (newItem, oldItem) => newItem._id === oldItem._id && newItem.type === oldItem.type
    );
  };

  schema.methods.updateAttachments = function(changes, newList)
  {
    this.updateList(
      changes,
      'attachments',
      newList,
      (newItem, oldItem) => newItem.name === oldItem.name && newItem.kind === oldItem.kind
    );
  };

  schema.statics.markAsSeen = function(filter, userId, done)
  {
    const Model = this;

    if (typeof userId !== 'string')
    {
      userId = String(userId);
    }

    const query = {
      participants: {
        $elemMatch: {
          'user.id': userId,
          notify: true
        }
      }
    };

    switch (filter)
    {
      case 'all':
        break;

      case 'finished':
        query.status = 'finished';
        break;

      case 'dayOld':
        query.createdAt = {$lt: new Date(Date.now() - 24 * 3600 * 1000)};
        break;

      case 'weekOld':
        query.createdAt = {$lt: new Date(Date.now() - 7 * 24 * 3600 * 1000)};
        break;

      case 'noComment':
        query.participants.$elemMatch['changes.comment'] = {$exists: false};
        break;

      default:
        query._id = {$in: filter};
        break;
    }

    step(
      function()
      {
        Model
          .find(query)
          .select({_id: 1})
          .lean()
          .exec(this.next());
      },
      function(err, entries)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (entries.length === 0)
        {
          return this.skip(null, []);
        }

        const seenIds = entries.map(e => e._id);

        setImmediate(this.parallel(), null, seenIds);

        const filter = {
          _id: {$in: seenIds}
        };
        const update = {
          $set: {
            'participants.$[p].notify': false,
            'participants.$[p].changes': {},
            'participants.$[p].lastSeenAt': new Date()
          }
        };
        const options = {
          arrayFilters: [
            {'p.user.id': userId}
          ]
        };

        Model.collection.updateMany(filter, update, options, this.parallel());
      },
      done
    );
  };

  return schema;
};
