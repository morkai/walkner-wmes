// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const autoIncrement = require('mongoose-plugin-autoinc-fix');
const jsonDeepEqual = require('util/jsonDeepEqual');
const userInfoSchema = require('user/models/userInfoSchema');
const attachmentSchema = require('./attachmentSchema');
const participantSchema = require('./participantSchema');
const changeSchema = require('./changeSchema');

exports.name = 'OshNearMiss';

exports.setUp = (app, mongoose) =>
{
  const STATUSES = ['new', 'inProgress', 'finished', 'paused', 'cancelled'];

  const schema = new mongoose.Schema({
    status: {
      type: String,
      enum: STATUSES
    },
    statusComment: {
      type: String,
      default: ''
    },
    statusUpdater: userInfoSchema,
    createdAt: {
      type: Date,
      required: true
    },
    startedAt: {
      type: Date,
      default: null
    },
    plannedAt: {
      type: Date,
      default: null
    },
    finishedAt: {
      type: Date,
      default: null
    },
    duration: {
      type: Number,
      min: 0,
      max: 36500
    },
    creator: userInfoSchema,
    implementer: userInfoSchema,
    coordinators: [userInfoSchema],
    userWorkplace: {
      type: Number,
      ref: 'OshWorkplace',
      default: null
    },
    userDivision: {
      type: Number,
      ref: 'OshDivision',
      default: null
    },
    workplace: {
      type: Number,
      ref: 'OshWorkplace',
      required: true
    },
    division: {
      type: Number,
      ref: 'OshDivision',
      required: true
    },
    building: {
      type: Number,
      ref: 'OshBuilding',
      required: true
    },
    location: {
      type: Number,
      ref: 'OshLocation',
      required: true
    },
    eventDate: {
      type: Date,
      required: true
    },
    eventCategory: {
      type: Number,
      ref: 'OshEventCategory',
      required: true
    },
    reasonCategory: {
      type: Number,
      ref: 'OshReasonCategory'
    },
    kind: {
      type: Number,
      ref: 'OshKind',
      required: true
    },
    priority: {
      type: Number,
      default: 1,
      min: 0,
      max: 4
    },
    materialLoss: {
      type: Boolean,
      default: false
    },
    subject: {
      type: String,
      required: true,
      trim: true,
      maxLength: 150
    },
    problem: {
      type: String,
      required: true,
      trim: true,
      maxLength: 1000
    },
    reason: {
      type: String,
      trim: true,
      maxLength: 1000
    },
    solution: {
      type: String,
      trim: true,
      maxLength: 1000
    },
    attachments: [attachmentSchema],
    participants: [participantSchema],
    changes: [changeSchema]
  }, {
    id: false,
    minimize: false
  });

  schema.statics.TOPIC_PREFIX = 'osh.nearMisses';
  schema.statics.BROWSE_LIMIT = 100;
  schema.statics.STATUSES = STATUSES;

  schema.plugin(autoIncrement.plugin, {
    model: exports.name,
    field: '_id',
    startAt: 1,
    incrementBy: 1
  });

  schema.pre('save', function(next)
  {
    next();
  });

  schema.statics.resolveCoordinators = async function({kind, division, userDivision})
  {
    if (userDivision)
    {
      division = userDivision;
    }

    const OshKind = mongoose.model('OshKind');
    const OshDivision = mongoose.model('OshDivision');

    const coordinators = new Map();

    const coordinatorSources = await Promise.all([
      OshKind.findById(kind).select({coordinators: 1}).lean().exec(),
      OshDivision.findById(division).select({coordinators: 1}).lean().exec()
    ]);

    coordinatorSources.forEach(source =>
    {
      if (!source || !Array.isArray(source.coordinators) || !source.coordinators.length)
      {
        return;
      }

      source.coordinators.forEach(user =>
      {
        coordinators.set(user.id, user);
      });
    });

    return Array.from(coordinators.values()).sort((a, b) => a.label.localeCompare(b.label));
  };

  schema.methods.isCreator = function(userId)
  {
    return this.creator.id === userId;
  };

  schema.methods.isImplementer = function(userId)
  {
    return !!this.implementer && this.implementer.id === userId;
  };

  schema.methods.isCoordinator = function(userId)
  {
    return this.coordinators.some(u => u.id === userId);
  };

  schema.methods.isParticipant = function(userId)
  {
    return this.participants.some(p => p.user.id === userId);
  };

  schema.methods.canDelete = function(userId)
  {
    return this.status === 'new' && (this.isCreator(userId) || this.isCoordinator(userId));
  };

  schema.methods.updateParticipants = function(changedPropertyList, updater)
  {
    const changedPropertyMap = {};
    const oldParticipants = new Map();
    const newParticipants = new Map();
    const subscribers = new Map();
    const usersToNotify = new Set();

    changedPropertyList.forEach(prop => changedPropertyMap[prop] = true);

    this.participants.forEach(participant =>
    {
      participant = participant.toObject();

      if (participant.roles.includes('subscriber'))
      {
        subscribers.set(participant.user.id, participant);
      }

      oldParticipants.set(participant.user.id, participant);
    });

    let creator;

    if (oldParticipants.has(this.creator.id))
    {
      creator = {
        ...oldParticipants.get(this.creator.id),
        roles: ['creator']
      };
    }
    else
    {
      creator = {
        user: this.creator,
        roles: ['creator'],
        lastSeenAt: this.createdAt,
        notify: false,
        changes: {}
      };

      usersToNotify.add(creator.user.id);
    }

    newParticipants.set(creator.user.id, creator);

    if (this.implementer)
    {
      let implementer = null;

      if (this.implementer.id === creator.user.id)
      {
        creator.roles.push('implementer');
      }
      else if (oldParticipants.has(this.implementer.id))
      {
        implementer = {
          ...oldParticipants.get(this.implementer.id),
          roles: ['implementer']
        };
      }
      else
      {
        implementer = {
          user: this.implementer,
          roles: ['implementer'],
          lastSeenAt: null,
          notify: true,
          changes: {}
        };

        usersToNotify.add(implementer.user.id);
      }

      if (implementer)
      {
        newParticipants.set(implementer.user.id, implementer);
      }
    }

    this.coordinators.forEach(user =>
    {
      if (newParticipants.has(user.id))
      {
        newParticipants.get(user.id).roles.push('coordinator');

        return;
      }

      if (oldParticipants.has(user.id))
      {
        newParticipants.set(user.id, {
          ...oldParticipants.get(user.id),
          roles: ['coordinator']
        });

        return;
      }

      usersToNotify.add(user.id);

      newParticipants.set(user.id, {
        user,
        roles: ['coordinator'],
        lastSeenAt: null,
        notify: true,
        changes: {}
      });
    });

    subscribers.forEach(participant =>
    {
      if (newParticipants.has(participant.user.id))
      {
        newParticipants.get(participant.user.id).roles.push('subscriber');
      }
      else
      {
        usersToNotify.add(participant.user.id);

        newParticipants.set(participant.user.id, {
          ...participant,
          roles: ['subscriber']
        });
      }
    });

    this.changes.forEach(change =>
    {
      const participant = newParticipants.get(change.user.id);

      if (participant)
      {
        if (participant.lastSeenAt < change.date)
        {
          participant.lastSeenAt = change.date;
        }

        return;
      }

      usersToNotify.add(change.user.id);

      newParticipants.set(change.user.id, {
        user: change.user,
        roles: ['subscriber'],
        lastSeenAt: change.date,
        notify: true,
        changes: {}
      });
    });

    newParticipants.forEach(participant =>
    {
      if (!participant.notify)
      {
        participant.notify = true;
        participant.changes = changedPropertyMap;

        usersToNotify.add(participant.user.id);

        return;
      }

      if (Object.keys(participant.changes).length)
      {
        Object.assign(participant.changes, changedPropertyMap);

        usersToNotify.add(participant.user.id);
      }
    });

    const updaterParticipant = updater ? newParticipants.get(updater.id) : null;

    if (updaterParticipant)
    {
      updaterParticipant.lastSeenAt = new Date();
      updaterParticipant.notify = false;
      updaterParticipant.changes = {};

      usersToNotify.delete(updaterParticipant.user.id);
    }

    newParticipants.delete(null);

    this.participants = Array.from(newParticipants.values());

    return Array.from(usersToNotify).map(userId => ({
      userId,
      changes: newParticipants.get(userId).changes
    }));
  };

  schema.methods.applyChanges = function(input, updater, updatedAt)
  {
    const changes = this.compareProperties(_.omit(input, [
      'comment',
      'coordinators',
      'attachments'
    ]));

    this.updateCoordinators(changes, input.coordinators);
    this.updateAttachments(changes, input.attachments);

    const changedProperties = Object.keys(changes);
    const comment = _.isEmpty(input.comment) || !_.isString(input.comment) ? '' : input.comment.trim();

    if (!_.isEmpty(input.comment))
    {
      changedProperties.push('comment');
    }

    if (!changedProperties.length)
    {
      return null;
    }

    if (_.isEmpty(comment) && _.isEmpty(changes))
    {
      return null;
    }

    const usersToNotify = {};

    this.updateParticipants(changedProperties, updater).forEach(({userId, changes}) =>
    {
      usersToNotify[userId] = changes;
    });

    this.changes.push({
      date: updatedAt,
      user: updater,
      data: changes,
      comment
    });

    return usersToNotify;
  };

  schema.methods.compareProperties = function(input)
  {
    const changes = {};

    Object.keys(input).forEach(property =>
    {
      this.compareProperty(property, input, changes);
    });

    return changes;
  };

  schema.methods.compareProperty = function(property, input, changes)
  {
    let oldValue = this[property];
    let newValue = input[property];

    if (_.isObject(oldValue) && _.isFunction(oldValue.toObject))
    {
      oldValue = oldValue.toObject();
    }

    if (_.isObject(newValue) && _.isFunction(newValue.toObject))
    {
      newValue = newValue.toObject();
    }

    if (oldValue instanceof mongoose.Types.ObjectId)
    {
      oldValue = oldValue.toString();
    }

    if (newValue instanceof mongoose.Types.ObjectId)
    {
      newValue = newValue.toString();
    }
    else if (_.isString(newValue))
    {
      if (property.endsWith('At') || property.endsWith('Date'))
      {
        newValue = new Date(newValue);

        if (isNaN(newValue.getTime()))
        {
          newValue = null;
        }
      }
      else if (schema.path(property).instance === 'Number')
      {
        newValue = +newValue;
      }
      else
      {
        newValue = newValue.trim();
      }
    }

    if (jsonDeepEqual(newValue, oldValue))
    {
      return false;
    }

    changes[property] = [oldValue, newValue];
    this[property] = newValue;

    return true;
  };

  schema.methods.updateCoordinators = function(changes, newCoordinatorList)
  {
    if (!Array.isArray(newCoordinatorList))
    {
      return;
    }

    const oldCoordinatorMap = new Map();
    const change = {
      added: [],
      edited: [],
      deleted: []
    };

    this.coordinators.forEach(c => oldCoordinatorMap.set(c.id, c));

    newCoordinatorList.forEach(newCoordinator =>
    {
      const oldCoordinator = oldCoordinatorMap.get(newCoordinator.id);

      if (!oldCoordinator)
      {
        change.added.push(newCoordinator);

        return;
      }

      oldCoordinatorMap.delete(newCoordinator.id);

      if (newCoordinator.label !== oldCoordinator.label)
      {
        change.edited.push(newCoordinator);
      }
    });

    oldCoordinatorMap.forEach(oldCoordinator =>
    {
      change.deleted.push(oldCoordinator);
    });

    if (!change.added.length && !change.edited.length && !change.deleted.length)
    {
      return;
    }

    changes.coordinators = [null, change];
    this.coordinators = newCoordinatorList;
  };

  schema.methods.updateAttachments = function(changes, newAttachmentList)
  {
    if (!Array.isArray(newAttachmentList))
    {
      return;
    }

    const oldAttachmentMap = new Map();
    const change = {
      added: [],
      edited: [],
      deleted: []
    };

    this.attachments.forEach(a => oldAttachmentMap.set(a._id, a));

    newAttachmentList.forEach(newAttachment =>
    {
      const oldAttachment = oldAttachmentMap.get(newAttachment._id);

      if (!oldAttachment)
      {
        change.added.push(newAttachment);

        return;
      }

      oldAttachmentMap.delete(newAttachment._id);

      if (newAttachment.name !== oldAttachment.name)
      {
        change.edited.push(newAttachment);
      }
    });

    oldAttachmentMap.forEach(oldAttachment =>
    {
      change.deleted.push(oldAttachment);
    });

    if (!change.added.length && !change.edited.length && !change.deleted.length)
    {
      return;
    }

    changes.attachments = [null, change];
    this.attachments = newAttachmentList;
  };

  return schema;
};
