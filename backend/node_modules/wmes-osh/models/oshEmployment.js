// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const userInfoSchema = require('user/models/userInfoSchema');

exports.name = 'OshEmployment';

exports.setUp = (app, mongoose) =>
{
  const createDepartment = (division = 0, workplace = 0, department = 0) => ({
    division,
    workplace,
    department,
    internal: 0,
    external: 0,
    absent: 0,
    total: 0,
    observers: 0,
    observerUsers: []
  });

  const departmentSchema = new mongoose.Schema({
    division: {type: Number, required: true, min: 0, max: 9999},
    workplace: {type: Number, required: true, min: 0, max: 9999},
    department: {type: Number, required: true, min: 0, max: 9999},
    internal: {type: Number, required: true, min: 0, max: 99999},
    external: {type: Number, required: true, min: 0, max: 99999},
    absent: {type: Number, required: true, min: 0, max: 99999},
    total: {type: Number, required: true, min: 0, max: 99999},
    observers: {type: Number, required: true, min: 0, max: 99999},
    observerUsers: [userInfoSchema]
  }, {
    _id: false,
    minimize: false
  });

  const schema = new mongoose.Schema({
    _id: Date,
    locked: {
      type: Boolean,
      default: false
    },
    departments: [departmentSchema]
  }, {
    id: false,
    minimize: false,
    versionKey: false
  });

  schema.statics.TOPIC_PREFIX = 'osh.employments';
  schema.statics.BROWSE_LIMIT = 100;

  schema.statics.recount = async function()
  {
    const User = mongoose.model('User');

    const result = {
      0: {internal: 0, external: 0, observers: 0}
    };

    const [employees, observers] = await Promise.all([
      User
        .aggregate([
          {$match: {
            active: true,
            oshDepartment: {$gt: 0}
          }},
          {$group: {
            _id: '$oshDepartment',
            internal: {$sum: {$cond: {if: {$eq: ['$oshExternal', false]}, then: 1, else: 0}}},
            external: {$sum: {$cond: {if: {$eq: ['$oshExternal', true]}, then: 1, else: 0}}}
          }}
        ])
        .exec(),
      User
        .aggregate([
          {$match: {
            active: true,
            privileges: 'OSH:OBSERVER',
            oshDepartment: {$gt: 0}
          }},
          {$group: {
            _id: '$oshDepartment',
            users: {$push: {
              _id: '$_id',
              firstName: '$firstName',
              lastName: '$lastName',
              login: '$login'
            }}
          }}
        ])
        .exec()
    ]);

    employees.forEach(item =>
    {
      result[item._id || 0] = {
        internal: item.internal,
        external: item.external,
        observers: 0,
        observerUsers: []
      };
    });

    observers.forEach(item =>
    {
      result[item._id || 0].observers = item.users.length;
      result[item._id || 0].observerUsers = item.users.map(user => ({
        id: user._id.toString(),
        label: User.prepareLabel(user)
      }));
    });

    return result;
  };

  schema.statics.getActiveOrgUnits = async function()
  {
    const OshDivision = mongoose.model('OshDivision');
    const OshWorkplace = mongoose.model('OshWorkplace');
    const OshDepartment = mongoose.model('OshDepartment');

    const [divisions, workplaces, departments] = await Promise.all([
      OshDivision
        .find({active: true})
        .select({_id: 1})
        .lean()
        .exec(),
      OshWorkplace
        .find({active: true})
        .select({division: 1})
        .lean()
        .exec(),
      OshDepartment
        .find({active: true})
        .select({workplace: 1})
        .lean()
        .exec()
    ]);

    const orgUnits = {
      divisions: listToMap(divisions),
      workplaces: listToMap(workplaces),
      departments: listToMap(departments)
    };

    workplaces.forEach(workplace =>
    {
      if (!orgUnits.divisions[workplace.division])
      {
        delete orgUnits.workplaces[workplace._id];
      }
    });

    departments.forEach(department =>
    {
      if (!orgUnits.workplaces[department.workplace])
      {
        delete orgUnits.departments[department._id];
      }
    });

    return orgUnits;

    function listToMap(list)
    {
      const map = {};

      list.forEach(item =>
      {
        map[item._id] = item;
      });

      return map;
    }
  };

  schema.methods.recreate = async function(keepInactive, orgUnits)
  {
    if (orgUnits)
    {
      orgUnits = {
        divisions: {...orgUnits.divisions},
        workplaces: {...orgUnits.workplaces},
        departments: {...orgUnits.departments}
      };
    }
    else
    {
      orgUnits = await schema.statics.getActiveOrgUnits();
    }

    const newDepartments = keepInactive ? this.departments : this.departments.filter(d =>
    {
      return (!d.division || orgUnits.divisions[d.division])
        && (!d.workplace || orgUnits.workplaces[d.workplace])
        && (!d.department || orgUnits.departments[d.department]);
    });
    const existingWorkplaces = new Set();
    const existingDivisions = new Set();

    newDepartments.forEach(d =>
    {
      delete orgUnits.departments[d.department];
      existingWorkplaces.add(d.workplace);
      existingDivisions.add(d.division);
    });

    Object.values(orgUnits.departments).forEach(department =>
    {
      const workplace = orgUnits.workplaces[department.workplace];

      if (!workplace)
      {
        return;
      }

      const division = orgUnits.divisions[workplace.division];

      if (!division)
      {
        return;
      }

      if (!existingWorkplaces.has(workplace._id))
      {
        newDepartments.push(createDepartment(division._id, workplace._id));
      }

      if (!existingWorkplaces.has(division._id))
      {
        newDepartments.push(createDepartment(division._id));
      }

      newDepartments.push(createDepartment(division._id, workplace._id, department._id));
    });

    this.departments = newDepartments;
  };

  schema.methods.recount = async function()
  {
    const idToCount = await schema.statics.recount();
    const divisions = new Map();
    const workplaces = new Map();

    this.departments.forEach(d =>
    {
      if (!d.department)
      {
        d.internal = 0;
        d.external = 0;
        d.absent = 0;
        d.observers = 0;

        if (d.workplace)
        {
          workplaces.set(d.workplace, d);
        }
        else
        {
          divisions.set(d.division, d);
        }

        return;
      }

      const count = idToCount[d.department];

      if (!count)
      {
        return;
      }

      Object.assign(d, count);

      d.total = Math.max(0, d.internal + d.external - d.absent);
    });

    const overall = divisions.get(0);

    this.departments.forEach(d =>
    {
      if (!d.department)
      {
        return;
      }

      [overall, divisions.get(d.division), workplaces.get(d.workplace)].forEach(parent =>
      {
        parent.internal += d.internal;
        parent.external += d.external;
        parent.absent += d.absent;
        parent.observers += d.observers;
      });
    });

    workplaces.forEach(d =>
    {
      d.total = Math.max(0, d.internal + d.external - d.absent);
    });

    divisions.forEach(d =>
    {
      d.total = Math.max(0, d.internal + d.external - d.absent);
    });
  };

  schema.methods.add = async function()
  {
    await this.save();

    app.broker.publish(`${schema.statics.TOPIC_PREFIX}.added`, {
      model: this,
      user: null
    });
  };

  schema.methods.edit = async function()
  {
    await this.save();

    app.broker.publish(`${schema.statics.TOPIC_PREFIX}.edited`, {
      model: this,
      user: null
    });
  };

  return schema;
};
