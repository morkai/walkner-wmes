// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const moment = require('moment');
const later = require('later');

module.exports = (app, module) =>
{
  const {
    OshNearMiss,
    OshKaizen,
    OshAction,
    OshObservation,
    OshAccident
  } = module;

  const TYPE_TO_CONFIG = {
    [OshNearMiss.RELATION_TYPE]: {
      enabled: true,
      userRoles: ['creator'],
      dateProperty: 'eventDate',
      utcDate: true
    },
    [OshKaizen.RELATION_TYPE]: {
      enabled: true,
      userRoles: ['implementer'],
      dateProperty: 'createdAt',
      utcDate: false
    },
    [OshAction.RELATION_TYPE]: {
      enabled: false,
      userRoles: ['creator', 'implementer', 'participant'],
      dateProperty: 'createdAt',
      utcDate: false
    },
    [OshObservation.RELATION_TYPE]: {
      enabled: false,
      userRoles: ['creator'],
      dateProperty: 'date',
      utcDate: true
    },
    [OshAccident.RELATION_TYPE]: {
      enabled: false,
      userRoles: ['creator'],
      dateProperty: 'eventDate',
      utcDate: true
    }
  };

  const logger = module.logger.create({submodule: 'stats'});

  const stats = new Map();
  const recountTimers = new Map();

  app.broker.subscribe('app.started', recountAllStats).setLimit(1);

  _.forEach(module.TYPE_TO_MODEL, Entry =>
  {
    if (!TYPE_TO_CONFIG[Entry.RELATION_TYPE] || !TYPE_TO_CONFIG[Entry.RELATION_TYPE].enabled)
    {
      return;
    }

    stats.set(Entry, {
      total: createEmptyStats(),
      users: {},
      currentTop10: [],
      previousTop10: []
    });

    const scheduleRecount = scheduleStatsRecount.bind(null, Entry);

    app.broker.subscribe(`${Entry.TOPIC_PREFIX}.added`, scheduleRecount);
    app.broker.subscribe(`${Entry.TOPIC_PREFIX}.edited`, scheduleRecount);
    app.broker.subscribe(`${Entry.TOPIC_PREFIX}.deleted`, scheduleRecount);
  });

  later.setInterval(recountStats, later.parse.text('on the first day of the month'));

  module.getStats = async (Entry, userId) =>
  {
    const userStats = await getUserStats(Entry, userId);
    const typeStats = stats.get(Entry);

    return {
      total: typeStats.total,
      currentTop10: typeStats.currentTop10,
      previousTop10: typeStats.previousTop10,
      user: userStats
    };
  };

  function createEmptyStats()
  {
    return {
      updatedAt: 0,
      allCount: 0,
      openCount: 0,
      monthCount: 0
    };
  }

  function scheduleStatsRecount(Entry)
  {
    if (recountTimers.get(Entry))
    {
      return;
    }

    const updatedAtDiff = Date.now() - stats.get(Entry).total.updatedAt;
    const delay = updatedAtDiff > 60000 ? 1337 : 60000;
    const timer = setTimeout(recountStats.bind(null, Entry), delay);

    recountTimers.set(Entry, timer);
  }

  function recountAllStats()
  {
    stats.forEach((stats, Entry) => recountStats(Entry));
  }

  async function recountStats(Entry)
  {
    const t = Date.now();

    if (recountTimers.get(Entry))
    {
      clearTimeout(recountTimers.get(Entry));
    }

    try
    {
      await Promise.all([
        recountTotalStats(Entry),
        recountTop10(Entry)
      ]);

      logger.info('Recounted.', {
        relationType: Entry.RELATION_TYPE,
        duration: Date.now() - t
      });

      stats.get(Entry).users = {};

      recountTimers.delete(Entry);
    }
    catch (err)
    {
      logger.error(err, 'Failed to recount.', {relationType: Entry.RELATION_TYPE});
    }
  }

  async function recountTotalStats(Entry)
  {
    const totalStats = await countEntries(Entry, null);

    if (!totalStats)
    {
      return;
    }

    delete totalStats._id;

    totalStats.updatedAt = Date.now();

    stats.get(Entry).total = totalStats;
  }

  async function recountTop10(Entry)
  {
    const {userRoles, dateProperty, utcDate} = TYPE_TO_CONFIG[Entry.RELATION_TYPE];

    const currentMonth = moment().startOf('month');
    const previousMonth = currentMonth.clone().subtract(1, 'month');

    if (utcDate)
    {
      currentMonth.utc(true);
      previousMonth.utc(true);
    }

    const pipeline = [
      {$match: {
        [dateProperty]: {
          $gte: previousMonth.toDate()
        },
        status: {
          $in: [
            'new',
            'inProgress',
            'verification',
            'paused',
            'finished'
          ]
        }
      }},
      {$unwind: '$users'},
      {$match: {
        'users.roles': {$in: userRoles}
      }},
      {$group: {
        _id: '$users.user.id',
        name: {$last: '$users.user.label'},
        currentCount: {
          $sum: {
            $cond: {
              if: {$gte: [`$${dateProperty}`, currentMonth.toDate()]},
              then: 1,
              else: 0
            }
          }
        },
        previousCount: {
          $sum: {
            $cond: {
              if: {$lt: [`$${dateProperty}`, currentMonth.toDate()]},
              then: 1,
              else: 0
            }
          }
        }
      }},
      {$sort: {previousCount: -1}}
    ];

    const results = await Entry.aggregate(pipeline).exec();
    const previousTop10 = [];
    const currentTop10 = [];

    for (let i = 0; i < results.length; ++i)
    {
      const result = results[i];

      if (result.previousCount)
      {
        previousTop10.push({
          place: -1,
          _id: result._id,
          name: result.name,
          count: result.previousCount
        });
      }

      if (result.currentCount)
      {
        currentTop10.push({
          place: -1,
          _id: result._id,
          name: result.name,
          count: result.currentCount
        });
      }
    }

    stats.get(Entry).previousTop10 = prepareTop10(previousTop10);
    stats.get(Entry).currentTop10 = prepareTop10(currentTop10);
  }

  function prepareTop10(top10)
  {
    top10.sort((a, b) =>
    {
      if (a.count === b.count)
      {
        return a.name.localeCompare(b.name);
      }

      return b.count - a.count;
    });

    top10 = top10.slice(0, 10);

    let lastPlace = 0;
    let lastCount = 0;

    top10.forEach(contender =>
    {
      if (contender.count === lastCount)
      {
        contender.place = lastPlace;
      }
      else
      {
        lastPlace += 1;
        lastCount = contender.count;

        contender.place = lastPlace;
      }
    });

    return top10;
  }

  async function getUserStats(Entry, userId)
  {
    if (!userId)
    {
      return createEmptyStats();
    }

    let userStats = stats.get(Entry).users[userId];

    if (userStats)
    {
      return userStats;
    }

    userStats = await countEntries(Entry, userId);

    if (!userStats)
    {
      userStats = createEmptyStats();
    }
    else
    {
      delete userStats._id;
    }

    userStats.updatedAt = Date.now();
    stats.get(Entry).users[userId] = userStats;

    return userStats;
  }

  async function countEntries(Entry, userId)
  {
    const {dateProperty, utcDate} = TYPE_TO_CONFIG[Entry.RELATION_TYPE];

    const currentMonth = moment().startOf('month');

    if (utcDate)
    {
      currentMonth.utc(true);
    }

    const pipeline = [];

    if (!_.isEmpty(userId))
    {
      pipeline.push({$match: {
        'users.user.id': userId
      }});
    }

    pipeline.push({$group: {
      _id: null,
      allCount: {$sum: 1},
      openCount: {$sum: {
        $cond: {
          if: {$in: ['$status', ['new', 'inProgress', 'verification', 'paused']]},
          then: 1,
          else: 0
        }
      }},
      monthCount: {$sum: {
        $cond: {
          if: {$gte: [`$${dateProperty}`, currentMonth.toDate()]},
          then: 1,
          else: 0
        }
      }}
    }});

    const results = await Entry.aggregate(pipeline).exec();

    return Array.isArray(results) && results.length ? results[0] : null;
  }
};
