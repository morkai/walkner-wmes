// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const fs = require('fs-extra');
const path = require('path');
const gm = require('gm');
const _ = require('lodash');
const step = require('h5.step');
const locks = require('util/locks');

module.exports = (app, module) =>
{
  const pendingUploads = new Map();

  module.attachments = {
    addPendingUploads,
    claimPendingUploads,
    optimizeImage
  };

  app.broker.subscribe('osh.*.deleted', onModelDeleted);

  function addPendingUploads(files, user)
  {
    const attachments = [];

    _.forEach(files, file =>
    {
      const id = file.filename.replace(/\..*?$/, '');

      if (pendingUploads.has(id))
      {
        return;
      }

      const attachment = {
        _id: id,
        date: new Date(),
        user,
        type: file.mimetype,
        size: file.size,
        name: file.originalname,
        meta: {}
      };

      const cleanupTimer = setTimeout(
        removePendingUpload,
        Math.max(30000, Math.ceil(attachment.size / 100)),
        id,
        file.path
      );

      const upload = {
        attachment,
        cleanupTimer
      };

      pendingUploads.set(id, upload);
      attachments.push(id);
    });

    return attachments;
  }

  function removePendingUpload(uploadId, filePath)
  {
    const upload = pendingUploads.get(uploadId);

    if (!upload)
    {
      return;
    }

    fs.unlink(filePath, err =>
    {
      if (err)
      {
        module.error(err, 'Failed to remove pending upload.', {
          uploadId,
          filePath
        });
      }
      else
      {
        module.debug('Removed pending upload.', {
          uploadId,
          filePath
        });
      }
    });
  }

  function claimPendingUploads(uploadIds)
  {
    const attachments = [];

    if (!Array.isArray(uploadIds) || uploadIds.length === 0)
    {
      return attachments;
    }

    uploadIds.forEach(uploadId =>
    {
      const upload = pendingUploads.get(uploadId);

      if (!upload)
      {
        return;
      }

      clearTimeout(upload.cleanupTimer);

      attachments.push(upload.attachment);
    });

    return attachments;
  }

  function onModelDeleted({model})
  {
    if (!Array.isArray(model.attachments) || model.attachments.length === 0)
    {
      return;
    }

    const filesToRemove = [];

    model.attachments.forEach(attachment =>
    {
      filesToRemove.push(attachment._id);

      if (attachment.type === 'image/jpeg')
      {
        filesToRemove.push(`${attachment._id}_min`);
      }
    });

    removeAttachments(filesToRemove);
  }

  function removeAttachments(filesToRemove)
  {
    filesToRemove.forEach(fileName =>
    {
      fs.unlink(path.join(module.config.uploadsPath, fileName), err =>
      {
        if (err && err.code !== 'ENOENT')
        {
          module.error(err, 'Failed to remove attachment file.', {fileName});
        }
      });
    });
  }

  async function optimizeImage(attachment, model)
  {
    const releaseLock = await locks.createAsync(`osh/attachments/${attachment._id}`);

    const bigFilePath = path.join(module.config.uploadsPath, attachment._id);
    const minFilePath = bigFilePath + '_min';

    await resizeImage(bigFilePath, `${bigFilePath}.jpg`, 1920, 1080, 80);
    await resizeImage(`${bigFilePath}.jpg`, `${minFilePath}.jpg`, 384, 216, 100);
    await Promise.all([
      fs.move(`${bigFilePath}.jpg`, bigFilePath, {overwrite: true}),
      fs.move(`${minFilePath}.jpg`, minFilePath, {overwrite: true})
    ]);

    const stats = await getImageStats(bigFilePath);

    attachment.type = 'image/jpeg';
    attachment.size = stats.size;
    attachment.meta = {
      width: stats.width,
      height: stats.height
    };

    await model.save();

    releaseLock();
  }
};

async function resizeImage(inFile, outFile, w, h, q)
{
  return new Promise((resolve, reject) =>
  {
    gm(inFile)
      .resize(w, h, '>')
      .autoOrient()
      .noProfile()
      .quality(q)
      .write(outFile, err =>
      {
        if (err)
        {
          reject(err);
        }
        else
        {
          resolve();
        }
      });
  });
}

async function getImageStats(filePath)
{
  return new Promise((resolve, reject) =>
  {
    step(
      function()
      {
        fs.stat(filePath, this.parallel());

        gm(filePath).size(this.parallel());
      },
      function(err, stat, dimensions)
      {
        if (err)
        {
          return reject(err);
        }

        resolve({
          size: stat.size,
          width: dimensions.width,
          height: dimensions.height
        });
      }
    );
  });
}
