// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const fs = require('fs-extra');
const path = require('path');
const gm = require('gm');
const _ = require('lodash');
const step = require('h5.step');
const locks = require('util/locks');
const transliterateFileName = require('./util/transliterateFileName');
const {KINDS} = require('./models/attachmentSchema').statics;

module.exports = (app, module) =>
{
  const pendingUploads = new Map();

  module.attachments = {
    addPendingUploads,
    claimPendingUploads,
    optimizeImage,
    prepareInput
  };

  app.broker.subscribe('osh.*.deleted', onModelDeleted);

  function addPendingUploads(files, user)
  {
    const attachments = [];

    _.forEach(files, file =>
    {
      const id = file.filename.replace(/\..*?$/, '');

      if (pendingUploads.has(id))
      {
        return;
      }

      const attachment = {
        _id: id,
        date: new Date(),
        user,
        type: file.mimetype,
        size: file.size,
        file: transliterateFileName(file.originalname),
        name: file.originalname,
        kind: KINDS.includes(file.fieldname) ? file.fieldname : 'other',
        meta: {}
      };

      const cleanupTimer = setTimeout(
        removePendingUpload,
        Math.max(30000, Math.ceil(attachment.size / 100)),
        id,
        file.path
      );

      const upload = {
        attachment,
        cleanupTimer
      };

      pendingUploads.set(id, upload);
      attachments.push(id);
    });

    return attachments;
  }

  function removePendingUpload(uploadId, filePath)
  {
    const upload = pendingUploads.get(uploadId);

    if (!upload)
    {
      return;
    }

    fs.unlink(filePath, err =>
    {
      if (err)
      {
        module.error(err, 'Failed to remove pending upload.', {
          uploadId,
          filePath
        });
      }
      else
      {
        module.debug('Removed pending upload.', {
          uploadId,
          filePath
        });
      }
    });
  }

  function claimPendingUploads(uploadIds)
  {
    const attachments = [];

    if (!Array.isArray(uploadIds) || uploadIds.length === 0)
    {
      return attachments;
    }

    uploadIds.forEach(uploadId =>
    {
      const upload = pendingUploads.get(uploadId);

      if (!upload)
      {
        return;
      }

      clearTimeout(upload.cleanupTimer);

      attachments.push(upload.attachment);
    });

    return attachments;
  }

  function onModelDeleted({model})
  {
    if (!Array.isArray(model.attachments) || model.attachments.length === 0)
    {
      return;
    }

    const filesToRemove = [];

    model.attachments.forEach(attachment =>
    {
      filesToRemove.push(attachment._id);

      if (attachment.meta.min)
      {
        filesToRemove.push(`${attachment._id}_min`);
      }
    });

    removeAttachments(filesToRemove);
  }

  function removeAttachments(filesToRemove)
  {
    filesToRemove.forEach(fileName =>
    {
      fs.unlink(path.join(module.config.uploadsPath, fileName), err =>
      {
        if (err && err.code !== 'ENOENT')
        {
          module.error(err, 'Failed to remove attachment file.', {fileName});
        }
      });
    });
  }

  async function optimizeImage(attachment, model)
  {
    const releaseLock = await locks.createAsync(`osh/attachments/${attachment._id}`);

    const originalFilePath = path.join(module.config.uploadsPath, attachment._id);
    const originalStats = await getImageStats(originalFilePath);
    const dimensionsTooBig = originalStats.width > 1920 || originalStats.height > 1080;
    const sizeTooBig = originalStats.size > 1024 * 1024;

    if (!dimensionsTooBig && !sizeTooBig)
    {
      Object.assign(attachment.meta, {
        width: originalStats.width,
        height: originalStats.height,
        min: false
      });
    }
    else
    {
      const minTargetPath = originalFilePath + '_min';
      const minSourcePath = `${originalFilePath}.jpg`;

      if (dimensionsTooBig)
      {
        originalStats.width = 1920;
        originalStats.height = 1080;
      }

      attachment.type = 'image/jpeg';

      Object.assign(attachment.meta, {
        width: originalStats.width,
        height: originalStats.height,
        min: false
      });

      await resizeImage(originalFilePath, minSourcePath, originalStats.width, originalStats.height, 80);

      if (originalStats.width > 384 || originalStats.height > 216)
      {
        attachment.meta.min = true;

        await resizeImage(minSourcePath, `${minTargetPath}.jpg`, 384, 216, 100);
      }

      await Promise.all([
        fs.move(minSourcePath, originalFilePath, {overwrite: true}),
        attachment.meta.min ? fs.move(`${minTargetPath}.jpg`, minTargetPath, {overwrite: true}) : null
      ]);

      const stats = await getImageStats(originalFilePath);

      attachment.type = 'image/jpeg';
      attachment.size = stats.size;

      Object.assign(attachment.meta, {
        width: stats.width,
        height: stats.height,
        min: true
      });
    }

    await model.constructor.collection.updateOne({_id: model._id}, {$set: {attachments: model.attachments}});

    releaseLock();
  }

  function prepareInput(input, entry)
  {
    if (!_.isPlainObject(input.attachments))
    {
      delete input.attachments;

      return input;
    }

    const {added, edited, deleted} = input.attachments;
    const attachments = new Map();

    entry.attachments.forEach(attachment =>
    {
      attachments.set(attachment._id, attachment.toObject ? attachment.toObject() : {...attachment});
    });

    if (Array.isArray(added))
    {
      claimPendingUploads(added).forEach(attachment =>
      {
        attachments.set(attachment._id, attachment);
      });
    }

    if (Array.isArray(edited))
    {
      edited.forEach(update =>
      {
        const attachment = attachments.get(update._id);

        if (attachment && typeof update.name === 'string' && update.name.length)
        {
          attachment.file = transliterateFileName(update.name);
          attachment.name = update.name;
        }

        if (attachment && KINDS.includes(update.kind))
        {
          attachment.kind = update.kind;
        }
      });
    }

    if (Array.isArray(deleted))
    {
      deleted.forEach(attachmentId => attachments.delete(attachmentId));
    }

    input.attachments = Array.from(attachments.values()).sort((a, b) => a.date - b.date);

    return input;
  }
};

async function resizeImage(inFile, outFile, w, h, q)
{
  return new Promise((resolve, reject) =>
  {
    gm(inFile)
      .resize(w, h, '>')
      .autoOrient()
      .noProfile()
      .quality(q)
      .write(outFile, err =>
      {
        if (err)
        {
          reject(err);
        }
        else
        {
          resolve();
        }
      });
  });
}

async function getImageStats(filePath)
{
  return new Promise((resolve, reject) =>
  {
    step(
      function()
      {
        fs.stat(filePath, this.parallel());

        gm(filePath).size(this.parallel());
      },
      function(err, stat, dimensions)
      {
        if (err)
        {
          return reject(err);
        }

        resolve({
          size: stat.size,
          width: dimensions.width,
          height: dimensions.height
        });
      }
    );
  });
}
