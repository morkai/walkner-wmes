// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const moment = require('moment');
const step = require('h5.step');
const util = require('reports/util');

exports.models = [
  require('wmes-osh/models/oshNearMiss'),
  require('wmes-osh/models/oshKaizen'),
  require('wmes-osh/models/oshAction'),
  require('wmes-osh/models/oshObservation'),
  require('wmes-osh/models/oshTarget'),
  require('wmes-osh/models/oshEmployment'),
  require('wmes-osh/models/oshBrigade'),
  require('settings/models/setting')
];

exports.report = (app, module, options, done) =>
{
  const {
    Setting,
    OshNearMiss,
    OshKaizen,
    OshAction,
    OshObservation,
    OshTarget,
    OshEmployment,
    OshBrigade
  } = module;

  options.fromTime = 0;
  options.toTime = 0;
  options.orgUnitType = null;
  options.orgUnitIds = [];
  options.leader = null;

  options.conditions.forEach(term =>
  {
    if (term.name === 'ge' && term.args[0] === 'date')
    {
      options.fromTime = term.args[1];

      return;
    }

    if (term.name === 'lt' && term.args[0] === 'date')
    {
      options.toTime = term.args[1];

      return;
    }

    if (term.name === 'eq' && term.args[0] === 'leader')
    {
      options.leader = term.args[1];

      return;
    }

    if ((term.name === 'eq' || term.name === 'in')
      && (term.args[0] === 'division' || term.args[0] === 'workplace' || term.args[0] === 'department'))
    {
      options.orgUnitType = term.args[0];
      options.orgUnitIds = term.name === 'eq' ? [term.args[1]] : term.args[1];
    }
  });

  if (!options.fromTime)
  {
    options.fromTime = moment().startOf('month').subtract(3, 'months').valueOf();
  }

  if (!options.toTime || options.toTime > Date.now())
  {
    options.toTime = moment().startOf('month').add(1, 'months').valueOf();
  }

  if (options.toTime <= options.fromTime)
  {
    options.toTime = moment(options.fromTime).add(1, 'months').valueOf();
  }

  delete options.conditions;

  const results = {
    options,
    settings: {},
    userLabels: {
      undefined: '?'
    },
    months: [],
    orgUnits: {},
    brigades: {
      undefined: {
        id: 'undefined',
        months: {}
      }
    },
    users: {}
  };

  const LOCATION_TO_USER_PROP = {
    division: 'oshDivision',
    workplace: 'oshWorkplace',
    department: 'oshDepartment'
  };
  const USER_ORG_UNIT_PROP = LOCATION_TO_USER_PROP[options.orgUnitType];
  const ENTRY_ORG_UNIT_PROP = options.orgUnitType;

  const userDepartments = new Set();
  const memberToBrigades = {};
  const minMonthKey = moment(options.fromTime).startOf('month').utc(true).valueOf();
  const maxMonthKey = moment(options.toTime).startOf('month').utc(true).valueOf();

  step(
    function()
    {
      Setting
        .find({
          _id: {$in: Object.keys(results.settings).map(s => `osh.${s}`)}
        })
        .select({value: 1})
        .lean()
        .exec(this.parallel());

      handleBrigades(this.parallel());
    },
    function(err, settings)
    {
      if (err)
      {
        return this.skip(err);
      }

      settings.forEach(setting =>
      {
        results.settings[setting._id.split('.').pop()] = setting.value;
      });
    },
    function()
    {
      handleNearMisses(this.group());
      handleKaizens(this.group());
      handleActions(this.group());
      handleObservations(this.group());
    },
    function(err)
    {
      if (err)
      {
        return this.skip(err);
      }

      const conditions = {
        _id: {
          $gte: moment(options.fromTime).utc(true).toDate()
        }
      };

      if (options.toTime > options.fromTime)
      {
        conditions._id.$lt = moment(options.toTime).utc(true).toDate();
      }

      OshTarget
        .find(conditions)
        .sort({_id: 1})
        .lean()
        .exec(this.parallel());

      OshEmployment
        .find(conditions)
        .sort({_id: 1})
        .lean()
        .exec(this.parallel());
    },
    function(err, targets, employments)
    {
      if (err)
      {
        return this.skip(err);
      }

      const usedOrgUnits = prepareUsedOrgUnits(employments);

      handleTargets(targets, usedOrgUnits);
      handleEmployments(employments, usedOrgUnits);
    },
    function(err)
    {
      if (err)
      {
        return this.skip(err);
      }

      const month = moment.utc(minMonthKey);

      while (month.valueOf() < maxMonthKey)
      {
        results.months.push(month.valueOf());

        month.add(1, 'months');
      }

      results.orgUnits = Object.values(results.orgUnits);

      const divisions = new Map();
      const workplaces = new Map();
      const departments = [];

      results.orgUnits.forEach(orgUnit =>
      {
        if (orgUnit.workplace === 0)
        {
          divisions.set(orgUnit.division, orgUnit);
        }
        else if (orgUnit.department === 0)
        {
          workplaces.set(orgUnit.workplace, orgUnit);
        }
        else
        {
          departments.push(orgUnit);
        }
      });

      departments.forEach(department =>
      {
        const workplace = workplaces.get(department.workplace);
        const division = divisions.get(department.division);
        const overall = divisions.get(0);

        Object.keys(department.months).forEach(monthKey =>
        {
          const childMonth = department.months[monthKey];

          [overall, division, workplace].forEach(parent =>
          {
            if (!parent.months[monthKey])
            {
              parent.months[monthKey] = createOrgUnitMonth();
            }

            const parentMonth = parent.months[monthKey];

            parentMonth.employed += childMonth.employed;

            childMonth.metrics.forEach((v, k) =>
            {
              parentMonth.metrics[k] += v;
            });

            childMonth.engaged.forEach(user =>
            {
              parentMonth.engaged.add(user);
            });
          });
        });
      });

      results.orgUnits.forEach(orgUnit =>
      {
        Object.keys(orgUnit.months).forEach(key =>
        {
          const month = orgUnit.months[key];

          month.engaged = month.engaged.size;
        });
      });

      if (_.isEmpty(results.brigades.undefined.months))
      {
        delete results.brigades.undefined;
      }

      results.brigades = Object.values(results.brigades).sort(sortUsers);

      results.brigades.forEach(brigade =>
      {
        Object.keys(brigade.months).forEach(key =>
        {
          const month = brigade.months[key];

          month.departments = Array.from(month.departments);
          month.members = Array.from(month.members);
          month.active = month.active.size;
        });
      });

      results.users = Object.values(results.users).sort(sortUsers);
    },
    function(err)
    {
      done(err, results);
    }
  );

  function sortUsers(a, b)
  {
    return results.userLabels[a.id].localeCompare(results.userLabels[b.id], undefined, {sensitivity: 'base'});
  }

  function getUserOrgUnit(monthKey, userInfo)
  {
    const {oshDivision, oshWorkplace, oshDepartment} = userInfo;

    if (oshDepartment)
    {
      userDepartments.add(oshDepartment);
    }

    return getOrgUnit(monthKey, {
      division: oshDivision || 0,
      workplace: oshWorkplace || 0,
      department: oshDepartment || 0
    });
  }

  function getOrgUnit(monthKey, {division, workplace, department})
  {
    const id = `${division}:${workplace}:${department}`;

    if (!results.orgUnits[id])
    {
      results.orgUnits[id] = {
        division,
        workplace,
        department,
        months: {}
      };
    }

    if (!results.orgUnits[id].months[monthKey])
    {
      results.orgUnits[id].months[monthKey] = createOrgUnitMonth();
    }

    return results.orgUnits[id];
  }

  function createOrgUnitMonth()
  {
    return {
      employed: 0,
      engaged: new Set(),
      minEngaged: 0,
      metrics: createMetrics()
    };
  }

  function getBrigades(monthKey, user)
  {
    const memberId = String(user._id || user.id);
    const monthBrigades = memberToBrigades[monthKey + memberId];

    if (monthBrigades)
    {
      return monthBrigades;
    }

    if (!results.brigades.undefined.months[monthKey])
    {
      results.brigades.undefined.months[monthKey] = {
        shift: 0,
        departments: new Set(),
        members: new Set(),
        active: new Set(),
        metrics: createMetrics()
      };
    }

    const undefinedBrigade = results.brigades.undefined.months[monthKey];

    undefinedBrigade.members.add(memberId);

    return [undefinedBrigade];
  }

  function getUser(monthKey, user)
  {
    const id = String(user._id || user.id);

    if (!results.users[id])
    {
      results.userLabels[id] = user.label || `${user.lastName} ${user.firstName}`.trim() || user.login;

      results.users[id] = {
        id,
        totals: createMetrics(),
        months: {}
      };
    }

    if (!results.users[id].months[monthKey])
    {
      results.users[id].months[monthKey] = createMetrics();
    }

    return results.users[id];
  }

  function createMetrics()
  {
    return [
      0, // 0. Near misses
      0, // 1. Kaizens
      0, // 2. Actions
      0 //  3. Observations
    ];
  }

  function prepareUsedOrgUnits(employments)
  {
    const usedOrgUnits = {
      division: new Set([0]),
      workplace: new Set(),
      department: new Set()
    };

    if (ENTRY_ORG_UNIT_PROP === 'department')
    {
      options.orgUnitIds.forEach(id => userDepartments.add(id));
    }

    employments.forEach(employment =>
    {
      employment.departments.forEach(d =>
      {
        if (!d.department)
        {
          return;
        }

        if ((!ENTRY_ORG_UNIT_PROP && !options.leader)
          || userDepartments.has(d.department)
          || (ENTRY_ORG_UNIT_PROP === 'division' && options.orgUnitIds.includes(d.division))
          || (ENTRY_ORG_UNIT_PROP === 'workplace' && options.orgUnitIds.includes(d.workplace)))
        {
          usedOrgUnits.division.add(d.division);
          usedOrgUnits.workplace.add(d.workplace);
          usedOrgUnits.department.add(d.department);
        }
      });
    });

    return usedOrgUnits;
  }

  function isUsedOrgUnit(orgUnit, usedOrgUnits)
  {
    return (orgUnit.department && usedOrgUnits.department.has(orgUnit.department))
      || (!orgUnit.department && orgUnit.workplace && usedOrgUnits.workplace.has(orgUnit.workplace))
      || (!orgUnit.department && !orgUnit.workplace && usedOrgUnits.division.has(orgUnit.division));
  }

  function handleTargets(targets, usedOrgUnits)
  {
    targets.forEach(target =>
    {
      const monthKey = target._id.getTime();

      target.orgUnits.forEach(ou =>
      {
        if (!isUsedOrgUnit(ou, usedOrgUnits))
        {
          return;
        }

        const orgUnit = getOrgUnit(monthKey, ou);

        orgUnit.months[monthKey].minEngaged = ou.targets.minActiveUsers;
      });
    });
  }

  function handleEmployments(employments, usedOrgUnits)
  {
    employments.forEach(employment =>
    {
      const monthKey = employment._id.getTime();

      employment.departments.forEach(ou =>
      {
        if (!usedOrgUnits.department.has(ou.department))
        {
          return;
        }

        const orgUnit = getOrgUnit(monthKey, ou);

        orgUnit.months[monthKey].employed += ou.total;
      });
    });
  }

  function handleBrigades(done)
  {
    const conditions = {
      date: {
        $gte: moment(options.fromTime).utc(true).toDate()
      }
    };

    if (options.toTime > options.fromTime)
    {
      conditions.date.$lt = moment(options.toTime).utc(true).toDate();
    }

    if (options.leader)
    {
      conditions['leader.id'] = options.leader;
    }

    if (options.orgUnitIds.length)
    {
      conditions[`leader.${USER_ORG_UNIT_PROP}`] = {$in: options.orgUnitIds};
    }

    const stream = OshBrigade
      .find(conditions)
      .lean()
      .cursor();
    const next = _.once(done);

    stream.on('error', next);
    stream.on('end', next);
    stream.on('data', handleBrigade);
  }

  function handleNearMisses(done)
  {
    const conditions = {
      eventDate: {
        $gte: moment(options.fromTime).utc(true).toDate()
      }
    };

    if (options.toTime > options.fromTime)
    {
      conditions.eventDate.$lt = moment(options.toTime).utc(true).toDate();
    }

    if (options.orgUnitIds.length)
    {
      conditions[`creator.${USER_ORG_UNIT_PROP}`] = {$in: options.orgUnitIds};
    }

    const stream = OshNearMiss
      .find(conditions)
      .select({
        status: 1,
        eventDate: 1,
        creator: 1
      })
      .lean()
      .cursor();
    const next = _.once(done);

    stream.on('error', next);
    stream.on('end', next);
    stream.on('data', handleNearMiss);
  }

  function handleKaizens(done)
  {
    const conditions = {
      createdAt: {
        $gte: new Date(options.fromTime)
      }
    };

    if (options.toTime > options.fromTime)
    {
      conditions.createdAt.$lt = new Date(options.toTime);
    }

    if (options.orgUnitIds.length)
    {
      conditions[`implementers.${USER_ORG_UNIT_PROP}`] = {$in: options.orgUnitIds};
    }

    const stream = OshKaizen
      .find(conditions)
      .select({
        status: 1,
        createdAt: 1,
        implementers: 1
      })
      .lean()
      .cursor();
    const next = _.once(done);

    stream.on('error', next);
    stream.on('end', next);
    stream.on('data', handleKaizen);
  }

  function handleActions(done)
  {
    const conditions = {
      createdAt: {
        $gte: new Date(options.fromTime)
      }
    };

    if (options.toTime > options.fromTime)
    {
      conditions.createdAt.$lt = new Date(options.toTime);
    }

    if (options.orgUnitIds.length)
    {
      conditions.$or = [
        {[`creator.${USER_ORG_UNIT_PROP}`]: {$in: options.orgUnitIds}},
        {[`implementers.${USER_ORG_UNIT_PROP}`]: {$in: options.orgUnitIds}},
        {[`participants.${USER_ORG_UNIT_PROP}`]: {$in: options.orgUnitIds}}
      ];
    }

    const stream = OshAction
      .find(conditions)
      .select({
        status: 1,
        createdAt: 1,
        creator: 1,
        implementers: 1,
        participants: 1
      })
      .lean()
      .cursor();
    const next = _.once(done);

    stream.on('error', next);
    stream.on('end', next);
    stream.on('data', handleAction);
  }

  function handleObservations(done)
  {
    const conditions = {
      date: {
        $gte: moment(options.fromTime).utc(true).toDate()
      }
    };

    if (options.toTime > options.fromTime)
    {
      conditions.date.$lt = moment(options.toTime).utc(true).toDate();
    }

    if (options.orgUnitIds.length)
    {
      conditions[`creator.${USER_ORG_UNIT_PROP}`] = {$in: options.orgUnitIds};
    }

    const stream = OshObservation
      .find(conditions)
      .select({
        date: 1,
        creator: 1
      })
      .lean()
      .cursor();
    const next = _.once(done);

    stream.on('error', next);
    stream.on('end', next);
    stream.on('data', handleObservation);
  }

  function handleBrigade(brigade)
  {
    if (!results.brigades[brigade.leader.id])
    {
      results.brigades[brigade.leader.id] = {
        id: brigade.leader.id,
        months: {}
      };
    }

    const monthKey = brigade.date.getTime();
    const leaderBrigade = results.brigades[brigade.leader.id];

    if (!leaderBrigade.months[monthKey])
    {
      leaderBrigade.months[monthKey] = {
        shift: brigade.shift,
        departments: new Set(),
        members: new Set(),
        active: new Set(),
        metrics: createMetrics()
      };
    }

    const monthBrigade = leaderBrigade.months[monthKey];

    if (brigade.leader.oshDepartment)
    {
      userDepartments.add(brigade.leader.oshDepartment);
      monthBrigade.departments.add(brigade.leader.oshDepartment);
    }

    mapMemberToBrigade(monthKey, brigade.leader, monthBrigade);

    brigade.members.forEach(member =>
    {
      mapMemberToBrigade(monthKey, member, monthBrigade);
    });
  }

  function mapMemberToBrigade(monthKey, member, monthBrigade)
  {
    results.userLabels[member.id] = member.label;

    const memberKey = monthKey + member.id;

    if (!memberToBrigades[memberKey])
    {
      memberToBrigades[memberKey] = new Set();
    }

    memberToBrigades[memberKey].add(monthBrigade);

    monthBrigade.members.add(member.id);

    if (options.leader)
    {
      getUser(monthKey, member);
    }
  }

  function filterLeader(monthKey, user)
  {
    if (!options.leader)
    {
      return false;
    }

    const leaderBrigade = results.brigades[options.leader];

    if (!leaderBrigade)
    {
      return true;
    }

    const monthBrigade = leaderBrigade.months[monthKey];

    if (!monthBrigade)
    {
      return true;
    }

    return !monthBrigade.members.has(user.id);
  }

  function handleNearMiss(entry)
  {
    if (entry.status === 'cancelled')
    {
      return false;
    }

    const monthKey = util.utc.createGroupKey('month', entry.eventDate, false);

    if (filterLeader(monthKey, entry.creator))
    {
      return;
    }

    const orgUnit = getUserOrgUnit(monthKey, entry.creator);

    orgUnit.months[monthKey].engaged.add(entry.creator.id);
    orgUnit.months[monthKey].metrics[0] += 1;

    getBrigades(monthKey, entry.creator).forEach(brigade =>
    {
      brigade.active.add(entry.creator.id);
      brigade.metrics[0] += 1;
    });

    const user = getUser(monthKey, entry.creator);

    user.totals[0] += 1;
    user.months[monthKey][0] += 1;
  }

  function handleKaizen(entry)
  {
    if (entry.status === 'cancelled')
    {
      return false;
    }

    const monthKey = util.utc.createGroupKey('month', moment(entry.createdAt).utc(true).toDate(), false);

    entry.implementers.forEach(implementer =>
    {
      if (ENTRY_ORG_UNIT_PROP && !options.orgUnitIds.includes(implementer[USER_ORG_UNIT_PROP]))
      {
        return;
      }

      if (filterLeader(monthKey, implementer))
      {
        return;
      }

      const count = 1 / entry.implementers.length;

      const orgUnit = getUserOrgUnit(monthKey, implementer);

      orgUnit.months[monthKey].engaged.add(implementer.id);
      orgUnit.months[monthKey].metrics[1] += count;

      getBrigades(monthKey, implementer).forEach(brigade =>
      {
        brigade.active.add(implementer.id);
        brigade.metrics[1] += count;
      });

      const user = getUser(monthKey, implementer);

      user.totals[1] += 1;
      user.months[monthKey][1] += 1;
    });
  }

  function handleAction(entry)
  {
    if (entry.status === 'cancelled')
    {
      return false;
    }

    const monthKey = util.utc.createGroupKey('month', moment(entry.createdAt).utc(true).toDate(), false);

    if (Array.isArray(entry.implementers))
    {
      entry.implementers.forEach(implementer =>
      {
        handleActionUser(monthKey, implementer, entry.implementers.length);
      });
    }

    if (Array.isArray(entry.participants))
    {
      entry.participants.forEach(participant =>
      {
        handleActionUser(monthKey, participant, entry.participants.length);
      });
    }

    if (!entry.implementers && !entry.participants)
    {
      handleActionUser(monthKey, entry.creator, 1);
    }
  }

  function handleActionUser(monthKey, actionUser, totalCount)
  {
    if (ENTRY_ORG_UNIT_PROP && !options.orgUnitIds.includes(actionUser[USER_ORG_UNIT_PROP] || 0))
    {
      return;
    }

    if (filterLeader(monthKey, actionUser))
    {
      return;
    }

    const count = 1 / totalCount;

    const orgUnit = getUserOrgUnit(monthKey, actionUser);

    orgUnit.months[monthKey].engaged.add(actionUser.id);
    orgUnit.months[monthKey].metrics[2] += count;

    getBrigades(monthKey, actionUser).forEach(brigade =>
    {
      brigade.active.add(actionUser.id);
      brigade.metrics[2] += 1;
    });

    const user = getUser(monthKey, actionUser);

    user.totals[2] += 1;
    user.months[monthKey][2] += 1;
  }

  function handleObservation(entry)
  {
    const monthKey = util.utc.createGroupKey('month', entry.date, false);

    const orgUnit = getUserOrgUnit(monthKey, entry.creator);

    orgUnit.months[monthKey].engaged.add(entry.creator.id);
    orgUnit.months[monthKey].metrics[3] += 1;

    getBrigades(monthKey, entry.creator).forEach(brigade =>
    {
      brigade.active.add(entry.creator.id);
      brigade.metrics[3] += 1;
    });

    const user = getUser(monthKey, entry.creator);

    user.totals[3] += 1;
    user.months[monthKey][3] += 1;
  }
};
