// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const moment = require('moment');
const step = require('h5.step');
const util = require('reports/util');

exports.models = [
  require('wmes-osh/models/oshNearMiss'),
  require('wmes-osh/models/oshKaizen'),
  require('wmes-osh/models/oshAction'),
  require('wmes-osh/models/oshObservation'),
  require('wmes-osh/models/oshEmployment'),
  require('settings/models/setting')
];

exports.report = (app, module, options, done) =>
{
  const {
    Setting,
    OshNearMiss,
    OshKaizen,
    OshAction,
    OshObservation,
    OshEmployment
  } = module;

  options.fromTime = 0;
  options.toTime = 0;
  options.oshDivision = [];
  options.oshWorkplace = [];
  options.oshDepartment = [];

  let orgUnitType = null;
  let orgUnitIds = [];

  options.conditions.forEach(term =>
  {
    if (term.name === 'gte' && term.name === 'date')
    {
      options.fromTime = term.args[1];

      return;
    }

    if (term.name === 'lt' && term.name === 'date')
    {
      options.toTime = term.args[1];

      return;
    }

    if ((term.name === 'eq' || term.name === 'in')
      && (term.args[0] === 'oshDivision' || term.args[0] === 'oshWorkplace' || term.args[0] === 'oshDepartment'))
    {
      orgUnitType = term.args[0];
      orgUnitIds = term.name === 'eq' ? [term.args[1]] : term.args[1];

      options[orgUnitType] = orgUnitIds;
    }
  });

  if (!options.fromTime)
  {
    options.fromTime = moment().startOf('month').subtract(3, 'months').valueOf();
  }

  delete options.conditions;

  const minMonthKey = moment(options.fromTime).startOf('month').valueOf();
  let maxMonthKey = 0;

  const results = {
    options,
    settings: {
      minEngagement: 0
    },
    months: [],
    orgUnits: {},
    users: {}
  };

  step(
    function()
    {
      Setting
        .find({
          _id: {$in: Object.keys(results.settings).map(s => `osh.${s}`)}
        })
        .select({value: 1})
        .lean()
        .exec(this.parallel());

      const employmentConditions = {
        _id: {
          $gte: moment(options.fromTime).utc(true).toDate()
        }
      };

      if (options.toTime > options.fromTime)
      {
        employmentConditions.date.$lt = moment(options.toTime).utc(true).toDate();
      }

      OshEmployment
        .find(employmentConditions)
        .sort({_id: 1})
        .lean()
        .exec(this.parallel());
    },
    function(err, settings, employments)
    {
      if (err)
      {
        return this.skip(err);
      }

      settings.forEach(setting =>
      {
        results.settings[setting._id.split('.').pop()] = setting.value;
      });

      employments.forEach(employment =>
      {
        employment.departments.forEach(d =>
        {
          if (options.oshDivision.length && !options.oshDivision.includes(d.division))
          {
            return;
          }

          if (options.oshWorkplace.length && !options.oshWorkplace.includes(d.workplace))
          {
            return;
          }

          if (options.oshDepartment.length && !options.oshDepartment.includes(d.department))
          {
            return;
          }

          getOrgUnit(d.department).employed += d.count;
        });
      });
    },
    function()
    {
      handleNearMisses(this.group());
      handleKaizens(this.group());
      handleActions(this.group());
      handleObservations(this.group());
    },
    function(err)
    {
      if (err)
      {
        return this.skip(err);
      }

      const month = moment(maxMonthKey);

      while (month.valueOf() >= minMonthKey)
      {
        results.months.push(month.valueOf());

        month.subtract(1, 'months');
      }

      results.orgUnits = Object.values(results.orgUnits);

      results.orgUnits.forEach(orgUnit =>
      {
        orgUnit.engaged = orgUnit.engaged.size;
      });

      results.users = Object
        .values(results.users)
        .sort((a, b) => a.label.localeCompare(b.label, undefined, {sensitivity: 'base'}));
    },
    function(err)
    {
      done(err, results);
    }
  );

  function getOrgUnit(id)
  {
    if (!results.orgUnits[id])
    {
      results.orgUnits[id] = {
        department: id,
        employed: 0,
        engaged: new Set(),
        metrics: createMetrics()
      };
    }

    return results.orgUnits[id];
  }

  function getUser(user, monthKey)
  {
    const id = String(user._id || user.id);

    if (!results.users[id])
    {
      results.users[id] = {
        id,
        label: user.label || `${user.lastName} ${user.firstName}`.trim() || user.login,
        totals: createMetrics(),
        months: {}
      };
    }

    if (!results.users[id].months[monthKey])
    {
      results.users[id].months[monthKey] = createMetrics();
    }

    return results.users[id];
  }

  function createMetrics()
  {
    return [
      0, // 0. Near misses
      0, // 1. Kaizens
      0, // 2. Actions
      0 //  3. Observations
    ];
  }

  function handleNearMisses(done)
  {
    const conditions = {
      eventDate: {
        $gte: moment(options.fromTime).utc(true).toDate()
      }
    };

    if (options.toTime > options.fromTime)
    {
      conditions.eventDate.$lt = moment(options.toTime).utc(true).toDate();
    }

    ['oshDivision', 'oshWorkplace', 'oshDepartment'].forEach(orgUnitType =>
    {
      if (options[orgUnitType].length)
      {
        conditions[`creator.${orgUnitType}`] = {$in: options[orgUnitType]};
      }
    });

    const stream = OshNearMiss
      .find(conditions)
      .select({
        status: 1,
        eventDate: 1,
        creator: 1
      })
      .lean()
      .cursor();
    const next = _.once(done);

    stream.on('error', next);
    stream.on('end', next);
    stream.on('data', handleNearMiss);
  }

  function handleKaizens(done)
  {
    const conditions = {
      createdAt: {
        $gte: new Date(options.fromTime)
      }
    };

    if (options.toTime > options.fromTime)
    {
      conditions.createdAt.$lt = new Date(options.toTime);
    }

    ['oshDivision', 'oshWorkplace', 'oshDepartment'].forEach(orgUnitType =>
    {
      if (options[orgUnitType].length)
      {
        conditions[`implementers.${orgUnitType}`] = {$in: options[orgUnitType]};
      }
    });

    const stream = OshKaizen
      .find(conditions)
      .select({
        status: 1,
        createdAt: 1,
        implementers: 1
      })
      .lean()
      .cursor();
    const next = _.once(done);

    stream.on('error', next);
    stream.on('end', next);
    stream.on('data', handleKaizen);
  }

  function handleActions(done)
  {
    const conditions = {
      createdAt: {
        $gte: new Date(options.fromTime)
      }
    };

    if (options.toTime > options.fromTime)
    {
      conditions.createdAt.$lt = new Date(options.toTime);
    }

    ['oshDivision', 'oshWorkplace', 'oshDepartment'].forEach(orgUnitType =>
    {
      if (options[orgUnitType].length)
      {
        conditions.$or = [
          {[`creator.${orgUnitType}`]: {$in: options[orgUnitType]}},
          {[`implementers.${orgUnitType}`]: {$in: options[orgUnitType]}},
          {[`participants.${orgUnitType}`]: {$in: options[orgUnitType]}}
        ];
        conditions[`implementers.${orgUnitType}`] = {$in: options[orgUnitType]};
      }
    });

    const stream = OshAction
      .find(conditions)
      .select({
        status: 1,
        createdAt: 1,
        creator: 1,
        implementers: 1,
        participants: 1
      })
      .lean()
      .cursor();
    const next = _.once(done);

    stream.on('error', next);
    stream.on('end', next);
    stream.on('data', handleAction);
  }

  function handleObservations(done)
  {
    const conditions = {
      date: {
        $gte: moment(options.fromTime).utc(true).toDate()
      }
    };

    if (options.toTime > options.fromTime)
    {
      conditions.date.$lt = moment(options.toTime).utc(true).toDate();
    }

    ['oshDivision', 'oshWorkplace', 'oshDepartment'].forEach(orgUnitType =>
    {
      if (options[orgUnitType].length)
      {
        conditions[`creator.${orgUnitType}`] = {$in: options[orgUnitType]};
      }
    });

    const stream = OshObservation
      .find(conditions)
      .select({
        date: 1,
        creator: 1
      })
      .lean()
      .cursor();
    const next = _.once(done);

    stream.on('error', next);
    stream.on('end', next);
    stream.on('data', handleObservation);
  }

  function handleNearMiss(entry)
  {
    if (entry.status === 'cancelled')
    {
      return false;
    }

    const monthKey = util.createGroupKey('month', moment.utc(entry.eventDate).local(true).toDate(), false);

    if (monthKey > maxMonthKey)
    {
      maxMonthKey = monthKey;
    }

    const user = getUser(entry.creator, monthKey);
    const orgUnit = getOrgUnit(entry.creator.oshDepartment);
    const totals = user.totals;
    const month = user.months[monthKey];

    orgUnit.engaged.add(entry.creator.id);
    orgUnit.metrics[0] += 1;
    totals[0] += 1;
    month[0] += 1;
  }

  function handleKaizen(entry)
  {
    if (entry.status === 'cancelled')
    {
      return false;
    }

    const monthKey = util.createGroupKey('month', entry.createdAt, false);

    if (monthKey > maxMonthKey)
    {
      maxMonthKey = monthKey;
    }

    entry.implementers.forEach(implementer =>
    {
      if (orgUnitType && !orgUnitIds.includes(implementer[orgUnitType]))
      {
        return;
      }

      const user = getUser(implementer, monthKey);
      const orgUnit = getOrgUnit(implementer.oshDepartment);
      const totals = user.totals;
      const month = user.months[monthKey];
      const count = 1 / entry.implementers.length;

      orgUnit.engaged.add(implementer.id);
      orgUnit.metrics[1] += count;
      totals[1] += 1;
      month[1] += 1;
    });
  }

  function handleAction(entry)
  {
    if (entry.status === 'cancelled')
    {
      return false;
    }

    const monthKey = util.createGroupKey('month', entry.createdAt, false);

    if (monthKey > maxMonthKey)
    {
      maxMonthKey = monthKey;
    }

    if (Array.isArray(entry.implementers))
    {
      entry.implementers.forEach(implementer =>
      {
        handleActionUser(monthKey, implementer, entry.implementers.length);
      });
    }

    if (Array.isArray(entry.participants))
    {
      entry.participants.forEach(participant =>
      {
        handleActionUser(monthKey, participant, entry.participants.length);
      });
    }

    if (entry.implementers && entry.participants)
    {
      handleActionUser(monthKey, entry.creator, 1);
    }
  }

  function handleActionUser(monthKey, actionUser, totalCount)
  {
    if (orgUnitType && !orgUnitIds.includes(actionUser[orgUnitType]))
    {
      return;
    }

    const user = getUser(actionUser, monthKey);
    const orgUnit = getOrgUnit(actionUser.oshDepartment);
    const totals = user.totals;
    const month = user.months[monthKey];
    const count = 1 / totalCount;

    orgUnit.engaged.add(actionUser.id);
    orgUnit.metrics[2] += count;
    totals[2] += 1;
    month[2] += 1;
  }

  function handleObservation(entry)
  {
    const monthKey = util.createGroupKey('month', moment.utc(entry.date).local(true).toDate(), false);

    if (monthKey > maxMonthKey)
    {
      maxMonthKey = monthKey;
    }

    const user = getUser(entry.creator, monthKey);
    const orgUnit = getOrgUnit(entry.creator.oshDepartment);
    const totals = user.totals;
    const month = user.months[monthKey];

    orgUnit.engaged.add(entry.creator.id);
    orgUnit.metrics[3] += 1;
    totals[3] += 1;
    month[3] += 1;
  }
};
