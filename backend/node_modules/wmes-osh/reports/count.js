// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const moment = require('moment');
const step = require('h5.step');
const mongoSerializer = require('h5.rql/lib/serializers/mongoSerializer');
const util = require('reports/util');
const median = require('util/median');

exports.models = [
  require('wmes-osh/models/oshNearMiss'),
  require('wmes-osh/models/oshKaizen'),
  require('wmes-osh/models/oshAction'),
  require('wmes-osh/models/oshObservation')
];

exports.report = (app, module, options, done) =>
{
  const {
    OshNearMiss,
    OshKaizen,
    OshAction,
    OshObservation
  } = module;

  const TYPE_TO_MODEL = {
    [OshNearMiss.RELATION_TYPE]: OshNearMiss,
    [OshKaizen.RELATION_TYPE]: OshKaizen,
    [OshAction.RELATION_TYPE]: OshAction,
    [OshObservation.RELATION_TYPE]: OshObservation
  };
  const GROUP_PROPERTIES = ['createdAt', 'eventDate', 'startedAt', 'implementedAt', 'plannedAt', 'finishedAt'];

  const Model = TYPE_TO_MODEL[options.type];

  if (!Model)
  {
    return done(app.createError('Invalid model type.', 'INPUT', 400));
  }

  const now = new Date();
  let groupProperty = 'createdAt';
  let minGroupKey = Number.MAX_VALUE;
  let maxGroupKey = Number.MIN_VALUE;

  const {selector} = mongoSerializer.fromQuery({
    selector: {
      name: 'and',
      args: options.conditions
    }
  });

  GROUP_PROPERTIES.forEach(prop =>
  {
    if (selector[prop] && selector[prop].$gte)
    {
      groupProperty = prop;
    }
  });

  if (!selector[groupProperty])
  {
    selector[groupProperty] = {
      $gte: moment().startOf('month').subtract(6, 'months').toDate()
    };
  }

  if (!selector[groupProperty].$gte)
  {
    selector[groupProperty].$gte = moment(selector[groupProperty].$lt || Date.now())
      .startOf('month')
      .subtract(6, 'months')
      .toDate();
  }

  delete options.conditions;

  options.fromTime = selector[groupProperty].$gte;
  options.toTime = selector[groupProperty].$lt || 0;

  const results = {
    options,
    users: {},
    totals: createGroup(),
    groups: {}
  };

  step(
    function()
    {
      const stream = Model
        .find(selector)
        .select({
          users: 0,
          attachments: 0,
          changes: 0
        })
        .lean()
        .cursor();
      const next = _.once(this.parallel());

      stream.on('error', next);
      stream.on('end', next);
      stream.on('data', handleEntry);
    },
    function(err)
    {
      if (err)
      {
        return this.skip(err);
      }

      const createNextGroupKey = util.createCreateNextGroupKey(options.interval);
      const groups = [];
      let groupKey = minGroupKey;

      while (groupKey <= maxGroupKey)
      {
        const group = results.groups[groupKey];

        if (group)
        {
          summarizeGroup(group);
        }

        groups.push(group || groupKey);

        groupKey = createNextGroupKey(groupKey);
      }

      results.groups = groups;

      summarizeGroup(results.totals);

      Object.keys(results.totals).forEach(property =>
      {
        if (_.isPlainObject(results.totals[property]))
        {
          sortTotals(property);
        }
      });
    },
    function(err)
    {
      done(err, results);
    }
  );

  function createGroup(key)
  {
    return {
      key,
      count: 0,
      finished: 0,
      duration: [Number.MAX_SAFE_INTEGER, 0, 0, []],
      status: {},
      division: {},
      workplace: {},
      department: {},
      building: {},
      location: {},
      station: {},
      creator: {}
    };
  }

  function handleEntry(entry)
  {
    const totals = results.totals;
    const groupKey = util.createGroupKey(options.interval, entry[groupProperty], false);

    if (groupKey < minGroupKey)
    {
      minGroupKey = groupKey;
    }

    if (groupKey > maxGroupKey)
    {
      maxGroupKey = groupKey;
    }

    let group = results.groups[groupKey];

    if (!group)
    {
      group = results.groups[groupKey] = createGroup(groupKey);
    }

    handleGroup(entry, totals);
    handleGroup(entry, group);
  }

  function handleGroup(entry, group)
  {
    const duration = (entry.finishedAt || now) - entry.createdAt;

    group.duration[0] = Math.min(group.duration[0], duration);
    group.duration[1] = Math.max(group.duration[1], duration);
    group.duration[2] += duration;
    group.duration[3].push(duration);

    incCount('count');
    incGroup('status');
    incGroup('division');
    incGroup('workplace');
    incGroup('department');
    incGroup('building');
    incGroup('location');
    incGroup('station');
    incGroup('eventCategory');
    incGroup('reasonCategory');
    incGroup('kaizenCategory');
    incGroup('kind');
    incGroup('activityKind');
    incGroup('observationKind');
    incGroup('priority');
    incGroup('company');
    incUser('creator');

    if (entry.status === 'finished' || entry.status === 'cancelled')
    {
      incCount('finished');
    }

    if (entry.implementers)
    {
      entry.implementers.forEach(u => incUser('implementer', u));
    }

    if (entry.participants)
    {
      entry.participants.forEach(u => incUser('participant', u));
    }

    if (entry.behaviors)
    {
      entry.behaviors.forEach(incObservation);
      entry.workConditions.forEach(incObservation);
    }

    function incCount(metricProperty)
    {
      if (!group[metricProperty])
      {
        group[metricProperty] = 0;
      }

      group[metricProperty] += 1;
    }

    function incGroup(metricProperty, metricKey)
    {
      if (metricKey === undefined)
      {
        metricKey = entry[metricProperty];
      }

      if (metricKey == null || metricKey === '')
      {
        return;
      }

      if (!group[metricProperty])
      {
        group[metricProperty] = {};
      }

      if (Array.isArray(metricKey))
      {
        metricKey.forEach(incMetric);
      }
      else
      {
        incMetric(metricKey);
      }

      function incMetric(key)
      {
        if (!group[metricProperty][key])
        {
          group[metricProperty][key] = 1;
        }
        else
        {
          group[metricProperty][key] += 1;
        }
      }
    }

    function incUser(metric, user)
    {
      if (!user)
      {
        user = entry[metric];
      }

      if (!user)
      {
        return;
      }

      results.users[user.id] = user.label;

      if (!group[metric])
      {
        group[metric] = {};
      }

      if (!group[metric][user.id])
      {
        group[metric][user.id] = 0;
      }

      group[metric][user.id] += 1;
    }

    function incObservation(o)
    {
      incCount('observation');
      incGroup('observationCategory', o.category);
      incCount(o.safe ? 'safe' : 'risky');
      incGroup(o.safe ? 'safeCategory' : 'riskyCategory', o.category);

      if (!o.safe)
      {
        incCount(o.easy ? 'easy' : 'hard');
        incGroup(o.easy ? 'easyCategory' : 'hardCategory', o.category);
      }
    }
  }

  function summarizeGroup(group)
  {
    group.duration[0] = util.round(group.duration[0] / 3600000, 1);
    group.duration[1] = util.round(group.duration[1] / 3600000, 1);
    group.duration[2] = util.round(group.duration[2] / group.count / 3600000, 1);
    group.duration[3] = util.round(median(group.duration[3], false) / 3600000, 1);
  }

  function sortTotals(property)
  {
    if (!results.totals[property])
    {
      return;
    }

    const totals = [];

    _.forEach(results.totals[property], (value, key) =>
    {
      totals.push([key, value]);
    });

    results.totals[property] = totals.sort((a, b) => b[1] - a[1]);
  }
};
