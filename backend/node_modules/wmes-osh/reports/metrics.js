// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const moment = require('moment');
const step = require('h5.step');
const util = require('reports/util');

exports.models = [
  require('wmes-osh/models/oshNearMiss'),
  require('wmes-osh/models/oshKaizen'),
  require('wmes-osh/models/oshAction'),
  require('wmes-osh/models/oshObservation'),
  require('wmes-osh/models/oshEmployment'),
  require('wmes-osh/models/oshBrigade'),
  require('settings/models/setting')
];

exports.report = (app, module, options, done) =>
{
  const {
    Setting,
    OshNearMiss,
    OshKaizen,
    OshAction,
    OshObservation,
    OshEmployment
  } = module;

  options.fromTime = 0;
  options.toTime = 0;
  options.oshDivision = [];
  options.oshWorkplace = [];
  options.oshDepartment = [];

  let orgUnitType = null;
  let orgUnitIds = [];

  options.conditions.forEach(term =>
  {
    if (term.name === 'ge' && term.args[0] === 'date')
    {
      options.fromTime = term.args[1];

      return;
    }

    if (term.name === 'lt' && term.args[0] === 'date')
    {
      options.toTime = term.args[1];

      return;
    }

    if ((term.name === 'eq' || term.name === 'in')
      && (term.args[0] === 'oshDivision' || term.args[0] === 'oshWorkplace' || term.args[0] === 'oshDepartment'))
    {
      orgUnitType = term.args[0];
      orgUnitIds = term.name === 'eq' ? [term.args[1]] : term.args[1];

      options[orgUnitType] = orgUnitIds;
    }
  });

  if (!options.fromTime)
  {
    options.fromTime = moment().startOf('month').subtract(3, 'months').valueOf();
  }

  delete options.conditions;

  const results = {
    options,
    settings: {},
    totals: {
      ...createEmptyGroup(),
      byOrgUnit: {
        division: {},
        workplace: {},
        department: {}
      }
    },
    groups: {}
  };
  const totals = results.totals;

  const ORG_UNIT_TYPES = ['division', 'workplace', 'department'];
  const USER_TO_LOCATION_PROP = {
    oshDivision: 'division',
    oshWorkplace: 'workplace',
    oshDepartment: 'department'
  };
  const ORG_UNIT_PROP = orgUnitType;
  const LOCATION_PROP = orgUnitType ? USER_TO_LOCATION_PROP[orgUnitType] : null;
  const FROM_TIME_LOCAL = moment(options.fromTime).subtract(12, 'months').valueOf();
  const FROM_TIME_UTC = moment(FROM_TIME_LOCAL).utc(true).valueOf();

  step(
    function()
    {
      const settingConditions = {
        _id: {$in: Object.keys(results.settings).map(s => `osh.${s}`)}
      };

      if (settingConditions._id.$in.length)
      {
        Setting
          .find(settingConditions)
          .select({value: 1})
          .lean()
          .exec(this.parallel());
      }
      else
      {
        setImmediate(this.parallel(), null, []);
      }

      const employmentConditions = {
        _id: {
          $gte: new Date(FROM_TIME_UTC)
        }
      };

      if (options.toTime > options.fromTime)
      {
        employmentConditions._id.$lt = moment(options.toTime).utc(true).toDate();
      }

      OshEmployment
        .find(employmentConditions)
        .sort({_id: 1})
        .lean()
        .exec(this.parallel());
    },
    function(err, settings, employments)
    {
      if (err)
      {
        return this.skip(err);
      }

      settings.forEach(setting =>
      {
        results.settings[setting._id.split('.').pop()] = setting.value;
      });

      employments.forEach(employment =>
      {
        handleFte(employment);
      });
    },
    function()
    {
      handleNearMisses(this.group());
      handleKaizens(this.group());
      handleActions(this.group());
      handleObservations(this.group());
    },
    function(err)
    {
      if (err)
      {
        return this.skip(err);
      }

      finalizeGroup(totals);

      const groupKeys = Object.keys(results.groups).sort().map(Number);
      const lastGroupKey = _.last(groupKeys);
      const createNextGroupKey = util.createCreateNextGroupKey(options.interval);
      const groups = [];
      let groupKey = groupKeys[0];

      while (groupKey <= lastGroupKey)
      {
        const group = getIntervalGroup(groupKey);

        finalizeGroup(group);

        groups.push(group);

        groupKey = createNextGroupKey(groupKey);
      }

      results.groups = groups.filter(g => g.key >= options.fromTime);
    },
    function(err)
    {
      done(err, results);
    }
  );

  function finalizeGroup(group)
  {
    finalizeFte(group);
    finalizeOrgUnits(group.byOrgUnit);

    group.userCount = group.userCount.size;
    group.entryCount = group.nearMissCount + group.kaizenCount + group.actionCount + group.observationCount;

    const iprNum = group.entryCount;
    const iprDen = group.fte.avg;
    const ipsNum = group.observationCount;
    const ipsDen = iprNum;
    const ippNum = group.userCount;
    const ippDen = group.fte.avg;

    group.ipr = iprDen ? util.round(iprNum / iprDen) : 0;
    group.ips = ipsDen ? util.round(ipsNum / ipsDen * 100) : 0;
    group.ipp = ippDen ? Math.min(100, util.round(ippNum / ippDen * 100)) : 0;
  }

  function finalizeFte({key, fte})
  {
    fte.months = fte.months.size;

    if (key)
    {
      let total = 0;
      let months = 0;
      const month = moment(key);

      for (let i = 1; i <= 12; ++i)
      {
        month.subtract(1, 'month');

        const group = results.groups[month.valueOf()];

        if (group)
        {
          total += group.fte.total;
          months += group.fte.total ? 1 : 0;
        }
      }

      fte.avg = total / months;
    }
    else
    {
      fte.avg = fte.months > 0 ? util.round(fte.total / fte.months) : 0;
    }

    fte.total = util.round(fte.total);
  }

  function finalizeOrgUnits(byOrgUnit)
  {
    if (!byOrgUnit)
    {
      return;
    }

    _.forEach(byOrgUnit.division, finalizeGroup);
    _.forEach(byOrgUnit.workplace, finalizeGroup);
    _.forEach(byOrgUnit.department, finalizeGroup);
  }

  function createEmptyGroup()
  {
    return {
      ipr: 0,
      ips: 0,
      ipp: 0,
      nearMissCount: 0,
      kaizenCount: 0,
      actionCount: 0,
      observationCount: 0,
      entryCount: 0,
      userCount: new Set(),
      fte: {
        avg: 0,
        total: 0,
        months: new Set()
      }
    };
  }

  function getOrgUnitGroup(type, id)
  {
    if (!totals.byOrgUnit[type][id])
    {
      totals.byOrgUnit[type][id] = createEmptyGroup();
    }

    return totals.byOrgUnit[type][id];
  }

  function getIntervalGroup(key, orgUnits)
  {
    if (!results.groups[key])
    {
      results.groups[key] = Object.assign(createEmptyGroup(), {
        key,
        ...createEmptyGroup(),
        byOrgUnit: {
          division: {},
          workplace: {},
          department: {}
        }
      });
    }

    if (orgUnits)
    {
      const {byOrgUnit} = results.groups[key];

      ORG_UNIT_TYPES.forEach(orgUnitType =>
      {
        const orgUnitId = orgUnits[orgUnitType];

        if (!byOrgUnit[orgUnitType][orgUnitId])
        {
          byOrgUnit[orgUnitType][orgUnitId] = createEmptyGroup();
        }
      });
    }

    return results.groups[key];
  }

  function getIntervalOrgUnitGroup(intervalGroup, type, id)
  {
    if (!intervalGroup.byOrgUnit[type][id])
    {
      intervalGroup.byOrgUnit[type][id] = createEmptyGroup();
    }

    return intervalGroup.byOrgUnit[type][id];
  }

  function getGroups(key, orgUnits)
  {
    const intervalGroup = getIntervalGroup(key);
    const groups = [totals, intervalGroup];

    ORG_UNIT_TYPES.forEach(type =>
    {
      const ids = Array.isArray(orgUnits[type]) ? orgUnits[type] : [orgUnits[type]];

      ids.forEach(id =>
      {
        groups.push(
          getOrgUnitGroup(type, id),
          getIntervalOrgUnitGroup(intervalGroup, type, id)
        );
      });
    });

    return groups;
  }

  function handleFte(employment)
  {
    const month = employment._id.valueOf();
    const groupKey = util.createGroupKey(options.interval, moment.utc(month).local(true).toDate(), false);

    employment.departments.forEach(d =>
    {
      if (!d.total)
      {
        return;
      }

      if (options.oshDivision.length && !options.oshDivision.includes(d.division))
      {
        return;
      }

      if (options.oshWorkplace.length && !options.oshWorkplace.includes(d.workplace))
      {
        return;
      }

      if (options.oshDepartment.length && !options.oshDepartment.includes(d.department))
      {
        return;
      }

      getGroups(groupKey, d).forEach(group =>
      {
        group.fte.months.add(month);
        group.fte.total += d.total;
      });
    });
  }

  function remapUserOrgUnits(userOrgUnits)
  {
    if (Array.isArray(userOrgUnits))
    {
      if (userOrgUnits.length === 1)
      {
        userOrgUnits = userOrgUnits[0];
      }
      else
      {
        const divisions = new Set();
        const workplaces = new Set();
        const departments = new Set();

        userOrgUnits.forEach(user =>
        {
          divisions.add(user.oshDivision || 0);
          workplaces.add(user.oshWorkplace || 0);
          departments.add(user.oshDepartment || 0);
        });

        return {
          division: Array.from(divisions),
          workplace: Array.from(workplaces),
          department: Array.from(departments)
        };
      }
    }

    return {
      division: [userOrgUnits.oshDivision || 0],
      workplace: [userOrgUnits.oshWorkplace || 0],
      department: [userOrgUnits.oshDepartment || 0]
    };
  }

  function handleNearMisses(done)
  {
    const conditions = {
      status: {$ne: 'cancelled'},
      eventDate: {
        $gte: moment(options.fromTime).utc(true).toDate()
      }
    };

    if (options.toTime > options.fromTime)
    {
      conditions.eventDate.$lt = moment(options.toTime).utc(true).toDate();
    }

    if (orgUnitIds.length)
    {
      conditions.$or = [
        {
          [LOCATION_PROP]: {$in: orgUnitIds},
          [`creator.${ORG_UNIT_PROP}`]: {$in: orgUnitIds}
        }
      ];
    }

    const stream = OshNearMiss
      .find(conditions)
      .select({
        status: 1,
        eventDate: 1,
        creator: 1,
        division: 1,
        workplace: 1,
        department: 1
      })
      .lean()
      .cursor();
    const next = _.once(done);

    stream.on('error', next);
    stream.on('end', next);
    stream.on('data', handleNearMiss);
  }

  function handleKaizens(done)
  {
    const conditions = {
      status: {$ne: 'cancelled'},
      createdAt: {
        $gte: new Date(options.fromTime)
      }
    };

    if (options.toTime > options.fromTime)
    {
      conditions.createdAt.$lt = new Date(options.toTime);
    }

    if (orgUnitIds.length)
    {
      conditions.$or = [
        {[LOCATION_PROP]: {$in: orgUnitIds}},
        {[`implementers.${ORG_UNIT_PROP}`]: {$in: orgUnitIds}}
      ];
    }

    const stream = OshKaizen
      .find(conditions)
      .select({
        status: 1,
        createdAt: 1,
        implementers: 1,
        division: 1,
        workplace: 1,
        department: 1
      })
      .lean()
      .cursor();
    const next = _.once(done);

    stream.on('error', next);
    stream.on('end', next);
    stream.on('data', handleKaizen);
  }

  function handleActions(done)
  {
    const conditions = {
      status: {$ne: 'cancelled'},
      createdAt: {
        $gte: new Date(options.fromTime)
      }
    };

    if (options.toTime > options.fromTime)
    {
      conditions.createdAt.$lt = new Date(options.toTime);
    }

    if (orgUnitIds.length)
    {
      conditions.$or = [
        {[LOCATION_PROP]: {$in: orgUnitIds}},
        {[`creator.${ORG_UNIT_PROP}`]: {$in: orgUnitIds}},
        {[`implementers.${ORG_UNIT_PROP}`]: {$in: orgUnitIds}},
        {[`participants.${ORG_UNIT_PROP}`]: {$in: orgUnitIds}}
      ];
    }

    const stream = OshAction
      .find(conditions)
      .select({
        status: 1,
        createdAt: 1,
        creator: 1,
        implementers: 1,
        participants: 1,
        division: 1,
        workplace: 1,
        department: 1
      })
      .lean()
      .cursor();
    const next = _.once(done);

    stream.on('error', next);
    stream.on('end', next);
    stream.on('data', handleAction);
  }

  function handleObservations(done)
  {
    const conditions = {
      date: {
        $gte: moment(options.fromTime).utc(true).toDate()
      }
    };

    if (options.toTime > options.fromTime)
    {
      conditions.date.$lt = moment(options.toTime).utc(true).toDate();
    }

    if (orgUnitIds.length)
    {
      conditions.$or = [
        {
          [LOCATION_PROP]: {$in: orgUnitIds},
          [`creator.${ORG_UNIT_PROP}`]: {$in: orgUnitIds}
        }
      ];
    }

    const stream = OshObservation
      .find(conditions)
      .select({
        date: 1,
        creator: 1,
        division: 1,
        workplace: 1,
        department: 1
      })
      .lean()
      .cursor();
    const next = _.once(done);

    stream.on('error', next);
    stream.on('end', next);
    stream.on('data', handleObservation);
  }

  function matchUsersOrgUnit(user)
  {
    return !ORG_UNIT_PROP || orgUnitIds.includes(user[ORG_UNIT_PROP]);
  }

  function matchEntryLocation(entry)
  {
    return !LOCATION_PROP || orgUnitIds.includes(entry[LOCATION_PROP]);
  }

  function handleNearMiss(entry)
  {
    const key = util.createGroupKey(options.interval, moment.utc(entry.eventDate).local(true).toDate(), false);

    if (matchUsersOrgUnit(entry.creator))
    {
      const orgUnits = remapUserOrgUnits(entry.creator);

      getGroups(key, orgUnits).forEach(group =>
      {
        group.userCount.add(entry.creator.id);
      });
    }

    if (matchEntryLocation(entry))
    {
      getGroups(key, entry).forEach(group =>
      {
        group.nearMissCount += 1;
      });
    }
  }

  function handleKaizen(entry)
  {
    const key = util.createGroupKey(options.interval, entry.createdAt, false);

    entry.implementers.forEach(implementer =>
    {
      if (!matchUsersOrgUnit(implementer))
      {
        return;
      }

      const orgUnits = remapUserOrgUnits(implementer);

      getGroups(key, orgUnits).forEach(group =>
      {
        group.userCount.add(implementer.id);
      });
    });

    if (matchEntryLocation(entry))
    {
      getGroups(key, entry).forEach(group =>
      {
        group.kaizenCount += 1;
      });
    }
  }

  function handleAction(entry)
  {
    const key = util.createGroupKey(options.interval, entry.createdAt, false);

    let users = [];

    if (Array.isArray(entry.implementers))
    {
      users = users.concat(entry.implementers);
    }

    if (Array.isArray(entry.participants))
    {
      users = users.concat(entry.participants);
    }

    if (!entry.implementers && !entry.participants)
    {
      users.push(entry.creator);
    }

    users.forEach(user =>
    {
      if (!matchUsersOrgUnit(user))
      {
        return;
      }

      const orgUnits = remapUserOrgUnits(user);

      getGroups(key, orgUnits).forEach(group =>
      {
        group.userCount.add(user.id);
      });
    });

    if (matchEntryLocation(entry))
    {
      getGroups(key, entry).forEach(group =>
      {
        group.actionCount += 1;
      });
    }
  }

  function handleObservation(entry)
  {
    const key = util.createGroupKey(options.interval, moment.utc(entry.date).local(true).toDate(), false);

    if (matchUsersOrgUnit(entry.creator))
    {
      const orgUnits = remapUserOrgUnits(entry.creator);

      getGroups(key, orgUnits).forEach(group =>
      {
        group.userCount.add(entry.creator.id);
      });
    }

    if (matchEntryLocation(entry))
    {
      getGroups(key, entry).forEach(group =>
      {
        group.observationCount += 1;
      });
    }
  }
};
