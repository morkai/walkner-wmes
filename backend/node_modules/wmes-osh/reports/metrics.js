// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const moment = require('moment');
const step = require('h5.step');
const util = require('reports/util');

exports.models = [
  require('wmes-osh/models/oshAccident'),
  require('wmes-osh/models/oshNearMiss'),
  require('wmes-osh/models/oshKaizen'),
  require('wmes-osh/models/oshAction'),
  require('wmes-osh/models/oshObservation'),
  require('wmes-osh/models/oshEmployment'),
  require('settings/models/setting')
];

exports.report = (app, module, options, done) =>
{
  const {
    Setting,
    OshAccident,
    OshNearMiss,
    OshKaizen,
    OshAction,
    OshObservation,
    OshEmployment
  } = module;

  const results = {
    options,
    settings: {
      minEngagement: 70,
      minObsCards: 4,
      observersPerDepartment: 20,
      obsCardsPerDepartment: 80,
      minSafeObs: 85,
      maxSafeObs: 97
    },
    users: {},
    yearlyAccidents: [],
    groups: {}
  };

  const LOCATION_TO_USER_PROP = {
    division: 'oshDivision',
    workplace: 'oshWorkplace',
    department: 'oshDepartment'
  };
  const USER_ORG_UNIT_PROP = LOCATION_TO_USER_PROP[options.orgUnitType];
  const ENTRY_ORG_UNIT_PROP = options.orgUnitType;
  const MONTH_KEY = moment(options.toTime).subtract(1, 'months').valueOf();
  const FROM_TIME_LOCAL = moment(options.fromTime).subtract(12, 'months').valueOf();
  const FROM_TIME_UTC = moment(FROM_TIME_LOCAL).utc(true).valueOf();

  step(
    function()
    {
      const settingConditions = {
        _id: {$in: Object.keys(results.settings).map(s => `osh.${s}`)}
      };

      if (settingConditions._id.$in.length)
      {
        Setting
          .find(settingConditions)
          .select({value: 1})
          .lean()
          .exec(this.parallel());
      }
      else
      {
        setImmediate(this.parallel(), null, []);
      }

      OshEmployment
        .find({
          _id: {
            $gte: new Date(FROM_TIME_UTC),
            $lt: new Date(options.toTime)
          }
        })
        .lean()
        .exec(this.parallel());
    },
    function(err, settings, employments)
    {
      if (err)
      {
        return this.skip(err);
      }

      settings.forEach(setting =>
      {
        results.settings[setting._id.split('.').pop()] = setting.value;
      });

      employments.forEach(employment =>
      {
        handleFte(employment);
      });
    },
    function()
    {
      handleYearlyAccidents(this.group());
      handleAccidents(this.group());
      handleNearMisses(this.group());
      handleKaizens(this.group());
      handleActions(this.group());
      handleObservations(this.group());
    },
    function(err)
    {
      if (err)
      {
        return this.skip(err);
      }

      const lastGroupKey = MONTH_KEY;
      const createNextGroupKey = util.createCreateNextGroupKey(options.interval);
      const groups = [];
      let groupKey = options.fromTime;

      while (groupKey <= lastGroupKey)
      {
        const group = getGroup(groupKey);

        finalizeGroup(group);

        groups.push(group);

        groupKey = createNextGroupKey(groupKey);
      }

      results.groups = groups.filter(g => g.key >= options.fromTime);
    },
    function(err)
    {
      done(err, results);
    }
  );

  function createEmptyGroup(key)
  {
    return {
      key,
      ipr: {
        target: 15,
        itm: 0,
        mat: 0
      },
      ips: {
        target: 0,
        itm: 0
      },
      ipp: {
        target: results.settings.minEngagement,
        itm: 0,
        observers: 0,
        observersTarget: results.settings.observersPerDepartment
      },
      trc: {
        target: 0.35,
        itm: 0,
        mat: 0
      },
      contact: {
        target: 0,
        itm: 0
      },
      obs: {
        plan: 0,
        cards: 0,
        cardsPercent: 0,
        behaviors: 0,
        workConditions: 0,
        risky: 0,
        riskyPercent: 0,
        minRisky: 0,
        maxRisky: 100,
        observers: {},
        observerCount: new Set()
      },
      nearMissCount: 0,
      kaizenCount: 0,
      actionCount: 0,
      entryCount: 0,
      userCount: new Set(),
      fte: {
        itm: 0,
        avg: 0,
        observers: 0
      }
    };
  }

  function finalizeGroup(group)
  {
    let fte12 = 0;
    let trc12 = 0;
    let entryCount12 = 0;
    let months = 0;
    const month = moment(group.key);

    for (let i = 1; i <= 12; ++i)
    {
      const group = results.groups[month.valueOf()];

      if (group)
      {
        fte12 += group.fte.itm;
        trc12 += group.trc.itm;
        entryCount12 += group.nearMissCount + group.kaizenCount + group.actionCount + group.obs.cards;
        months += group.fte.itm || entryCount12 ? 1 : 0;
      }

      month.subtract(1, 'month');
    }

    group.userCount = group.userCount.size;
    group.entryCount = group.nearMissCount + group.kaizenCount + group.actionCount + group.obs.cards;

    group.fte.avg = util.round(fte12 / months);

    group.trc.mat = util.round(trc12 / group.fte.avg * 100);

    group.ipr.itm = util.round(group.entryCount * 12 / group.fte.itm);
    group.ipr.mat = util.round(entryCount12 / group.fte.avg);

    group.ips.itm = util.round(group.obs.cards / group.entryCount * 100);

    group.contact.target = util.round(results.settings.obsCardsPerDepartment / 100);
    group.contact.itm = util.round(group.obs.cards / group.fte.itm * 100);

    group.obs.observerCount = group.obs.observerCount.size;
    group.obs.plan = Math.round(group.fte.itm * (results.settings.obsCardsPerDepartment / 100));
    group.obs.cardsPercent = util.round(group.obs.cards / group.obs.plan * 100);
    group.obs.riskyPercent = util.round(group.obs.risky / (group.obs.behaviors + group.obs.workConditions) * 100);
    group.obs.minRisky = 100 - results.settings.maxSafeObs;
    group.obs.maxRisky = 100 - results.settings.minSafeObs;

    group.ipp.itm = util.round(group.userCount / group.fte.itm * 100);
    group.ipp.observers = util.round(group.obs.observerCount / group.fte.itm * 100);
  }

  function getGroup(key)
  {
    if (!results.groups[key])
    {
      results.groups[key] = createEmptyGroup(key);
    }

    return results.groups[key];
  }

  function handleFte(employment)
  {
    const month = employment._id.valueOf();
    const groupKey = util.createGroupKey(options.interval, moment.utc(month).local(true).toDate(), false);

    employment.departments.forEach(d =>
    {
      if (!d.total || !d.department)
      {
        return;
      }

      if (options.orgUnitId && options.orgUnitId !== d[ENTRY_ORG_UNIT_PROP])
      {
        return;
      }

      const group = getGroup(groupKey);

      group.fte.itm += d.total;
      group.fte.observers += d.observers;
    });
  }

  function handleYearlyAccidents(done)
  {
    const conditions = {};

    if (options.orgUnitId)
    {
      conditions[ENTRY_ORG_UNIT_PROP] = options.orgUnitId;
    }

    step(
      function()
      {
        OshAccident
          .aggregate([
            {$group: {
              _id: {$year: '$eventDate'},
              count: {$sum: 1}
            }}
          ])
          .exec(this.parallel());

        if (options.orgUnitId)
        {
          OshAccident
            .aggregate([
              {$match: {
                [ENTRY_ORG_UNIT_PROP]: options.orgUnitId
              }},
              {$group: {
                _id: {$year: '$eventDate'},
                count: {$sum: 1}
              }}
            ])
            .exec(this.parallel());
        }
      },
      function(err, totalResults, orgUnitResults)
      {
        if (err)
        {
          return this.skip(err);
        }

        const yearlyAccidents = {};

        totalResults.forEach(r =>
        {
          const key = moment(r._id.toString(), 'YYYY').valueOf();

          yearlyAccidents[key] = {
            year: r._id,
            total: r.count,
            orgUnit: 0
          };
        });

        (orgUnitResults || []).forEach(r =>
        {
          const key = moment(r._id.toString(), 'YYYY').valueOf();

          yearlyAccidents[key].orgUnit = r.count;
        });

        const keys = Object.keys(yearlyAccidents).map(k => +k).sort((a, b) => a - b);

        if (keys.length === 0)
        {
          return;
        }

        const year = moment(keys[0]);
        const last = keys[keys.length - 1];

        while (year.valueOf() <= last)
        {
          const key = year.valueOf();

          results.yearlyAccidents.push(yearlyAccidents[key] || {
            key,
            total: 0,
            orgUnit: 0
          });

          year.add(1, 'years');
        }
      },
      done
    );
  }

  function handleAccidents(done)
  {
    const conditions = {
      eventDate: {
        $gte: moment(options.fromTime).utc(true).toDate(),
        $lt: moment(options.toTime).utc(true).toDate()
      }
    };

    if (options.orgUnitId)
    {
      conditions[ENTRY_ORG_UNIT_PROP] = options.orgUnitId;
    }

    const stream = OshAccident
      .find(conditions)
      .select({
        eventDate: 1,
        division: 1,
        workplace: 1,
        department: 1
      })
      .lean()
      .cursor();
    const next = _.once(done);

    stream.on('error', next);
    stream.on('end', next);
    stream.on('data', handleAccident);
  }

  function handleNearMisses(done)
  {
    const conditions = {
      status: {$ne: 'cancelled'},
      eventDate: {
        $gte: moment(options.fromTime).utc(true).toDate(),
        $lt: moment(options.toTime).utc(true).toDate()
      }
    };

    if (options.orgUnitId)
    {
      conditions.$or = [
        {
          [ENTRY_ORG_UNIT_PROP]: options.orgUnitId,
          [`creator.${USER_ORG_UNIT_PROP}`]: options.orgUnitId
        }
      ];
    }

    const stream = OshNearMiss
      .find(conditions)
      .select({
        status: 1,
        eventDate: 1,
        creator: 1,
        division: 1,
        workplace: 1,
        department: 1
      })
      .lean()
      .cursor();
    const next = _.once(done);

    stream.on('error', next);
    stream.on('end', next);
    stream.on('data', handleNearMiss);
  }

  function handleKaizens(done)
  {
    const conditions = {
      status: {$ne: 'cancelled'},
      createdAt: {
        $gte: new Date(options.fromTime),
        $lt: new Date(options.toTime)
      }
    };

    if (options.orgUnitId)
    {
      conditions.$or = [
        {[ENTRY_ORG_UNIT_PROP]: options.orgUnitId},
        {[`implementers.${USER_ORG_UNIT_PROP}`]: options.orgUnitId}
      ];
    }

    const stream = OshKaizen
      .find(conditions)
      .select({
        status: 1,
        createdAt: 1,
        implementers: 1,
        division: 1,
        workplace: 1,
        department: 1
      })
      .lean()
      .cursor();
    const next = _.once(done);

    stream.on('error', next);
    stream.on('end', next);
    stream.on('data', handleKaizen);
  }

  function handleActions(done)
  {
    const conditions = {
      status: {$ne: 'cancelled'},
      createdAt: {
        $gte: new Date(options.fromTime),
        $lt: new Date(options.toTime)
      }
    };

    if (options.orgUnitId)
    {
      conditions.$or = [
        {[ENTRY_ORG_UNIT_PROP]: options.orgUnitId},
        {[`creator.${USER_ORG_UNIT_PROP}`]: options.orgUnitId},
        {[`implementers.${USER_ORG_UNIT_PROP}`]: options.orgUnitId},
        {[`participants.${USER_ORG_UNIT_PROP}`]: options.orgUnitId}
      ];
    }

    const stream = OshAction
      .find(conditions)
      .select({
        status: 1,
        createdAt: 1,
        creator: 1,
        implementers: 1,
        participants: 1,
        division: 1,
        workplace: 1,
        department: 1
      })
      .lean()
      .cursor();
    const next = _.once(done);

    stream.on('error', next);
    stream.on('end', next);
    stream.on('data', handleAction);
  }

  function handleObservations(done)
  {
    const conditions = {
      date: {
        $gte: moment(options.fromTime).utc(true).toDate(),
        $lt: moment(options.toTime).utc(true).toDate()
      }
    };

    if (options.orgUnitId)
    {
      conditions.$or = [
        {
          [ENTRY_ORG_UNIT_PROP]: options.orgUnitId,
          [`creator.${USER_ORG_UNIT_PROP}`]: options.orgUnitId
        }
      ];
    }

    const stream = OshObservation
      .find(conditions)
      .select({
        date: 1,
        creator: 1,
        division: 1,
        workplace: 1,
        department: 1,
        behaviors: 1,
        workConditions: 1
      })
      .lean()
      .cursor();
    const next = _.once(done);

    stream.on('error', next);
    stream.on('end', next);
    stream.on('data', handleObservation);
  }

  function matchUsersOrgUnit(user)
  {
    return !USER_ORG_UNIT_PROP || user[USER_ORG_UNIT_PROP] === options.orgUnitId;
  }

  function matchEntryOrgUnit(entry)
  {
    return !ENTRY_ORG_UNIT_PROP || entry[ENTRY_ORG_UNIT_PROP] === options.orgUnitId;
  }

  function handleAccident(entry)
  {
    const key = util.createGroupKey(options.interval, moment.utc(entry.eventDate).local(true).toDate(), false);

    const group = getGroup(key);

    group.trc.itm += 1;
  }

  function handleNearMiss(entry)
  {
    const key = util.createGroupKey(options.interval, moment.utc(entry.eventDate).local(true).toDate(), false);

    if (matchUsersOrgUnit(entry.creator))
    {
      const group = getGroup(key);

      group.userCount.add(entry.creator.id);
    }

    if (matchEntryOrgUnit(entry))
    {
      const group = getGroup(key);

      group.nearMissCount += 1;
    }
  }

  function handleKaizen(entry)
  {
    const key = util.createGroupKey(options.interval, entry.createdAt, false);

    entry.implementers.forEach(implementer =>
    {
      if (!matchUsersOrgUnit(implementer))
      {
        return;
      }

      const group = getGroup(key);

      group.userCount.add(implementer.id);
    });

    if (matchEntryOrgUnit(entry))
    {
      const group = getGroup(key);

      group.kaizenCount += 1;
    }
  }

  function handleAction(entry)
  {
    const key = util.createGroupKey(options.interval, entry.createdAt, false);

    let users = [];

    if (Array.isArray(entry.implementers))
    {
      users = users.concat(entry.implementers);
    }

    if (Array.isArray(entry.participants))
    {
      users = users.concat(entry.participants);
    }

    if (!entry.implementers && !entry.participants)
    {
      users.push(entry.creator);
    }

    users.forEach(user =>
    {
      if (!matchUsersOrgUnit(user))
      {
        return;
      }

      const group = getGroup(key);

      group.userCount.add(user.id);
    });

    if (matchEntryOrgUnit(entry))
    {
      const group = getGroup(key);

      group.actionCount += 1;
    }
  }

  function handleObservation(entry)
  {
    const key = util.createGroupKey(options.interval, moment.utc(entry.date).local(true).toDate(), false);

    if (matchUsersOrgUnit(entry.creator))
    {
      const group = getGroup(key);

      group.userCount.add(entry.creator.id);
      group.obs.observerCount.add(entry.creator.id);
    }

    if (matchEntryOrgUnit(entry))
    {
      const group = getGroup(key);

      group.obs.cards += 1;
      group.obs.behaviors += entry.behaviors.length;
      group.obs.workConditions += entry.workConditions.length;

      entry.behaviors.forEach(o =>
      {
        if (!o.safe)
        {
          group.obs.risky += 1;
        }
      });

      entry.workConditions.forEach(o =>
      {
        if (!o.safe)
        {
          group.obs.risky += 1;
        }
      });

      if (key === MONTH_KEY)
      {
        results.users[entry.creator.id] = entry.creator.label;

        if (!group.obs.observers[entry.creator.id])
        {
          group.obs.observers[entry.creator.id] = 1;
        }
        else
        {
          group.obs.observers[entry.creator.id] += 1;
        }
      }
    }
  }
};
