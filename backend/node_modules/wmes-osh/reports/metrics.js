// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const fs = require('fs');
const _ = require('lodash');
const moment = require('moment');
const step = require('h5.step');
const util = require('reports/util');

let history = null;
let historyWatcher = null;

exports.models = [
  require('wmes-osh/models/oshAccident'),
  require('wmes-osh/models/oshNearMiss'),
  require('wmes-osh/models/oshKaizen'),
  require('wmes-osh/models/oshAction'),
  require('wmes-osh/models/oshObservation'),
  require('wmes-osh/models/oshTarget'),
  require('wmes-osh/models/oshEmployment'),
  require('settings/models/setting')
];

exports.report = (app, module, options, done) =>
{
  const {
    Setting,
    OshAccident,
    OshNearMiss,
    OshKaizen,
    OshAction,
    OshObservation,
    OshTarget,
    OshEmployment
  } = module;

  if (!history)
  {
    loadHistory(module.config.metricsHistoryPath, module.logger.create({submodule: 'osh/metrics'}));
  }

  const results = {
    options,
    settings: {},
    users: {},
    yearlyAccidents: [],
    groups: {}
  };

  const LOCATION_TO_USER_PROP = {
    division: 'oshDivision',
    workplace: 'oshWorkplace',
    department: 'oshDepartment'
  };
  const USER_ORG_UNIT_PROP = LOCATION_TO_USER_PROP[options.orgUnitType];
  const ENTRY_ORG_UNIT_PROP = options.orgUnitType;
  const MONTH_KEY = moment(options.toTime).subtract(1, 'months').valueOf();
  const FROM_TIME_LOCAL = moment(options.fromTime).subtract(12, 'months').valueOf();
  const FROM_TIME_UTC = moment(FROM_TIME_LOCAL).utc(true).valueOf();

  step(
    function()
    {
      const settingConditions = {
        _id: {$in: Object.keys(results.settings).map(s => `osh.${s}`)}
      };

      if (settingConditions._id.$in.length)
      {
        Setting
          .find(settingConditions)
          .select({value: 1})
          .lean()
          .exec(this.parallel());
      }
      else
      {
        setImmediate(this.parallel(), null, []);
      }

      OshTarget
        .find({
          _id: {
            $gte: moment(options.fromTime).utc(true).toDate(),
            $lt: moment(options.toTime).utc(true).toDate()
          }
        })
        .lean()
        .exec(this.parallel());

      OshEmployment
        .find({
          _id: {
            $gte: new Date(FROM_TIME_UTC),
            $lt: new Date(options.toTime)
          }
        })
        .lean()
        .exec(this.parallel());
    },
    function(err, settings, targets, employments)
    {
      if (err)
      {
        return this.skip(err);
      }

      settings.forEach(setting =>
      {
        results.settings[setting._id.split('.').pop()] = setting.value;
      });

      targets.forEach(target =>
      {
        handleTarget(target);
      });

      employments.forEach(employment =>
      {
        handleEmployment(employment);
      });
    },
    function()
    {
      handleYearlyAccidents(this.group());
      handleAccidents(this.group());
      handleNearMisses(this.group());
      handleKaizens(this.group());
      handleActions(this.group());
      handleObservations(this.group());
    },
    function(err)
    {
      if (err)
      {
        return this.skip(err);
      }

      const createNextGroupKey = util.createCreateNextGroupKey(options.interval);
      const lastGroupKey = MONTH_KEY;

      const historicData = options.orgUnitId
        ? history[options.orgUnitType].get(options.orgUnitId)
        : history.division.get(0);

      if (historicData)
      {
        let groupKey = FROM_TIME_LOCAL;

        while (groupKey <= lastGroupKey)
        {
          const monthlyMetrics = historicData.monthlyMetrics[groupKey];

          if (monthlyMetrics)
          {
            results.groups[groupKey] = createHistoricGroup(groupKey, monthlyMetrics);
          }

          groupKey = createNextGroupKey(groupKey);
        }
      }

      const groups = [];
      let groupKey = options.fromTime;

      while (groupKey <= lastGroupKey)
      {
        const group = getGroup(groupKey);

        finalizeGroup(group);

        groups.push(group);

        groupKey = createNextGroupKey(groupKey);
      }

      results.groups = groups.filter(g => g.key >= options.fromTime);
    },
    function(err)
    {
      done(err, results);
    }
  );

  function createEmptyGroup(key)
  {
    return {
      key,
      historic: false,
      ipr: {
        target: 0,
        itm: -1,
        mat: -1
      },
      ips: {
        target: 0,
        itm: -1
      },
      ipp: {
        target: 0,
        itm: -1,
        observers: -1,
        observersTarget: 0
      },
      trc: {
        target: 0,
        itm: 0,
        mat: -1
      },
      contact: {
        target: 0,
        itm: -1
      },
      obs: {
        plan: -1,
        cards: 0,
        cardsPercent: -1,
        behaviors: 0,
        workConditions: 0,
        risky: 0,
        riskyPercent: -1,
        minRisky: 0,
        maxRisky: 0,
        observers: {},
        observerCount: new Set(),
        minCardsPerObservers: 0
      },
      nearMissCount: 0,
      kaizenCount: 0,
      actionCount: 0,
      entryCount: 0,
      userCount: new Set(),
      fte: {
        itm: 0,
        avg: 0,
        observers: 0
      }
    };
  }

  function createHistoricGroup(key, historic)
  {
    const group = createEmptyGroup(key);

    group.historic = true;
    group.fte.itm = historic.FTE_ITM || 0;
    group.userCount = historic.FTE_ACTIVE || 0;
    group.fte.observers = historic.OBSERVERS_ITM || 0;
    group.obs.observerCount = historic.OBSERVERS_ACTIVE || 0;
    group.ipp.target = historic.IPP_PARTICIPATION_TARGET || 0;
    group.ipp.itm = historic.IPP_OBSERVERS_RATE || 0;
    group.ipp.observersTarget = historic.IPP_OBSERVERS_TARGET || 0;
    group.ipp.observers = historic.IPP_OBSERVERS_RATE || 0;
    group.trc.itm = historic.TRC_ITM || 0;
    group.trc.target = historic.TRC_TARGET || 0;
    group.trc.mat = historic.TRC_MAT || 0;
    group.nearMissCount = historic.NEAR_MISSES || 0;
    group.obs.cards = historic.OBSERVATIONS || 0;
    group.actionCount = historic.ACTIONS || 0;
    group.kaizenCount = historic.KAIZENS || 0;
    group.ipr.target = historic.IPR_TARGET || 0;
    group.ipr.itm = historic.IPR_VPM || 0;
    group.ipr.mat = historic.IPR_MAT || 0;
    group.obs.plan = historic.OBSERVATIONS_PLAN || 0;
    group.obs.cardsPercent = (historic.OBSERVATIONS_ACTUAL || 0) / group.obs.plan;
    group.contact.target = historic.CONTACT_TARGET || 0;
    group.contact.itm = historic.CONTACT_ITM || 0;
    group.obs.behaviors = historic.OBS_BEHAVIORS || 0;
    group.obs.workConditions = historic.OBS_WORK_CONDITIONS || 0;
    group.obs.risky = historic.OBS_RISKY || 0;
    group.obs.minRisky = historic.OBS_RISKY_MIN || 0;
    group.obs.maxRisky = historic.OBS_RISKY_MAX || 0;
    group.obs.riskyPercent = historic.OBS_RISKY_ITM || 0;

    return group;
  }

  function finalizeGroup(group)
  {
    let fte12 = 0;
    let trc12 = 0;
    let entryCount12 = 0;
    let months = 0;
    const month = moment(group.key);

    for (let i = 1; i <= 12; ++i)
    {
      const group = results.groups[month.valueOf()];

      if (group)
      {
        fte12 += group.fte.itm;
        trc12 += group.trc.itm;
        entryCount12 += group.nearMissCount + group.kaizenCount + group.actionCount + group.obs.cards;
        months += group.fte.itm || entryCount12 ? 1 : 0;
      }

      month.subtract(1, 'month');
    }

    if (group.userCount instanceof Set)
    {
      group.userCount = group.userCount.size;
    }
    else
    {
      group.userCount = util.round(group.userCount, 1);
    }

    group.entryCount = group.nearMissCount + group.kaizenCount + group.actionCount + group.obs.cards;

    group.fte.avg = util.round(fte12 / months);
    group.fte.itm = util.round(group.fte.itm, 1);
    group.fte.observers = util.round(group.fte.observers, 1);

    group.trc.target = util.round(group.trc.target, 2);

    if (group.trc.mat === -1)
    {
      group.trc.mat = trc12 / group.fte.avg * 100;
    }

    group.trc.mat = util.round(group.trc.mat, 2);

    if (group.ipr.itm === -1)
    {
      group.ipr.itm = group.entryCount * 12 / group.fte.itm;
    }

    group.ipr.itm = util.round(group.ipr.itm, 2);

    if (group.ipr.mat === -1)
    {
      group.ipr.mat = entryCount12 / group.fte.avg;
    }

    group.ipr.mat = util.round(group.ipr.mat, 2);

    if (group.ips.itm === -1)
    {
      group.ips.itm = group.obs.cards / group.entryCount * 100;
    }

    group.ips.itm = util.round(group.ips.itm, 1);

    group.contact.target = util.round(group.contact.target, 3);

    if (group.contact.itm === -1)
    {
      group.contact.itm = group.obs.cards / group.fte.itm;
    }

    group.contact.itm = util.round(group.contact.itm, 3);

    if (group.obs.observerCount instanceof Set)
    {
      group.obs.observerCount = group.obs.observerCount.size;
    }
    else
    {
      group.obs.observerCount = util.round(group.obs.observerCount, 1);
    }

    if (group.obs.plan === -1)
    {
      group.obs.plan = group.fte.itm * group.contact.target;
    }

    group.obs.plan = util.round(group.obs.plan, 1);

    if (group.obs.cardsPercent === -1)
    {
      group.obs.cardsPercent = group.obs.cards / group.obs.plan * 100;
    }

    group.obs.cardsPercent = util.round(group.obs.cardsPercent, 1);

    if (group.obs.riskyPercent === -1)
    {
      group.obs.riskyPercent = group.obs.risky / (group.obs.behaviors + group.obs.workConditions) * 100;
    }

    group.obs.riskyPercent = util.round(group.obs.riskyPercent, 1);

    if (group.ipp.itm === -1)
    {
      group.ipp.itm = group.userCount / group.fte.itm * 100;
    }

    group.ipp.itm = util.round(group.ipp.itm, 2);

    if (group.ipp.observers === -1)
    {
      group.ipp.observers = group.obs.observerCount / group.fte.itm * 100;
    }

    group.ipp.observers = util.round(group.ipp.observers, 2);
  }

  function getGroup(key)
  {
    if (!results.groups[key])
    {
      results.groups[key] = createEmptyGroup(key);
    }

    return results.groups[key];
  }

  function handleTarget(target)
  {
    const month = target._id.valueOf();
    const groupKey = util.createGroupKey(options.interval, moment.utc(month).local(true).toDate(), false);

    const required = {
      division: null,
      workplace: null,
      department: null
    };

    switch (options.orgUnitType)
    {
      case 'division':
        required.division = options.orgUnitId;
        required.workplace = 0;
        required.department = 0;
        break;

      case 'workplace':
        required.workplace = options.orgUnitId;
        required.department = 0;
        break;

      case 'department':
        required.department = options.orgUnitId;
        break;

      default:
        required.division = 0;
        required.workplace = 0;
        required.department = 0;
        break;
    }

    const orgUnit = target.orgUnits.find(ou =>
    {
      return (required.division === null || ou.division === required.division)
        && (required.workplace === null || ou.workplace === required.workplace)
        && (required.department === null || ou.department === required.department);
    });

    if (!orgUnit)
    {
      return;
    }

    const {targets} = orgUnit;
    const group = getGroup(groupKey);

    group.targets = targets;
    group.ipp.target = targets.minActiveUsers || 0;
    group.ipp.observersTarget = targets.minObservers || 0;
    group.trc.target = targets.trc || 0;
    group.ipr.target = targets.ipr || 0;
    group.contact.target = targets.contact || 0;
    group.obs.minRisky = 100 - (targets.maxSafeObs || 0);
    group.obs.maxRisky = 100 - (targets.minSafeObs || 0);
    group.obs.minCardsPerObservers = targets.minObsCardsPerObserver;
  }

  function handleEmployment(employment)
  {
    const month = employment._id.valueOf();
    const groupKey = util.createGroupKey(options.interval, moment.utc(month).local(true).toDate(), false);

    employment.departments.forEach(d =>
    {
      if (!d.total || !d.department)
      {
        return;
      }

      if (options.orgUnitId && options.orgUnitId !== d[ENTRY_ORG_UNIT_PROP])
      {
        return;
      }

      const group = getGroup(groupKey);

      group.fte.itm += d.total;
      group.fte.observers += d.observers;

      if (groupKey === MONTH_KEY)
      {
        d.observerUsers.forEach(u =>
        {
          results.users[u.id] = u.label;
          group.obs.observers[u.id] = 0;
        });
      }
    });
  }

  function handleYearlyAccidents(done)
  {
    const conditions = {};

    if (options.orgUnitId)
    {
      conditions[ENTRY_ORG_UNIT_PROP] = options.orgUnitId;
    }

    step(
      function()
      {
        OshAccident
          .aggregate([
            {$group: {
              _id: {$year: '$eventDate'},
              count: {$sum: 1}
            }}
          ])
          .exec(this.parallel());

        if (options.orgUnitId)
        {
          OshAccident
            .aggregate([
              {$match: {
                [ENTRY_ORG_UNIT_PROP]: options.orgUnitId
              }},
              {$group: {
                _id: {$year: '$eventDate'},
                count: {$sum: 1}
              }}
            ])
            .exec(this.parallel());
        }
      },
      function(err, totalResults, orgUnitResults)
      {
        if (err)
        {
          return this.skip(err);
        }

        const totalHistory = history.division.get(0);

        if (totalHistory)
        {
          const orgUnitHistory = options.orgUnitId && history[options.orgUnitType].get(options.orgUnitId);

          Object.keys(totalHistory.yearlyAccidents).forEach(year =>
          {
            totalResults.push({
              _id: +year,
              count: totalHistory.yearlyAccidents[year]
            });

            if (orgUnitHistory)
            {
              const count = orgUnitHistory.yearlyAccidents[year];

              if (count >= 0)
              {
                orgUnitResults.push({
                  _id: +year,
                  count
                });
              }
            }
          });
        }

        const yearlyAccidents = {};

        totalResults.forEach(r =>
        {
          const key = moment(r._id.toString(), 'YYYY').valueOf();

          yearlyAccidents[key] = {
            year: r._id,
            total: r.count,
            orgUnit: 0
          };
        });

        (orgUnitResults || []).forEach(r =>
        {
          const key = moment(r._id.toString(), 'YYYY').valueOf();

          yearlyAccidents[key].orgUnit = r.count;
        });

        const keys = Object.keys(yearlyAccidents).map(k => +k).sort((a, b) => a - b);

        if (keys.length === 0)
        {
          return;
        }

        const year = moment(keys[0]);
        const last = keys[keys.length - 1];

        while (year.valueOf() <= last)
        {
          const key = year.valueOf();

          results.yearlyAccidents.push(yearlyAccidents[key] || {
            key,
            total: 0,
            orgUnit: 0
          });

          year.add(1, 'years');
        }
      },
      done
    );
  }

  function handleAccidents(done)
  {
    const conditions = {
      eventDate: {
        $gte: moment(options.fromTime).utc(true).toDate(),
        $lt: moment(options.toTime).utc(true).toDate()
      }
    };

    if (options.orgUnitId)
    {
      conditions[ENTRY_ORG_UNIT_PROP] = options.orgUnitId;
    }

    const stream = OshAccident
      .find(conditions)
      .select({
        eventDate: 1,
        division: 1,
        workplace: 1,
        department: 1
      })
      .lean()
      .cursor();
    const next = _.once(done);

    stream.on('error', next);
    stream.on('end', next);
    stream.on('data', handleAccident);
  }

  function handleNearMisses(done)
  {
    const conditions = {
      status: {$ne: 'cancelled'},
      eventDate: {
        $gte: moment(options.fromTime).utc(true).toDate(),
        $lt: moment(options.toTime).utc(true).toDate()
      }
    };

    if (options.orgUnitId)
    {
      conditions.$or = [
        {
          [ENTRY_ORG_UNIT_PROP]: options.orgUnitId,
          [`creator.${USER_ORG_UNIT_PROP}`]: options.orgUnitId
        }
      ];
    }

    const stream = OshNearMiss
      .find(conditions)
      .select({
        status: 1,
        eventDate: 1,
        creator: 1,
        division: 1,
        workplace: 1,
        department: 1
      })
      .lean()
      .cursor();
    const next = _.once(done);

    stream.on('error', next);
    stream.on('end', next);
    stream.on('data', handleNearMiss);
  }

  function handleKaizens(done)
  {
    const conditions = {
      status: {$ne: 'cancelled'},
      createdAt: {
        $gte: new Date(options.fromTime),
        $lt: new Date(options.toTime)
      }
    };

    if (options.orgUnitId)
    {
      conditions.$or = [
        {[ENTRY_ORG_UNIT_PROP]: options.orgUnitId},
        {[`implementers.${USER_ORG_UNIT_PROP}`]: options.orgUnitId}
      ];
    }

    const stream = OshKaizen
      .find(conditions)
      .select({
        status: 1,
        createdAt: 1,
        implementers: 1,
        division: 1,
        workplace: 1,
        department: 1
      })
      .lean()
      .cursor();
    const next = _.once(done);

    stream.on('error', next);
    stream.on('end', next);
    stream.on('data', handleKaizen);
  }

  function handleActions(done)
  {
    const conditions = {
      status: {$ne: 'cancelled'},
      createdAt: {
        $gte: new Date(options.fromTime),
        $lt: new Date(options.toTime)
      }
    };

    if (options.orgUnitId)
    {
      conditions.$or = [
        {[ENTRY_ORG_UNIT_PROP]: options.orgUnitId},
        {[`creator.${USER_ORG_UNIT_PROP}`]: options.orgUnitId},
        {[`implementers.${USER_ORG_UNIT_PROP}`]: options.orgUnitId},
        {[`participants.${USER_ORG_UNIT_PROP}`]: options.orgUnitId}
      ];
    }

    const stream = OshAction
      .find(conditions)
      .select({
        status: 1,
        createdAt: 1,
        creator: 1,
        implementers: 1,
        participants: 1,
        division: 1,
        workplace: 1,
        department: 1
      })
      .lean()
      .cursor();
    const next = _.once(done);

    stream.on('error', next);
    stream.on('end', next);
    stream.on('data', handleAction);
  }

  function handleObservations(done)
  {
    const conditions = {
      date: {
        $gte: moment(options.fromTime).utc(true).toDate(),
        $lt: moment(options.toTime).utc(true).toDate()
      }
    };

    if (options.orgUnitId)
    {
      conditions.$or = [
        {
          [ENTRY_ORG_UNIT_PROP]: options.orgUnitId,
          [`creator.${USER_ORG_UNIT_PROP}`]: options.orgUnitId
        }
      ];
    }

    const stream = OshObservation
      .find(conditions)
      .select({
        date: 1,
        creator: 1,
        division: 1,
        workplace: 1,
        department: 1,
        behaviors: 1,
        workConditions: 1
      })
      .lean()
      .cursor();
    const next = _.once(done);

    stream.on('error', next);
    stream.on('end', next);
    stream.on('data', handleObservation);
  }

  function matchUsersOrgUnit(user)
  {
    return !USER_ORG_UNIT_PROP || user[USER_ORG_UNIT_PROP] === options.orgUnitId;
  }

  function matchEntryOrgUnit(entry)
  {
    return !ENTRY_ORG_UNIT_PROP || entry[ENTRY_ORG_UNIT_PROP] === options.orgUnitId;
  }

  function handleAccident(entry)
  {
    const key = util.createGroupKey(options.interval, moment.utc(entry.eventDate).local(true).toDate(), false);

    const group = getGroup(key);

    group.trc.itm += 1;
  }

  function handleNearMiss(entry)
  {
    const key = util.createGroupKey(options.interval, moment.utc(entry.eventDate).local(true).toDate(), false);

    if (matchUsersOrgUnit(entry.creator))
    {
      const group = getGroup(key);

      group.userCount.add(entry.creator.id);
    }

    if (matchEntryOrgUnit(entry))
    {
      const group = getGroup(key);

      group.nearMissCount += 1;
    }
  }

  function handleKaizen(entry)
  {
    const key = util.createGroupKey(options.interval, entry.createdAt, false);

    entry.implementers.forEach(implementer =>
    {
      if (!matchUsersOrgUnit(implementer))
      {
        return;
      }

      const group = getGroup(key);

      group.userCount.add(implementer.id);
    });

    if (matchEntryOrgUnit(entry))
    {
      const group = getGroup(key);

      group.kaizenCount += 1;
    }
  }

  function handleAction(entry)
  {
    const key = util.createGroupKey(options.interval, entry.createdAt, false);

    let users = [];

    if (Array.isArray(entry.implementers))
    {
      users = users.concat(entry.implementers);
    }

    if (Array.isArray(entry.participants))
    {
      users = users.concat(entry.participants);
    }

    if (!entry.implementers && !entry.participants)
    {
      users.push(entry.creator);
    }

    users.forEach(user =>
    {
      if (!matchUsersOrgUnit(user))
      {
        return;
      }

      const group = getGroup(key);

      group.userCount.add(user.id);
    });

    if (matchEntryOrgUnit(entry))
    {
      const group = getGroup(key);

      group.actionCount += 1;
    }
  }

  function handleObservation(entry)
  {
    const key = util.createGroupKey(options.interval, moment.utc(entry.date).local(true).toDate(), false);

    if (matchUsersOrgUnit(entry.creator))
    {
      const group = getGroup(key);

      group.userCount.add(entry.creator.id);
      group.obs.observerCount.add(entry.creator.id);
    }

    if (matchEntryOrgUnit(entry))
    {
      const group = getGroup(key);

      group.obs.cards += 1;
      group.obs.behaviors += entry.behaviors.length;
      group.obs.workConditions += entry.workConditions.length;

      entry.behaviors.forEach(o =>
      {
        if (!o.safe)
        {
          group.obs.risky += 1;
        }
      });

      entry.workConditions.forEach(o =>
      {
        if (!o.safe)
        {
          group.obs.risky += 1;
        }
      });

      if (key === MONTH_KEY)
      {
        results.users[entry.creator.id] = entry.creator.label;

        if (!group.obs.observers[entry.creator.id])
        {
          group.obs.observers[entry.creator.id] = 1;
        }
        else
        {
          group.obs.observers[entry.creator.id] += 1;
        }
      }
    }
  }
};

function loadHistory(historyPath, logger)
{
  history = {
    division: new Map(),
    workplace: new Map(),
    department: new Map()
  };

  if (!historyPath)
  {
    logger.info('Not loading the OSH metrics history: no file path.');

    return;
  }

  if (!historyWatcher)
  {
    setUpHistoryWatcher(historyPath, logger);
  }

  let rows = [];

  try
  {
    rows = fs.readFileSync(historyPath, 'utf8')
      .split('\n')
      .map(row => row.trim().split(';'))
      .filter(cells => cells.length >= 3);
  }
  catch (err) {} // eslint-disable-line

  let columns = null;

  while (rows.length)
  {
    columns = {
      orgUnit: -1,
      metric: -1,
      months: []
    };

    const row = rows.shift();

    row.forEach((cell, cellI) => // eslint-disable-line no-loop-func
    {
      if (/^org unit/i.test(cell))
      {
        columns.orgUnit = cellI;
      }
      else if (/^metric/i.test(cell))
      {
        columns.metric = cellI;
      }
      else if (/^[0-9]{4}-[0-9]{2}$/.test(cell))
      {
        columns.months.push({
          month: cell,
          index: cellI,
          time: moment(cell, 'YYYY-MM').valueOf()
        });
      }
    });

    if (columns.orgUnit !== -1
      && columns.metric !== -1
      && columns.months.length)
    {
      break;
    }

    columns = null;
  }

  if (!columns)
  {
    logger.warn('Not loading the OSH metrics history: invalid file structure.');

    return;
  }

  const orgUnitTypes = Object.keys(history);
  let orgUnit = null;

  rows.forEach(row =>
  {
    const metric = row[columns.metric];

    if (!metric)
    {
      return;
    }

    let orgUnitType = '';
    let orgUnitId = -1;

    orgUnitTypes.forEach(type =>
    {
      const match = (row[columns.orgUnit] || '').match(new RegExp(`${type}=([0-9]+)`));

      if (match)
      {
        orgUnitType = type;
        orgUnitId = +match[1];
      }
    });

    if (orgUnitId !== -1)
    {
      if (!history[orgUnitType].has(orgUnitId))
      {
        history[orgUnitType].set(orgUnitId, {
          orgUnitType,
          orgUnitId,
          yearlyAccidents: {},
          monthlyMetrics: {}
        });
      }

      orgUnit = history[orgUnitType].get(orgUnitId);
    }

    if (!orgUnit)
    {
      return;
    }

    const {yearlyAccidents, monthlyMetrics} = orgUnit;

    if (metric === 'YEARLY_ACCIDENTS')
    {
      columns.months.forEach(column =>
      {
        for (const matches of (row[column.index] || '').matchAll(/([0-9]+)=([0-9]+)/g))
        {
          yearlyAccidents[matches[1]] = +matches[2];
        }
      });

      return;
    }

    columns.months.forEach(column =>
    {
      if (!monthlyMetrics[column.time])
      {
        monthlyMetrics[column.time] = {};
      }

      const monthsMetrics = monthlyMetrics[column.time];
      const value = parseFloat((row[column.index] || '').replace(',', '.'));

      monthsMetrics[metric] = isNaN(value) || !isFinite(value) ? null : value;
    });
  });

  logger.info('Loaded the OSH metrics history.');
}

function setUpHistoryWatcher(historyPath, logger)
{
  historyWatcher = fs.watch(historyPath);

  historyWatcher.on('error', err =>
  {
    logger.error(err, 'Failed to watch history file.', {historyPath});
  });

  historyWatcher.on('close', () =>
  {
    clearTimeout(loadHistory.timer);
    loadHistory.timer = setTimeout(() =>
    {
      historyWatcher = null;
      loadHistory(historyPath, logger);
    }, 10000);
  });

  historyWatcher.on('change', () =>
  {
    clearTimeout(loadHistory.timer);
    loadHistory.timer = setTimeout(loadHistory, 5000, historyPath, logger);
  });
}
