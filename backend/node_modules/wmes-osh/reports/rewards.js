// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');
const moment = require('moment');

exports.models = [
  require('wmes-osh/models/oshBrigade'),
  require('wmes-osh/models/oshReward'),
  require('settings/models/setting')
];

exports.report = (app, module, options, done) =>
{
  const {
    Setting,
    OshBrigade,
    OshReward
  } = module;

  options.orgUnitType = null;
  options.orgUnitIds = [];
  options.leader = null;
  options.employee = null;
  options.status = null;
  options.paidAt = null;

  options.conditions.forEach(term =>
  {
    const cond = term.name;
    const prop = term.args[0];
    const value = term.args[1];

    if (cond === 'eq'
      && (prop === 'paidAt' || prop === 'leader' || prop === 'employee' || prop === 'status'))
    {
      options[prop] = value;

      return;
    }

    if ((cond === 'eq' || cond === 'in')
      && (prop === 'division' || prop === 'workplace' || prop === 'department'))
    {
      options.orgUnitType = prop;
      options.orgUnitIds = term.name === 'eq' ? [value] : value;

      return;
    }
  });

  delete options.conditions;

  const results = {
    options,
    settings: {
      minPayout: 50
    },
    users: {}
  };

  const LOCATION_TO_USER_PROP = {
    division: 'oshDivision',
    workplace: 'oshWorkplace',
    department: 'oshDepartment'
  };
  const USER_ORG_UNIT_PROP = LOCATION_TO_USER_PROP[options.orgUnitType];

  const brigadeMembers = new Set();

  step(
    function()
    {
      Setting.findValues('osh.rewards.', this.parallel());

      findLatestBrigade(this.parallel());
    },
    function(err, settings)
    {
      if (err)
      {
        return this.skip(err);
      }

      Object.assign(results.settings, settings);
    },
    function()
    {
      handleRewards(this.next());
    },
    function(err)
    {
      if (err)
      {
        return this.skip(err);
      }

      results.users = Object.values(results.users).sort(
        (a, b) => a.recipient.label.localeCompare(b.recipient.label, undefined, {sensitivity: 'base'})
      );

      if (options.status === 'payout')
      {
        results.users = results.users.filter(u => u.payout[1] >= results.settings.minPayout);
      }
    },
    function(err)
    {
      done(err, results);
    }
  );

  function findLatestBrigade(done)
  {
    if (!options.leader)
    {
      return done();
    }

    OshBrigade
      .findOne({
        'leader.id': options.leader
      })
      .sort({
        'leader.id': 1,
        date: -1
      })
      .lean()
      .exec((err, brigade) =>
      {
        if (err)
        {
          return done(err);
        }

        if (brigade)
        {
          brigadeMembers.add(brigade.leader.id);

          brigade.members.forEach(member => brigadeMembers.add(member.id));
        }

        done();
      });
  }

  function handleRewards(done)
  {
    const conditions = {};

    if (options.paidAt)
    {
      const month = moment(options.paidAt, 'YYYY-MM');

      conditions.paidAt = {
        $gte: month.toDate(),
        $lt: month.clone().add(1, 'months').toDate()
      };
    }

    if (options.status === 'paid')
    {
      conditions.paid = true;
    }
    else if (options.status === 'unpaid' || options.status === 'payout')
    {
      conditions.paid = false;
    }

    if (options.orgUnitIds.length)
    {
      conditions[`recipient.${USER_ORG_UNIT_PROP}`] = {$in: options.orgUnitIds};
    }

    if (options.leader)
    {
      conditions['recipient.id'] = {$in: Array.from(brigadeMembers)};
    }

    if (options.employee)
    {
      conditions['recipient.id'] = options.employee;
    }

    const stream = OshReward
      .find(conditions)
      .select({
        rid: 1,
        createdAt: 1,
        recipient: 1,
        amount: 1,
        paid: 1,
        paidAt: 1
      })
      .lean()
      .cursor();
    const next = _.once(done);

    stream.on('error', next);
    stream.on('end', next);
    stream.on('data', handleReward);
  }

  function handleReward(reward)
  {
    if (!results.users[reward.recipient.id])
    {
      results.users[reward.recipient.id] = {
        recipient: null,
        earned: [0, 0],
        paid: [0, 0],
        payout: [0, 0],
        lastCreatedAt: 0,
        lastPaidAt: 0,
        unpaid: []
      };
    }

    const user = results.users[reward.recipient.id];

    user.recipient = reward.recipient;

    user.earned[0] += 1;
    user.earned[1] += reward.amount;

    if (reward.paid)
    {
      user.paid[0] += 1;
      user.paid[1] += reward.amount;
      user.lastPaidAt = Math.max(user.lastPaidAt, reward.paidAt.getTime());
    }
    else
    {
      user.payout[0] += 1;
      user.payout[1] += reward.amount;

      user.unpaid.push(reward.rid);
    }

    if (reward.createdAt > user.lastCreatedAt)
    {
      user.lastCreatedAt = reward.createdAt.getTime();
      user.recipient = reward.recipient;
    }
  }
};
