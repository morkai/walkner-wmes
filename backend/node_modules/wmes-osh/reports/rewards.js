// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');
const moment = require('moment');
const {ObjectId} = require('mongoose').Types;
const {transliterate} = require('transliteration');

exports.models = [
  require('wmes-osh/models/oshBrigade'),
  require('wmes-osh/models/oshReward'),
  require('settings/models/setting'),
  require('user/models/user')
];

exports.report = (app, module, options, done) =>
{
  const {
    Setting,
    User,
    OshBrigade,
    OshReward
  } = module;

  options.orgUnitType = null;
  options.orgUnitIds = [];
  options.leader = null;
  options.employee = null;
  options.status = null;
  options.paidAt = null;
  options.type = ['kaizen', 'observation'];
  options.company = [];

  options.conditions.forEach(term =>
  {
    const cond = term.name;
    const prop = term.args[0];
    const value = term.args[1];

    if (cond === 'eq'
      && (prop === 'paidAt' || prop === 'employee' || prop === 'status'))
    {
      options[prop] = value;

      return;
    }

    if ((cond === 'eq' || cond === 'in')
      && (prop === 'type' || prop === 'company'))
    {
      options[prop] = Array.isArray(value) ? value : [value];
    }

    if ((cond === 'eq' || cond === 'in')
      && (prop === 'division' || prop === 'workplace' || prop === 'department'))
    {
      options.orgUnitType = prop;
      options.orgUnitIds = term.name === 'eq' ? [value] : value;

      return;
    }
  });

  delete options.conditions;

  const results = {
    options,
    settings: {
      minPayout: 50,
      companies: []
    },
    companies: {},
    users: {}
  };

  const LOCATION_TO_USER_PROP = {
    division: 'oshDivision',
    workplace: 'oshWorkplace',
    department: 'oshDepartment'
  };
  const USER_ORG_UNIT_PROP = LOCATION_TO_USER_PROP[options.orgUnitType];

  const brigadeMembers = new Set();

  step(
    function()
    {
      Setting.findValues('osh.rewards.', this.parallel());

      findLatestBrigade(this.parallel());
    },
    function(err, settings)
    {
      if (err)
      {
        return this.skip(err);
      }

      Object.assign(results.settings, settings);

      this.companyMatchers = results.settings.companies.map(createCompanyMatcher);
    },
    function()
    {
      handleRewards(this.next());
    },
    function(err)
    {
      if (err)
      {
        return this.skip(err);
      }

      const userIds = Object.keys(results.users).map(id => new ObjectId(id));

      User
        .find({_id: {$in: userIds}})
        .select({
          personnelId: 1,
          syncData: 1
        })
        .lean()
        .exec(this.next());
    },
    function(err, users)
    {
      if (err)
      {
        return this.skip(err);
      }

      users.forEach(user =>
      {
        const {recipient} = results.users[user._id];

        recipient.personnelId = user.personnelId;
        recipient.department = user.syncData.department || '';
        recipient.company = matchUserCompany(user.syncData.company || '', this.companyMatchers);

        if (options.company.length && !options.company.includes(recipient.company.id))
        {
          delete results.users[user._id];
        }
      });

      results.users = Object.values(results.users).sort(
        (a, b) => a.recipient.label.localeCompare(b.recipient.label, undefined, {sensitivity: 'base'})
      );

      if (options.status === 'payout')
      {
        results.users = results.users.filter(u => u.payout[1] >= results.settings.minPayout);
      }
    },
    function(err)
    {
      done(err, results);
    }
  );

  function findLatestBrigade(done)
  {
    if (!options.leader)
    {
      return done();
    }

    OshBrigade
      .findOne({
        'leader.id': options.leader
      })
      .sort({
        'leader.id': 1,
        date: -1
      })
      .lean()
      .exec((err, brigade) =>
      {
        if (err)
        {
          return done(err);
        }

        if (brigade)
        {
          brigadeMembers.add(brigade.leader.id);

          brigade.members.forEach(member => brigadeMembers.add(member.id));
        }

        done();
      });
  }

  function handleRewards(done)
  {
    const conditions = {};

    if (options.paidAt)
    {
      const month = moment(options.paidAt, 'YYYY-MM');

      conditions.paidAt = {
        $gte: month.toDate(),
        $lt: month.clone().add(1, 'months').toDate()
      };
    }

    if (options.status === 'paid')
    {
      conditions.paid = true;
    }
    else if (options.status === 'unpaid' || options.status === 'payout')
    {
      conditions.paid = false;
    }

    if (options.orgUnitIds.length)
    {
      conditions[`recipient.${USER_ORG_UNIT_PROP}`] = {$in: options.orgUnitIds};
    }

    if (options.leader)
    {
      conditions['recipient.id'] = {$in: Array.from(brigadeMembers)};
    }

    if (options.employee)
    {
      conditions['recipient.id'] = options.employee;
    }

    if (options.type.length === 1)
    {
      conditions.type = options.type;
    }

    const stream = OshReward
      .find(conditions)
      .select({
        rid: 1,
        createdAt: 1,
        recipient: 1,
        count: 1,
        amount: 1,
        paid: 1,
        paidAt: 1
      })
      .lean()
      .cursor();
    const next = _.once(done);

    stream.on('error', next);
    stream.on('end', next);
    stream.on('data', handleReward);
  }

  function handleReward(reward)
  {
    if (!results.users[reward.recipient.id])
    {
      results.users[reward.recipient.id] = {
        recipient: null,
        earned: [0, 0],
        paid: [0, 0],
        payout: [0, 0],
        lastCreatedAt: 0,
        lastPaidAt: 0,
        unpaid: []
      };
    }

    const user = results.users[reward.recipient.id];

    user.recipient = reward.recipient;

    user.earned[0] += reward.count;
    user.earned[1] += reward.amount;

    if (reward.paid)
    {
      user.paid[0] += reward.count;
      user.paid[1] += reward.amount;
      user.lastPaidAt = Math.max(user.lastPaidAt, reward.paidAt.getTime());
    }
    else
    {
      user.payout[0] += reward.count;
      user.payout[1] += reward.amount;

      user.unpaid.push(reward.rid);
    }

    if (reward.createdAt > user.lastCreatedAt)
    {
      user.lastCreatedAt = reward.createdAt.getTime();
      user.recipient = reward.recipient;
    }
  }

  function prepareCompanyId(companyName)
  {
    return transliterate(companyName, {unknown: '_'}).trim().toUpperCase().replace(/[^A-Z0-9_]+/g, '_');
  }

  function createCompanyMatcher(company)
  {
    const patterns = company.patterns.map(pattern =>
    {
      pattern = _.escapeRegExp(
        prepareCompanyId(pattern.replace(/\*/g, '_STAR_'))
      ).replace(/_STAR_/g, '.*?');

      return new RegExp(`^${pattern}$`);
    });

    delete company.patterns;

    return userCompany =>
    {
      return patterns.some(pattern => pattern.test(userCompany)) ? company : null;
    };
  }

  function matchUserCompany(userCompany, companyMatchers)
  {
    userCompany = prepareCompanyId(userCompany);

    for (const companyMatcher of companyMatchers)
    {
      const company = companyMatcher(userCompany);

      if (company)
      {
        results.companies[company.id] = company.text;

        return company;
      }
    }

    return {
      id: 'OTHER',
      text: 'Inne'
    };
  }
};
