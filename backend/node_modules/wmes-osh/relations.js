// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const locks = require('util/locks');

module.exports = (app, module) =>
{
  const {
    OshNearMiss,
    OshKaizen,
    OshAction,
    OshObservation
  } = module;

  app.broker.subscribe(`${OshNearMiss.TOPIC_PREFIX}.edited`, onEntryEdited);
  app.broker.subscribe(`${OshNearMiss.TOPIC_PREFIX}.deleted`, onEntryDeleted);
  app.broker.subscribe(`${OshKaizen.TOPIC_PREFIX}.edited`, onEntryEdited);
  app.broker.subscribe(`${OshKaizen.TOPIC_PREFIX}.deleted`, onEntryDeleted);
  app.broker.subscribe(`${OshAction.TOPIC_PREFIX}.edited`, onEntryEdited);
  app.broker.subscribe(`${OshAction.TOPIC_PREFIX}.deleted`, onEntryDeleted);
  app.broker.subscribe(`${OshObservation.TOPIC_PREFIX}.deleted`, onEntryDeleted);

  function onEntryEdited({model})
  {
    if (!Array.isArray(model.relations) || model.relations.length === 0)
    {
      return;
    }

    const change = _.last(model.changes);

    if (model.lastModifiedPaths().includes('status'))
    {
      const wasFinished = change.data.status[0] === 'finished';
      const isFinished = change.data.status[1] === 'finished';

      if (wasFinished || isFinished)
      {
        model.relations.forEach(relation =>
        {
          updateRelatedEntry(relation, model, change, isFinished);
        });
      }
    }

    const modelRelation = model.getRelation();

    model.relations.forEach(relation =>
    {
      const RelatedEntry = module.TYPE_TO_MODEL[relation.type];

      app.broker.publish(`${RelatedEntry.TOPIC_PREFIX}.relations.${relation._id}`, {
        relation: modelRelation,
        change
      });
    });
  }

  function onEntryDeleted({user, model})
  {
    const change = {
      date: new Date(),
      user
    };

    if (Array.isArray(model.relations) && model.relations.length)
    {
      model.relations.forEach(relation =>
      {
        resetResolution(relation, model, change);
      });
    }

    const modelRelation = model.getRelation();

    if (model.resolution && model.resolution._id)
    {
      removeRelation(model.resolution, modelRelation, change);
    }

    if (Array.isArray(model.resolutions))
    {
      model.resolutions.forEach(relation =>
      {
        removeRelation(relation, modelRelation, change);
      });
    }

    if (model instanceof OshObservation)
    {
      [...model.behaviors, ...model.workConditions].forEach(observation =>
      {
        if (observation.resolution._id)
        {
          removeRelation(observation.resolution, modelRelation, change);
        }
      });
    }
  }

  async function updateRelatedEntry(relation, changedEntry, change, isFinished)
  {
    const RelationModel = module.TYPE_TO_MODEL[relation.type];

    if (!RelationModel)
    {
      return;
    }

    const releaseLocks = [await locks.createAsync(`${RelationModel.TOPIC_PREFIX}.${relation._id}`)];

    try
    {
      const relationEntry = await RelationModel.findById(relation._id).exec();

      if (!relationEntry)
      {
        return;
      }

      if (typeof relationEntry.isFinished === 'function')
      {
        isFinished = await relationEntry.isFinished(releaseLocks);
      }
      else if (relationEntry.resolution.rid !== changedEntry.rid)
      {
        return removeBrokenRelation(changedEntry, relation);
      }

      const input = {
        status: isFinished ? 'finished' : 'inProgress',
        statusUpdater: change.user,
        statusComment: change.comment || '',
        finishedAt: isFinished ? change.date : null,
        comment: change.comment || ''
      };

      if (input.status === relationEntry.status)
      {
        return;
      }

      const usersToNotify = relationEntry.applyChanges(input, change.user, change.date);

      if (!usersToNotify)
      {
        return;
      }

      await relationEntry.save();

      app.broker.publish(`${RelationModel.TOPIC_PREFIX}.edited`, {
        user: change.user,
        model: relationEntry
      });

      app.broker.publish(`${RelationModel.TOPIC_PREFIX}.updated.${relationEntry._id}`, {
        _id: relationEntry._id,
        change: _.last(relationEntry.changes),
        notify: usersToNotify
      });
    }
    catch (err)
    {
      module.error(err, `Failed to update related entry.`, {
        relation,
        changedType: changedEntry.constructor.RELATION_TYPE,
        changedModel: changedEntry._id,
        isFinished
      });
    }
    finally
    {
      releaseLocks.forEach(releaseLock => releaseLock());
    }
  }

  async function resetResolution(relation, deletedEntry, change)
  {
    const RelationModel = module.TYPE_TO_MODEL[relation.type];

    if (!RelationModel)
    {
      return;
    }

    const releaseLocks = [await locks.createAsync(`${RelationModel.TOPIC_PREFIX}.${relation._id}`)];

    try
    {
      const relationEntry = await RelationModel.findById(relation._id).exec();

      if (!relationEntry)
      {
        return;
      }

      const input = {
        comment: change.comment || ''
      };

      if (relation.type === 'observation')
      {
        let property = null;

        if (relationEntry.behaviors.some(o => o.resolution.rid === deletedEntry.rid))
        {
          property = 'behaviors';
        }
        else if (relationEntry.workConditions.some(o => o.resolution.rid === deletedEntry.rid))
        {
          property = 'workConditions';
        }
        else
        {
          return;
        }

        input[property] = relationEntry[property].toObject();

        input[property].forEach(o =>
        {
          if (o.resolution.rid === deletedEntry.rid)
          {
            o.resolution._id = 0;
            o.resolution.rid = '';
            o.resolution.type = 'unspecified';
            o.implementer = null;
          }
        });

        if (relationEntry.status === 'finished')
        {
          Object.assign(input, {
            status: 'inProgress',
            statusUpdater: change.user,
            statusComment: change.comment || '',
            finishedAt: null
          });
        }
      }
      else if (Array.isArray(relationEntry.resolutions))
      {
        input.resolutions = relationEntry.resolutions.filter(r => r.rid !== deletedEntry.rid);

        if (input.resolutions.length === relationEntry.resolutions.length)
        {
          return;
        }

        const ids = {
          action: [],
          kaizen: []
        };

        input.resolutions.forEach(r =>
        {
          if (!ids[r.type])
          {
            ids[r.type] = [];
          }

          ids[r.type].push(r._id);
        });

        const finished = input.resolutions.length && (await relationEntry.isFinished(releaseLocks, ids));
        const newStatus = finished ? 'finished' : 'inProgress';

        if (relationEntry.status === newStatus)
        {
          return;
        }

        Object.assign(input, {
          status: newStatus,
          statusUpdater: change.user,
          statusComment: change.comment || '',
          finishedAt: finished ? new Date() : null
        });
      }
      else if (relationEntry.resolution)
      {
        if (relationEntry.resolution.rid !== deletedEntry.rid)
        {
          return;
        }

        input.resolution = {
          _id: 0,
          rid: '',
          type: relationEntry.resolution.type
        };

        if (relationEntry.status === 'finished')
        {
          Object.assign(input, {
            status: 'inProgress',
            statusUpdater: change.user,
            statusComment: change.comment || '',
            finishedAt: null
          });
        }
      }
      else
      {
        return;
      }

      const usersToNotify = relationEntry.applyChanges(input, change.user, change.date);

      if (!usersToNotify)
      {
        return;
      }

      await relationEntry.save();

      app.broker.publish(`${RelationModel.TOPIC_PREFIX}.edited`, {
        user: change.user,
        model: relationEntry
      });

      app.broker.publish(`${RelationModel.TOPIC_PREFIX}.updated.${relationEntry._id}`, {
        _id: relationEntry._id,
        change: _.last(relationEntry.changes),
        notify: usersToNotify
      });
    }
    catch (err)
    {
      module.error(err, `Failed to reset resolution.`, {
        entry: deletedEntry.getRelation(),
        relation
      });
    }
    finally
    {
      releaseLocks.forEach(releaseLock => releaseLock());
    }
  }

  async function removeRelation(resolution, relation, change)
  {
    const ResolutionModel = module.TYPE_TO_MODEL[resolution.type];

    if (!ResolutionModel)
    {
      return;
    }

    const releaseLock = await locks.createAsync(`${ResolutionModel.TOPIC_PREFIX}.${resolution._id}`);

    try
    {
      const conditions = {
        _id: resolution._id,
        'relations.rid': relation.rid
      };

      const resolutionEntry = await ResolutionModel.findOne(conditions).exec();

      if (!resolutionEntry)
      {
        return;
      }

      const input = {
        relations: resolutionEntry.relations.filter(r => r.rid !== relation.rid),
        comment: change.comment || ''
      };

      const usersToNotify = resolutionEntry.applyChanges(input, change.user, change.date);

      if (!usersToNotify)
      {
        return;
      }

      await resolutionEntry.save();

      app.broker.publish(`${ResolutionModel.TOPIC_PREFIX}.edited`, {
        user: change.user,
        model: resolutionEntry
      });

      app.broker.publish(`${ResolutionModel.TOPIC_PREFIX}.updated.${resolutionEntry._id}`, {
        _id: resolutionEntry._id,
        change: _.last(resolutionEntry.changes),
        notify: usersToNotify
      });
    }
    catch (err)
    {
      module.error(err, `Failed to reset resolution.`, {
        relation,
        resolution
      });
    }
    finally
    {
      releaseLock();
    }
  }

  async function removeBrokenRelation(entry, relation)
  {
    // TODO?

    module.warn(`Removing broken relation...`, {
      entry: entry.getRelation(),
      relation
    });
  }
};
