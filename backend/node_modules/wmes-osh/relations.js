// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const locks = require('util/locks');

module.exports = (app, module) =>
{
  const {
    OshNearMiss,
    OshKaizen,
    OshAction
  } = module;

  app.broker.subscribe(`${OshKaizen.TOPIC_PREFIX}.edited`, onEntryEdited);
  app.broker.subscribe(`${OshKaizen.TOPIC_PREFIX}.deleted`, onEntryDeleted);
  app.broker.subscribe(`${OshAction.TOPIC_PREFIX}.edited`, onEntryEdited);
  app.broker.subscribe(`${OshAction.TOPIC_PREFIX}.deleted`, onEntryDeleted);

  function onEntryEdited({model})
  {
    if (!model.relations
      || model.relations.length === 0
      || !model.lastModifiedPaths().includes('status'))
    {
      return;
    }

    const change = _.last(model.changes);
    const wasFinished = change.data.status[0] === 'finished';
    const isFinished = change.data.status[1] === 'finished';

    if (!wasFinished && !isFinished)
    {
      return;
    }

    model.relations.forEach(relation =>
    {
      updateRelatedEntry(relation, model, change, isFinished);
    });
  }

  function onEntryDeleted({user, model})
  {
    if (!model.relations
      || model.relations.length === 0)
    {
      return;
    }

    const change = {
      date: new Date(),
      user
    };

    model.relations.forEach(relation =>
    {
      resetResolution(relation, model, change);
    });
  }

  async function updateRelatedEntry(relation, changedEntry, change, isFinished)
  {
    const RelationModel = module.TYPE_TO_MODEL[relation.type];

    if (!RelationModel)
    {
      return;
    }

    const releaseLock = await locks.createAsync(`${RelationModel.TOPIC_PREFIX}.${relation._id}`);

    try
    {
      const conditions = {
        _id: relation._id,
        status: {
          [isFinished ? '$ne' : '$eq']: 'finished'
        }
      };

      const relationEntry = await RelationModel.findOne(conditions).exec();

      if (!relationEntry)
      {
        return;
      }

      if (relationEntry.resolution.rid !== changedEntry.rid)
      {
        return removeBrokenRelation(changedEntry, relation);
      }

      const input = {
        status: isFinished ? 'finished' : 'inProgress',
        statusUpdater: change.user,
        statusComment: change.comment || '',
        finishedAt: isFinished ? change.date : null,
        comment: change.comment || ''
      };

      const usersToNotify = relationEntry.applyChanges(input, change.user, change.date);

      if (!usersToNotify)
      {
        return;
      }

      await relationEntry.save();

      app.broker.publish(`${RelationModel.TOPIC_PREFIX}.edited`, {
        user: change.user,
        model: relationEntry
      });

      app.broker.publish(`${RelationModel.TOPIC_PREFIX}.updated.${relationEntry._id}`, {
        _id: relationEntry._id,
        change: _.last(relationEntry.changes),
        notify: usersToNotify
      });
    }
    catch (err)
    {
      module.error(err, `Failed to update related entry.`, {
        relation,
        changedType: changedEntry.constructor.RELATION_TYPE,
        changedModel: changedEntry._id,
        isFinished
      });
    }
    finally
    {
      releaseLock();
    }
  }

  async function resetResolution(relation, deletedEntry, change)
  {
    const RelationModel = module.TYPE_TO_MODEL[relation.type];

    if (!RelationModel)
    {
      return;
    }

    const releaseLock = await locks.createAsync(`${RelationModel.TOPIC_PREFIX}.${relation._id}`);

    try
    {
      const conditions = {
        _id: relation._id,
        'resolution.rid': deletedEntry.rid
      };

      const relationEntry = await RelationModel.findOne(conditions).exec();

      if (!relationEntry)
      {
        return;
      }

      const input = {
        status: 'inProgress',
        statusUpdater: change.user,
        statusComment: change.comment || '',
        finishedAt: null,
        resolution: {
          _id: 0,
          rid: '',
          type: relationEntry.resolution.type
        },
        comment: change.comment || ''
      };

      const usersToNotify = relationEntry.applyChanges(input, change.user, change.date);

      if (!usersToNotify)
      {
        return;
      }

      await relationEntry.save();

      app.broker.publish(`${RelationModel.TOPIC_PREFIX}.edited`, {
        user: change.user,
        model: relationEntry
      });

      app.broker.publish(`${RelationModel.TOPIC_PREFIX}.updated.${relationEntry._id}`, {
        _id: relationEntry._id,
        change: _.last(relationEntry.changes),
        notify: usersToNotify
      });
    }
    catch (err)
    {
      module.error(err, `Failed to reset resolution.`, {
        entry: deletedEntry.getRelation(),
        relation
      });
    }
    finally
    {
      releaseLock();
    }
  }

  async function removeBrokenRelation(entry, relation)
  {
    // TODO?

    module.warn(`Removing broken relation...`, {
      entry: entry.getRelation(),
      relation
    });
  }
};
