// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const locks = require('util/locks');

module.exports = (app, module) =>
{
  const {
    OshNearMiss,
    OshKaizen
  } = module;

  app.broker.subscribe(`${OshKaizen.TOPIC_PREFIX}.edited`, onKaizenEdited);
  app.broker.subscribe(`${OshKaizen.TOPIC_PREFIX}.deleted`, onKaizenDeleted);

  function onKaizenEdited({model: kaizen})
  {
    if (!kaizen.relations
      || kaizen.relations.length === 0
      || !kaizen.lastModifiedPaths().includes('status'))
    {
      return;
    }

    const change = _.last(kaizen.changes);
    const wasFinished = change.data.status[0] === 'finished';
    const isFinished = change.data.status[1] === 'finished';

    if (!wasFinished && !isFinished)
    {
      return;
    }

    kaizen.relations.forEach(r =>
    {
      if (r.type === 'nearMiss')
      {
        updateRelatedNearMiss(r._id, 'kaizen', kaizen, change, isFinished);
      }
    });
  }

  function onKaizenDeleted({user, model: kaizen})
  {
    if (!kaizen.relations
      || kaizen.relations.length === 0
      || kaizen.status !== 'finished')
    {
      return;
    }

    const change = {
      date: new Date(),
      user
    };

    kaizen.relations.forEach(r =>
    {
      if (r.type === 'nearMiss')
      {
        updateRelatedNearMiss(r._id, 'kaizen', kaizen, change, false);
      }
    });
  }

  async function updateRelatedNearMiss(nearMissId, relatedType, relatedModel, change, isFinished)
  {
    const releaseLock = await locks.createAsync(`${OshNearMiss.TOPIC_PREFIX}.${nearMissId}`);

    try
    {
      const conditions = {
        _id: nearMissId,
        status: {
          [isFinished ? '$ne' : '$eq']: 'finished'
        }
      };

      const nearMiss = await OshNearMiss.findOne(conditions).exec();

      if (!nearMiss)
      {
        return;
      }

      if (nearMiss.resolution.type !== relatedType || nearMiss.resolution._id !== relatedModel._id)
      {
        return removeBrokenRelation(relatedType, relatedModel._id, 'nearMiss', nearMissId);
      }

      const input = {
        status: isFinished ? 'finished' : 'inProgress',
        statusUpdater: change.user,
        statusComment: change.comment || '',
        finishedAt: change.date,
        comment: change.comment || ''
      };

      const usersToNotify = nearMiss.applyChanges(input, change.user, change.date);

      if (!usersToNotify)
      {
        return;
      }

      await nearMiss.save();

      app.broker.publish(`${OshNearMiss.TOPIC_PREFIX}.edited`, {
        user: change.user,
        model: nearMiss
      });

      app.broker.publish(`${OshNearMiss.TOPIC_PREFIX}.updated.${nearMiss._id}`, {
        _id: nearMiss._id,
        change: _.last(nearMiss.changes),
        notify: usersToNotify
      });
    }
    catch (err)
    {
      module.error(err, `Failed to update related near miss.`, {
        nearMissId,
        relatedType,
        isFinished
      });
    }
    finally
    {
      releaseLock();
    }
  }

  async function removeBrokenRelation(modelType, modelId, relationType, relationId)
  {
    // TODO?

    module.warn(`Removing broken relation...`, {
      modelType,
      modelId,
      relationType,
      relationId
    });
  }
};
