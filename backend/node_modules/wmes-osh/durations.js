// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const moment = require('moment');

module.exports = (app, module) =>
{
  const {
    OshNearMiss,
    OshKaizen,
    OshAction,
    OshObservation
  } = module;

  app.broker.subscribe(`app.started`, () =>
  {
    scheduleDurationsUpdate();
    updateDurations();
  });

  function scheduleDurationsUpdate()
  {
    const now = Date.now();
    const delay = moment(now).startOf('hour').add(3, 'hours').diff(now);

    if (delay > 1800000)
    {
      setTimeout(scheduleDurationsUpdate, 1800000);
    }
    else
    {
      setTimeout(updateDurations, delay + 1000);
    }
  }

  async function updateDurations()
  {
    for (const Entry of [OshNearMiss, OshKaizen, OshAction, OshObservation])
    {
      await updateEntryDurations(Entry);
    }
  }

  async function updateEntryDurations(Entry)
  {
    const now = Date.now();

    module.debug('Updating durations...', {entryType: Entry.RELATION_TYPE});

    try
    {
      const entries = await Entry
        .find({
          status: {$in: Entry.STATUSES.filter(s => s !== 'finished' && s !== 'cancelled')}
        })
        .select({
          createdAt: 1
        })
        .lean()
        .exec();

      if (!entries.length)
      {
        return;
      }

      const ops = [];

      for (const entry of entries)
      {
        ops.push({
          updateOne: {
            filter: {_id: entry._id},
            update: {
              $set: {
                duration: (now - entry.createdAt) / 1000
              }
            }
          }
        });
      }

      await Entry.collection.bulkWrite(ops, {ordered: false});

      module.info('Updated durations.', {
        entryType: Entry.RELATION_TYPE,
        entryCount: ops.length,
        duration: Date.now() - now
      });
    }
    catch (err)
    {
      module.error(err, 'Failed to update durations.', {entryType: Entry.RELATION_TYPE});
    }
  }
};
