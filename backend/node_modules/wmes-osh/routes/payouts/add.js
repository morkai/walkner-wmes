// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const {ObjectId} = require('mongoose').Types;
const locks = require('util/locks');

module.exports = async (app, module, req, res, next) =>
{
  const {
    user,
    Setting,
    OshReward,
    OshPayout
  } = module;

  const {payouts} = req.body;

  if (!Array.isArray(payouts) || !payouts.length)
  {
    return next(app.createError('Invalid payouts.', 'INPUT', 400));
  }

  const entries = new Map();
  const recipients = new Set();

  payouts.forEach(payout =>
  {
    if (!payout
      || !payout.recipient
      || typeof payout.recipient.id !== 'string'
      || !Array.isArray(payout.entries))
    {
      return;
    }

    recipients.add(payout.recipient.id);

    payout.entries.forEach(rid =>
    {
      if (!entries.has(rid))
      {
        entries.set(rid, new Map());
      }

      entries.get(rid).set(payout.recipient.id, payout.recipient);
    });
  });

  if (!entries.size)
  {
    return next(app.createError('Invalid payouts.', 'INPUT', 400));
  }

  const releaseLock = await locks.createAsync(OshReward.TOPIC_PREFIX);

  const paidAt = new Date();
  const payer = user.createUserInfo(req.session.user, req);

  let session = null;

  try
  {
    session = await OshReward.startSession();
    session.startTransaction();

    const ignoredUserList = await Setting
      .findById('osh.rewards.ignoredUsers')
      .select({value: 1})
      .lean()
      .exec();
    const ignoredUserSet = new Set();

    (ignoredUserList ? ignoredUserList.value : []).forEach(user => ignoredUserSet.add(user.id));

    const rewards = await OshReward
      .find({
        rid: Array.from(entries.keys()),
        'recipient.id': {$in: Array.from(recipients)},
        paid: false
      })
      .lean()
      .session(session)
      .exec();

    if (!rewards.length)
    {
      throw app.createError('No rewards.', 'STATE', 500);
    }

    const updated = [];
    const ops = [];
    const payout = {
      _id: new ObjectId(),
      createdAt: new Date(),
      creator: user.createUserInfo(req.session.user, req),
      types: new Set(),
      companies: new Map(),
      description: req.body.description || '',
      options: req.body.options,
      recipients: new Map(),
      count: {
        total: 0,
        kaizen: new Set(),
        observation: 0
      },
      amount: {
        total: 0,
        kaizen: 0,
        observation: 0
      }
    };

    rewards.forEach(reward =>
    {
      const recipient = entries.get(reward.rid).get(reward.recipient.id);

      if (!recipient)
      {
        return;
      }

      updated.push({
        _id: reward._id,
        rid: reward.rid,
        paid: true,
        paidAt,
        payer,
        payout: payout._id
      });

      ops.push({
        updateOne: {
          filter: {_id: reward._id},
          update: {
            $set: {
              paid: true,
              paidAt,
              payer,
              payout: payout._id
            }
          }
        }
      });

      if (ignoredUserSet.has(recipient.id))
      {
        return;
      }

      if (!payout.recipients.has(recipient.id))
      {
        payout.recipients.set(recipient.id, {
          id: recipient.id,
          label: recipient.label,
          personnelId: recipient.personnelId || '',
          company: recipient.company,
          department: recipient.department || '',
          oshDivision: recipient.oshDivision || 0,
          oshWorkplace: recipient.oshWorkplace || 0,
          oshDepartment: recipient.oshDepartment || 0,
          count: {
            total: 0,
            kaizen: new Set(),
            observation: 0
          },
          amount: {
            total: 0,
            kaizen: 0,
            observation: 0
          },
          entries: []
        });
      }

      const payoutRecipient = payout.recipients.get(recipient.id);

      payoutRecipient.entries.push(reward.rid);

      if (reward.type === 'kaizen')
      {
        payoutRecipient.count.kaizen.add(reward.rid);
        payout.count.kaizen.add(reward.rid);
      }
      else
      {
        payoutRecipient.count[reward.type] += reward.count;
        payout.count[reward.type] += reward.count;
      }

      payoutRecipient.amount[reward.type] += reward.amount;
      payout.amount[reward.type] += reward.amount;

      payout.types.add(reward.type);
      payout.companies.set(recipient.company.id, {
        id: recipient.company.id,
        label: recipient.company.text
      });
    });

    if (!updated.length)
    {
      throw app.createError('No rewards.', 'STATE', 500);
    }

    payout.types = Array.from(payout.types);
    payout.companies = Array.from(payout.companies.values());

    payout.recipients = Array.from(payout.recipients.values());

    payout.recipients.forEach(recipient =>
    {
      recipient.count.kaizen = recipient.count.kaizen.size;
      recipient.count.total = recipient.count.kaizen + recipient.count.observation;
      recipient.amount.total = recipient.amount.kaizen + recipient.amount.observation;
    });

    payout.recipients.sort((a, b) => a.label.localeCompare(b.label, 'pl'));

    payout.count.kaizen = payout.count.kaizen.size;
    payout.count.total = payout.count.kaizen + payout.count.observation;
    payout.amount.total = payout.amount.kaizen + payout.amount.observation;

    await Promise.all([
      OshReward.collection.bulkWrite(ops, {session}),
      OshPayout.collection.insertOne(payout, {session})
    ]);

    await session.commitTransaction();

    res.json(payout);

    app.broker.publish(`${OshReward.TOPIC_PREFIX}.updated`, {updated});

    app.broker.publish(`${OshPayout.TOPIC_PREFIX}.added`, {
      user: payout.creator,
      model: new OshPayout(payout)
    });
  }
  catch (err)
  {
    next(err);

    if (session)
    {
      try
      {
        await session.abortTransaction();
      }
      catch (err)
      {
        if (err.message !== 'Cannot call abortTransaction twice')
        {
          module.error(err, `Failed to abort a transaction.`);
        }
      }
    }
  }
  finally
  {
    if (session)
    {
      session.endSession();
    }

    releaseLock();
  }
};
