// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const moment = require('moment');
const {ObjectId} = require('mongoose').Types;

module.exports = (app, module) =>
{
  const {
    OshEmployment,
    OshTarget,
    OshBrigade
  } = module;

  const logger = module.logger.create({submodule: 'autoData'});

  module.autoData = {
    createEmployments,
    createTargets,
    createBrigades
  };

  app.broker.subscribe(`app.started`, () =>
  {
    scheduleNewMonthData();
  });

  function scheduleNewMonthData()
  {
    const now = Date.now();
    const delay = moment(now).startOf('month').add(1, 'months').add(5, 'minutes').diff(now);

    if (delay > 1800000)
    {
      setTimeout(scheduleNewMonthData, 1800000);
    }
    else
    {
      setTimeout(createNewMonthData, delay + 1000);
    }
  }

  async function createNewMonthData()
  {
    try
    {
      await createEmployments();
    }
    catch (err)
    {
      logger.error(err, `Failed to auto-create new month's employment.`);
    }

    try
    {
      await createTargets();
    }
    catch (err)
    {
      logger.error(err, `Failed to auto-create new month's employment.`);
    }

    try
    {
      await createBrigades();
    }
    catch (err)
    {
      logger.error(err, `Failed to auto-create new month's brigades.`);
    }
  }

  async function createEmployments()
  {
    const currentMonth = moment().startOf('month').utc(true).toDate();
    const prevMonth = moment.utc(currentMonth).subtract(1, 'months').toDate();

    let [prevEmployment, currentEmployment, orgUnits] = await Promise.all([
      OshEmployment
        .findById(prevMonth)
        .exec(),
      OshEmployment
        .findById(currentMonth)
        .exec(),
      OshEmployment.getActiveOrgUnits()
    ]);

    if (prevEmployment && !prevEmployment.locked)
    {
      logger.info('Recounting previous employment...', {month: prevMonth});

      await prevEmployment.recreate(true, orgUnits);
      await prevEmployment.recount();
      await prevEmployment.edit();
    }

    if (currentEmployment)
    {
      if (!currentEmployment.locked)
      {
        logger.info('Recounting current employment...', {month: currentMonth});

        await currentEmployment.recreate(false, orgUnits);
        await currentEmployment.recount();
        await currentEmployment.edit();
      }

      return;
    }

    if (prevEmployment)
    {
      logger.info('Creating current employment based on the previous one...', {month: currentMonth});

      currentEmployment = new OshEmployment({
        _id: currentMonth,
        locked: false,
        departments: prevEmployment.departments.toObject()
      });

      await currentEmployment.add();

      return;
    }

    logger.info('Creating new current employment...', {month: currentMonth});

    currentEmployment = new OshEmployment({
      _id: currentMonth,
      locked: false,
      departments: []
    });

    await currentEmployment.recreate(false, orgUnits);
    await currentEmployment.recount();
    await currentEmployment.add();
  }

  async function createTargets()
  {
    const currentMonth = moment().startOf('month').utc(true).toDate();
    const prevMonth = moment.utc(currentMonth).subtract(1, 'months').toDate();

    let [prevTarget, currentTarget] = await Promise.all([
      OshTarget
        .findById(prevMonth)
        .lean()
        .exec(),
      OshTarget
        .findById(currentMonth)
        .select({_id: 1})
        .lean()
        .exec()
    ]);

    if (!prevTarget)
    {
      logger.warn('Not creating the current targets: no previous data.', {month: prevMonth});

      return;
    }

    if (currentTarget)
    {
      logger.info('Not creating the current targets: already exists.', {month: currentMonth});

      return;
    }

    logger.info('Creating new current targets...', {month: currentMonth});

    currentTarget = new OshTarget({
      _id: currentMonth,
      orgUnits: prevTarget.orgUnits
    });

    await currentTarget.recreate(false);
    await currentTarget.add();
  }

  async function createBrigades()
  {
    const currentMonth = moment().startOf('month').utc(true).toDate();
    const prevMonth = moment.utc(currentMonth).subtract(1, 'months').toDate();

    const prevBrigades = await OshBrigade
      .find({date: prevMonth})
      .lean()
      .exec();

    const currentBrigades = prevBrigades.map(prevBrigade =>
    {
      return {
        _id: new ObjectId(),
        date: currentMonth,
        shift: prevBrigade.shift,
        leader: prevBrigade.leader,
        members: prevBrigade.members
      };
    });

    let addedCount = 0;

    while (currentBrigades.length)
    {
      const newBrigadeList = currentBrigades.splice(0, 10);
      const newBrigadeMap = new Map();
      const addedBrigades = [];

      newBrigadeList.forEach(brigade => newBrigadeMap.set(brigade._id.toString(), brigade));

      try
      {
        await OshBrigade.collection.insertMany(newBrigadeList, {ordered: false});

        newBrigadeList.forEach(brigade =>
        {
          addedBrigades.push(new OshBrigade(brigade));
        });
      }
      catch (err)
      {
        if (err.code !== 11000)
        {
          throw err;
        }

        err.writeErrors.forEach(({err}) =>
        {
          newBrigadeMap.delete(err.op._id.toString());
        });

        newBrigadeMap.forEach(brigade =>
        {
          addedBrigades.push(new OshBrigade(brigade));
        });
      }

      addedCount += addedBrigades.length;

      addedBrigades.forEach(model =>
      {
        app.broker.publish(`${OshBrigade.TOPIC_PREFIX}.added`, {
          model,
          user: null
        });
      });
    }

    if (addedCount)
    {
      logger.info('Created current brigades based on the previous ones.', {
        month: currentMonth,
        count: addedCount
      });
    }
  }
};
