// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const moment = require('moment');
const {ObjectId} = require('mongoose').Types;

module.exports = (app, module) =>
{
  const {
    user,
    User,
    OshEmployment,
    OshTarget,
    OshBrigade,
    OshReward,
    OshObservation
  } = module;

  const logger = module.logger.create({submodule: 'autoData'});

  module.autoData = {
    createEmployments,
    createTargets,
    createBrigades
  };

  app.broker.subscribe(`app.started`, () =>
  {
    scheduleNewMonthData();
    scheduleObsCoordinatorRewards();
  });

  function scheduleNewMonthData()
  {
    const now = Date.now();
    const delay = moment(now).startOf('month').add(1, 'months').add(5, 'minutes').diff(now);

    if (delay > 1800000)
    {
      setTimeout(scheduleNewMonthData, 1800000);
    }
    else
    {
      setTimeout(createNewMonthData, delay + 1000);
    }
  }

  function scheduleObsCoordinatorRewards()
  {
    const now = Date.now();
    const delay = moment(now).startOf('day').add(1, 'days').add(15, 'seconds').diff(now);

    if (delay > 1800000)
    {
      setTimeout(scheduleObsCoordinatorRewards, 1800000);
    }
    else
    {
      setTimeout(createObsCoordinatorRewards, delay + 1000);
    }
  }

  async function createNewMonthData()
  {
    try
    {
      await createEmployments();
    }
    catch (err)
    {
      logger.error(err, `Failed to auto-create new month's employment.`);
    }

    try
    {
      await createTargets();
    }
    catch (err)
    {
      logger.error(err, `Failed to auto-create new month's employment.`);
    }

    try
    {
      await createBrigades();
    }
    catch (err)
    {
      logger.error(err, `Failed to auto-create new month's brigades.`);
    }

    scheduleNewMonthData();
  }

  async function createEmployments()
  {
    const currentMonth = moment().startOf('month').utc(true).toDate();
    const prevMonth = moment.utc(currentMonth).subtract(1, 'months').toDate();

    let [prevEmployment, currentEmployment, orgUnits] = await Promise.all([
      OshEmployment
        .findById(prevMonth)
        .exec(),
      OshEmployment
        .findById(currentMonth)
        .exec(),
      OshEmployment.getActiveOrgUnits()
    ]);

    if (prevEmployment && !prevEmployment.locked)
    {
      logger.info('Recounting previous employment...', {month: prevMonth});

      await prevEmployment.recreate(true, orgUnits);
      await prevEmployment.recount();
      await prevEmployment.edit();
    }

    if (currentEmployment)
    {
      if (!currentEmployment.locked)
      {
        logger.info('Recounting current employment...', {month: currentMonth});

        await currentEmployment.recreate(false, orgUnits);
        await currentEmployment.recount();
        await currentEmployment.edit();
      }

      return;
    }

    if (prevEmployment)
    {
      logger.info('Creating current employment based on the previous one...', {month: currentMonth});

      currentEmployment = new OshEmployment({
        _id: currentMonth,
        locked: false,
        departments: prevEmployment.departments.toObject()
      });

      await currentEmployment.add();

      return;
    }

    logger.info('Creating new current employment...', {month: currentMonth});

    currentEmployment = new OshEmployment({
      _id: currentMonth,
      locked: false,
      departments: []
    });

    await currentEmployment.recreate(false, orgUnits);
    await currentEmployment.recount();
    await currentEmployment.add();
  }

  async function createTargets()
  {
    const currentMonth = moment().startOf('month').utc(true).toDate();
    const prevMonth = moment.utc(currentMonth).subtract(1, 'months').toDate();

    let [prevTarget, currentTarget] = await Promise.all([
      OshTarget
        .findById(prevMonth)
        .lean()
        .exec(),
      OshTarget
        .findById(currentMonth)
        .select({_id: 1})
        .lean()
        .exec()
    ]);

    if (!prevTarget)
    {
      logger.warn('Not creating the current targets: no previous data.', {month: prevMonth});

      return;
    }

    if (currentTarget)
    {
      logger.info('Not creating the current targets: already exists.', {month: currentMonth});

      return;
    }

    logger.info('Creating new current targets...', {month: currentMonth});

    currentTarget = new OshTarget({
      _id: currentMonth,
      orgUnits: prevTarget.orgUnits
    });

    await currentTarget.recreate(false);
    await currentTarget.add();
  }

  async function createBrigades()
  {
    const currentMonth = moment().startOf('month').utc(true).toDate();
    const prevMonth = moment.utc(currentMonth).subtract(1, 'months').toDate();

    const prevBrigades = await OshBrigade
      .find({date: prevMonth})
      .lean()
      .exec();

    const currentBrigades = prevBrigades.map(prevBrigade =>
    {
      return {
        _id: new ObjectId(),
        date: currentMonth,
        shift: prevBrigade.shift,
        leader: prevBrigade.leader,
        members: prevBrigade.members
      };
    });

    let addedCount = 0;

    while (currentBrigades.length)
    {
      const newBrigadeList = currentBrigades.splice(0, 10);
      const newBrigadeMap = new Map();
      const addedBrigades = [];

      newBrigadeList.forEach(brigade => newBrigadeMap.set(brigade._id.toString(), brigade));

      try
      {
        await OshBrigade.collection.insertMany(newBrigadeList, {ordered: false});

        newBrigadeList.forEach(brigade =>
        {
          addedBrigades.push(new OshBrigade(brigade));
        });
      }
      catch (err)
      {
        if (err.code !== 11000)
        {
          throw err;
        }

        err.writeErrors.forEach(({err}) =>
        {
          newBrigadeMap.delete(err.op._id.toString());
        });

        newBrigadeMap.forEach(brigade =>
        {
          addedBrigades.push(new OshBrigade(brigade));
        });
      }

      addedCount += addedBrigades.length;

      addedBrigades.forEach(model =>
      {
        app.broker.publish(`${OshBrigade.TOPIC_PREFIX}.added`, {
          model,
          user: null
        });
      });
    }

    if (addedCount)
    {
      logger.info('Created current brigades based on the previous ones.', {
        month: currentMonth,
        count: addedCount
      });
    }
  }

  async function createObsCoordinatorRewards()
  {
    try
    {
      const obsCoordinators = await User
        .find({privileges: 'OSH:OBSERVATIONS:MANAGE'})
        .select({
          login: 1,
          firstName: 1,
          lastName: 1,
          oshDivision: 1,
          oshWorkplace: 1,
          oshDepartment: 1
        })
        .lean()
        .exec();

      if (obsCoordinators.length)
      {
        logger.info('Rewarding observation coordinators...', {
          users: obsCoordinators.map(u => u._id.toString())
        });
      }
      else
      {
        logger.info('No observation coordinators to reward.');
      }

      for (const obsCoordinator of obsCoordinators)
      {
        await createObsCoordinatorReward(user.createUserInfo(obsCoordinator));
      }
    }
    catch (err)
    {
      logger.error(err, 'Failed to reward observation coordinators.');
    }

    scheduleObsCoordinatorRewards();
  }

  async function createObsCoordinatorReward(creator)
  {
    try
    {
      const createdAt = new Date();
      const date = moment.utc().subtract(1, 'days').startOf('month');
      const obs = new OshObservation({
        rid: 'O-0000-000000',
        ridInc: 0,
        status: 'finished',
        statusComment: '',
        statusUpdater: null,
        createdAt,
        updatedAt: createdAt,
        finishedAt: createdAt,
        duration: 0,
        creator,
        updater: creator,
        coordinators: [],
        date: date.toDate(),
        company: 0,
        companyName: '',
        division: 0,
        workplace: 0,
        department: 0,
        building: 0,
        location: 0,
        station: 0,
        observationKind: 0,
        behaviors: [],
        workConditions: [],
        attachments: [],
        users: [],
        changes: []
      });

      const {messages} = await OshReward.updateEntry({
        entry: obs,
        createdAt,
        creator,
        recipients: [creator],
        totalAmount: 0
      });

      messages.forEach(({topic, message}) => app.broker.publish(topic, message));
    }
    catch (err)
    {
      logger.error(err, 'Failed to reward observation coordinator.', {user: creator._id});
    }
  }
};
