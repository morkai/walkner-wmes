// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');

exports.DEFAULT_CONFIG = {
  mongooseId: 'mongoose',
  userId: 'user',
  expressId: 'express',
  collection: (app) => app.mongodb.db.collection('events'),
  insertDelay: 1000,
  topics: ['events.**'],
  blacklist: [],
  print: []
};

exports.models = [
  require('./models/event')
];

exports.optionalModules = {
  'mongoose user express': require('./routes')
};

exports.onModuleSetUp = (app, {module, setUpAppModule}) =>
{
  if (!setUpAppModule.recordTopics)
  {
    return;
  }

  if (Array.isArray(setUpAppModule.recordTopics))
  {
    if (Array.isArray(module.config.topics))
    {
      setUpAppModule.recordTopics.forEach((topic) => module.config.topics.push(topic));
    }

    return;
  }

  Object.keys(setUpAppModule.recordTopics).forEach((severity) =>
  {
    let topics = module.config.topics;

    if (severity === 'blacklist' || severity === 'print')
    {
      topics = module.config[severity];
    }
    else if (!topics[severity])
    {
      topics = topics[severity] = [];
    }
    else
    {
      topics = topics[severity];
    }

    setUpAppModule.recordTopics[severity].forEach((topic) => topics.push(topic));
  });
};

exports.start = (app, module) =>
{
  const {config} = module;

  /**
   * @private
   * @type {Collection}
   */
  const eventsCollection = config.collection(app);

  /**
   * @private
   * @type {Array.<object>|null}
   */
  let pendingEvents = null;

  /**
   * @private
   * @type {number}
   */
  let lastFetchAllTypesTime = 0;

  /**
   * @private
   * @type {object|null}
   */
  let nextFetchAllTypesTimer = null;

  /**
   * @private
   * @type {number}
   */
  let lastInsertDelayTime = 0;

  /**
   * @private
   * @type {object.<string, boolean>}
   */
  const blacklist = {};

  module.types = {};

  module.getPendingEvents = function()
  {
    return pendingEvents || [];
  };

  module.insertEvents = insertEvents;

  config.blacklist.forEach((topic) => blacklist[topic] = true);

  subscribe();

  app.broker.subscribe('app.started').setLimit(1).on('message', () =>
  {
    fetchAllTypes();
    setInterval(checkBlockedInsert, 5000);
  });

  function fetchAllTypes()
  {
    const now = Date.now();
    const diff = now - lastFetchAllTypesTime;

    if (diff < 60000)
    {
      if (nextFetchAllTypesTimer === null)
      {
        nextFetchAllTypesTimer = setTimeout(fetchAllTypes, diff);
      }

      return;
    }

    eventsCollection.distinct('type', null, null, (err, types) =>
    {
      if (err)
      {
        module.error(err, `Failed to fetch event types.`);
      }
      else
      {
        types.forEach((type) => module.types[type] = 1);
      }

      lastFetchAllTypesTime = Date.now();
      nextFetchAllTypesTimer = null;
    });
  }

  function subscribe()
  {
    if (Array.isArray(config.topics))
    {
      const queueInfoEvent = queueEvent.bind(null, 'info');

      _.uniq(config.topics).forEach((topic) =>
      {
        app.broker.subscribe(topic, queueInfoEvent);
      });
    }
    else
    {
      Object.keys(config.topics).forEach((severity) =>
      {
        const queueCustomSeverityEvent = queueEvent.bind(null, severity);

        _.uniq(config.topics[severity]).forEach((topic) =>
        {
          app.broker.subscribe(topic, queueCustomSeverityEvent);
        });
      });
    }

    _.uniq(module.config.print).forEach((topic) =>
    {
      app.broker.subscribe(topic, printMessage);
    });
  }

  function printMessage(message, topic)
  {
    module.info({topic, message});
  }

  function queueEvent(severity, data, topic)
  {
    if (topic === 'events.saved')
    {
      fetchAllTypes();

      return;
    }

    if (blacklist[topic])
    {
      return;
    }

    const userData = data.user;
    let user = null;

    if (_.isObject(user))
    {
      user = {
        _id: String(userData._id || userData.id),
        name: userData.lastName && userData.firstName
          ? (userData.lastName + ' ' + userData.firstName)
          : (userData.login || userData.label),
        login: userData.login || userData.label,
        ipAddress: userData.ipAddress || userData.ip
      };
    }

    if (!_.isObject(data))
    {
      data = {};
    }
    else
    {
      data = JSON.parse(JSON.stringify(data));
    }

    const type = topic.replace(/^events\./, '');

    if (_.isString(data.severity))
    {
      severity = data.severity;

      delete data.severity;
    }

    if (user !== null)
    {
      delete data.user;
    }

    const event = {
      type: type,
      severity: severity,
      time: Date.now(),
      user: user,
      data: data
    };

    if (pendingEvents === null)
    {
      pendingEvents = [];

      setTimeout(insertEvents, module.config.insertDelay);

      lastInsertDelayTime = event.time;
    }

    pendingEvents.push(event);

    module.types[type] = 1;
  }

  function insertEvents()
  {
    if (pendingEvents === null)
    {
      return;
    }

    const eventsToSave = pendingEvents;

    pendingEvents = null;

    eventsCollection.insertMany(eventsToSave, (err) =>
    {
      if (err)
      {
        module.error(err, `Failed to save ${eventsToSave.length} events.`);
      }
      else
      {
        app.broker.publish('events.saved', eventsToSave);
      }
    });
  }

  function checkBlockedInsert()
  {
    if (pendingEvents === null)
    {
      return;
    }

    if (Date.now() - lastInsertDelayTime > 3333)
    {
      module.warn(`Blocked! Forcing insert of ${pendingEvents.length} pending events!`);

      insertEvents();
    }
  }
};
