// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const moment = require('moment');

module.exports = (app, module, req, res, next) =>
{
  const {express, PaintShopOrder, ProdShiftOrder} = module;

  const fromMoment = moment.utc(req.query.from, 'YYYY-MM-DD');
  const toMoment = req.query.to ? moment.utc(req.query.to, 'YYYY-MM-DD') : moment.utc().startOf('day');

  if (!fromMoment.isValid() || !toMoment.isValid())
  {
    return next(app.createError('Invalid date.', 'INPUT', 400));
  }

  const mrp = String(req.query.mrp || '').split(',').filter(v => v.length > 0);
  const toTime = toMoment.valueOf();

  const options = {
    filename: 'WMES-PAINT_SHOP-PLAN_EXECUTION',
    freezeRows: 1,
    freezeColumns: 1,
    columns: {
      scheduledStartDate: 'date+utc',
      paint: 12,
      mrp: 4,
      leadingOrder: 10,
      leadingName: 40,
      leadingQty: 'integer',
      childOrder: 10,
      childName: 40,
      childQty: 'integer',
      paintingStartTime: 'datetime',
      paintingFinishTime: 'datetime',
      plannedStartTime: 'datetime+utc',
      actualStartTime: 'datetime',
      actualFinishTime: 'datetime'
    },
    cursor: null,
    serializeStream: (cursor, emitter) =>
    {
      exportNextDate(emitter);
    }
  };

  express.crud.exportRoute(app, options, req, res, next);

  function exportNextDate(emitter)
  {
    if (fromMoment.valueOf() >= toTime)
    {
      return emitter.emit('end');
    }

    const conditions = {
      date: {
        $gte: new Date(fromMoment.valueOf()),
        $lt: fromMoment.add(1, 'days').toDate()
      }
    };

    if (mrp.length)
    {
      conditions.mrp = {$in: mrp};
    }

    const fields = {
      startedAt: 1,
      finishedAt: 1,
      order: 1,
      name: 1,
      qty: 1,
      mrp: 1,
      startTime: 1,
      childOrders: 1
    };

    const cursor = PaintShopOrder
      .find(conditions)
      .select(fields)
      .sort({startTime: 1})
      .lean()
      .cursor();
    const paintToOrders = {};
    const leadingOrderSet = new Set();

    cursor.on('error', err => emitter.emit('error', err));

    cursor.on('end', () =>
    {
      findProductionTimes(emitter, paintToOrders, Array.from(leadingOrderSet));
    });

    cursor.on('data', leadingOrder =>
    {
      leadingOrderSet.add(leadingOrder.order);

      leadingOrder.childOrders.forEach(childOrder =>
      {
        if (childOrder.deleted)
        {
          return;
        }

        childOrder.components.forEach(component =>
        {
          if (component.unit !== 'G' && component.unit !== 'KG')
          {
            return;
          }

          if (!paintToOrders[component.nc12])
          {
            paintToOrders[component.nc12] = {};
          }

          const leadingToChild = paintToOrders[component.nc12];

          if (!leadingToChild[leadingOrder.order])
          {
            leadingToChild[leadingOrder.order] = {};
          }

          const childOrders = leadingToChild[leadingOrder.order];

          childOrders[childOrder.order] = {
            leadingOrder,
            childOrder
          };
        });
      });
    });
  }

  function findProductionTimes(emitter, paintToOrders, leadingOrderList)
  {
    const conditions = {
      orderId: {$in: leadingOrderList}
    };
    const fields = {
      orderId: 1,
      startedAt: 1,
      finishedAt: 1
    };
    const cursor = ProdShiftOrder
      .find(conditions)
      .select(fields)
      .lean()
      .cursor();
    const orderToTimes = {};

    cursor.on('error', err => emitter.emit('error', err));

    cursor.on('end', () =>
    {
      const scheduledStartDate = fromMoment.clone().subtract(1, 'days').toDate();

      Object.keys(paintToOrders).forEach(paint =>
      {
        const leadingOrders = paintToOrders[paint];

        Object.keys(leadingOrders).forEach(leadingOrderNo =>
        {
          const orderTimes = orderToTimes[leadingOrderNo];
          const childOrders = leadingOrders[leadingOrderNo];

          Object.keys(childOrders).forEach(childOrderNo =>
          {
            const {leadingOrder, childOrder} = childOrders[childOrderNo];

            emitter.emit('data', {
              scheduledStartDate,
              paint,
              mrp: leadingOrder.mrp,
              leadingOrder: leadingOrder.order,
              leadingName: leadingOrder.name,
              leadingQty: leadingOrder.qty,
              childOrder: childOrder.order,
              childName: childOrder.name,
              childQty: childOrder.qty,
              paintingStartTime: leadingOrder.startedAt,
              paintingFinishTime: leadingOrder.finishedAt,
              plannedStartTime: leadingOrder.startTime,
              actualStartTime: orderTimes ? orderTimes.startedAt : null,
              actualFinishTime: orderTimes ? orderTimes.finishedAt : null
            });
          });
        });
      });

      exportNextDate(emitter);
    });

    cursor.on('data', pso =>
    {
      if (!orderToTimes[pso.orderId])
      {
        orderToTimes[pso.orderId] = {
          startedAt: Number.MAX_SAFE_INTEGER,
          finishedAt: Number.MIN_SAFE_INTEGER
        };
      }

      const orderTimes = orderToTimes[pso.orderId];

      if (pso.startedAt < orderTimes.startedAt)
      {
        orderTimes.startedAt = pso.startedAt;
      }

      if (pso.finishedAt > orderTimes.finishedAt)
      {
        orderTimes.finishedAt = pso.finishedAt;
      }
    });
  }
};
