// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');
const moment = require('moment');
const util = require('../reports/util');

exports.models = [
  require('./models/paintShopLoad'),
  require('./models/paintShopLoadReason'),
  require('settings/models/setting')
];

exports.report = (app, module, options, done) =>
{
  const {
    Setting,
    PaintShopLoad,
    PaintShopLoadReason
  } = module;

  const results = {
    options,
    settings: {},
    counters: [1, 2, 3],
    bucketSize: 0,
    reasonLabels: {},
    load: {},
    groups: {},
    totals: {}
  };

  results.counters.forEach(c =>
  {
    results.settings[`delayedDuration.${c}`] = 0;
    results.settings[`statuses.${c}`] = [];

    results.load[c] = [];

    getCounter(results.totals, c);
  });

  const reasonLabels = {
    null: 'Nieokre≈õlony'
  };

  if (!options.fromTime)
  {
    options.fromTime = moment().startOf('day').subtract(30, 'days').valueOf();
    options.toTime = 0;
    options.interval = 'day';
  }

  if (!options.toTime)
  {
    options.toTime = Date.now();
  }

  options.fromTime = moment(options.fromTime).startOf('day').hours(6).valueOf();
  options.toTime = moment(options.toTime).startOf('day').hours(6).valueOf();

  if (options.toTime <= options.fromTime)
  {
    options.toTime = moment(options.fromTime).add(1, 'days').valueOf();
  }

  const timeDiff = options.toTime - options.fromTime;
  let maxGroups = timeDiff / util.getIntervalSize(options.interval);

  while (maxGroups > 1500)
  {
    options.interval = util.getNextInterval(options.interval);
    maxGroups = timeDiff / util.getIntervalSize(options.interval);
  }

  const interval = options.interval;
  const groupInterval = interval;

  step(
    function()
    {
      Setting.findValues('paintShop.load.', this.parallel());

      PaintShopLoadReason
        .find({})
        .select({label: 1})
        .lean()
        .exec(this.parallel());
    },
    function(err, settings, reasons)
    {
      if (err)
      {
        return this.skip(err);
      }

      Object.assign(results.settings, settings);

      reasons.forEach(reason =>
      {
        reasonLabels[reason._id] = reason.label;
      });
    },
    function()
    {
      const conditions = {
        '_id.ts': {
          $gte: new Date(options.fromTime),
          $lt: new Date(options.toTime)
        }
      };

      const next = _.once(this.next());
      const cursor = PaintShopLoad
        .find(conditions)
        .sort({'_id.ts': 1})
        .lean()
        .cursor({batchSize: 50});

      cursor.on('error', next);
      cursor.on('end', next);
      cursor.on('data', handleItem);
    },
    function(err)
    {
      if (err)
      {
        return this.skip(err);
      }

      const groupKeys = Object.keys(results.groups).sort();
      const createNextGroupKey = util.createCreateNextGroupKey(groupInterval);
      const groups = [];
      const lastGroupKey = +_.last(groupKeys);
      let groupKey = +groupKeys[0];

      while (groupKey <= lastGroupKey)
      {
        const group = getGroup(groupKey, false);
        const counters = {};

        results.counters.forEach(c =>
        {
          const counter = getCounter(group, c);

          counter.avg = Math.round(counter.sum / (counter.count - counter.zero)) || 0;

          if (counter.min === Number.MAX_SAFE_INTEGER)
          {
            counter.min = 0;
          }

          counters[c] = counter;
        });

        groups.push({
          key: groupKey,
          counters
        });

        groupKey = createNextGroupKey(groupKey);
      }

      results.groups = groups;

      if (interval === 'min')
      {
        summarizeLoad();
      }

      setImmediate(this.next());
    },
    function sendResultsStep(err)
    {
      return done(err, results);
    }
  );

  function handleItem(item)
  {
    if (interval === 'min')
    {
      handleUngrouped(item);
    }

    handleGrouped(item);
  }

  function handleUngrouped(item)
  {
    const time = item._id.ts.getTime();
    const counter = item._id.c;

    if (!results.load[counter])
    {
      results.load[counter] = [];
    }

    results.load[counter].push([time, Math.round(item.d / 1000)]);
  }

  function handleGrouped(item)
  {
    const {ts, c} = item._id;
    const group = getGroup(ts, true);
    const groupCounter = getCounter(group, c);
    const totalCounter = getCounter(results.totals, c);

    inc(groupCounter, c, item.d, item.r);
    inc(totalCounter, c, item.d, item.r);
  }

  function getGroup(date, useShifts)
  {
    const key = util.createGroupKey(groupInterval, date, useShifts);

    if (!results.groups[key])
    {
      results.groups[key] = {};
    }

    return results.groups[key];
  }

  function getCounter(group, counter)
  {
    if (!group[counter])
    {
      group[counter] = {
        sum: 0,
        min: Number.MAX_SAFE_INTEGER,
        max: 0,
        avg: 0,
        zero: 0,
        count: 0,
        delayed: {
          time: 0,
          count: 0,
          reasons: {}
        }
      };
    }

    return group[counter];
  }

  function inc(group, c, d, r)
  {
    const duration = Math.round(d / 1000);

    group.count += 1;

    if (duration > 0)
    {
      group.sum += duration;

      if (duration < group.min)
      {
        group.min = duration;
      }

      if (duration > group.max)
      {
        group.max = duration;
      }
    }
    else
    {
      group.zero += 1;
    }

    const delayedDuration = results.settings[`delayedDuration.${c}`] || Number.MAX_SAFE_INTEGER;

    if (group.delayed && (duration > delayedDuration || r))
    {
      const delay = duration - delayedDuration;

      group.delayed.count += 1;
      group.delayed.time += delay;

      const reason = r ? r.toString() : 'null';

      results.reasonLabels[reason] = reasonLabels[reason] || reason;

      if (!group.delayed.reasons[reason])
      {
        group.delayed.reasons[reason] = [0, 0];
      }

      group.delayed.reasons[reason][0] += 1;
      group.delayed.reasons[reason][1] += delay;
    }
  }

  function summarizeLoad()
  {
    const counters = Object.keys(results.load);
    let first = Number.MAX_SAFE_INTEGER;
    let last = Number.MIN_SAFE_INTEGER;

    counters.forEach(c =>
    {
      const load = results.load[c];

      if (!load.length)
      {
        return;
      }

      const f = _.first(load)[0];

      if (f < first)
      {
        first = f;
      }

      const l = _.last(load)[0];

      if (l > last)
      {
        last = l;
      }
    });

    const diff = (last - first) / 1000;
    let bucketSizeMin = 5;

    while (diff / (bucketSizeMin * 60) > 1500)
    {
      bucketSizeMin += 5;
    }

    if (bucketSizeMin < options.bucketSize)
    {
      bucketSizeMin = options.bucketSize;
    }

    const bucketSizeMs = bucketSizeMin * 60 * 1000;

    counters.forEach(c =>
    {
      const oldLoad = results.load[c];
      const newLoad = [];

      oldLoad.forEach(([ts, d]) =>
      {
        const key = ts - ts % bucketSizeMs;
        let bucket = _.last(newLoad);

        if (!bucket || bucket.key !== key)
        {
          bucket = {
            key,
            sum: 0,
            min: Number.MAX_SAFE_INTEGER,
            max: 0,
            avg: 0,
            zero: 0,
            count: 0
          };

          newLoad.push(bucket);
        }

        inc(bucket, c, d * 1000, null);
      });

      newLoad.forEach(bucket =>
      {
        bucket.avg = Math.round(bucket.sum / (bucket.count - bucket.zero)) || 0;

        if (bucket.min === Number.MAX_SAFE_INTEGER)
        {
          bucket.min = 0;
        }
      });

      results.load[c] = newLoad;
    });

    results.bucketSize = bucketSizeMin;
  }
};
