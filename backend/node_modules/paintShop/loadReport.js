// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');
const moment = require('moment');
const util = require('../reports/util');

exports.models = [
  require('./models/paintShopLoad'),
  require('./models/paintShopLoadReason'),
  require('settings/models/setting')
];

exports.report = (app, module, options, done) =>
{
  const {
    Setting,
    PaintShopLoad,
    PaintShopLoadReason
  } = module;

  const results = {
    options,
    settings: {
      delayedDuration: 200
    },
    counters: [1, 2, 3],
    reasonLabels: {},
    load: {},
    groups: {},
    totals: {}
  };

  results.counters.forEach(c =>
  {
    results.load[c] = [];

    getCounter(results.totals, c);
  });

  const reasonLabels = {
    null: 'Nieokre≈õlony'
  };

  if (!options.fromTime)
  {
    options.fromTime = moment().startOf('day').subtract(30, 'days').valueOf();
    options.toTime = 0;
    options.interval = 'day';
  }

  if (!options.toTime)
  {
    options.toTime = Date.now();
  }

  options.fromTime = moment(options.fromTime).startOf('day').hours(6).valueOf();
  options.toTime = moment(options.toTime).startOf('day').hours(6).valueOf();

  if (options.interval === 'none' || options.toTime <= options.fromTime)
  {
    options.toTime = moment(options.fromTime).add(1, 'days').valueOf();
  }

  const timeDiff = options.toTime - options.fromTime;
  let maxGroups = timeDiff / util.getIntervalSize(options.interval);

  while (maxGroups > 1500)
  {
    options.interval = util.getNextInterval(options.interval);
    maxGroups = timeDiff / util.getIntervalSize(options.interval);
  }

  const interval = options.interval;
  const groupInterval = interval === 'none' ? 'day' : interval;

  step(
    function()
    {
      Setting
        .find({_id: /^paintShop\.load\./})
        .select({value: 1})
        .lean()
        .exec(this.parallel());

      PaintShopLoadReason
        .find({})
        .select({label: 1})
        .lean()
        .exec(this.parallel());
    },
    function(err, settings, reasons)
    {
      if (err)
      {
        return this.skip(err);
      }

      settings.forEach(setting =>
      {
        results.settings[setting._id.replace('paintShop.load.', '')] = setting.value;
      });

      reasons.forEach(reason =>
      {
        reasonLabels[reason._id] = reason.label;
      });
    },
    function()
    {
      const conditions = {
        '_id.ts': {
          $gte: new Date(options.fromTime),
          $lt: new Date(options.toTime)
        }
      };

      const next = _.once(this.next());
      const cursor = PaintShopLoad
        .find(conditions)
        .sort({'_id.ts': 1})
        .lean()
        .cursor({batchSize: 50});

      cursor.on('error', next);
      cursor.on('end', next);
      cursor.on('data', handleItem);
    },
    function(err)
    {
      if (err)
      {
        return this.skip(err);
      }

      const groupKeys = Object.keys(results.groups).sort();
      const createNextGroupKey = util.createCreateNextGroupKey(groupInterval);
      const groups = [];
      const lastGroupKey = +_.last(groupKeys);
      let groupKey = +groupKeys[0];

      while (groupKey <= lastGroupKey)
      {
        const group = getGroup(groupKey, false);
        const counters = {};

        results.counters.forEach(c =>
        {
          const counter = getCounter(group, c);

          counter.avg = Math.round(counter.sum / (counter.count - counter.zero)) || 0;

          if (counter.min === Number.MAX_SAFE_INTEGER)
          {
            counter.min = 0;
          }

          counters[c] = counter;
        });

        groups.push({
          key: groupKey,
          counters
        });

        groupKey = createNextGroupKey(groupKey);
      }

      results.groups = groups;

      setImmediate(this.next());
    },
    function sendResultsStep(err)
    {
      return done(err, results);
    }
  );

  function handleItem(item)
  {
    if (interval === 'none')
    {
      handleUngrouped(item);
    }

    handleGrouped(item);
  }

  function handleUngrouped(item)
  {
    const time = item._id.ts.getTime();
    const counter = item._id.c;

    if (!results.load[counter])
    {
      results.load[counter] = [];
    }

    results.load[counter].push([time, Math.round(item.d / 1000)]);
  }

  function handleGrouped(item)
  {
    const group = getGroup(item._id.ts, true);
    const groupCounter = getCounter(group, item._id.c);
    const totalCounter = getCounter(results.totals, item._id.c);

    inc(groupCounter, item);
    inc(totalCounter, item);
  }

  function getGroup(date, useShifts)
  {
    const key = util.createGroupKey(groupInterval, date, useShifts);

    if (!results.groups[key])
    {
      results.groups[key] = {};
    }

    return results.groups[key];
  }

  function getCounter(group, counter)
  {
    if (!group[counter])
    {
      group[counter] = {
        sum: 0,
        min: Number.MAX_SAFE_INTEGER,
        max: 0,
        avg: 0,
        zero: 0,
        count: 0,
        delayed: {
          time: 0,
          count: 0,
          reasons: {}
        }
      };
    }

    return group[counter];
  }

  function inc(group, item)
  {
    const duration = Math.round(item.d / 1000);

    group.count += 1;

    if (duration > 0)
    {
      group.sum += duration;

      if (duration < group.min)
      {
        group.min = duration;
      }

      if (duration > group.max)
      {
        group.max = duration;
      }
    }
    else
    {
      group.zero += 1;
    }

    if (duration > results.settings.delayedDuration || item.r)
    {
      group.delayed.count += 1;
      group.delayed.time += duration;

      const reason = item.r ? item.r.toString() : 'null';

      results.reasonLabels[reason] = reasonLabels[reason] || reason;

      if (!group.delayed.reasons[reason])
      {
        group.delayed.reasons[reason] = [0, 0];
      }

      group.delayed.reasons[reason][0] += 1;
      group.delayed.reasons[reason][1] += duration;
    }
  }
};
