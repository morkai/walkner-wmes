// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const modbus = require('h5.modbus');

exports.DEFAULT_CONFIG = {
  mongooseId: 'mongoose',
  master: {},
  maxLoadDuration: 3600 * 1000
};

exports.models = [
  require('./models/paintShopLoad')
];

exports.republishTopics = [

];

exports.start = (app, module) =>
{
  const {PaintShopLoad} = module;

  const previous = {
    2: {ts: 0, value: 0},
    3: {ts: 0, value: 0}
  };
  let timer = null;
  let master = null;

  app.broker.subscribe('app.started').setLimit(1).on('message', readPreviousValues);

  async function readPreviousValues()
  {
    try
    {
      const loads = await Promise.all(Object.keys(previous).map(c =>
      {
        return PaintShopLoad
          .findOne({'_id.c': +c})
          .select({d: 1})
          .sort({'_id.c': 1, '_id.ts': -1})
          .lean()
          .exec();
      }));

      loads.forEach(load =>
      {
        previous[load._id.c].ts = load._id.ts.getTime();
      });

      module.debug('Read previous values.', {previous});

      setUpMaster();
    }
    catch (err)
    {
      module.error(err, 'Failed to read previous values.');

      setTimeout(readPreviousValues, 5000);
    }
  }

  function setUpMaster()
  {
    master = modbus.createMaster(module.config.master);

    master.on('error', err => module.warn(err, 'MODBUS error.'));

    master.on('close', () =>
    {
      clearTimeout(timer);

      module.info('Disconnected.');
    });

    master.on('open', () =>
    {
      module.info('Connected.');

      readCounters();
    });
  }

  function readCounters()
  {
    if (!master.isOpen())
    {
      return;
    }

    master.readHoldingRegisters(0, 4).once('complete', (err, res) =>
    {
      if (err)
      {
        module.error(err, 'Read error.');

        scheduleAction(readCounters, 3000);
      }
      else if (res.isException())
      {
        module.warn(err, 'Read exception.');

        scheduleAction(readCounters, 6000);
      }
      else
      {
        handleReadResponse(res);
      }
    });
  }

  function scheduleAction(action, delay)
  {
    clearTimeout(timer);
    timer = setTimeout(action, delay);
  }

  function clearCounters()
  {
    if (!master.isOpen())
    {
      return;
    }

    master.writeMultipleCoils(36, [true, true, true, true, true, true, true, true], (err, res) =>
    {
      if (err)
      {
        module.error(err, 'Clear error.');

        scheduleAction(clearCounters, 3000);
      }
      else if (res.isException())
      {
        module.warn(err, 'Clear exception.');

        scheduleAction(clearCounters, 6000);
      }
      else
      {
        module.info('Counters cleared.');

        Object.keys(previous).forEach(counter =>
        {
          previous[counter].value = 0;
        });

        scheduleAction(readCounters, 100);
      }
    });
  }

  function handleReadResponse(res)
  {
    const now = Date.now();
    const next = {
      2: {ts: now, value: Buffer.from([res.data[2], res.data[3], res.data[0], res.data[1]]).readUInt32BE(0)},
      3: {ts: now, value: Buffer.from([res.data[6], res.data[7], res.data[4], res.data[5]]).readUInt32BE(0)}
    };
    let clear = false;

    Object.keys(next).forEach(counter =>
    {
      clear = clear || next[counter].value === 1000;

      if (next[counter].value === previous[counter].value)
      {
        return;
      }

      app.broker.publish('paintShop.load.changed', {
        counter: +counter,
        timestamp: next[counter].ts,
        duration: Math.max(0, next[counter].ts - previous[counter].ts)
      });

      Object.assign(previous[counter], next[counter]);
    });

    if (clear)
    {
      scheduleAction(clearCounters, 1);
    }
    else
    {
      scheduleAction(readCounters, 1000);
    }
  }
};
