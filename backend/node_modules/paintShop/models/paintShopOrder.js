// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const userInfoSchema = require('user/models/userInfoSchema');

exports.name = 'PaintShopOrder';

exports.setUp = (app, mongoose) =>
{
  const componentSchema = new mongoose.Schema({
    item: String,
    nc12: String,
    name: String,
    qty: Number,
    unit: String
  }, {
    _id: false,
    minimize: false
  });

  const childOrderSchema = new mongoose.Schema({
    order: String,
    nc12: String,
    name: String,
    qty: Number,
    mrp: String,
    manHours: Number,
    components: [componentSchema],
    notes: [{}],
    deleted: {
      type: Boolean,
      default: false
    }
  }, {
    _id: false,
    minimize: false
  });

  const workOrderSchema = new mongoose.Schema({
    _id: String,
    createdAt: Date,
    creator: userInfoSchema,
    childOrder: String,
    qtyDone: Number,
    shift: Date,
    workers: [userInfoSchema]
  }, {
    _id: false,
    minimize: false
  });

  const schema = new mongoose.Schema({
    _id: String,
    status: {
      type: String,
      enum: ['new', 'aside', 'started', 'startedMsp', 'partial', 'finished', 'cancelled'],
      default: 'new'
    },
    startedAt: Date,
    finishedAt: Date,
    comment: String,
    order: String,
    followups: [String],
    date: Date,
    nc12: String,
    name: String,
    qty: Number,
    qtyDone: Number,
    qtyPaint: Number,
    qtyDlv: Number,
    cabin: Number,
    mrp: String,
    placement: String,
    startTime: Number,
    paint: {
      nc12: String,
      name: String
    },
    childOrders: [childOrderSchema],
    workOrders: [workOrderSchema],
    notes: [{}]
  }, {
    id: false,
    minimize: false
  });

  schema.statics.TOPIC_PREFIX = 'paintShop.orders';
  schema.statics.BROWSE_LIMIT = 1000;

  schema.index({date: -1});
  schema.index({status: 1, date: -1});
  schema.index({order: 1});
  schema.index({'childOrders.order': 1});
  schema.index({'workOrders.shift': 1});

  schema.methods.act = function(input, done)
  {
    if (!_.isPlainObject(input))
    {
      return setImmediate(done, app.createError('Invalid input.', 'INPUT', 400));
    }

    const changes = {
      _id: this._id,
      order: this.order
    };

    const comment = input.comment;

    if (typeof comment === 'string' && comment.length)
    {
      changes.comment = comment;
    }

    switch (input.action)
    {
      case 'start':
        changes.status = 'started';
        changes.startedAt = new Date();
        changes.finishedAt = null;
        changes.cabin = typeof input.cabin === 'number' ? input.cabin : 0;
        break;

      case 'startMsp':
        changes.status = 'startedMsp';
        changes.startedAt = new Date();
        changes.finishedAt = null;
        changes.cabin = typeof input.cabin === 'number' ? input.cabin : 0;
        break;

      case 'finish':
      {
        if (typeof input.qtyDone !== 'number' || input.qtyDone <= 0)
        {
          input.qtyDone = this.qty;
        }

        changes.finishedAt = new Date();
        changes.qtyDone = input.qtyDone;
        changes.status = changes.qtyDone >= this.qty ? 'finished' : 'partial';

        if (Array.isArray(input.workOrders))
        {
          changes.workOrders = input.workOrders;
        }
        break;
      }

      case 'deliver':
      {
        if (typeof input.qtyDlv !== 'number' || input.qtyDlv === 0)
        {
          const diff = this.qty - this.qtyDlv;

          if (diff <= 0)
          {
            return setImmediate(done);
          }

          input.qtyDlv = diff;
        }

        if (this.qtyDlv + input.qtyDlv > this.qty)
        {
          if (this.qtyDlv === this.qty)
          {
            return setImmediate(done);
          }

          input.qtyDlv = this.qty - this.qtyDlv;
        }

        changes.qtyDlv = this.qtyDlv + input.qtyDlv;
        break;
      }

      case 'continue':
        changes.status = 'started';
        changes.finishedAt = null;
        changes.cabin = typeof input.cabin === 'number' ? input.cabin : 0;
        break;

      case 'reset':
        changes.status = 'new';
        changes.startedAt = null;
        changes.finishedAt = null;
        changes.qtyDone = 0;
        changes.qtyDlv = 0;
        changes.cabin = 0;
        break;

      case 'aside':
        changes.status = 'aside';
        break;

      case 'cancel':
        changes.status = 'cancelled';
        break;

      case 'comment':
        break;

      case 'addWorkOrder':
        if (!_.isPlainObject(input.workOrder))
        {
          return setImmediate(done, app.createError('Invalid work order.', 'INPUT', 400));
        }

        changes.workOrders = this.workOrders.toObject();
        changes.workOrders.push(input.workOrder);
        break;

      case 'removeWorkOrder':
        if (!_.isPlainObject(input.workOrder))
        {
          return setImmediate(done, app.createError('Invalid work order.', 'INPUT', 400));
        }

        changes.workOrders = this.workOrders.filter(o => o._id !== input.workOrder._id);
        break;

      default:
        return setImmediate(done, app.createError('Unknown action.', 'INPUT', 400));
    }

    this.set(changes).save(err => done(err, changes));
  };

  return schema;
};
