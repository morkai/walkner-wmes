// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const moment = require('moment');
const axios = require('axios').create({
  timeout: 10000,
  responseType: 'json',
  maxRedirects: 0,
  validateStatus: status => status === 200 || status === 404
});

const SOURCE_URI = `https://api.nbp.pl/api/exchangerates/tables/a/{from}/{to}`;
const MAX_BATCH_SIZE = 90;

module.exports = (app, module, src) =>
{
  if (src !== 'pln')
  {
    throw app.createError('Unsupported source currency.', 'INPUT', 400, {
      sourceCurrency: src
    });
  }

  return {
    resolveNextUpdateAt: () =>
    {
      const nextUpdateAt = moment();
      const h = 20;

      if (nextUpdateAt.hours() >= h)
      {
        nextUpdateAt.add(1, 'days').startOf('day');
      }
      else
      {
        nextUpdateAt.hours(h).startOf('hour');
      }

      return nextUpdateAt;
    },
    resolveFromDate: () =>
    {
      const fromDate = moment();

      if (fromDate < 14)
      {
        fromDate.subtract(1, 'days');
      }

      if (fromDate.isoWeekday() > 5)
      {
        fromDate.isoWeekday(5);
      }

      return fromDate.startOf('day');
    },
    fetch: (options) =>
    {
      return fetchCurrencyRates(options.from, options.to);
    }
  };

  async function fetchCurrencyRates(from, to)
  {
    from = moment.utc(from, 'YYYY-MM-DD');

    if (!from.isValid())
    {
      throw app.createError('Invalid from date.', 'INPUT', 400);
    }

    to = moment.utc(to || moment().format('YYYY-MM-DD'), 'YYYY-MM-DD');

    if (!to.isValid())
    {
      throw app.createError('Invalid to date.', 'INPUT', 400);
    }

    if (from.valueOf() > to.valueOf())
    {
      [from, to] = [to, from];
    }

    const batches = [];

    while (true) // eslint-disable-line no-constant-condition
    {
      const batch = {
        from: from.format('YYYY-MM-DD'),
        to: null
      };

      batches.push(batch);

      from.add(MAX_BATCH_SIZE, 'days');

      if (from.valueOf() >= to.valueOf())
      {
        batch.to = to.format('YYYY-MM-DD');

        break;
      }
      else
      {
        batch.to = from.format('YYYY-MM-DD');

        from.add(1, 'days');
      }
    }

    const currencyRates = [];

    while (batches.length)
    {
      const batch = batches.shift();

      await fetchNextCurrencyRates(batch.from, batch.to, currencyRates);
    }

    return currencyRates;
  }

  async function fetchNextCurrencyRates(from, to, currencyRates)
  {
    const url = SOURCE_URI.replace('{from}', from).replace('{to}', to);
    const {data} = await axios.get(url);

    if (typeof data === 'string' && data.includes('Brak danych'))
    {
      return;
    }

    if (!Array.isArray(data))
    {
      throw app.createError('Invalid response data.', 'RESPONSE', 500);
    }

    data.forEach(({effectiveDate, rates}) =>
    {
      if (!Array.isArray(rates))
      {
        throw app.createError('Invalid response data.', 'RESPONSE', 500);
      }

      const date = moment.utc(effectiveDate, 'YYYY-MM-DD').toDate();
      const currencyRate = {
        _id: date,
        rates: {
          [src]: {}
        }
      };

      rates.forEach(rate =>
      {
        const tgt = rate.code.toLowerCase();

        if (module.config.currencies[src].includes(tgt))
        {
          currencyRate.rates[src][tgt] = rate.mid;
        }
      });

      currencyRates.push(currencyRate);
    });
  }
};
