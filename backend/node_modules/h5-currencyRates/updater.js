// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const moment = require('moment');

module.exports = (app, module) =>
{
  const {CurrencyRate} = module;

  if (app.options.env !== 'development')
  {
    app.broker.subscribe('app.started', init);
  }

  module.updateCurrency = updateCurrency;

  function init()
  {
    Object.keys(module.config.currencies).forEach(initCurrency);
  }

  async function initCurrency(currency)
  {
    const toDate = moment().startOf('day').utc(true);
    let fromDate = toDate.clone().subtract(7, 'days');

    try
    {
      const recentCurrency = await CurrencyRate
        .findOne({
          _id: {$gte: fromDate.toDate()},
          [`rates.${currency}`]: {$exists: true}
        })
        .select({_id: 1})
        .sort({_id: -1})
        .lean()
        .exec();

      if (recentCurrency)
      {
        fromDate = moment.utc(recentCurrency._id);
      }

      await updateCurrency(currency, fromDate.format('YYYY-MM-DD'), toDate.format('YYYY-MM-DD'));

      module.info(`Initialized currency.`, {
        currency,
        fromDate: fromDate.toDate(),
        toDate: toDate.toDate()
      });

      scheduleCurrencyUpdate(currency);
    }
    catch (err)
    {
      module.error(err, `Failed to initialize currency.`, {currency});

      setTimeout(initCurrency, 60000, currency);
    }
  }

  async function updateCurrency(sourceCurrency, from, to)
  {
    const currencyRates = await module.getSource(sourceCurrency).fetch({from, to});

    if (!currencyRates.length)
    {
      return;
    }

    const ops = currencyRates.map(currencyRate =>
    {
      const $set = {};

      Object.keys(currencyRate.rates[sourceCurrency]).forEach(targetCurrency =>
      {
        $set[`rates.${sourceCurrency}.${targetCurrency}`] = currencyRate.rates[sourceCurrency][targetCurrency];
      });

      return {
        updateOne: {
          filter: {_id: currencyRate._id},
          update: {$set},
          upsert: true
        }
      };
    });

    while (ops.length)
    {
      await CurrencyRate.collection.bulkWrite(ops.splice(0, 100));

      app.broker.publish(`${CurrencyRate.TOPIC_PREFIX}.updated`, {
        updated: currencyRates
      });
    }

    app.broker.publish(`${CurrencyRate.TOPIC_PREFIX}.synced`, {sourceCurrency, from, to});
  }

  async function tryUpdateCurrency(currency, tryCount)
  {
    try
    {
      const fromDate = module.getSource(currency).resolveFromDate();
      const toDate = moment().startOf('day').utc(true);

      await updateCurrency(currency, fromDate.format('YYYY-MM-DD'), toDate.format('YYYY-MM-DD'));

      module.info(`Updated currency.`, {
        currency,
        fromDate: fromDate.toDate(),
        toDate: toDate.toDate()
      });

      scheduleCurrencyUpdate(currency);
    }
    catch (err)
    {
      module.error(err, `Failed to update currency.`, {currency});

      setTimeout(tryUpdateCurrency, Math.min(tryCount, 10) * 60000, currency, tryCount + 1);
    }
  }

  function scheduleCurrencyUpdate(currency)
  {
    const nextUpdateAt = module.getSource(currency).resolveNextUpdateAt();

    setTimeout(
      callAfter,
      Math.abs(nextUpdateAt.diff(Date.now())),
      nextUpdateAt.valueOf(),
      tryUpdateCurrency.bind(null, currency, 1)
    );
  }

  function callAfter(time, cb)
  {
    const now = Date.now();

    if (now >= time)
    {
      cb();
    }
    else
    {
      setTimeout(callAfter, time - now + 100, time, cb);
    }
  }
};


