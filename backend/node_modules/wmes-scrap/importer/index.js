// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const path = require('path');
const moment = require('moment');
const step = require('h5.step');
const fs = require('fs-extra');
const {ObjectId} = require('mongoose').Types;
const parseSapTextTable = require('sap/util/parseSapTextTable');
const parseSapNumber = require('sap/util/parseSapNumber');
const parseSapString = require('sap/util/parseSapString');
const parseSapDate = require('sap/util/parseSapDate');
const parseSapTime = require('sap/util/parseSapTime');

exports.DEFAULT_CONFIG = {
  mongooseId: 'mongoose',
  filterRe: /^SCRAP\.txt$/,
  parsedOutputDir: null
};

exports.models = [
  require('../models/scrapType'),
  require('../models/scrapComponent'),
  require('h5-currencyRates/models/currencyRate')
];

exports.recordTopics = {
  info: ['scrap.components.synced'],
  error: ['scrap.components.syncFailed']
};

exports.requiredModules = 'mongoose';

exports.start = (app, module) =>
{
  const {CurrencyRate, ScrapType, ScrapComponent} = module;

  const filePathCache = {};
  const queue = [];
  let locked = false;

  app.broker.subscribe('directoryWatcher.changed', queueFile).setFilter(filterFile);

  function filterFile(fileInfo)
  {
    if (filePathCache[fileInfo.filePath] || !module.config.filterRe.test(fileInfo.fileName))
    {
      return false;
    }

    fileInfo.timeKey = createTimeKey(fileInfo.timestamp);

    return true;
  }

  function createTimeKey(timestamp)
  {
    return moment(timestamp).format('YYMMDDHHMMSS');
  }

  function queueFile(fileInfo)
  {
    filePathCache[fileInfo.filePath] = true;

    queue.push(fileInfo);

    module.info('Queued...', {fileInfo});

    setImmediate(importNext);
  }

  function importNext()
  {
    if (locked)
    {
      return;
    }

    const fileInfo = queue.shift();

    if (!fileInfo)
    {
      return;
    }

    locked = true;

    const startTime = Date.now();

    module.info('Importing...', {fileInfo});

    importFile(fileInfo, function(err, count)
    {
      cleanUpFileInfoFile(fileInfo);

      if (err)
      {
        module.error(err, 'Failed to import.', {fileInfo});

        app.broker.publish('scrap.components.syncFailed', {
          timestamp: fileInfo.timestamp,
          error: err.message
        });
      }
      else
      {
        module.info('Imported!', {fileInfo, count, duration: Date.now() - startTime});

        app.broker.publish('scrap.components.synced', {
          timestamp: fileInfo.timestamp,
          count
        });
      }

      locked = false;

      setImmediate(importNext);
    });
  }

  function importFile(fileInfo, done)
  {
    step(
      function()
      {
        fs.readFile(fileInfo.filePath, {encoding: 'utf8'}, this.next());
      },
      function(err, fileContents)
      {
        if (err)
        {
          return this.skip(err);
        }

        module.info('Parsing...', {fileInfo, fileSize: fileContents.length});

        const t = Date.now();

        this.output = {
          minTime: null,
          maxTime: null
        };
        this.components = parseTable(fileContents, this.output);
        this.count = this.components.length;

        module.info('Parsed!', {
          fileInfo,
          count: this.count,
          duration: Date.now() - t
        });

        if (this.count === 0)
        {
          return this.skip();
        }

        setImmediate(this.next());
      },
      function()
      {
        CurrencyRate
          .findOne({_id: {$lte: this.output.minTime}})
          .select({'rates.pln.eur': 1})
          .lean()
          .exec(this.parallel());

        CurrencyRate
          .find({
            _id: {
              $gte: this.output.minTime,
              $lte: this.output.maxTime
            }
          })
          .select({'rates.pln.eur': 1})
          .sort({_id: 1})
          .lean()
          .exec(this.parallel());

        ScrapType
          .find({active: true})
          .select({patterns: 1})
          .sort({position: 1})
          .lean()
          .exec(this.parallel());
      },
      function(err, fromCurrencyRate, currencyRates, scrapTypes)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (fromCurrencyRate && fromCurrencyRate._id.getTime() !== currencyRates[0]._id.getTime())
        {
          currencyRates.push({
            _id: this.output.minTime,
            rates: fromCurrencyRate.rates
          });
        }

        this.currencyRates = new Map();

        currencyRates.forEach(currencyRate =>
        {
          this.currencyRates.set(currencyRate._id.getTime(), currencyRate.rates.pln.eur);
        });

        const from = moment.utc(this.output.minTime.getTime());
        const to = this.output.maxTime;

        while (from.valueOf() < to)
        {
          const rate = this.currencyRates.get(from.valueOf()) || 0;

          from.add(1, 'days');

          if (!this.currencyRates.has(from.valueOf()))
          {
            this.currencyRates.set(from.valueOf(), rate);
          }
        }

        this.scrapTypes = [];

        scrapTypes.forEach(scrapType =>
        {
          if (scrapType.patterns.length)
          {
            this.scrapTypes.push({
              _id: scrapType._id,
              match: ScrapType.createMatcher(scrapType.patterns)
            });
          }
        });

        setImmediate(this.next());
      },
      function()
      {
        this.components.forEach(component =>
        {
          const workDay = resolveWorkDay(component.time);
          const currencyRate = this.currencyRates.get(workDay) || 0;

          component.eur = Math.round(component.pln / currencyRate * 100) / 100;

          const scrapType = this.scrapTypes.find(scrapType => scrapType.match(component.name));

          if (scrapType)
          {
            component.type = scrapType._id;
          }
        });

        setImmediate(this.next());
      },
      function()
      {
        ScrapComponent
          .deleteMany({
            time: {
              $gte: this.output.minTime,
              $lte: this.output.maxTime
            }
          })
          .exec(this.next());
      },
      function(err)
      {
        if (err)
        {
          return this.skip(err);
        }

        insertNextBatch(this.components, this.next());
      },
      function(err)
      {
        if (err)
        {
          return done(err);
        }

        done(null, this.count);
      }
    );
  }

  function insertNextBatch(remainingComponents, done)
  {
    if (remainingComponents.length === 0)
    {
      return done();
    }

    ScrapComponent.collection.insertMany(remainingComponents.splice(0, 200), err =>
    {
      if (err)
      {
        return done(err);
      }

      insertNextBatch(remainingComponents, done);
    });
  }

  function resolveWorkDay(date)
  {
    const workDay = moment.utc(date.getTime());

    if (workDay.hours() < 6)
    {
      workDay.subtract(1, 'days');
    }

    if (workDay.isoWeekday() > 5)
    {
      workDay.isoWeekday(5);
    }

    return workDay.startOf('day').valueOf();
  }

  function cleanUpFileInfoFile(fileInfo)
  {
    setTimeout(removeFilePathFromCache, 15000, fileInfo.filePath);

    if (module.config.parsedOutputDir)
    {
      moveFileInfoFile(fileInfo.filePath);
    }
    else
    {
      deleteFileInfoFile(fileInfo.filePath);
    }
  }

  function moveFileInfoFile(oldFilePath)
  {
    const newFilePath = path.join(module.config.parsedOutputDir, path.basename(oldFilePath));

    fs.move(oldFilePath, newFilePath, {overwrite: true}, err =>
    {
      if (err)
      {
        module.error(err, 'Failed to rename file.', {oldFilePath, newFilePath});
      }
    });
  }

  function deleteFileInfoFile(filePath)
  {
    fs.unlink(filePath, err =>
    {
      if (err)
      {
        module.error(err, 'Failed to delete file.', {filePath});
      }
    });
  }

  function removeFilePathFromCache(filePath)
  {
    delete filePathCache[filePath];
  }

  function parseTable(input, output)
  {
    return parseSapTextTable(input, {
      columnMatchers: {
        code: /^Material$/,
        name: /Description/,
        mvt: /^MvT$/,
        qty: /^Quantity/,
        uom: /^EUn$/,
        pln: /Amount/,
        user: /User/,
        date: /Date/,
        time: /Time/,
        text: /Text/
      },
      valueParsers: {
        code: input => input.replace(/^0+/, ''),
        name: input => parseSapString(input, 'latin2'),
        mvt: parseSapNumber,
        qty: parseSapNumber,
        pln: parseSapNumber,
        date: parseSapDate,
        time: parseSapTime,
        text: parseSapString
      },
      itemDecorator: obj =>
      {
        const time = new Date(Date.UTC(
          obj.date.y, obj.date.m - 1, obj.date.d,
          obj.time.h, obj.time.m, obj.time.s
        ));

        if (!output.minTime || time < output.minTime)
        {
          output.minTime = time;
        }

        if (!output.maxTime || time > output.maxTime)
        {
          output.maxTime = time;
        }

        return {
          _id: new ObjectId(),
          code: obj.code,
          name: obj.name,
          type: null,
          mvt: obj.mvt,
          qty: obj.qty * -1,
          uom: obj.uom,
          pln: obj.pln * -1,
          eur: 0,
          user: obj.user,
          time,
          text: obj.text
        };
      }
    });
  }
};
