// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const os = require('os');
const _ = require('lodash');
const step = require('h5.step');
const resolveIpAddress = require('util/resolveIpAddress');
let mongoose = null;
let bcrypt = null;
let cookie = null;
let cookieParser = null;

/* eslint-disable no-empty */

try { mongoose = require('mongoose'); }
catch (err) {}

try { bcrypt = require('bcrypt'); }
catch (err) {}

try { cookie = require('cookie'); }
catch (err) {}

try { cookieParser = require('cookie-parser'); }
catch (err) {}

/* eslint-enable no-empty */

exports.DEFAULT_CONFIG = {
  sioId: 'sio',
  expressId: 'express',
  mongooseId: 'mongoose',
  privileges: [],
  root: {
    password: '$2a$10$qSJWcm1LtN0OzlSHkSRl..ZezbqHAjW2ZuHzBd.F0CTQoWBvf0uQi'
  },
  guest: {},
  localAddresses: null,
  loginFailureDelay: 1000,
  userInfoIdProperty: '_id'
};

exports.models = [
  require('./models/user')
];

exports.onModuleSetUp = (app, {module, setUpAppModule}) =>
{
  (setUpAppModule.userPrivileges || []).forEach(privilege => module.config.privileges.push(privilege));
};

exports.start = (app, module) =>
{
  const localAddresses = module.config.localAddresses || getLocalAddresses();

  module.config.privileges = _.uniq(module.config.privileges);

  module.root = Object.assign(module.config.root, {
    loggedIn: true,
    super: true,
    _id: '52a33b8bfb955dac8a92261b',
    login: 'root',
    privileges: ['SUPER']
  });

  module.guest = Object.assign({privileges: []}, module.config.guest, {
    loggedIn: false,
    super: false,
    _id: '52a33b9cfb955dac8a92261c',
    login: 'guest',
    password: undefined
  });

  module.auth = createAuthMiddleware;
  module.authenticate = authenticate;
  module.getRealIp = getRealIp;
  module.isLocalIpAddress = isLocalIpAddress;
  module.isAllowedTo = isAllowedTo;
  module.createUserInfo = createUserInfo;
  module.prepareSessionUser = prepareSessionUser;

  app.onModuleReady([module.config.expressId, module.config.sioId], setUpSio);

  app.broker.subscribe('app.started').setLimit(1).on('message', removeApiSessions);

  app.broker.subscribe('express.beforeRouter').setLimit(1).on('message', (message) =>
  {
    const expressModule = message.module;
    const expressApp = expressModule.app;

    expressApp.use(ensureUserMiddleware);
  });

  /**
   * @private
   * @returns {Array.<string>}
   */
  function getLocalAddresses()
  {
    const localAddresses = [];

    _.forEach(os.networkInterfaces(), (addresses) =>
    {
      _.forEach(addresses, (address) =>
      {
        if (address.family === 'IPv4')
        {
          localAddresses.push(address.address.replace(/\.[0-9]+$/, ''));
        }
      });
    });

    return localAddresses;
  }

  /**
   * @param {string} ipAddress
   * @returns {boolean}
   */
  function isLocalIpAddress(ipAddress)
  {
    if (ipAddress === '127.0.0.1' || ipAddress === '::1')
    {
      return true;
    }

    for (let i = 0, l = localAddresses.length; i < l; ++i)
    {
      const pattern = localAddresses[i];

      if (typeof pattern === 'string')
      {
        if (ipAddress.indexOf(pattern) === 0)
        {
          return true;
        }
      }
      else if (pattern.test(ipAddress))
      {
        return true;
      }
    }

    return false;
  }

  /**
   * @private
   * @param {string} ipAddress
   * @returns {Object}
   */
  function createGuestData(ipAddress)
  {
    return prepareSessionUser(_.cloneDeep(module.guest), false, {address: ipAddress});
  }

  /**
   * @param {Object} user
   * @param {boolean} loggedIn
   * @param {IncomingMessage} req
   * @returns {Object}
   */
  function prepareSessionUser(user, loggedIn, req)
  {
    delete user.password;
    delete user.apiKey;

    user._id = user._id.toString();
    user.loggedIn = loggedIn;
    user.ipAddress = getRealIp({}, req);
    user.local = isLocalIpAddress(user.ipAddress);
    user.super = _.includes(user.privileges, 'SUPER');

    return user;
  }

  function isAllowedTo(user, anyPrivileges)
  {
    if (!user)
    {
      return false;
    }

    if (user.super)
    {
      return true;
    }

    if (typeof anyPrivileges === 'string')
    {
      anyPrivileges = [[anyPrivileges]];
    }

    if (!Array.isArray(anyPrivileges))
    {
      throw new Error(`[anyPrivileges] must be a string or an array.`);
    }

    if (anyPrivileges.length
      && user.local
      && anyPrivileges[0].some((privilege) => privilege === 'LOCAL'))
    {
      return true;
    }

    if (!user.privileges)
    {
      return false;
    }

    if (!anyPrivileges.length)
    {
      return true;
    }

    for (let i = 0, l = anyPrivileges.length; i < l; ++i)
    {
      const allPrivileges = anyPrivileges[i];
      let matches = 0;

      for (let ii = 0; ii < allPrivileges.length; ++ii)
      {
        const privilege = allPrivileges[ii];

        if (privilege === 'USER')
        {
          matches += user.loggedIn ? 1 : 0;
        }
        else if (/^FN:/.test(privilege))
        {
          const requiredFn = privilege.substring(3);

          if (requiredFn.includes('*'))
          {
            const requiredFnRe = new RegExp(`^${requiredFn.replace(/\*/g, '.*?')}$`);

            matches += requiredFnRe.test(user.prodFunction) ? 1 : 0;
          }
          else
          {
            matches += user.prodFunction === requiredFn ? 1 : 0;
          }
        }
        else
        {
          matches += hasPrivilege(user, allPrivileges[ii]) ? 1 : 0;
        }
      }

      if (matches === allPrivileges.length)
      {
        return true;
      }
    }

    return false;
  }

  function preparePrivileges(user)
  {
    if (!Array.isArray(user.privileges))
    {
      user.privileges = [];
    }

    user.privilegesString = '|' + user.privileges.join('|');
    user.privilegesMap = {};

    _.forEach(user.privileges, (privilege) =>
    {
      user.privilegesMap[privilege] = true;
    });

    return user;
  }

  function hasPrivilege(user, privilege)
  {
    if (_.isEmpty(user.privilegesString))
    {
      preparePrivileges(user);
    }

    if (privilege.charAt(privilege.length - 1) === '*')
    {
      return user.privilegesString.indexOf('|' + privilege.substr(0, privilege.length - 1)) !== -1;
    }

    return user.privilegesMap[privilege] === true;
  }

  function ensureUserMiddleware(req, res, next)
  {
    if (!req.session)
    {
      return next();
    }

    const user = req.session.user;

    if (!user)
    {
      req.session.user = createGuestData(getRealIp({}, req));
    }

    return next();
  }

  /**
   * @returns {function(object, object, function)}
   */
  function createAuthMiddleware(...args)
  {
    const anyPrivileges = [];

    for (let i = 0, l = args.length; i < l; ++i)
    {
      let allPrivileges = args[i];

      if (!Array.isArray(allPrivileges))
      {
        allPrivileges = [allPrivileges];
      }

      anyPrivileges.push(allPrivileges);
    }

    return function authMiddleware(req, res, next)
    {
      step(
        function()
        {
          let sessionUser = req.session && req.session.user;

          if (!sessionUser)
          {
            sessionUser = createGuestData(getRealIp({}, req));
          }

          const apiKey = req.headers['x-api-key'] || (req.body && req.body.apiKey) || null;

          if (sessionUser._id === module.guest._id && typeof apiKey === 'string' && apiKey.length)
          {
            resolveApiUser(sessionUser, apiKey, req, this.next());
          }
          else
          {
            setImmediate(this.next(), null, sessionUser);
          }
        },
        function(err, sessionUser)
        {
          if (err)
          {
            return this.skip(err);
          }

          if (req.session)
          {
            req.session.user = sessionUser;
          }

          if (sessionUser.apiUser)
          {
            req.sessionID = null;
          }

          if (!isAllowedTo(sessionUser, anyPrivileges))
          {
            return this.skip(app.createError('Not allowed.', 'AUTH', 403, {
              method: req.method,
              url: req.url,
              privileges: anyPrivileges,
              user: _.pick(sessionUser, ['_id', 'login', 'ipAddress', 'prodFunction', 'privileges'])
            }));
          }
        },
        next
      );
    };
  }

  function resolveApiUser(sessionUser, apiKey, req, done)
  {
    const {User} = module;
    const apiUserId = req.headers['x-api-user'];

    step(
      function()
      {
        User.findOne({apiKey, active: true}).exec(this.parallel());

        if (apiUserId && apiUserId !== module.guest._id)
        {
          User.findById(apiUserId).exec(this.parallel());
        }
      },
      function(err, apiUser, loggedUser)
      {
        if (err)
        {
          return done(err);
        }

        if (!apiUser)
        {
          return done(app.createError('Unknown user API key.', 'INPUT', 401));
        }

        if (apiUserId && apiUserId !== module.guest._id && !loggedUser)
        {
          return done(app.createError('Unknown API user.', 'INPUT', 400));
        }

        const user = loggedUser || apiUser;

        Object.assign(sessionUser, user.toObject());
        prepareSessionUser(sessionUser, true, req);

        sessionUser.apiUser = true;

        done(null, sessionUser);
      }
    );
  }

  function authenticate(credentials, done)
  {
    const apiKey = typeof credentials.apiKey === 'string' && credentials.apiKey.length >= 32
      ? credentials.apiKey
      : null;

    step(
      function()
      {
        if (apiKey)
        {
          return;
        }

        if (!_.isString(credentials.login)
          || _.isEmpty(credentials.login)
          || !_.isString(credentials.password)
          || _.isEmpty(credentials.password))
        {
          return this.skip(app.createError(`Invalid credentials.`, 'INPUT', 400));
        }
      },
      function findUserDataStep()
      {
        const next = this.next();

        if (!apiKey && credentials.login.toLowerCase() === module.root.login.toLowerCase())
        {
          next(null, [{...module.root}]);

          return;
        }

        const User = app[module.config.mongooseId].model('User');
        const conditions = {};
        let property;
        let value;

        if (apiKey)
        {
          property = 'apiKey';
          value = apiKey;
        }
        else
        {
          property = /^.*?@.*?\.[a-zA-Z]+$/.test(credentials.login) ? 'email' : 'login';
          value = new RegExp(`^${_.escapeRegExp(credentials.login)}$`, 'i');
        }

        conditions[property] = value;

        if (User.schema.path('active'))
        {
          conditions.active = true;
        }

        User.find(conditions).exec(next);
      },
      function checkUserDataStep(err, users)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (users.length === 0)
        {
          return this.skip(app.createError(`Invalid credentials.`, 'INPUT', 401));
        }

        if (users.length > 1)
        {
          return this.skip(app.createError(`Many matching users found.`, 'MANY_MATCHES', 400));
        }

        const userData = _.isFunction(users[0].toObject)
          ? users[0].toObject()
          : users[0];

        const hasAnyPrivileges = !_.isEmpty(userData.privileges);
        const hasProdFunction = !_.isEmpty(userData.prodFunction);
        const hasUnsafePassword = !apiKey && (userData.login === credentials.password
          || userData.personellId === credentials.password);

        if (hasUnsafePassword && (hasAnyPrivileges || hasProdFunction))
        {
          return this.skip(app.createError(`Unsafe password: reset required.`, 'UNSAFE_PASSWORD', 400));
        }

        this.userData = userData;
      },
      function comparePasswordStep()
      {
        if (apiKey)
        {
          setImmediate(this.next(), null, true);
        }
        else if (bcrypt)
        {
          bcrypt.compare(credentials.password, this.userData.password, this.next());
        }
        else
        {
          setImmediate(this.next(), null, credentials.password === this.userData.password);
        }
      },
      function handleComparePasswordResultStep(err, result)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!result)
        {
          return this.skip(app.createError(`Invalid credentials.`, 'INPUT', 401));
        }
      },
      function(err)
      {
        if (err)
        {
          delayAuthFailure(err, done);
        }
        else
        {
          done(null, this.userData);
        }
      }
    );
  }

  function delayAuthFailure(err, done)
  {
    setTimeout(done, module.config.loginFailureDelay, err);
  }

  function createUserInfo(userData, addressData)
  {
    if (!userData)
    {
      userData = {};
    }

    const userInfo = {
      [module.config.userInfoIdProperty]: module.guest._id.toString(),
      ip: '',
      label: module.guest.login
    };

    try
    {
      const userId = String(userData._id || userData.id);

      userInfo[module.config.userInfoIdProperty] = mongoose
        ? mongoose.Types.ObjectId.createFromHexString(userId).toHexString()
        : userId;
    }
    catch (err) {} // eslint-disable-line no-empty

    if (typeof userData.label === 'string')
    {
      userInfo.label = userData.label;
    }
    else if (userData.firstName && userData.lastName)
    {
      userInfo.label = userData.lastName + ' ' + userData.firstName;
    }
    else if (userData.login)
    {
      userInfo.label = String(userData.login);
    }

    userInfo.ip = getRealIp(userData, addressData);

    return userInfo;
  }

  function getRealIp(userData, addressData)
  {
    let ip = '';

    if (addressData)
    {
      ip = resolveIpAddress(addressData);
    }

    if (ip === '')
    {
      ip = userData.ip || userData.ipAddress || '0.0.0.0';
    }

    return ip;
  }

  /**
   * @private
   */
  function setUpSio()
  {
    const sioModule = app[module.config.sioId];
    const expressModule = app[module.config.expressId];
    const sosMap = {};
    const usersToSocketsMap = {};

    sioModule.use((socket, done) =>
    {
      if (!cookie || !cookieParser)
      {
        return done(app.createError('cookie/cookie-parser not available.', 'NO_DEPENDENCY', 500));
      }

      const handshakeData = socket.handshake;
      const cookies = cookie.parse(String(handshakeData.headers.cookie));
      const sessionCookie = cookies[expressModule.config.sessionCookieKey];

      if (typeof sessionCookie !== 'string')
      {
        handshakeData.sessionId = String(Date.now() + Math.random());
        handshakeData.user = createGuestData(getRealIp({}, handshakeData));

        return done();
      }

      const sessionId = cookieParser.signedCookie(sessionCookie, expressModule.config.cookieSecret);

      expressModule.sessionStore.get(sessionId, (err, session) =>
      {
        if (err)
        {
          return done(err);
        }

        handshakeData.sessionId = sessionId;
        handshakeData.user = session && session.user
          ? session.user
          : createGuestData(getRealIp({}, handshakeData));

        return done();
      });
    });

    sioModule.sockets.on('connection', (socket) =>
    {
      const handshake = socket.handshake;

      if (handshake.sessionId)
      {
        socket.sessionId = handshake.sessionId;

        if (typeof sosMap[socket.sessionId] === 'undefined')
        {
          sosMap[socket.sessionId] = {};
        }

        sosMap[socket.sessionId][socket.id] = true;
      }

      if (handshake.user)
      {
        socket.emit('user.reload', socket.handshake.user);
      }

      mapUserToSocket(socket);

      socket.on('disconnect', () =>
      {
        const userSockets = socket.handshake.user ? usersToSocketsMap[socket.handshake.user._id] : null;

        if (userSockets)
        {
          delete userSockets[socket.id];

          if (Object.keys(userSockets).length === 0)
          {
            delete userSockets[socket.handshake.user._id];
          }
        }

        const sessionSockets = sosMap[socket.sessionId];

        if (sessionSockets)
        {
          delete sessionSockets[socket.id];

          if (Object.keys(sessionSockets).length === 0)
          {
            delete sessionSockets[socket.sessionId];
          }
        }
      });
    });

    app.broker.subscribe('users.login', (message) =>
    {
      const sockets = moveSos(message.oldSessionId, message.newSessionId);

      _.forEach(sockets, (socket) =>
      {
        socket.handshake.sessionId = message.newSessionId;
        socket.handshake.user = message.user;

        mapUserToSocket(socket);

        socket.emit('user.reload', message.user);
      });
    });

    app.broker.subscribe('users.logout', (message) =>
    {
      const sockets = moveSos(message.oldSessionId, message.newSessionId);
      const userId = message.user._id;
      const userToSocketsMap = usersToSocketsMap[userId];

      _.forEach(sockets, (socket) =>
      {
        socket.handshake.sessionId = message.newSessionId;
        socket.handshake.user = createGuestData(getRealIp({}, socket));

        if (userToSocketsMap && userToSocketsMap[socket.id])
        {
          delete userToSocketsMap[socket.id];

          if (Object.keys(userToSocketsMap).length === 0)
          {
            delete usersToSocketsMap[userId];
          }
        }

        socket.emit('user.reload', socket.handshake.user);
      });
    });

    app.broker.subscribe('users.edited', (message) =>
    {
      const userToSocketsMap = usersToSocketsMap[message.model._id];

      if (userToSocketsMap)
      {
        handleUserEdit(userToSocketsMap, message.model.toJSON());
      }
    });

    app.broker.subscribe('users.deleted', (message) =>
    {
      const userToSocketsMap = usersToSocketsMap[message.model._id];

      if (userToSocketsMap)
      {
        handleUserDelete(userToSocketsMap, message.model._id);
      }
    });

    function mapUserToSocket(socket)
    {
      const handshake = socket.handshake;

      if (handshake.user && handshake.user.loggedIn)
      {
        const userId = handshake.user._id;

        if (!usersToSocketsMap[userId])
        {
          usersToSocketsMap[userId] = {};
        }

        usersToSocketsMap[userId][socket.id] = true;
      }
    }

    function moveSos(oldSessionId, newSessionId)
    {
      const sockets = [];

      if (typeof sosMap[oldSessionId] !== 'object')
      {
        return sockets;
      }

      _.forEach(Object.keys(sosMap[oldSessionId]), (socketId) =>
      {
        const socket = sioModule.sockets.connected[socketId];

        if (typeof socket === 'undefined')
        {
          delete sosMap[oldSessionId][socketId];
        }
        else
        {
          socket.sessionId = newSessionId;

          sockets.push(socket);
        }
      });

      if (newSessionId !== oldSessionId)
      {
        sosMap[newSessionId] = sosMap[oldSessionId];

        delete sosMap[oldSessionId];
      }

      return sockets;
    }

    function handleUserEdit(userToSocketsMap, userData)
    {
      const userId = userData._id.toString();

      delete userData._id;

      preparePrivileges(userData);
      updateUserSessions(userId, userData);
      updateUserSockets(userToSocketsMap, userData);
    }

    function handleUserDelete(userToSocketsMap, userId)
    {
      removeUserSessions(userId);

      _.forEach(userToSocketsMap, (unused, socketId) =>
      {
        const socket = sioModule.sockets.connected[socketId];

        if (socket)
        {
          socket.emit('user.deleted');
        }
      });
    }

    function updateUserSockets(userToSocketsMap, userData)
    {
      _.forEach(userToSocketsMap, (unused, socketId) =>
      {
        const socket = sioModule.sockets.connected[socketId];

        if (socket)
        {
          Object.assign(socket.handshake.user, userData);

          socket.emit('user.reload', socket.handshake.user);
        }
      });
    }

    function updateUserSessions(userId, userData)
    {
      const collection = getSessionsCollection();

      if (!collection)
      {
        return;
      }

      const conditions = {
        'data.user._id': userId
      };
      const update = {
        $set: {}
      };

      _.forEach(userData, (v, k) =>
      {
        update.$set['data.user.' + k] = v;
      });

      collection.updateMany(conditions, update, (err) =>
      {
        if (err)
        {
          module.error(err, `Failed to update user sessions.`);
        }
      });
    }

    function removeUserSessions(userId)
    {
      const collection = getSessionsCollection();

      if (!collection)
      {
        return;
      }

      collection.deleteMany({'data.user._id': userId.toString()}, (err) =>
      {
        if (err)
        {
          module.error(err, `Failed to remove user sessions.`);
        }
      });
    }
  }

  function getSessionsCollection()
  {
    const express = app[module.config.expressId];

    if (!express)
    {
      return null;
    }

    const sessionStore = express.sessionStore;

    if (sessionStore && typeof sessionStore.collection === 'function')
    {
      return sessionStore.collection();
    }

    return null;
  }

  function removeApiSessions()
  {
    const sessionsCollection = getSessionsCollection();

    if (!sessionsCollection)
    {
      return;
    }

    const User = app[module.config.mongooseId].model('User');

    if (!User.schema.path('apiKey'))
    {
      return;
    }

    step(
      function()
      {
        User
          .find({apiKey: {$ne: ''}})
          .select({_id: 1})
          .lean()
          .exec(this.next());
      },
      function(err, apiUsers)
      {
        if (err)
        {
          return this.skip(err);
        }

        const ids = apiUsers.map(u => u._id.toString());

        if (!ids.length)
        {
          return this.skip();
        }

        sessionsCollection.deleteMany({'data.user._id': {$in: ids}}, this.next());
      },
      function(err)
      {
        if (err)
        {
          module.error(err, 'Failed to remove API user sessions.');
        }

        setTimeout(removeApiSessions, 60 * 60 * 1000);
      }
    );
  }
};
