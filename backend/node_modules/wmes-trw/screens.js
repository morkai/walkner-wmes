// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const {transliterate} = require('transliteration');
let SerialPort = null;
let goldelox = null;

try { SerialPort = require('serialport'); } catch (err) {} // eslint-disable-line no-empty
try { goldelox = require('node-goldelox'); } catch (err) {} // eslint-disable-line no-empty

module.exports = (app, module) =>
{
  const logger = module.logger.create({submodule: 'screens'});
  const Commander = goldelox ? goldelox.Commander : null;
  const colors = goldelox ? goldelox.colors : null;

  let sp = null;
  let cmd = null;
  let updated = true;
  let updating = false;
  let screen = {state: 'error'};

  const SCREENS = {};

  module.changeScreen = newScreen =>
  {
    if (!SerialPort)
    {
      logger.warn(`Ignoring screen change: no serialport module!`);

      return;
    }

    if (!Commander)
    {
      logger.warn(`Ignoring screen change: no node-goldelox module!`);

      return;
    }

    if (SCREENS[newScreen.state])
    {
      if (JSON.stringify(screen) === JSON.stringify(newScreen))
      {
        return;
      }

      screen = newScreen;
    }
    else
    {
      screen = {state: 'error'};
    }

    updated = true;

    update();
  };

  async function update()
  {
    if (updating)
    {
      return;
    }

    updating = true;

    try
    {
      await setUpSerialPort();
      await setUpCommander();
      await SCREENS[screen.state]();
    }
    catch (err)
    {
      updated = true;

      logger.error(err, `Failed to update screen.`, {screen});
    }

    updating = false;

    if (updated)
    {
      updated = false;

      setImmediate(update);
    }
  }

  async function setUpSerialPort()
  {
    if (sp && sp.isOpen)
    {
      return;
    }

    if (cmd)
    {
      cmd.destroy();
      cmd = null;
    }

    if (sp)
    {
      sp.removeAllListeners();
      sp.on('error', () => {});
      sp.close();
      sp = null;
    }

    const ports = await SerialPort.list();

    if (ports.length === 0)
    {
      throw new Error('No serial ports found!');
    }

    const port = ports.find(p => p.vendorId === '10C4');

    if (!port)
    {
      throw new Error('No valid serial port found!');
    }

    sp = new SerialPort(port.path, {
      baudRate: 115200,
      dataBits: 8,
      stopBits: 1,
      parity: 'none',
      autoOpen: false
    });

    sp.on('error', err =>
    {
      logger.error(err, `Serial port error.`);

      if (cmd)
      {
        cmd.destroy();
        cmd = null;
      }

      sp.removeAllListeners();
      sp.on('error', () => {});
      sp = null;

      setImmediate(update);
    });

    sp.open();
  }

  async function setUpCommander()
  {
    if (!cmd)
    {
      cmd = new Commander(sp);

      cmd.on('open', () => logger.debug('Opened.'));
      cmd.on('close', () => logger.debug('Closed.'));
      cmd.on('readyCheck', () => logger.debug('Ready check...'));
      cmd.on('notReady', (err) => logger.debug(err, 'Not ready.'));
      cmd.on('resetting', () => logger.debug('Resetting...'));
      cmd.on('reset', () => logger.debug('Reset.'));
      cmd.on('ready', () => logger.debug('Ready.'));
      cmd.on('keepAliveError', () => update());
    }

    await cmd.ready();
  }

  SCREENS.message = async () =>
  {
    await cmd.gfx.bgColor(colors.BLACK);
    await cmd.gfx.cls();
    await cmd.txt.fgColor(colors.WHITE);
    await cmd.txt.width(3);
    await cmd.txt.height(3);
    await cmd.txt.opacity(false);
    await cmd.gfx.moveTo({x: 32, y: 52});
    await cmd.putstr('???');
  };

  SCREENS.unknown = SCREENS.message;

  SCREENS.error = async () =>
  {
    await cmd.gfx.bgColor(colors.hex('#EE0000'));
    await cmd.gfx.cls();
    await cmd.txt.fgColor(colors.WHITE);
    await cmd.txt.width(3);
    await cmd.txt.height(3);
    await cmd.txt.opacity(false);
    await cmd.gfx.moveTo({x: 32, y: 52});
    await cmd.putstr('NOK');
  };

  SCREENS.test = async () =>
  {
    await cmd.gfx.bgColor(colors.BLACK);
    await cmd.txt.fgColor(colors.WHITE);
    await cmd.gfx.cls();

    await cmd.gfx.moveTo({x: 4, y: 4});
    const hd = typeof screen.step === 'string' ? screen.step : '?';
    const length = typeof screen.length === 'string' && screen.length >= 3 ? screen.length : '';
    await cmd.putstr(`${hd}${length.toString().padStart(17 - hd.length, ' ')}`);

    /*
    await cmd.gfx.moveTo({x: 4, y: 29});
    await cmd.putstr(`od`);

    await cmd.gfx.moveTo({x: 4, y: 61});
    await cmd.putstr(`do`);
    */

    await cmd.gfx.circleFilled({x: 11, y: 32, radius: 7, color: colors.WHITE});
    await cmd.gfx.circleFilled({x: 11, y: 64, radius: 7, color: colors.WHITE});

    if (typeof screen.color === 'string' && screen.color !== '?' && screen.color.length)
    {
      const parts = transliterate(screen.color, {unknown: ''}).split('-');
      const lines = [parts.shift()];

      while (parts.length)
      {
        const part = parts.shift();

        if (lines[lines.length - 1].length + 1 + part.length > 17)
        {
          lines.push(part);
        }
        else
        {
          lines[lines.length - 1] += `-${part}`;
        }
      }

      for (let i = 0; i < lines.length; ++i)
      {
        await cmd.gfx.moveTo({x: 4, y: 86 + 16 * i});
        await cmd.putstr(lines[i]);
      }
    }

    await cmd.txt.width(3);
    await cmd.txt.height(3);
    await cmd.gfx.moveTo({x: 22, y: 22});
    await cmd.putstr(`${screen.source || '?'}`);
    await cmd.gfx.moveTo({x: 22, y: 54});
    await cmd.putstr(`${screen.target || '?'}`);
  };

  SCREENS['test-teardown'] = async () =>
  {
    await cmd.gfx.bgColor(colors.hex('#EEAA00'));
    await cmd.gfx.cls();
    await cmd.txt.fgColor(colors.BLACK);
    await cmd.txt.width(1);
    await cmd.txt.height(1);
    await cmd.txt.opacity(false);

    const words = transliterate(screen.message || '...', {unknown: ''}).split(/\s+/);
    const lines = [words.shift()];

    while (words.length)
    {
      const word = words.shift();

      if (lines[lines.length - 1].length + 1 + word.length > 17)
      {
        lines.push(word);
      }
      else
      {
        lines[lines.length - 1] += ` ${word}`;
      }
    }

    const height = 16 * Math.min(lines.length, 7);
    const top = Math.floor((128 - height) / 2);

    for (let i = 0; i < lines.length; ++i)
    {
      const line = lines[i];

      await cmd.gfx.moveTo({x: 4, y: top + 18 * i});
      await cmd.putstr(line.padStart(Math.floor((17 - line.length) / 2) + line.length, ' '));
    }
  };

  SCREENS['test-saving'] = SCREENS['test-teardown'];

  SCREENS['test-success'] = async () =>
  {
    await cmd.gfx.bgColor(colors.hex('#00E600'));
    await cmd.gfx.cls();
    await cmd.txt.fgColor(colors.BLACK);
    await cmd.txt.width(3);
    await cmd.txt.height(3);
    await cmd.txt.opacity(false);
    await cmd.gfx.moveTo({x: 42, y: 52});
    await cmd.putstr('OK');
  };
};
