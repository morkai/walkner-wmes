// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');

exports.DEFAULT_CONFIG = {
  mongooseId: 'mongoose',
  expressId: 'express',
  userId: 'user'
};

exports.models = [
  require('./models/setting')
];

exports.republishTopics = ['settings.updated.**'];

exports.requiredModules = 'mongoose';

exports.optionalModules = {
  'express': require('./routes')
};

exports.start = (app, module) =>
{
  const {Setting} = module;

  module.findById = (id, done) =>
  {
    return Setting.findById(id).select({value: 1}).lean().exec(done);
  };

  module.find = (conditions, done) =>
  {
    return Setting.find(conditions).select({value: 1}).lean().exec(done);
  };

  module.findValue = (id, done) =>
  {
    if (!done)
    {
      return module.findById(id).then(setting => setting ? setting.value : null);
    }

    module.findById(id).then(setting => done(null, setting ? setting.value : null), done);
  };

  module.findValues = (conditions, ns, done) =>
  {
    if (typeof conditions === 'string' && (!ns || typeof ns === 'function'))
    {
      done = ns;
      ns = conditions;
      conditions = {_id: new RegExp(`^${_.escapeRegExp(ns)}`)};
    }

    if (!done)
    {
      return module.find(conditions).then(prepareValues);
    }

    module.find(conditions).then(settings => done(null, prepareValues(settings)), done);

    function prepareValues(settings)
    {
      const values = {};

      settings.forEach(setting =>
      {
        values[setting._id.replace(ns, '')] = setting.value;
      });

      return values;
    }
  };

  module.update = (_id, newValue, updater, done) =>
  {
    if (done)
    {
      doUpdate(done, done);
    }
    else
    {
      return new Promise((resolve, reject) =>
      {
        doUpdate(resolve, reject);
      });
    }

    function doUpdate(resolve, reject)
    {
      const updatedAt = new Date();
      const update = {
        $set: {
          value: newValue,
          updater,
          updatedAt
        }
      };

      Setting.updateOne({_id}, update, {upsert: true}, err =>
      {
        if (err)
        {
          module.error(err, `Failed to update a setting.`, {setting: {_id, newValue, updater}});
        }
        else
        {
          app.broker.publish(`settings.updated.${_id}`, {
            _id,
            value: newValue,
            updater,
            updatedAt
          });
        }

        if (err)
        {
          reject(err);
        }
        else
        {
          resolve();
        }
      });
    }
  };

  module.multiUpdate = (settings, updater, done) =>
  {
    step(
      function()
      {
        Object.keys(settings).forEach(_id =>
        {
          module.update(_id, settings[_id], updater, this.group());
        });
      },
      done
    );
  };

  module.updateRoute = (req, res, next) =>
  {
    const {_id, value} = req.body;

    if (typeof _id !== 'string' || _id.trim().length === 0)
    {
      return next(app.createError(`Invalid setting ID.`, 'INPUT', 400));
    }

    if (value === undefined)
    {
      return next(app.createError(`Invalid setting value.`, 'INPUT', 400));
    }

    const userModule = app[module.config.userId];
    const updater = userModule ? userModule.createUserInfo(req.session.user, req) : null;

    module.update(_id, value, updater, (err) =>
    {
      if (err)
      {
        next(err);
      }
      else
      {
        res.sendStatus(204);
      }
    });
  };

  module.browseRoute = (pattern) =>
  {
    return function(req, res, next)
    {
      const express = app[module.config.expressId];

      if (!express)
      {
        return next(app.createError('No express module.', 'NO_MODULE', 500));
      }

      if (/^[A-Za-z0-9.-]+$/.test(pattern))
      {
        pattern = `^${pattern}\\.`;
      }

      req.rql.selector = {
        name: 'regex',
        args: ['_id', pattern]
      };

      express.crud.browseRoute(app, Setting, req, res, next);
    };
  };
};
