// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const dgram = require('dgram');
const fs = require('fs');
const _ = require('lodash');
const expressMiddleware = require('./expressMiddleware');

exports.DEFAULT_CONFIG = {
  expressId: 'express',
  sioId: 'sio',
  packageJsonPath: 'package.json',
  versionsKey: 'wmes',
  backendVersionKey: 'backend',
  frontendVersionKey: 'frontend',
  manifestPath: null,
  restartDelay: 15000,
  errorTemplate: 'error503',
  pull: {
    exe: 'git',
    cwd: process.cwd(),
    timeout: 60000
  },
  manifests: [],
  captureSigint: true,
  restartBroadcastPort: 1337
};

exports.republishTopics = ['updater.newVersion'];

exports.optionalModules = {
  'express': require('./routes'),
  'sio': require('./commands')
};

exports.start = (app, module) =>
{
  let reloadTimer = null;
  let restartTimer = null;

  module.config.packageJsonPath = require.resolve(module.config.packageJsonPath);

  module.package = reloadPackageJson();

  module.restarting = 0;

  module.manifest = module.config.manifestPath ? fs.readFileSync(module.config.manifestPath, 'utf8') : null;

  module.config.manifests.forEach(manifest => _.defaults(manifest, {
    frontendVersionKey: module.config.frontendVersionKey,
    template: module.manifest
  }));

  module.getManifest = (requiredFrontendVersionKey) =>
  {
    return module.config.manifests.find(manifest =>
    {
      const actualFrontendVersionKey = manifest.frontendVersionKey || module.config.frontendVersionKey;

      return actualFrontendVersionKey === requiredFrontendVersionKey;
    });
  };

  module.getAppTemplateData = (appId, req, appData) =>
  {
    const manifest = module.getManifest(appId);

    if (!manifest)
    {
      throw new Error(`Manifest not found for app [${appId}]!`);
    }

    if (!req)
    {
      req = {
        session: null,
        secure: false
      };
    }

    const sessionUser = req.session && req.session.user;
    const locale = sessionUser && sessionUser.locale ? sessionUser.locale : 'pl';

    const matches = (req.headers['user-agent'] || '').match(/Chrome\/([0-9]+)/);
    const chromeVersion = matches ? +matches[1] : 99;
    const appCacheManifest = app.options.env !== 'development' && (chromeVersion < 70 || req.secure)
      ? manifest.path
      : '';

    return {
      appCacheManifest,
      appData: module.extendAppData(appId, {
        LOCALE: JSON.stringify(locale),
        ...appData
      }),
      mainJsFile: manifest.mainJsFile,
      mainCssFile: manifest.mainCssFile
    };
  };

  module.extendAppData = (appId, appData) =>
  {
    if (!appData)
    {
      appData = {};
    }

    const manifest = module.getManifest(appId);

    Object.assign(appData, {
      ENV: JSON.stringify(app.options.env),
      VERSIONS: JSON.stringify(module.getVersions()),
      TIME: JSON.stringify(Date.now()),
      FRONTEND_SERVICE: JSON.stringify(appId)
    });

    app.broker.publish('app.prepareAppData', {appId, appData});

    if (!manifest)
    {
      return appData;
    }

    _.forEach(manifest.dictionaryModules, (appDataKey, moduleName) =>
    {
      const dictionaryModule = app[moduleName];

      if (!dictionaryModule)
      {
        return;
      }

      const models = dictionaryModule.models;

      if (models.length === 0)
      {
        appData[appDataKey] = '[]';

        return;
      }

      if (typeof models[0].toDictionaryObject !== 'function')
      {
        appData[appDataKey] = JSON.stringify(models);

        return;
      }

      appData[appDataKey] = JSON.stringify(_.invokeMap(models, 'toDictionaryObject'));
    });

    _.forEach(manifest.frontendAppData, (appDataValue, appDataKey) =>
    {
      appData[appDataKey] = JSON.stringify(
        _.isFunction(appDataValue) ? appDataValue(app) : appDataValue
      );
    });

    return appData;
  };

  module.getVersions = clone =>
  {
    if (!module.package.updater)
    {
      module.package.updater = {};
    }

    const updater = module.package.updater;
    const versionsKey = module.config.versionsKey;

    if (!updater[versionsKey])
    {
      updater[versionsKey] = {};
      updater[versionsKey][module.config.backendVersionKey] = -1;
      updater[versionsKey][module.config.frontendVersionKey] = -1;
    }

    updater[versionsKey].package = module.package.version;

    return clone === false ? updater[versionsKey] : _.cloneDeep(updater[versionsKey]);
  };

  module.getBackendVersion = backendVersionKey =>
  {
    return module.getVersions(false)[backendVersionKey || module.config.backendVersionKey];
  };

  module.getFrontendVersion = frontendVersionKey =>
  {
    return module.getVersions(false)[frontendVersionKey || module.config.frontendVersionKey];
  };

  module.updateFrontendVersion = frontendVersionKey =>
  {
    const versions = module.getVersions(false);

    if (typeof versions[frontendVersionKey] === 'undefined')
    {
      frontendVersionKey = module.config.frontendVersionKey;
    }

    versions[frontendVersionKey] = Date.now();
  };

  app.broker.subscribe('express.beforeMiddleware').setLimit(1).on('message', message =>
  {
    const expressModule = message.module;
    const expressApp = expressModule.app;

    expressApp.use(expressMiddleware.bind(null, app, module));
  });

  fs.watch(module.config.packageJsonPath, () =>
  {
    if (reloadTimer !== null)
    {
      clearTimeout(reloadTimer);
    }

    reloadTimer = setTimeout(compareVersions, 1000);
  });

  if (module.config.captureSigint)
  {
    process.on('SIGINT', handleSigint);
  }

  function reloadPackageJson()
  {
    delete require.cache[module.config.packageJsonPath];

    module.package = require(module.config.packageJsonPath);

    return module.package;
  }

  function compareVersions()
  {
    reloadTimer = null;

    const oldVersions = module.getVersions(true);
    const oldBackendVersion = module.getBackendVersion();
    const oldFrontendVersion = module.getFrontendVersion();

    reloadPackageJson();

    const newVersions = module.getVersions(false);
    const newBackendVersion = module.getBackendVersion();
    const newFrontendVersion = module.getFrontendVersion();
    let backendNotified = false;
    let frontendNotified = false;

    if (newBackendVersion !== oldBackendVersion)
    {
      module.info('Backend version changed.', {oldBackendVersion, newBackendVersion});

      handleBackendUpdate(oldBackendVersion, newBackendVersion);

      backendNotified = true;
    }
    else if (newFrontendVersion !== oldFrontendVersion)
    {
      module.info('Frontend version changed.', {oldFrontendVersion, newFrontendVersion});

      handleFrontendUpdate(oldFrontendVersion, newFrontendVersion);

      frontendNotified = true;
    }

    _.forEach(newVersions, (newVersion, service) =>
    {
      if ((backendNotified && service === 'backend') || (frontendNotified && service === 'frontend'))
      {
        return;
      }

      const oldVersion = oldVersions[service] || 0;

      if (newVersion !== oldVersion)
      {
        app.broker.publish('updater.newVersion', {
          service: service,
          oldVersion: oldVersion,
          newVersion: newVersion
        });
      }
    });
  }

  function handleBackendUpdate(oldBackendVersion, newBackendVersion)
  {
    if (restartTimer !== null)
    {
      return false;
    }

    module.restarting = Date.now();

    module.info('Restarting...', {restartDelay: module.config.restartDelay / 1000});

    app.broker.publish('updater.newVersion', {
      service: 'backend',
      oldVersion: oldBackendVersion,
      newVersion: newBackendVersion,
      delay: module.config.restartDelay
    });

    app.broker.publish('updater.restarting', {
      appId: app.options.id,
      delay: module.config.restartDelay
    });

    broadcastRestartMessage();

    restartTimer = setTimeout(shutdown, module.config.restartDelay);

    return true;
  }

  function handleFrontendUpdate(oldFrontendVersion, newFrontendVersion)
  {
    app.broker.publish('updater.newVersion', {
      service: 'frontend',
      oldVersion: oldFrontendVersion,
      newVersion: newFrontendVersion
    });
  }

  function handleSigint()
  {
    const backendVersion = module.getBackendVersion();

    if (!handleBackendUpdate(backendVersion, backendVersion))
    {
      module.info('Forcing shutdown...');

      shutdown();
    }
  }

  function shutdown()
  {
    module.info('Exiting the process...');

    setImmediate(process.exit.bind(process));
  }

  function broadcastRestartMessage()
  {
    const port = module.config.restartBroadcastPort;

    if (port <= 0)
    {
      return;
    }

    const socket = dgram.createSocket('udp4');

    socket.on('error', err =>
    {
      module.error(err, 'Broadcast error.');
    });

    socket.once('listening', () =>
    {
      socket.setBroadcast(true);

      const message = Buffer.from(JSON.stringify({
        topic: 'updater.restarting',
        payload: {
          appId: app.options.id,
          delay: module.config.restartDelay
        }
      }), 'utf8');

      socket.send(message, 0, message.length, port, '255.255.255.255', err =>
      {
        if (err)
        {
          module.error(err, `Failed to broadcast restarting message.`);
        }
        else
        {
          module.info(`Broadcasted restarting message!`);
        }

        socket.close();
      });
    });

    socket.bind();
  }
};
