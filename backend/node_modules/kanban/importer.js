// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const path = require('path');
const moment = require('moment');
const step = require('h5.step');
const fs = require('fs-extra');
const jsonDeepEqual = require('util/jsonDeepEqual');

const BATCH_SIZE = 100;
const UPDATER = {
  id: null,
  label: 'System'
};

exports.DEFAULT_CONFIG = {
  mongooseId: 'mongoose',
  settingsId: 'settings',
  filterRe: /^KANBAN\.json$/,
  parsedOutputDir: null
};

exports.models = [
  require('./models/kanbanEntry'),
  require('./models/kanbanComponent'),
  require('orders/models/order')
];

exports.recordTopics = {
  info: ['kanban.import.success'],
  error: ['kanban.import.failure']
};

exports.requiredModules = 'mongoose settings';

exports.start = (app, module) =>
{
  const {settings, KanbanEntry, KanbanComponent} = module;

  const filePathCache = {};
  const queue = [];
  let locked = false;

  app.broker.subscribe('directoryWatcher.changed', queueFile).setFilter(filterFile);

  app.broker.subscribe('orders.bom.synced', updateComponentUsage);

  function filterFile(fileInfo)
  {
    if (filePathCache[fileInfo.filePath] || !module.config.filterRe.test(fileInfo.fileName))
    {
      return false;
    }

    fileInfo.timeKey = createTimeKey(fileInfo.timestamp);

    return true;
  }

  function createTimeKey(timestamp)
  {
    return moment(timestamp).subtract(1, 'days').format('YYMMDDHHMM');
  }

  function queueFile(fileInfo)
  {
    filePathCache[fileInfo.filePath] = true;

    queue.push(fileInfo);

    module.info(`Queued...`, {key: fileInfo.timeKey});

    setImmediate(importNext);
  }

  function importNext()
  {
    if (locked)
    {
      return;
    }

    const fileInfo = queue.shift();

    if (!fileInfo)
    {
      return;
    }

    locked = true;

    const startTime = Date.now();

    module.info('Importing...', {key: fileInfo.timeKey});

    importFile(fileInfo, (err, updatedAt, entryCount, componentCount, deletedCount) =>
    {
      cleanUpFileInfoFile(fileInfo);

      if (err)
      {
        module.error(err, 'Failed to import.', {key: fileInfo.timeKey});

        app.broker.publish('kanban.import.failure', {
          timestamp: fileInfo.timestamp,
          error: err.message
        });
      }
      else
      {
        module.info('Imported.', {
          key: fileInfo.timeKey,
          duration: Date.now() - startTime
        });

        app.broker.publish('kanban.import.success', {
          timestamp: fileInfo.timestamp,
          updatedAt,
          entryCount: entryCount + deletedCount,
          componentCount
        });
      }

      locked = false;

      setImmediate(importNext);
    });
  }

  function importFile(fileInfo, done)
  {
    step(
      function readFileStep()
      {
        fs.readFile(fileInfo.filePath, {encoding: 'utf8'}, this.next());
      },
      function parseFileStep(err, fileContents)
      {
        if (err)
        {
          return this.skip(err);
        }

        module.info(`Parsing...`, {
          key: fileInfo.timeKey,
          fileSize: fileContents.length
        });

        this.t = new Date();

        try
        {
          this.input = JSON.parse(fileContents);
          this.kanbanCount = this.input.kanbans.rows.length;
          this.componentCount = this.input.components.rows.length;

          module.info('Parsed!', {
            key: fileInfo.timeKey,
            kanbanCount: this.kanbanCount,
            componentCount: this.componentCount,
            duration: Date.now() - this.t
          });
        }
        catch (err)
        {
          return this.skip(err);
        }

        setImmediate(this.next());
      },
      function importComponentsStep()
      {
        importDocs(KanbanComponent, this.input.components, this.t, this.next());
      },
      function deleteEntriesStep(err)
      {
        if (err)
        {
          return this.skip(err);
        }

        deleteEntries(this.input.kanbans.rows.map(r => r[0]), this.t, this.next());
      },
      function importEntriesStep(err, deletedCount)
      {
        if (err)
        {
          return this.skip(err);
        }

        this.deletedCount = deletedCount;

        importDocs(KanbanEntry, this.input.kanbans, this.t, this.next());
      },
      function updateImportedAtStep(err)
      {
        if (err)
        {
          return this.skip(err);
        }

        settings.update('kanban.import.importedAt', this.t, null, this.next());
      },
      function finalizeStep(err)
      {
        return done(err, this.t, this.kanbanCount, this.componentCount, this.deletedCount);
      }
    );
  }

  function cleanUpFileInfoFile(fileInfo)
  {
    setTimeout(removeFilePathFromCache, 15000, fileInfo.filePath);

    if (module.config.parsedOutputDir)
    {
      moveFileInfoFile(fileInfo.filePath);
    }
    else
    {
      deleteFileInfoFile(fileInfo.filePath);
    }
  }

  function moveFileInfoFile(oldFilePath)
  {
    const newFilePath = path.join(module.config.parsedOutputDir, path.basename(oldFilePath));

    fs.move(oldFilePath, newFilePath, {overwrite: true}, function(err)
    {
      if (err)
      {
        module.error(err, 'Failed to rename file.', {oldFilePath, newFilePath});
      }
    });
  }

  function deleteFileInfoFile(filePath)
  {
    fs.unlink(filePath, function(err)
    {
      if (err)
      {
        module.error(err, 'Failed to delete file.', {filePath});
      }
    });
  }

  function removeFilePathFromCache(filePath)
  {
    delete filePathCache[filePath];
  }

  function importDocs(Model, input, updatedAt, done)
  {
    if (!input.rows.length)
    {
      return done();
    }

    step(
      function()
      {
        this.newDocs = new Map();

        input.rows.splice(0, BATCH_SIZE).forEach(d =>
        {
          this.newDocs.set(d[0], d);
        });

        Model
          .find({_id: {$in: Array.from(this.newDocs.keys())}}, {changes: 0})
          .lean()
          .exec(this.next());
      },
      function(err, oldDocs)
      {
        if (err)
        {
          return this.skip(err);
        }

        this.inserts = [];
        this.updates = [];

        oldDocs.forEach(oldDoc =>
        {
          compareDocs(
            oldDoc,
            this.newDocs.get(oldDoc._id),
            input.columns,
            updatedAt,
            this.updates
          );

          this.newDocs.delete(oldDoc._id);
        });

        this.newDocs.forEach(newDoc =>
        {
          this.inserts.push(Model.createFromImport(newDoc, updatedAt, UPDATER));
        });

        setImmediate(this.next());
      },
      function()
      {
        if (this.inserts.length)
        {
          Model.collection.insertMany(this.inserts, this.next());
        }
      },
      function(err)
      {
        if (err)
        {
          return this.skip(err);
        }

        this.updates.forEach(update =>
        {
          Model.collection.updateOne({_id: update._id}, update.update, this.group());
        });
      },
      function(err)
      {
        if (err)
        {
          return done(err);
        }

        importDocs(Model, input, updatedAt, done);
      }
    );
  }

  function deleteEntries(ids, updatedAt, done)
  {
    if (!ids.length)
    {
      return done();
    }

    const conditions = {
      _id: {$nin: ids},
      deleted: false
    };
    const update = {
      $set: {
        updatedAt,
        deleted: true,
        'updates.deleted': {
          date: updatedAt,
          user: UPDATER,
          data: false
        }
      },
      $push: {
        changes: {
          date: updatedAt,
          user: UPDATER,
          data: {
            deleted: [false, true]
          }
        }
      }
    };

    KanbanEntry.collection.updateMany(conditions, update, (err, result) =>
    {
      done(err, result && result.modifiedCount || 0);
    });
  }

  function compareDocs(oldDoc, newDoc, columns, updatedAt, updates)
  {
    const update = {
      $set: {updatedAt},
      $push: {
        changes: {
          date: updatedAt,
          user: UPDATER,
          data: {}
        }
      }
    };

    if (oldDoc.deleted)
    {
      update.$set.deleted = false;
      update.$set['updates.deleted'] = {
        date: updatedAt,
        user: UPDATER,
        data: true
      };
      update.$push.changes.data.deleted = [true, false];
    }

    columns.forEach((column, i) =>
    {
      const oldValue = oldDoc[column];
      const newValue = newDoc[i];

      if (jsonDeepEqual(newValue, oldValue))
      {
        return;
      }

      update.$set[column] = newValue;
      update.$set[`updates.${column}`] = {
        date: updatedAt,
        user: UPDATER,
        data: oldValue
      };
      update.$push.changes.data[column] = [oldValue, newValue];
    });

    if (Object.keys(update.$set).length === 1)
    {
      return;
    }

    updates.push({
      _id: oldDoc._id,
      update
    });
  }

  function updateComponentUsage()
  {
    module.info('Updating component usage...');

    step(
      function()
      {
        module.Order.aggregate([
          {$match: {
            scheduledStartDate: {$gte: moment().startOf('day').subtract(1, 'days').toDate()}
          }},
          {$unwind: '$bom'},
          {$group: {
            _id: {
              nc12: '$bom.nc12',
              sa: {$ifNull: ['$bom.supplyArea', '']}
            },
            max: {$max: '$scheduledStartDate'}
          }}
        ], this.parallel());

        module.KanbanComponent.aggregate([
          {$group: {
            _id: null,
            nc12: {$addToSet: '$_id'}
          }}
        ], this.parallel());
      },
      function(err, usageResults, componentResults)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!usageResults.length || !componentResults.length)
        {
          return this.skip();
        }

        const components = new Set();
        const componentToUsage = {};

        componentResults[0].nc12.forEach(nc12 => components.add(nc12));

        usageResults.forEach(r =>
        {
          if (!components.has(r._id.nc12))
          {
            return;
          }

          if (!r._id.sa)
          {
            r._id.sa = 'null';
          }

          if (!componentToUsage[r._id.nc12])
          {
            componentToUsage[r._id.nc12] = {};
          }

          componentToUsage[r._id.nc12][r._id.sa] = r.max.getTime();
        });

        updateNextComponentUsage(Object.keys(componentToUsage), componentToUsage, this.next());
      },
      function(err)
      {
        if (err)
        {
          module.error(err, 'Failed to update component usage.');
        }
        else
        {
          module.info('Updated component usage.');
        }
      }
    );
  }

  function updateNextComponentUsage(remaining, componentToUsage, done)
  {
    if (!remaining.length)
    {
      return done();
    }

    const nc12 = remaining.shift();
    const usage = componentToUsage[nc12];

    module.KanbanComponent.collection.updateOne({_id: nc12}, {$set: {usage}}, err =>
    {
      if (err)
      {
        module.error(err, 'Failed to update component usage.', {
          component: {nc12, usage}
        });
      }

      updateNextComponentUsage(remaining, componentToUsage, done);
    });
  }
};
