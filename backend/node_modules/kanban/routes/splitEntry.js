// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const step = require('h5.step');
const locks = require('util/locks');

module.exports = (app, module, req, res, next) =>
{
  const {user, KanbanEntry} = module;

  const entryId = req.params.id;
  const newValue = req.body.parts;
  const date = new Date();
  const userInfo = user.createUserInfo(req.session.user, req);

  if (!/^[0-9]{1,10}[a-z]?$/.test(entryId) || newValue < 1 || newValue > 35)
  {
    return next(app.createError('Invalid input.', 'INPUT', 400));
  }

  step(
    function()
    {
      this.locks = [
        locks.create('kanbanEntry/update', this.next())
      ];
    },
    function()
    {
      module.getState(this.parallel());

      KanbanEntry
        .find({_id: new RegExp(`^${entryId}[a-z]?$`)})
        .select({_id: 1})
        .sort({_id: 1})
        .lean()
        .exec(this.parallel());
    },
    function(err, state, entries)
    {
      if (err)
      {
        return this.skip(err);
      }

      if (!entries.length)
      {
        return this.skip(app.createError(`Entries not found: ${entryId}`, 'NOT_FOUND', 404));
      }

      const mainEntry = state.maps.entries[entryId];

      if (!mainEntry)
      {
        return this.skip(app.createError(`Entry not found: ${entryId}`, 'NOT_FOUND', 404));
      }

      if (entries.some(entry => !state.maps.entries[entry._id]))
      {
        return this.skip(app.createError(`Entry not found in map: ${entryId}`, 'STATE', 500));
      }

      const oldValue = mainEntry.split;

      if (newValue === oldValue)
      {
        return this.skip();
      }

      const deletedEntries = new Set();
      const remainingKanbanIds = [];

      entries.forEach(({_id}) =>
      {
        const entry = state.maps.entries[_id];

        deletedEntries.add(entry._id);

        entry.kanbanId.forEach(kanbanId =>
        {
          remainingKanbanIds.push(kanbanId);
        });
      });

      const perEntryCount = Math.ceil(remainingKanbanIds.length / newValue);
      const ops = [];

      for (let i = 0; i < newValue; ++i)
      {
        if (entries[i])
        {
          const entryId = entries[i]._id;

          deletedEntries.delete(entryId);

          ops.push({
            updateOne: {
              filter: {_id: entryId},
              update: {$set: {
                kanbanId: remainingKanbanIds.splice(0, perEntryCount),
                updatedAt: date,
                updater: userInfo,
                split: i === 0 ? newValue : 1
              }}
            }
          });
        }
        else
        {
          const newEntry = KanbanEntry.createFromImport(
            [
              mainEntry._id + (i + 9).toString(36),
              mainEntry.nc12,
              mainEntry.supplyArea,
              0,
              mainEntry.componentQty,
              remainingKanbanIds.splice(0, perEntryCount),
              mainEntry.storageType
            ],
            date,
            userInfo
          );

          newEntry.kind = mainEntry.kind;
          newEntry.container = mainEntry.container;
          newEntry.discontinued = mainEntry.discontinued;

          ops.push({
            insertOne: {
              document: newEntry
            }
          });
        }
      }

      deletedEntries.forEach(entryId =>
      {
        ops.push({
          updateOne: {
            filter: {_id: entryId},
            update: {$set: {
              deleted: true,
              kanbanId: [],
              updatedAt: date,
              updater: userInfo
            }}
          }
        });
      });

      KanbanEntry.collection.bulkWrite(ops, this.next());
    },
    function(err, result)
    {
      this.locks.forEach(release => release());

      if (err)
      {
        return next(err);
      }

      res.sendStatus(204);

      app.broker.publish('kanban.import.success', {
        timestamp: date,
        updatedAt: date,
        entryCount: result.insertedCount + result.modifiedCount + result.deletedCount,
        componentCount: 0
      });
    }
  );
};
