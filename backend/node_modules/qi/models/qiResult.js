// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const deepEqual = require('deep-equal');
const autoIncrement = require('mongoose-plugin-autoinc-fix');

exports.name = 'QiResult';

exports.setUp = (app, mongoose) =>
{
  const changeSchema = new mongoose.Schema({
    date: Date,
    user: {},
    data: {},
    comment: {
      type: String,
      trim: true,
      default: ''
    }
  }, {
    _id: false,
    minimize: false
  });

  const correctiveActionSchema = new mongoose.Schema({
    kind: {
      type: String,
      enum: ['std', 'kz'],
      required: true
    },
    rid: {
      type: Number,
      default: 0
    },
    what: {
      type: String,
      required: true
    },
    when: {
      type: Date,
      default: null
    },
    who: {},
    status: {
      type: String,
      required: true
    }
  }, {
    _id: false,
    minimize: false
  });

  const schema = new mongoose.Schema({
    ok: {
      type: Boolean,
      required: true
    },
    creator: {},
    createdAt: Date,
    updater: {},
    updatedAt: Date,
    inspector: {},
    inspectedAt: {
      type: Date,
      required: true
    },
    nokOwner: {},
    source: {
      type: String,
      enum: ['prod', 'wh']
    },
    division: {
      type: String,
      required: true
    },
    line: {
      type: String,
      default: ''
    },
    leader: {},
    coach: {},
    operator: {},
    orderNo: {
      type: String,
      default: ''
    },
    mrp: {
      type: String,
      default: ''
    },
    nc12: {
      type: String,
      required: true
    },
    productName: {
      type: String,
      required: true
    },
    productFamily: {
      type: String,
      default: ''
    },
    standard: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'QiStandard'
    },
    kind: {
      type: mongoose.Schema.Types.ObjectId,
      required: true,
      ref: 'QiKind'
    },
    faultCode: {
      type: String,
      ref: 'QiFault'
    },
    faultDescription: {
      type: String,
      trim: true
    },
    errorCategory: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'QiErrorCategory'
    },
    problem: {
      type: String,
      trim: true
    },
    immediateActions: {
      type: String,
      trim: true
    },
    immediateResults: {
      type: String,
      trim: true,
      default: ''
    },
    rootCause: {},
    correctiveActions: [correctiveActionSchema],
    notes: {
      type: String,
      trim: true
    },
    qtyOrder: {
      type: Number,
      default: 0,
      min: 0
    },
    qtyInspected: {
      type: Number,
      default: 0,
      min: 0
    },
    qtyToFix: {
      type: Number,
      default: 0,
      min: 0
    },
    qtyNok: {
      type: Number,
      default: 0,
      min: 0
    },
    qtyNokInspected: {
      type: Number,
      default: 0,
      min: 0
    },
    serialNumbers: [String],
    okFile: {
      type: {},
      default: null
    },
    nokFile: {
      type: {},
      default: null
    },
    changes: [changeSchema],
    users: [String]
  }, {
    id: false,
    minimize: false
  });

  schema.plugin(autoIncrement.plugin, {
    model: 'QiResult',
    field: 'rid',
    startAt: 1,
    incrementBy: 1
  });

  schema.statics.TOPIC_PREFIX = 'qi.results';

  schema.index({'users': 1});
  schema.index({'inspector.id': 1});
  schema.index({'nokOwner.id': 1});
  schema.index({'leader.id': 1});
  schema.index({'coach.id': 1});
  schema.index({'operator.id': 1});
  schema.index({inspectedAt: -1});
  schema.index({division: 1});
  schema.index({line: 1});
  schema.index({orderNo: 1});
  schema.index({nc12: 1});
  schema.index({productFamily: 1});
  schema.index({kind: 1});
  schema.index({faultCode: 1});
  schema.index({errorCategory: 1});
  schema.index({'correctiveActions.status': 1});
  schema.index({'correctiveActions.rid': 1});
  schema.index({serialNumbers: 1});

  schema.pre('save', function(next)
  {
    if (this.isNew)
    {
      this.createdAt = new Date();
      this.updatedAt = this.createdAt;
    }

    this.users = this.collectUsers();

    next();
  });

  schema.statics.prepareCorrectiveActions = async function(newActions)
  {
    const rids = new Map();

    newActions.forEach(action =>
    {
      if (action.rid)
      {
        rids.set(action.rid, action);
      }
    });

    const Suggestion = mongoose.model('Suggestion');
    const suggestions = await Suggestion
      .find({rid: {$in: Array.from(rids.keys())}})
      .select({
        _id: 0,
        rid: 1,
        subject: 1,
        status: 1,
        kaizenOwners: 1
      })
      .lean()
      .exec();

    suggestions.forEach(suggestion =>
    {
      const action = rids.get(suggestion.rid);

      action.status = suggestion.status;
      action.who = suggestion.kaizenOwners;
      action.what = suggestion.subject;

      rids.delete(action.rid);
    });

    return newActions.filter(action => !rids.has(action.rid));
  };

  schema.methods.collectUsers = function()
  {
    const users = {};

    users[this.creator.id] = 1;

    if (this.updater)
    {
      users[this.updater.id] = 1;
    }

    if (this.inspector)
    {
      users[this.inspector.id] = 1;
    }

    if (this.nokOwner)
    {
      users[this.nokOwner.id] = 1;
    }

    if (this.leader)
    {
      users[this.leader.id] = 1;
    }

    if (this.coach)
    {
      users[this.coach.id] = 1;
    }

    if (this.operator)
    {
      users[this.operator.id] = 1;
    }

    _.forEach(this.changes, (change) =>
    {
      if (change.user)
      {
        users[change.user.id] = 1;
      }
    });

    _.forEach(this.correctiveActions, (action) =>
    {
      _.forEach(action.who, (user) =>
      {
        users[user.id] = 1;
      });
    });

    return Object.keys(users);
  };

  schema.methods.applyChanges = function(input, updater)
  {
    this.updater = updater;
    this.updatedAt = new Date();

    const changes = this.compareProperties(_.pick(input, [
      'ok',
      'inspector',
      'inspectedAt',
      'nokOwner',
      'division',
      'line',
      'leader',
      'coach',
      'operator',
      'orderNo',
      'mrp',
      'nc12',
      'productName',
      'productFamily',
      'standard',
      'kind',
      'faultCode',
      'faultDescription',
      'errorCategory',
      'problem',
      'immediateActions',
      'immediateResults',
      'rootCause',
      'correctiveActions',
      'qtyOrder',
      'qtyInspected',
      'qtyToFix',
      'qtyNok',
      'qtyNokInspected',
      'serialNumbers',
      'okFile',
      'nokFile',
      'notes'
    ]));
    const changedProperties = Object.keys(changes);
    const comment = _.isEmpty(input.comment) || !_.isString(input.comment) ? '' : input.comment.trim();

    if (!_.isEmpty(input.comment))
    {
      changedProperties.push('comment');
    }

    if (!changedProperties.length)
    {
      return false;
    }

    if (!this.changes)
    {
      this.changes = [];
    }

    this.changes.push({
      date: this.updatedAt,
      user: updater,
      data: changes,
      comment
    });

    return true;
  };

  schema.methods.compareProperties = function(input)
  {
    const changes = {};

    _.forEach(input, (value, key) => this.compareProperty(key, input, changes));

    return changes;
  };

  schema.methods.compareProperty = function(property, input, changes)
  {
    let oldValue = this[property];
    this[property] = input[property];
    let newValue = this[property];

    if (property === 'standard' && _.isEmpty(oldValue))
    {
      oldValue = null;
    }

    if ((oldValue === null && newValue === '')
      || (oldValue === '' && newValue === null))
    {
      return;
    }

    if (oldValue && oldValue.toObject)
    {
      oldValue = oldValue.toObject();
    }

    if (newValue && newValue.toObject)
    {
      newValue = newValue.toObject();
    }

    if (typeof oldValue === 'string')
    {
      oldValue = oldValue.trim();
    }

    if (typeof newValue === 'string')
    {
      newValue = newValue.trim();
    }

    if (property === 'serialNumbers')
    {
      if (!Array.isArray(oldValue))
      {
        oldValue = [];
      }

      if (!Array.isArray(newValue))
      {
        newValue = [];
      }

      oldValue.sort();
      newValue.sort();
    }

    if (!deepEqual(newValue, oldValue, {strict: true}))
    {
      changes[property] = [oldValue, newValue];
    }
  };

  return schema;
};
