// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');
const moment = require('moment');
const util = require('reports/util');

exports.models = [
  require('./models/qiOqlWeek'),
  require('./models/qiResult')
];

exports.report = (app, {QiOqlWeek, QiResult}, options, done) =>
{
  const weekMatch = String(options.week).match(/([0-9]{4})-W([0-9]{2})/);
  const weekMoment = moment().startOf('isoWeek');

  if (weekMatch)
  {
    weekMoment.isoWeekYear(+weekMatch[1]).isoWeek(+weekMatch[2]);
  }

  options.fromTime = weekMoment.clone().subtract(11, 'weeks').toDate();
  options.toTime = weekMoment.clone().add(1, 'weeks').toDate();
  options.topFromTime = weekMoment.clone().subtract(3, 'weeks').toDate();
  options.topCount = 3;

  let minGroupKey = Number.MAX_VALUE;
  let maxGroupKey = weekMoment.valueOf();
  let oqlWeeks = [];
  let oqlTarget = 0;

  const results = {
    options,
    totals: createGroup(),
    top: createGroup(),
    groups: {},
    results: []
  };

  step(
    function findFirstOqlWeekStep()
    {
      QiOqlWeek
        .findOne({_id: {$lte: options.fromTime}})
        .sort({_id: -1})
        .lean()
        .exec(this.next());
    },
    function findRemainingOqlWeeksStep(err, firstOqlWeek)
    {
      if (err)
      {
        return this.skip(err);
      }

      if (!firstOqlWeek)
      {
        firstOqlWeek = new QiOqlWeek({_id: options.fromTime});
      }

      setImmediate(this.parallel(), null, firstOqlWeek);

      QiOqlWeek
        .find({_id: {
          $gt: options.fromTime,
          $lt: options.toTime
        }})
        .sort({_id: 1})
        .lean()
        .exec(this.parallel());
    },
    function prepareOqlWeeksStep(err, firstOqlWeek, remainingOqlWeeks)
    {
      if (err)
      {
        return this.skip(err);
      }

      options.oqlWeeks = [firstOqlWeek].concat(remainingOqlWeeks);
      oqlWeeks = [].concat(options.oqlWeeks);
      oqlTarget = firstOqlWeek.target;
    },
    function findResultsStep()
    {
      const conditions = {
        inspectedAt: {
          $gte: options.fromTime,
          $lt: options.toTime
        },
        source: 'prod'
      };
      const sort = {
        inspectedAt: 1
      };
      const fields = {
        rid: 1,
        ok: 1,
        inspectedAt: 1,
        faultCode: 1,
        mrp: 1
      };

      const stream = QiResult.find(conditions).select(fields).sort(sort).lean().cursor();
      const next = _.once(this.next());

      stream.on('error', next);
      stream.on('end', next);
      stream.on('data', handleQiResult);
    },
    function finalizeStep(err)
    {
      if (err)
      {
        return this.skip(err);
      }

      const createNextGroupKey = util.createCreateNextGroupKey(options.interval);
      const groups = [];
      let groupKey = minGroupKey;

      while (groupKey <= maxGroupKey)
      {
        const toTime = createNextGroupKey(groupKey);
        const group = results.groups[groupKey] || createGroup(groupKey);

        summarizeGroup(group);

        groups.push(group);

        groupKey = toTime;
      }

      results.groups = groups;

      summarizeGroup(results.totals);
      summarizeGroup(results.top);

      return setImmediate(this.next());
    },
    function sendResultsStep(err)
    {
      if (err)
      {
        return done(err);
      }

      options.fromTime = options.fromTime.getTime();
      options.toTime = options.toTime.getTime();
      options.topFromTime = options.topFromTime.getTime();

      options.oqlWeeks.forEach(oqlWeek => oqlWeek._id = oqlWeek._id.getTime());

      done(null, results);
    }
  );

  function calcOqlTarget(key)
  {
    while (oqlWeeks.length && oqlWeeks[0]._id <= key)
    {
      const oqlWeek = oqlWeeks.shift();

      if (oqlWeek.target)
      {
        oqlTarget = oqlWeek.target;
      }
    }
  }

  function createGroup(key)
  {
    if (key)
    {
      calcOqlTarget(key);
    }

    return {
      key,
      totalCount: 0,
      nokCount: 0,
      oql: 0,
      oqlTarget,
      where: {},
      what: {}
    };
  }

  function summarizeGroup(group)
  {
    group.oql = group.totalCount ? Math.round(group.nokCount / group.totalCount * 1000000) : 0;
    group.where = sortGroup(group.where, group.nokCount);
    group.what = sortGroup(group.what, group.nokCount);
  }

  function sortGroup(unsorted, nokCount)
  {
    const sorted = [];

    Object.keys(unsorted).forEach(key =>
    {
      sorted.push([
        key,
        unsorted[key],
        Math.round(unsorted[key] / nokCount * 100)
      ]);
    });

    sorted.sort((a, b) => b[1] - a[1]);

    return sorted;
  }

  function handleQiResult(qiResult)
  {
    if (!qiResult.mrp)
    {
      return;
    }

    const groupKey = util.createGroupKey(options.interval, qiResult.inspectedAt, false);
    const {totals, top, groups} = results;
    let group = groups[groupKey];

    if (!group)
    {
      group = groups[groupKey] = createGroup(groupKey);
    }

    if (groupKey < minGroupKey)
    {
      minGroupKey = groupKey;
    }

    if (groupKey > maxGroupKey)
    {
      maxGroupKey = groupKey;
    }

    totals.totalCount += 1;
    group.totalCount += 1;

    const isTop = qiResult.inspectedAt >= options.topFromTime;

    if (isTop)
    {
      top.totalCount += 1;
    }

    if (qiResult.ok)
    {
      return;
    }

    totals.nokCount += 1;
    group.nokCount += 1;

    inc(totals, 'where', qiResult.mrp);
    inc(group, 'where', qiResult.mrp);

    inc(totals, 'what', qiResult.faultCode);
    inc(group, 'what', qiResult.faultCode);

    if (isTop)
    {
      top.nokCount += 1;

      inc(top, 'where', qiResult.mrp);
      inc(top, 'what', qiResult.faultCode);
    }

    if (qiResult.inspectedAt >= maxGroupKey)
    {
      results.results.push({
        rid: qiResult.rid,
        where: qiResult.mrp,
        what: qiResult.faultCode
      });
    }
  }

  function inc(group, prop, key)
  {
    if (!group[prop][key])
    {
      group[prop][key] = 0;
    }

    group[prop][key] += 1;
  }
};
