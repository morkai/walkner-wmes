// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');
const moment = require('moment');
const util = require('reports/util');

exports.models = [
  require('./models/qiResult')
];

exports.report = (app, {QiResult}, options, done) =>
{
  const results = {
    options: options,
    totalCount: 0,
    nokCount: 0,
    where: {},
    what: {},
    groups: {}
  };

  let minGroupKey = Number.MAX_VALUE;
  let maxGroupKey = Number.MIN_VALUE;

  step(
    function findResultsStep()
    {
      const weekMatch = String(options.week).match(/([0-9]{4})-W([0-9]{2})/);
      const weekMoment = moment().startOf('isoWeek');

      if (weekMatch)
      {
        weekMoment.isoWeekYear(+weekMatch[1]).isoWeek(+weekMatch[2]);
      }

      const conditions = {
        inspectedAt: {
          $lt: weekMoment.clone().add(1, 'weeks').toDate(),
          $gt: weekMoment.clone().subtract(11, 'weeks').toDate()
        },
        source: 'prod'
      };
      const sort = {};
      const fields = {
        ok: 1,
        inspectedAt: 1,
        faultCode: 1,
        mrp: 1
      };

      maxGroupKey = weekMoment.valueOf();

      const stream = QiResult.find(conditions).select(fields).sort(sort).lean().cursor();
      const next = _.once(this.next());

      stream.on('error', next);
      stream.on('end', next);
      stream.on('data', handleQiResult);
    },
    function finalizeStep(err)
    {
      if (err)
      {
        return this.skip(err);
      }

      const createNextGroupKey = util.createCreateNextGroupKey(options.interval);
      const groups = [];
      let groupKey = minGroupKey;

      while (groupKey <= maxGroupKey)
      {
        const toTime = createNextGroupKey(groupKey);
        const group = results.groups[groupKey] || createGroup(groupKey);

        summarizeGroup(group);

        groups.push(group);

        groupKey = toTime;
      }

      results.where = sortGroup(results.where, results.nokCount);
      results.what = sortGroup(results.what, results.nokCount);
      results.groups = groups;

      return setImmediate(this.next());
    },
    function sendResultsStep(err)
    {
      done(err, results);
    }
  );

  function createGroup(key)
  {
    return {
      key,
      totalCount: 0,
      nokCount: 0,
      oql: 0,
      oqlTarget: 0,
      where: {},
      what: {}
    };
  }

  function summarizeGroup(group)
  {
    group.oql = group.totalCount ? Math.round(group.nokCount / group.totalCount * 1000000) : 0;
    group.where = sortGroup(group.where, group.nokCount);
    group.what = sortGroup(group.what, group.nokCount);
  }

  function sortGroup(unsorted, nokCount)
  {
    const sorted = [];

    Object.keys(unsorted).forEach(key =>
    {
      sorted.push([
        key,
        unsorted[key],
        Math.round(unsorted[key] / nokCount * 100)
      ]);
    });

    sorted.sort((a, b) => b[1] - a[1]);

    return sorted;
  }

  function handleQiResult(qiResult)
  {
    if (!qiResult.mrp)
    {
      return;
    }

    const groupKey = util.createGroupKey(options.interval, qiResult.inspectedAt, false);
    let group = results.groups[groupKey];

    if (!group)
    {
      group = results.groups[groupKey] = createGroup(groupKey);
    }

    if (groupKey < minGroupKey)
    {
      minGroupKey = groupKey;
    }

    if (groupKey > maxGroupKey)
    {
      maxGroupKey = groupKey;
    }

    results.totalCount += 1;
    group.totalCount += 1;

    if (qiResult.ok)
    {
      return;
    }

    results.nokCount += 1;
    group.nokCount += 1;

    inc(results, 'where', qiResult.mrp);
    inc(group, 'where', qiResult.mrp);

    inc(results, 'what', qiResult.faultCode);
    inc(group, 'what', qiResult.faultCode);
  }

  function inc(group, prop, key)
  {
    if (!group[prop][key])
    {
      group[prop][key] = 0;
    }

    group[prop][key] += 1;
  }
};
