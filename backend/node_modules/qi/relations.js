// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const locks = require('util/locks');

module.exports = (app, module) =>
{
  const {
    QiResult
  } = module;

  const logger = module.logger.create({submodule: 'relations'});

  app.broker.subscribe('suggestions.edited', handleSuggestionEdited);
  app.broker.subscribe('suggestions.deleted', handleSuggestionDeleted);

  function handleSuggestionEdited({user, model})
  {
    const change = model.changes[model.changes.length - 1];

    if (!change.data.status
      && !change.data.subject
      && !change.data.kaizenOwners)
    {
      return;
    }

    QiResult.find({'correctiveActions.rid': model.rid}).select({_id: 1}).lean().exec((err, qiResults) =>
    {
      if (err)
      {
        return logger.error(err, 'Failed to update suggestion.', {suggestion: model.rid});
      }

      qiResults.forEach(qiResult => updateSuggestion(qiResult._id, model, user));
    });
  }

  function handleSuggestionDeleted({user, model})
  {
    QiResult.find({'correctiveActions.rid': model.rid}).select({_id: 1}).lean().exec((err, qiResults) =>
    {
      if (err)
      {
        return logger.error(err, 'Failed to remove suggestion.', {suggestion: model.rid});
      }

      qiResults.forEach(qiResult => removeSuggestion(qiResult._id, model.rid, user));
    });
  }

  function updateSuggestion(qiResultId, suggestion, updater)
  {
    updateCorrectiveActions(qiResultId, updater, correctiveActions =>
    {
      const action = correctiveActions.find(a => a.rid === suggestion.rid);

      if (action)
      {
        action.status = suggestion.status;
        action.who = suggestion.kaizenOwners;
        action.what = suggestion.subject;
      }

      return correctiveActions;
    });
  }

  function removeSuggestion(qiResultId, suggestionRid, updater)
  {
    updateCorrectiveActions(qiResultId, updater, correctiveActions =>
    {
      return correctiveActions.filter(action => action.rid !== suggestionRid);
    });
  }

  async function updateCorrectiveActions(qiResultId, updater, prepareCorrectiveActions)
  {
    const releaseLock = await locks.createAsync(`${QiResult.TOPIC_PREFIX}.${qiResultId}`);

    try
    {
      const qiResult = await QiResult.findById(qiResultId).exec();

      if (!qiResult)
      {
        return;
      }

      const input = {
        correctiveActions: prepareCorrectiveActions(qiResult.correctiveActions.toObject())
      };

      const changed = qiResult.applyChanges(input, updater);

      if (!changed)
      {
        return;
      }

      await qiResult.save();

      app.broker.publish('qi.results.edited', {
        model: qiResult,
        user: updater
      });
    }
    catch (err)
    {
      logger.error(err, 'Failed to update corrective actions.', {qiResult: qiResultId});
    }
    finally
    {
      releaseLock();
    }
  }
};
