// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const moment = require('moment');
const step = require('h5.step');

module.exports = (app, module) =>
{
  const {QiResult} = module;

  let nextResetAt = moment().startOf('day').add(1, 'day').hours(6).valueOf();
  let resetTimer = null;

  app.broker.subscribe('app.started', scheduleReset).setLimit(1);
  app.broker.subscribe('qi.results.added', handleAddedResult);
  app.broker.subscribe('qi.results.edited', handleEditedResult);
  app.broker.subscribe('qi.results.deleted', handleDeletedResult);

  module.getActualCountForUser = function(userId, done)
  {
    const pipeline = [
      {$match: {
        inspectedAt: getCurrentTimeBoundaries(),
        $or: [
          {'inspector.id': userId},
          {'leader.id': userId}
        ]
      }},
      {$group: {
        _id: null,
        count: {$sum: '$qtyInspected'}
      }}
    ];

    QiResult.aggregate(pipeline, function(err, results)
    {
      if (err)
      {
        return done(err);
      }

      if (!results.length)
      {
        return done(null, 0);
      }

      return done(null, results[0].count);
    });
  };

  module.resetCounters = function(done)
  {
    const inspectedAt = getCurrentTimeBoundaries();

    step(
      function()
      {
        ['inspector', 'leader'].forEach(userProp =>
        {
          const pipeline = [
            {$match: {inspectedAt}},
            {
              $group: {
                _id: `$${userProp}.id`,
                count: {$sum: '$qtyInspected'}
              }
            }
          ];

          QiResult.aggregate(pipeline, this.parallel());
        });
      },
      function(err, inspectorResults, leaderResults)
      {
        if (err)
        {
          return done(err);
        }

        scheduleReset();

        const results = inspectorResults.concat(leaderResults).map(result =>
        {
          result = {
            user: result._id,
            count: result.count
          };

          app.broker.publish('qi.counter.recounted', result);

          return result;
        });

        return done(null, results);
      }
    );
  };

  function getCurrentTimeBoundaries()
  {
    const inspectedAt = moment();

    if (inspectedAt.hour() < 6)
    {
      inspectedAt.subtract(1, 'days');
    }

    inspectedAt.startOf('day');

    return {
      $gte: new Date(inspectedAt.valueOf()),
      $lt: inspectedAt.add(1, 'days').toDate()
    };
  }

  function scheduleReset()
  {
    if (resetTimer)
    {
      clearTimeout(resetTimer);
    }

    let delay = nextResetAt - Date.now();

    if (delay <= 0)
    {
      nextResetAt = moment().startOf('day').add(1, 'day').hours(6).valueOf();

      return resetAllCounters();
    }

    if (delay > 3600000)
    {
      delay = 3600000;
    }
    else if (delay > 1000)
    {
      delay /= 2;
    }

    resetTimer = setTimeout(scheduleReset, delay);
  }

  function resetAllCounters()
  {
    module.resetCounters(err =>
    {
      if (err)
      {
        module.error(err, 'Failed to reset counters.');
      }
    });
  }

  function resetUsersCounter(userId)
  {
    module.getActualCountForUser(userId, (err, count) =>
    {
      if (err)
      {
        module.error(err, `Failed to reset counter for user.`, {userId});
      }
      else
      {
        app.broker.publish('qi.counter.recounted', {
          user: userId,
          count
        });
      }
    });
  }

  function handleAddedResult(message)
  {
    const result = message.model;

    if (result.inspector)
    {
      resetUsersCounter(result.inspector.id);
    }

    if (result.leader)
    {
      resetUsersCounter(result.leader.id);
    }
  }

  function handleDeletedResult(message)
  {
    const result = message.model;

    if (result.inspector)
    {
      resetUsersCounter(result.inspector.id);
    }

    if (result.leader)
    {
      resetUsersCounter(result.leader.id);
    }
  }

  function handleEditedResult(message)
  {
    const result = message.model;
    const change = result.changes[result.changes.length - 1].data;

    if (!change.qtyInspected && !change.inspector && !change.leader)
    {
      return;
    }

    const userIds = new Set();

    if (result.inspector)
    {
      userIds.add(result.inspector.id);
    }

    if (result.leader)
    {
      userIds.add(result.leader.id);
    }

    ['inspector', 'leader'].forEach(prop =>
    {
      if (!change[prop])
      {
        return;
      }

      if (change[prop][0])
      {
        userIds.add(change[prop][0].id);
      }

      if (change[prop][1])
      {
        userIds.add(change[prop][1].id);
      }
    });

    userIds.forEach(userId => resetUsersCounter(userId));
  }
};
