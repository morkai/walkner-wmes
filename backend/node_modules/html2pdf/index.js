// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const {createHash} = require('crypto');
const {join} = require('path');
const {exec, execFile} = require('child_process');
const {tmpdir} = require('os');
const fs = require('fs');
const step = require('h5.step');
const request = require('request');
const setUpPuppeteerPool = require('./puppeteerPool');

exports.DEFAULT_CONFIG = {
  expressId: 'express',
  mongooseId: 'mongoose',
  fileUrl: 'http://localhost/html2pdf/${hash}.${format}',
  storagePath: './data/html2pdf',
  puppeteerPoolOptions: {},
  puppeteerLaunchOptions: {},
  sumatraExe: 'SumatraPDF.exe',
  zintExe: 'zint',
  spoolExe: 'spool.exe',
  ncatExe: 'ncat'
};

exports.models = [
  require('printing/models/printer')
];

exports.optionalModules = {
  'mongoose express': require('./routes')
};

exports.start = (app, module) =>
{
  const zintVersion = [0, 0];

  setUpPuppeteerPool(app, module);

  module.generateBarCode = (options, done) =>
  {
    step(
      function()
      {
        if (zintVersion[0] === 0)
        {
          exec(`"${module.config.zintExe}" --help`, {encoding: 'utf8'}, this.next());
        }
      },
      function(err, stdout, stderr)
      {
        if (stdout || stderr)
        {
          const matches = (stdout || stderr).match(/Zint version ([0-9]+)\.([0-9]+)/i);

          if (matches)
          {
            zintVersion[0] = +matches[1];
            zintVersion[1] = +matches[2];

            return;
          }
        }

        if (err)
        {
          return this.skip(err);
        }
      },
      function()
      {
        const cmd = [`"${module.config.zintExe}"`];

        if (zintVersion[0] === 2 && zintVersion[1] === 4)
        {
          cmd.push('--directpng');
        }
        else
        {
          cmd.push('--direct', '--filetype=PNG');
        }

        Object.keys(options || {}).forEach((k) =>
        {
          const v = options[k];

          if (v === false)
          {
            return;
          }

          if (v === true)
          {
            cmd.push(`--${k}`);
          }
          else if (typeof v === 'string')
          {
            cmd.push(`--${k}="${v}"`);
          }
          else
          {
            cmd.push(`--${k}=${v}`);
          }
        });

        exec(cmd.join(' '), {encoding: 'buffer'}, this.next());
      },
      function(err, stdout, stderr)
      {
        if (err)
        {
          return done(err);
        }

        if (stderr && stderr.length)
        {
          return done(app.createError(stderr.toString(), 'ZINT_STDERR', 500));
        }

        done(null, stdout.toString('base64'));
      }
    );
  };

  module.generatePdf = (html, userOptions, done) =>
  {
    const options = {
      orientation: 'portrait',
      format: 'A4',
      width: undefined,
      height: undefined,
      margin: {
        top: '0mm',
        right: '0mm',
        bottom: '0mm',
        left: '0mm'
      },
      waitUntil: 'networkidle2'
    };

    Object.keys(options).forEach((k) =>
    {
      if (userOptions && userOptions[k] !== undefined)
      {
        options[k] = userOptions[k];
      }
    });

    if (userOptions.width && userOptions.height)
    {
      delete options.format;
    }

    const hash = createHash('md5').update(html).update(JSON.stringify(options)).digest('hex');

    step(
      function()
      {
        fs.stat(join(module.config.storagePath, `${hash}.pdf`), this.next());
      },
      function(err, stats) // eslint-disable-line handle-callback-err
      {
        if (stats && stats.isFile())
        {
          return this.skip();
        }

        fs.writeFile(join(module.config.storagePath, `${hash}.html`), html, this.next());
      },
      function(err)
      {
        if (err)
        {
          return this.skip(err);
        }

        const next = this.next();

        module.puppeteerPool.acquire()
          .then(async browser =>
          {
            try
            {
              const page = await browser.newPage();
              const res = await page.goto(
                module.config.fileUrl.replace('${hash}', hash).replace('${format}', 'html'),
                {waitUntil: options.waitUntil}
              );

              if (!res || !res.ok())
              {
                throw app.createError('INVALID_STATUS', 500);
              }

              await page.emulateMediaType('print');
              await page.pdf({
                path: module.getPdfFilePath(hash),
                scale: 1,
                displayHeaderFooter: false,
                printBackground: true,
                preferCSSPageSize: true,
                landscape: options.orientation === 'landscape',
                pageRanges: '',
                format: options.format,
                margin: options.margin,
                width: options.width,
                height: options.height
              });
              await page.close();

              next();
            }
            catch (err)
            {
              next(err);
            }

            module.puppeteerPool.release(browser);
          })
          .catch(err => next(err));
      },
      function(err)
      {
        if (err)
        {
          return done(err);
        }

        done(null, {hash});
      }
    );
  };

  module.getPdfFilePath = (hash) => join(module.config.storagePath, `${hash}.pdf`);

  module.printPdf = (hash, printer, settings, done) =>
  {
    const pdfFilePath = module.getPdfFilePath(hash);

    step(
      function()
      {
        fs.stat(pdfFilePath, this.parallel());

        module.Printer.findById(printer).lean().exec(this.parallel());
      },
      function(err, stats, printer)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!stats || !stats.isFile())
        {
          return this.skip(app.createError('INVALID_HASH', 400));
        }

        if (!printer)
        {
          module.warn(`Can't print PDF: invalid printer.`, {
            pdfFilePath,
            printer
          });

          return this.skip(app.createError('INVALID_PRINTER', 400));
        }

        const special = parseSpecial(printer.special);

        if (special.VERSALINK && special.VERSALINK.length)
        {
          return handleDirectVersaLinkPrint(special.VERSALINK[0], pdfFilePath, this.next());
        }

        const cmd = [
          `"${module.config.sumatraExe}"`,
          `-print-to "${printer.name}"`,
          `-print-settings "${settings || 'fit'}"`,
          `"${pdfFilePath}"`
        ];

        exec(cmd.join(' '), this.next());
      },
      done
    );
  };

  module.compileZpl = (zpl, data) =>
  {
    data.DLE = '\u0010';

    Object.keys(data).forEach(key =>
    {
      zpl = zpl.replace(new RegExp(`\\$\\{${key}\\}`, 'g'), String(data[key]).replace(/~/g, '\\7e'));
    });

    return zpl;
  };

  module.printZpl = (zpl, options, done) =>
  {
    if (typeof done === 'function')
    {
      return printZpl(zpl, options, done);
    }

    return new Promise((resolve, reject) =>
    {
      printZpl(zpl, options, err =>
      {
        if (err)
        {
          reject(err);
        }
        else
        {
          resolve();
        }
      });
    });
  };

  function printZpl(zpl, options, done)
  {
    const labelFilePath = join(tmpdir(), `WMES.${Date.now()}.${Math.random()}.zpl`);

    step(
      function()
      {
        if (typeof options.tag === 'string')
        {
          module.Printer.find({tags: options.tag}).lean().exec(this.parallel());
        }
        else if (!options.printer)
        {
          setImmediate(this.parallel(), null, []);
        }
        else if (options.printer._id)
        {
          setImmediate(this.parallel(), null, [options.printer]);
        }
        else
        {
          module.Printer.find({_id: options.printer}).lean().exec(this.parallel());
        }

        fs.writeFile(labelFilePath, zpl, this.parallel());
      },
      function(err, printers)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!printers.length)
        {
          return this.skip(app.createError(`Unknown ZPL printer.`, 'PRINTER_NOT_FOUND', 400, {
            printer: options.printer,
            tag: options.tag
          }));
        }

        let linePrinter = null;
        let printer = null;

        do
        {
          printer = printers.shift();
          linePrinter = findLinePrinter(parseSpecial(printer.special), options.line);
        }
        while (!linePrinter && printers.length);

        if (options.line && !linePrinter)
        {
          return this.skip(app.createError(`No ZPL printer for line.`, 'INVALID_PRINTER', 500, {
            line: options.line,
            printer: options.printer,
            tag: options.tag
          }));
        }

        if (linePrinter)
        {
          const cmd = [
            `"${module.config.ncatExe}"`,
            '-4 --send-only -w 5',
            linePrinter.host,
            linePrinter.port,
            `< "${labelFilePath}"`
          ];

          return exec(cmd.join(' '), this.next());
        }

        if (process.platform !== 'win32')
        {
          return this.skip(app.createError(
            `Printing by printer name not supported in non win32.`, 'INVALID_PRINTER', 500
          ));
        }

        if (!printer.name)
        {
          return this.skip(app.createError(
            `Invalid printer: no name. Missing special LINE definition?`, 'INVALID_PRINTER', 400
          ));
        }

        execFile(module.config.spoolExe, [labelFilePath, printer.name], this.next());
      },
      function(err)
      {
        fs.unlink(labelFilePath, () => {});

        done(err);
      }
    );
  }

  function parseSpecial(input)
  {
    const special = {};

    (input || '').split(/\s+/).forEach(line =>
    {
      const parts = line.split(':');
      const key = parts.shift().toUpperCase();

      if (!key.length)
      {
        return;
      }

      if (!special[key])
      {
        special[key] = [];
      }

      special[key].push(parts);
    });

    return special;
  }

  function findLinePrinter(special, line)
  {
    if (!special.LINE)
    {
      return null;
    }

    if (!line)
    {
      line = '*';
    }

    line = line.toUpperCase();

    let wildcardPrinter = null;

    for (const parts of special.LINE)
    {
      if (parts.length < 2)
      {
        continue;
      }

      const printerLines = (parts[0] || '').toUpperCase().split(',');
      const linePrinter = {
        host: parts[1].trim(),
        port: parseInt(parts[2], 10) || 9100
      };

      if (!wildcardPrinter && printerLines.includes('*'))
      {
        wildcardPrinter = linePrinter;
      }

      if (printerLines.includes(line))
      {
        return linePrinter;
      }
    }

    return wildcardPrinter;
  }

  function handleDirectVersaLinkPrint(printerOptions, pdfFilePath, done)
  {
    const [printerHost, printerPort] = printerOptions;
    const printerScheme = printerPort === '443' ? 'https' : 'http';

    const options = {
      url: `${printerScheme}://${printerHost}:${printerPort || 80}/UPLPRT.cmd`,
      formData: {
        DEFPRNT: '1',
        FILE: fs.createReadStream(pdfFilePath)
      }
    };

    request.post(options, (err, res, body) =>
    {
      if (err)
      {
        return done(app.createError(
          `Failed direct VersaLink print: ${err.message}`,
          'PRINT_VERSALINK_FAILURE',
          {printerHost, pdfFilePath}
        ));
      }

      if (res.statusCode !== 200)
      {
        return done(app.createError(`Unexpected response code to VersaLink print.`, 'PRINT_VERSALINK_FAILURE', {
          printerHost,
          pdfFilePath,
          expectedStatusCode: 200,
          actualStatusCode: res.statusCode
        }));
      }

      try
      {
        body = JSON.parse(body);

        if (body.result !== '0' || body.errorCode !== '0')
        {
          throw new Error();
        }
      }
      catch (err)
      {
        return done(app.createError(`Invalid response to VersaLink print.`, 'PRINT_VERSALINK_FAILURE', {
          printerHost,
          pdfFilePath,
          responseBody: body
        }));
      }

      done();
    });
  }
};
