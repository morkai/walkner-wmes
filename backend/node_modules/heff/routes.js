// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const moment = require('moment');
const step = require('h5.step');
const shifts = require('util/shifts');
const min = require('./min');

module.exports = (app, module) =>
{
  const {
    express,
    updater,
    user,
    orgUnits,
    production,
    ProdShift,
    ProdShiftOrder,
    ProdDowntime,
    Plan
  } = module;

  const canView = user.auth('LOCAL', 'USER');

  express.get('/heff', (req, res) =>
  {
    res.format({
      'text/html': () =>
      {
        res.render('index', updater.getAppTemplateData('heff', req));
      }
    });
  });

  express.get('/heff/:prodLine', canView, (req, res, next) =>
  {
    req.params.prodLine = orgUnits.fix.prodLine(req.params.prodLine);

    const lineId = orgUnits.fix.prodLine(req.params.prodLine);
    const currentShift = shifts.getCurrentShiftInfo();

    step(
      function()
      {
        findProdShift(lineId, currentShift, this.parallel());
        findProdShiftOrders(lineId, currentShift, this.parallel());
        findPlanShiftOrders(lineId, currentShift, this.parallel());
        findProdDowntimes(lineId, currentShift, this.parallel());
      },
      function(err, prodShift, prodShiftOrders, planShiftOrders, prodDowntimes)
      {
        if (err)
        {
          return next(err);
        }

        res.json({
          prodLine: lineId,
          prodShift,
          prodShiftOrders,
          planShiftOrders,
          prodDowntimes
        });
      }
    );
  });

  function findProdShift(lineId, shiftInfo, done)
  {
    const prodLineState = production.getProdLineState(lineId);

    if (prodLineState
      && prodLineState.prodShift
      && prodLineState.prodShift.date.getTime() === shiftInfo.startTime
      && Array.isArray(prodLineState.prodShift.quantitiesDone))
    {
      return done(null, _.pick(prodLineState.prodShift, [
        '_id',
        'date',
        'quantitiesDone'
      ]));
    }

    ProdShift
      .findOne({
        prodLine: lineId,
        date: shiftInfo.date
      })
      .select({
        date: 1,
        quantitiesDone: 1
      })
      .sort({_id: -1})
      .lean()
      .exec((err, prodShift) =>
      {
        if (err)
        {
          return done(err);
        }

        if (!prodShift)
        {
          prodShift = {
            _id: null,
            date: shiftInfo.date,
            quantitiesDone: [
              {planned: 0, actual: 0},
              {planned: 0, actual: 0},
              {planned: 0, actual: 0},
              {planned: 0, actual: 0},
              {planned: 0, actual: 0},
              {planned: 0, actual: 0},
              {planned: 0, actual: 0},
              {planned: 0, actual: 0}
            ]
          };
        }

        done(null, prodShift);
      });
  }

  function findProdShiftOrders(lineId, shiftInfo, done)
  {
    const prodLineState = production.getProdLineState(lineId);

    if (prodLineState
      && prodLineState.prodShift
      && prodLineState.prodShift.date.getTime() === shiftInfo.startTime
      && Array.isArray(prodLineState.prodShiftOrders))
    {
      return done(null, prodLineState.prodShiftOrders.map(min.prodShiftOrder));
    }

    ProdShiftOrder
      .find({
        prodLine: lineId,
        startedAt: {
          $gte: new Date(shiftInfo.startTime),
          $lt: new Date(shiftInfo.endTime)
        }
      })
      .select({
        startedAt: 1,
        finishedAt: 1,
        orderId: 1,
        operationNo: 1,
        sapTaktTime: 1,
        quantityDone: 1,
        workDuration: 1,
        workerCount: 1,
        laborTime: 1,
        'orderData.operations': 1,
        'orderData.taktTimeCoeff': 1
      })
      .sort({startedAt: 1})
      .lean()
      .exec((err, prodShiftOrders) =>
      {
        if (err)
        {
          return done(err);
        }

        done(null, prodShiftOrders.map(min.operations));
      });
  }

  function findProdDowntimes(lineId, shiftInfo, done)
  {
    const prodLineState = production.getProdLineState(lineId);

    if (prodLineState
      && prodLineState.prodShift
      && prodLineState.prodShift.date.getTime() === shiftInfo.startTime
      && Array.isArray(prodLineState.prodDowntimes))
    {
      return done(null, prodLineState.prodDowntimes.map(pdt =>
      {
        return {
          _id: pdt._id,
          startedAt: pdt.startedAt,
          finishedAt: pdt.finishedAt,
          prodShiftOrder: pdt.prodShiftOrder,
          aor: pdt.aor,
          reason: pdt.reason
        };
      }));
    }

    ProdDowntime
      .find({
        prodLine: lineId,
        startedAt: {
          $gte: new Date(shiftInfo.startTime),
          $lt: new Date(shiftInfo.endTime)
        }
      })
      .select({
        startedAt: 1,
        finishedAt: 1,
        prodShiftOrder: 1,
        aor: 1,
        reason: 1
      })
      .sort({startedAt: 1})
      .lean()
      .exec(done);
  }

  function findPlanShiftOrders(lineId, shiftInfo, done)
  {
    const pipeline = [
      {$match: {
        _id: shiftInfo.moment.clone().startOf('day').utc(true).toDate()
      }},
      {$unwind: '$lines'},
      {$match: {'lines._id': lineId}},
      {$unwind: '$lines.orders'},
      {$match: {
        'lines.orders._id': new RegExp(`-${shiftInfo.no}-`)
      }},
      {$project: {
        _id: 0,
        orderId: '$lines.orders.orderNo',
        quantityDone: '$lines.orders.quantity',
        startedAt: '$lines.orders.startAt',
        finishedAt: '$lines.orders.finishAt'
      }}
    ];

    Plan.aggregate(pipeline, (err, prodShiftOrders) =>
    {
      if (err)
      {
        return done(err);
      }

      prodShiftOrders.forEach(pso =>
      {
        pso.startedAt = moment.utc(pso.startedAt).local(true).toISOString();
        pso.finishedAt = moment.utc(pso.finishedAt).local(true).toISOString();
      });

      done(null, prodShiftOrders);
    });
  }
};
