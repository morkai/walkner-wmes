// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const axon = require('axon');
const Message = require('amp-message');

exports.DEFAULT_CONFIG = {
  pubHost: '0.0.0.0',
  pubPort: 5050,
  repHost: '0.0.0.0',
  repPort: 5051,
  pullHost: null,
  pullPort: 5052,
  broadcastTopics: []
};

exports.onModuleSetUp = (app) =>
{
  monkeyPatch(app);
};

exports.start = function startMessengerServerModule(app, module, done)
{
  const requestHandlers = {
    '@broadcast': function(reqData, done)
    {
      app.broker.publish(reqData.topic, reqData.message, reqData.meta);

      done();
    },
    '@subscribe': function({sock, topics}, done)
    {
      if (!sock.broker)
      {
        sock.broker = app.broker.sandbox();
      }

      _.forEach(topics, (topic) =>
      {
        sock.broker.subscribe(topic, (message, topic, meta) =>
        {
          if (sock.writable)
          {
            const msg = new Message([{topic, message, meta}, '@publish']);

            sock.write(msg.toBuffer());
          }
        });
      });

      done();
    }
  };

  let pubSocket = null;
  let repSocket = null; // eslint-disable-line no-unused-vars
  let pullSocket = null;

  _.forEach(module.config.broadcastTopics, function(broadcastTopic)
  {
    app.broker.subscribe(broadcastTopic, function(message, topic)
    {
      module.broadcast(topic, typeof message === 'undefined' ? null : message);
    });
  });

  createPullSocket();
  createPubSocket(function(err, socket)
  {
    if (err)
    {
      return done(err);
    }

    pubSocket = socket;

    module.info(`pub socket listening on port ${module.config.pubPort}.`);

    createRepSocket(function(err, socket)
    {
      if (err)
      {
        return done(err);
      }

      repSocket = socket;

      module.info(`rep socket listening on port ${module.config.repPort}`);

      done();
    });
  });

  /**
   * @param {string} type
   * @param {function(object, function)} handler
   */
  module.handle = function(type, handler)
  {
    requestHandlers[type] = handler;
  };

  /**
   * @param {string} topic
   * @param {Object} message
   */
  module.broadcast = function(topic, message)
  {
    if (pubSocket)
    {
      pubSocket.send(topic, message);
    }
  };

  /**
   * @private
   * @param {function(Error, object)} done
   */
  function createPubSocket(done)
  {
    const pub = axon.socket('pub');

    pub.set('hwm', 10);
    pub.bind(module.config.pubPort, module.config.pubHost);

    pub.once('error', done);

    pub.on('bind', function()
    {
      pub.removeListener('error', done);

      done(null, pub);
    });
  }

  /**
   * @private
   * @param {function(Error, object)} done
   */
  function createRepSocket(done)
  {
    const rep = axon.socket('rep');

    rep.set('hwm', 10);
    rep.bind(module.config.repPort, module.config.repHost);

    rep.once('error', done);

    rep.on('disconnect', (sock) =>
    {
      if (sock.broker)
      {
        sock.broker.destroy();
        sock.broker = null;
      }
    });

    rep.on('bind', function()
    {
      rep.removeListener('error', done);

      rep.on('message', handleRequest);

      done(null, rep);
    });
  }

  /**
   * @private
   * @returns {undefined}
   */
  function createPullSocket()
  {
    if (!module.config.pullHost)
    {
      return module.info('pull socket not used.');
    }

    let connected = false;

    pullSocket = axon.socket('rep');

    pullSocket.set('hwm', 10);
    pullSocket.connect(module.config.pullPort, module.config.pullHost);

    pullSocket.on('error', function(err)
    {
      module.error(err, 'pull socket error');
    });

    pullSocket.on('connect', function()
    {
      connected = true;

      module.info(`pull socket connected on port ${module.config.pullPort}.`);

      app.broker.publish('messenger.client.connected', {
        moduleName: module.name,
        socketType: 'pull',
        host: module.config.pullHost,
        port: module.config.pullPort
      });
    });

    pullSocket.on('reconnect attempt', function()
    {
      if (connected)
      {
        module.info(`pull socket disconnected. Reconnecting...`);

        connected = false;
      }
    });

    pullSocket.on('message', handleRequest);
  }

  /**
   * @private
   * @param {string} type
   * @param {Object} req
   * @param {function} reply
   * @param {Object} sock
   */
  function handleRequest(type, req, reply, sock)
  {
    if (!_.isString(type))
    {
      return;
    }

    const requestHandler = requestHandlers[type];

    if (!_.isFunction(requestHandler))
    {
      return;
    }

    requestHandler({...req, sock}, (...args) =>
    {
      if (args.length && args[0] instanceof Error)
      {
        args[0] = {
          message: args[0].message,
          name: args[0].name,
          code: args[0].code
        };
      }

      if (_.isFunction(reply))
      {
        reply(...args);
      }
    });
  }
};

function monkeyPatch()
{
  axon.RepSocket.prototype.onmessage = function(sock)
  {
    const self = this;

    return (buf) =>
    {
      const msg = new Message(buf);
      const args = msg.args;
      const id = args.pop();

      args.unshift('message');
      args.push(reply, sock);

      self.emit.apply(self, args);

      function reply(...args)
      {
        args[0] = args[0] || null;

        let fn = () => {};

        if (typeof args[args.length - 1] === 'function')
        {
          fn = args.pop();
        }

        args.push(id);

        if (sock.writable)
        {
          sock.write(self.pack(args), () => { fn(true); });

          return true;
        }

        process.nextTick(() => { fn(false); });

        return false;
      }
    };
  };
}
