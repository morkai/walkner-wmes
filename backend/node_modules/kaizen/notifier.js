// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const fs = require('fs');
const _ = require('lodash');
const step = require('h5.step');
const ejs = require('ejs');
const moment = require('moment');

module.exports = (app, module) =>
{
  const {
    mailSender,
    mongoose,
    settings,
    KaizenSection,
    KaizenArea,
    KaizenCategory,
    KaizenCause,
    KaizenRisk,
    User
  } = module;
  const logger = module.logger.create({
    submodule: 'notifier'
  });

  const emailTemplateFile = `${__dirname}/templates/notifier.email.pl.ejs`;
  const fm24TemplateFile = `${__dirname}/templates/notifier.fm24.en.ejs`;
  const renderEmail = ejs.compile(fs.readFileSync(emailTemplateFile, 'utf8'), {
    cache: true,
    filename: emailTemplateFile,
    compileDebug: false,
    rmWhitespace: true
  });
  const renderFm24Email = ejs.compile(fs.readFileSync(fm24TemplateFile, 'utf8'), {
    cache: true,
    filename: fm24TemplateFile,
    compileDebug: false,
    rmWhitespace: true
  });
  const nameMaps = {
    status: {
      new: 'Nowe',
      accepted: 'Zaakceptowane',
      todo: 'Do realizacji',
      inProgress: 'W realizacji',
      paused: 'Zatrzymane',
      finished: 'Zakończone',
      cancelled: 'Anulowane'
    },
    section: {},
    area: {},
    nearMissCategory: {},
    cause: {},
    risk: {},
    behaviour: {}
  };

  app.broker.subscribe('kaizen.orders.added', (message) =>
  {
    notifyAboutAdd(message.model, message.fm24 ? message.fm24.confirmationEmail : null);
  });

  app.broker.subscribe('kaizen.orders.edited', (message) =>
  {
    if (!_.isEmpty(message.notify))
    {
      notifyAboutEdit(message.model, message.notify);
    }
  });

  function notifyAboutAdd(kaizenOrder, fm24ConfirmationEmail)
  {
    const emailRecipients = new Set();
    const isFm24 = /fm.?24/i.test(kaizenOrder.confirmer.label);

    if (isFm24)
    {
      setImmediate(notifyAboutFm24, kaizenOrder, fm24ConfirmationEmail);
    }

    _.forEach(kaizenOrder.observers, (observer) =>
    {
      if (observer.role !== 'creator' && (!isFm24 || observer.role !== 'confirmer'))
      {
        emailRecipients.add(String(observer.user.id));
      }
    });

    step(
      function findFm24RecipientsStep()
      {
        if (!isFm24)
        {
          return;
        }

        User
          .find({
            $or: [
              {'preferences.fm24_email': true},
              {'preferences.fm24_sms': true}
            ]
          })
          .select({
            mobile: 1,
            'preferences.fm24_email': 1,
            'preferences.fm24_sms': 1
          })
          .lean()
          .exec(this.next());
      },
      function findRecipientsStep(err, users)
      {
        if (err)
        {
          return this.skip(err);
        }

        const smsRecipients = new Set();

        users.forEach((user) =>
        {
          if (user.preferences.fm24_email)
          {
            emailRecipients.add(String(user._id));
          }

          if (user.preferences.fm24_sms)
          {
            const mobile = User.resolveMobile(user.mobile);

            if (mobile)
            {
              smsRecipients.add(mobile);
            }
          }
        });

        if (smsRecipients.size)
        {
          setImmediate(sendFm24Sms, kaizenOrder, [...smsRecipients]);
        }

        if (!emailRecipients.size)
        {
          return this.skip();
        }

        User
          .find({
            _id: {
              $in: Array.from(emailRecipients).map(id => new mongoose.Types.ObjectId(id))
            }
          })
          .select({email: 1})
          .lean()
          .exec(this.next());
      },
      function sendEmailStep(err, recipients)
      {
        if (err)
        {
          return this.skip(err);
        }

        const to = recipients
          .filter((recipient) =>_.isString(recipient.email) && recipient.email.includes('@'))
          .map((recipient) =>recipient.email);

        if (!to.length)
        {
          return this.skip();
        }

        this.mailOptions = {
          to: to,
          replyTo: to,
          subject: `[WMES] [ZPW] Nowe zgłoszenie: ${kaizenOrder.rid}`,
          html: ''
        };

        return prepareTemplateData('add', kaizenOrder, this.next());
      },
      function sendEmailStep(err, templateData)
      {
        if (err)
        {
          return this.skip(err);
        }

        this.mailOptions.html = renderEmail(templateData);

        mailSender.send(this.mailOptions, this.next());
      },
      function finalizeStep(err)
      {
        if (err)
        {
          logger.error(err, `Failed to notify users about a new order [${kaizenOrder.rid}].`);
        }
        else if (this.mailOptions)
        {
          logger.info(`Notified [${this.mailOptions.to.length}] users about a new order: [${kaizenOrder.rid}].`);
        }

        this.mailOptions = null;
      }
    );
  }

  function notifyAboutFm24(kaizenOrder, confirmationEmail)
  {
    step(
      function()
      {
        User.findById(kaizenOrder.confirmer.id).select({email: 1}).lean().exec(this.parallel());

        settings.findValues('kaizen.fm24.', this.parallel());
      },
      function(err, user, settings)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!user || !user.email || !user.email.includes('@'))
        {
          return this.skip();
        }

        this.mailOptions = {
          to: [user.email],
          replyTo: typeof confirmationEmail === 'string' && confirmationEmail.includes('@')
            ? confirmationEmail
            : undefined,
          subject: (settings.subject || `New issue: {rid}`).replace('{rid}', kaizenOrder.rid),
          html: ''
        };

        const data = {
          ...kaizenOrder.toJSON(),
          fm24: {
            confirmationEmail,
            message: settings.message
          }
        };

        return prepareTemplateData('fm24', data, this.next());
      },
      function sendEmailStep(err, templateData)
      {
        if (err)
        {
          return this.skip(err);
        }

        this.mailOptions.html = renderFm24Email(templateData);

        mailSender.send(this.mailOptions, this.next());
      },
      function finalizeStep(err)
      {
        if (err)
        {
          logger.error(err, `Failed to send FM-24 ticket [${kaizenOrder.rid}].`);
        }
        else if (this.mailOptions)
        {
          logger.info(`Sent FM-24 ticket notification: [${kaizenOrder.rid}].`);
        }

        this.mailOptions = null;
      }
    );
  }

  function notifyAboutEdit(kaizenOrder, usersToNotify)
  {
    const recipients = [];

    _.forEach(usersToNotify, (changes, userId) =>
    {
      recipients.push(new mongoose.Types.ObjectId(userId));
    });

    if (!recipients.length)
    {
      return;
    }

    step(
      function findRecipientsStep()
      {
        User.find({_id: {$in: recipients}}, {email: 1}).lean().exec(this.next());
      },
      function sendEmailStep(err, recipients)
      {
        if (err)
        {
          return this.skip(err);
        }

        const to = recipients
          .filter((recipient) => _.isString(recipient.email) && recipient.email.includes('@'))
          .map((recipient) => recipient.email);

        if (!to.length)
        {
          return this.skip();
        }

        this.mailOptions = {
          to: to,
          replyTo: to,
          subject: `[WMES] [ZPW] Zmiana zgłoszenia: ${kaizenOrder.rid}`,
          html: ''
        };

        return prepareTemplateData('edit', kaizenOrder, this.next());
      },
      function sendEmailStep(err, templateData)
      {
        if (err)
        {
          return this.skip(err);
        }

        this.mailOptions.html = renderEmail(templateData);

        mailSender.send(this.mailOptions, this.next());
      },
      function finalizeStep(err)
      {
        if (err)
        {
          logger.error(err, `Failed to notify users about an order change [${kaizenOrder.rid}].`);
        }
        else if (this.mailOptions)
        {
          logger.info(
            `Notified [${this.mailOptions.to.length}] users about an order change: [${kaizenOrder.rid}].`
          );
        }

        this.mailOptions = null;
      }
    );
  }

  function sendFm24Sms(kaizenOrder, recipients)
  {
    const sms = {
      to: recipients,
      text: `Nowe ZPW FM-24: ${kaizenOrder.rid}`
    };

    if (app.options.emailUrlPrefix)
    {
      sms.text += ` ${app.options.emailUrlPrefix}r/kaizen/${kaizenOrder.rid}`;
    }

    app[module.config.smsSenderId].send(sms, (err) =>
    {
      if (err)
      {
        logger.error(err, `Failed to send SMS.`, {
          kaizenOrder: kaizenOrder._id,
          recipients
        });
      }
    });
  }

  function prepareTemplateData(mode, data, done)
  {
    const templateData = {
      mode,
      urlPrefix: app.options.emailUrlPrefix,
      nearMiss: {
        rid: data.rid,
        subject: data.subject,
        section: data.section,
        confirmer: data.confirmer.label,
        owners: data.nearMissOwners.map(function(o) { return o.label; }).join('; '),
        category: data.nearMissCategory,
        area: data.area,
        cause: data.cause,
        risk: data.risk,
        behaviour: data.behaviour,
        status: nameMaps.status[data.status],
        eventDate: moment(data.date).format('LLLL'),
        description: data.description,
        causeText: data.causeText,
        correctiveMeasures: data.correctiveMeasures,
        preventiveMeasures: data.preventiveMeasures,
        comment: mode === 'edit' ? _.last(data.changes).comment : ''
      },
      fm24: data.fm24 || {}
    };

    step(
      function()
      {
        User.findById(data.creator.id).select({email: 1}).lean().exec(this.parallel());
        findName(KaizenSection, data, 'section', 'name', this.parallel());
        findName(KaizenArea, data, 'area', 'name', this.parallel());
        findName(KaizenCategory, data, 'nearMissCategory', 'name', this.parallel());
        findName(KaizenCause, data, 'cause', 'name', this.parallel());
        findName(KaizenRisk, data, 'risk', 'name', this.parallel());
        findName(KaizenRisk, data, 'behaviour', 'name', this.parallel());
      },
      function(err, creator, section, area, category, cause, risk, behaviour)
      {
        if (err)
        {
          return done(err);
        }

        templateData.nearMiss.creator = {
          label: data.creator.label,
          email: creator ? creator.email : ''
        };
        templateData.nearMiss.section = section;
        templateData.nearMiss.area = area;
        templateData.nearMiss.category = category;
        templateData.nearMiss.cause = cause;
        templateData.nearMiss.risk = risk;
        templateData.nearMiss.behaviour = behaviour;

        return done(null, templateData);
      }
    );
  }

  function findName(Model, kaizenOrder, mapProperty, nameProperty, done)
  {
    const id = kaizenOrder[mapProperty];
    const nameMap = nameMaps[mapProperty];
    const multiple = _.isArray(id);

    if (multiple)
    {
      const names = [];

      _.forEach(id, function(id)
      {
        if (nameMap[id])
        {
          names.push(nameMap[id]);
        }
      });

      if (names.length === id.length)
      {
        return setImmediate(done, null, names);
      }
    }
    else if (nameMap[id])
    {
      return setImmediate(done, null, nameMap[id]);
    }

    const conditions = {
      _id: multiple ? {$in: id} : id
    };
    const fields = {};
    fields[nameProperty] = 1;

    Model.find(conditions, fields).lean().exec((err, models) =>
    {
      if (err)
      {
        return done(err);
      }

      if (_.isEmpty(models))
      {
        return done(null, id);
      }

      if (multiple)
      {
        const names = [];

        _.forEach(models, (model) =>
        {
          const name = model[nameProperty];

          nameMap[model._id] = name;

          names.push(name);
        });

        return done(null, names);
      }

      return done(null, models[0][nameProperty]);
    });
  }
};
