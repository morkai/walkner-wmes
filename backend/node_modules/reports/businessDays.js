'use strict';

const _ = require('lodash');
const moment = require('moment');
const step = require('h5.step');

const MONTH_TO_QUARTER = {
  0: 1,
  1: 1,
  2: 1,
  3: 3,
  4: 3,
  5: 3,
  6: 6,
  7: 6,
  8: 6,
  9: 9,
  10: 9,
  11: 9
};

const staticData = {
  holidays: null,
  years: null,
  quarters: null,
  months: null
};

let reloadCounter = 0;
let reloadTimer = null;

exports.holidays = {};

exports.years = {};

exports.quarters = {};

exports.months = {};

exports.reload = reload;

exports.isHoliday = function(date)
{
  return exports.holidays[date.getTime()] === true;
};

exports.countBetweenDates = function(fromTime, toTime)
{
  let businessDays = 0;

  if (fromTime >= toTime)
  {
    return businessDays;
  }

  const fromMoment = moment(fromTime);

  while (fromMoment.valueOf() < toTime)
  {
    businessDays += exports.countInDay(fromMoment.toDate());

    fromMoment.add(1, 'days');
  }

  return businessDays;
};

exports.countInDay = function(date)
{
  const time = date.getTime();

  if (exports.holidays[time])
  {
    return 0;
  }

  const weekDay = date.getDay();

  return weekDay === 0 || weekDay === 6 ? 0 : 1;
};

exports.countInWeek = function(date, currentShiftStartDate)
{
  if (date > currentShiftStartDate)
  {
    return -1;
  }

  const currentShiftStartTime = currentShiftStartDate.getTime();
  const dateMoment = moment(date);
  let businessDays = 0;

  for (let i = 0; i < 5; ++i)
  {
    const time = dateMoment.valueOf();

    if (time > currentShiftStartTime)
    {
      break;
    }

    if (!exports.holidays[time])
    {
      businessDays += 1;
    }

    dateMoment.add(1, 'days');
  }

  return businessDays;
};

exports.countInMonth = function(date, currentShiftStartDate)
{
  if (date > currentShiftStartDate)
  {
    return -1;
  }

  const currentDay = currentShiftStartDate.getDate();
  const currentMonth = currentShiftStartDate.getMonth();
  const currentYear = currentShiftStartDate.getFullYear();
  const key = date.getTime().toString();
  let businessDays = exports.months[key];
  let weekDay;

  if (!businessDays)
  {
    businessDays = 0;

    const year = date.getFullYear();
    const month = date.getMonth();
    let day = date.getDate();
    const sameMonth = year === currentYear && month === currentMonth;

    while (date.getMonth() === month)
    {
      weekDay = date.getDay();

      if (weekDay !== 0 && weekDay !== 6)
      {
        ++businessDays;
      }

      if (sameMonth && day === currentDay)
      {
        break;
      }

      date.setDate(++day);
    }

    return businessDays;
  }

  if (currentShiftStartDate.getFullYear() === date.getFullYear()
    && currentShiftStartDate.getMonth() === date.getMonth())
  {
    businessDays = 0;

    while (date.getDate() <= currentDay)
    {
      weekDay = date.getDay();

      if (weekDay !== 0 && weekDay !== 6 && !exports.holidays[date.getTime()])
      {
        ++businessDays;
      }

      date.setDate(date.getDate() + 1);
    }
  }

  return businessDays;
};

exports.countInQuarter = function(date, currentShiftStartDate)
{
  if (date > currentShiftStartDate)
  {
    return -1;
  }

  let businessDays = exports.quarters[date.getTime()];
  const quarterMoment = moment(date);

  if (businessDays !== undefined
    && quarterMoment.year() !== currentShiftStartDate.getFullYear()
    && quarterMoment.quarter() !== moment(currentShiftStartDate).quarter())
  {
    return businessDays;
  }

  businessDays = 0;

  for (let i = 0; i < 3; ++i)
  {
    businessDays += exports.countInMonth(quarterMoment.toDate(), currentShiftStartDate);

    quarterMoment.add(1, 'months');
  }

  return businessDays;
};

exports.countInYear = function(date, currentShiftStartDate)
{
  if (date > currentShiftStartDate)
  {
    return -1;
  }

  if (date.getFullYear() !== currentShiftStartDate.getFullYear())
  {
    return exports.years[date.getTime()] || 250;
  }

  let businessDays = 0;
  const dateMoment = moment(date);

  for (let m = 0, month = currentShiftStartDate.getMonth(); m <= month; ++m)
  {
    businessDays += exports.countInMonth(
      dateMoment.clone().month(m).toDate(),
      currentShiftStartDate
    );
  }

  return businessDays;
};

addYear(
  2013,
  [
    [22, 1, 6],
    20,
    [21, 31],
    [21, 1],
    [20, 1, 3, 19, 30],
    20,
    23,
    [21, 15],
    21,
    23,
    [19, 1, 11],
    [20, 25, 26]
  ]
);

addYear(
  2014,
  [
    [21, 1, 6],
    20,
    21,
    [21, 20, 21],
    [21, 1, 3],
    [20, 8, 19],
    23,
    [20, 15],
    22,
    23,
    [19, 1, 11],
    [21, 25, 26]
  ]
);

addYear(
  2015,
  [
    [20, 1, 6],
    20,
    22,
    [21, 5, 6],
    [20, 1, 3, 24],
    [21, 4],
    23,
    [21, 15],
    22,
    22,
    [20, 1, 11],
    [22, 25, 26]
  ]
);

addYear(
  2016,
  [
    [19, 1, 6],
    21,
    [22, 27, 28],
    21,
    [20, 1, 3, 15, 26],
    22,
    21,
    [22, 15],
    22,
    21,
    [20, 1, 11],
    [21, 25, 26]
  ]
);

addYear(
  2017,
  [
    [21, 1, 6],
    20,
    23,
    [19, 16, 17],
    [21, 1, 3],
    [21, 4, 15],
    21,
    [22, 15],
    21,
    22,
    [21, 1, 11],
    [19, 25, 26, 27, 28, 29, 30, 31]
  ]
);

addYear(
  2018,
  [
    [22, 1, 6],
    20,
    22,
    [20, 1, 2],
    [20, 1, 3, 20, 31],
    21,
    22,
    [22, 15],
    20,
    23,
    [21, 1, 11],
    [19, 25, 26]
  ]
);

addYear(
  2019,
  [
    [22, 1, 6],
    20,
    21,
    [21, 21, 22],
    [21, 1, 3],
    [19, 9, 20],
    23,
    [21, 15],
    21,
    23,
    [19, 1, 11],
    [20, 25, 26]
  ]
);

addYear(
  2020,
  [
    [21, 1, 6],
    20,
    22,
    [21, 12, 13],
    [20, 1, 3, 31],
    [21, 11],
    23,
    [21, 15],
    22,
    22,
    [20, 1, 11],
    [22, 25, 26]
  ]
);

addYear(
  2021,
  [
    [19, 1, 6],
    [20],
    [23],
    [21, 4, 5],
    [20, 1, 3, 23],
    [21, 3],
    [22],
    [22, 15],
    [22],
    [21],
    [20, 1, 11],
    [23, 25, 26]
  ]
);

Object.keys(staticData).forEach(group =>
{
  staticData[group] = {...exports[group]};
});

function addYear(year, months)
{
  let businessDaysInYear = 0;
  let quarterKey;

  _.forEach(months, function(days, month)
  {
    let businessDaysInMonth;

    if (typeof days === 'number')
    {
      businessDaysInMonth = days;
    }
    else
    {
      businessDaysInMonth = days.shift();

      _.forEach(days, function(day)
      {
        exports.holidays[key(year, month, day)] = true;
      });
    }

    const monthKey = key(year, month, 1);

    exports.months[monthKey] = businessDaysInMonth;

    if (month === 0 || month === 3 || month === 6 || month === 9)
    {
      quarterKey = monthKey;

      exports.quarters[quarterKey] = 0;
    }

    exports.quarters[quarterKey] += businessDaysInMonth;

    businessDaysInYear += businessDaysInMonth;
  });

  exports.years[key(year, 0, 1)] = businessDaysInYear;
}

function key(year, month, day)
{
  return new Date(year, month, day, 0, 0, 0, 0).getTime();
}

function reload(app, module, {recount})
{
  const t = Date.now();
  const mongoose = app[module.config.mongooseId];
  const NonBusinessDay = mongoose.model('NonBusinessDay');

  module.info(`Reloading non-business days...`);

  step(
    function()
    {
      recountNonBusinessDays(app, module, recount, this.next());
    },
    function(err)
    {
      if (err)
      {
        module.error(err, `Failed to recount non-business days.`);
      }

      Object.keys(staticData).forEach(group =>
      {
        exports[group] = {...staticData[group]};
      });

      const cursor = NonBusinessDay.find().lean().cursor({batchSize: 50});
      const next = _.once(this.next());

      cursor.on('error', next);
      cursor.on('end', next);
      cursor.on('data', nbd =>
      {
        const date = nbd._id;
        const year = date.getFullYear();
        const month = date.getMonth();
        const dayKey = date.getTime();
        const monthKey = key(year, month, 1);
        const quarterKey = key(year, MONTH_TO_QUARTER[month], 1);
        const yearKey = key(year, 0, 1);

        if (exports.holidays[dayKey])
        {
          return;
        }

        exports.holidays[dayKey] = true;

        if (exports.months[monthKey])
        {
          exports.months[monthKey] -= 1;
        }

        if (exports.quarters[quarterKey])
        {
          exports.quarters[quarterKey] -= 1;
        }

        if (exports.years[yearKey])
        {
          exports.years[yearKey] -= 1;
        }
      });
    },
    function(err)
    {
      if (err)
      {
        module.error(err, `Failed to reload non-business days.`);
      }
      else
      {
        module.info(`Reloaded non-business days.`, {duration: Date.now() - t});
      }

      if (reloadTimer)
      {
        clearTimeout(reloadTimer);
      }

      const delay = !err && (recount > 0 || reloadCounter > 0)
        ? 4 * 60 * 60
        : 60;

      reloadTimer = setTimeout(reload, delay * 1000, app, module, {recount});
      reloadCounter += 1;
    }
  );
}

function recountNonBusinessDays(app, module, dayCount, done)
{
  if (dayCount <= 0)
  {
    return done();
  }

  const t = Date.now();
  const mongoose = app[module.config.mongooseId];
  const Order = mongoose.model('Order');
  const NonBusinessDay = mongoose.model('NonBusinessDay');

  module.info(`Recounting non-business days...`);

  step(
    function()
    {
      NonBusinessDay.findOne({}, {_id: 1}).lean().exec(this.next());
    },
    function(err, doc)
    {
      if (err)
      {
        return this.skip(err);
      }

      this.from = doc || !app.options.productionDataStartDate
        ? moment().startOf('day').subtract(dayCount, 'days')
        : moment(app.options.productionDataStartDate, 'YYYY-MM-DD');

      const pipeline = [
        {$match: {
          scheduledStartDate: {$gte: this.from.toDate()},
          statuses: {
            $in: ['REL'],
            $nin: ['TECO', 'DLFL', 'DLT']
          }
        }},
        {$group: {
          _id: '$scheduledStartDate'
        }},
        {$sort: {
          _id: 1
        }}
      ];

      Order.aggregate(pipeline, this.parallel());

      NonBusinessDay.deleteMany({_id: {$gte: this.from.toDate()}}, this.parallel());
    },
    function(err, businessDayList)
    {
      if (err)
      {
        return this.skip(err);
      }

      if (businessDayList.length === 0)
      {
        return this.skip();
      }

      const to = Math.min(
        businessDayList[businessDayList.length - 1]._id.getTime(),
        moment().startOf('day').add(3, 'days').valueOf()
      );
      const businessDayMap = {};

      businessDayList.forEach(businessDay =>
      {
        businessDayMap[businessDay._id.getTime()] = true;
      });

      const nonBusinessDays = [];
      const from = this.from.clone();

      while (from.valueOf() <= to)
      {
        const time = from.valueOf();

        if (!businessDayMap[time]
          && !staticData.holidays[time]
          && from.day() !== 0
          && from.day() !== 6)
        {
          nonBusinessDays.push({_id: new Date(+time)});
        }

        from.add(1, 'days');
      }

      NonBusinessDay.insertMany(nonBusinessDays, {ordered: false}, this.next());
    },
    function(err)
    {
      if (err && err.code === 11000)
      {
        return done();
      }

      module.info(`Recounted non-business days.`, {
        duration: Date.now() - t,
        from: this.from.toDate(),
        dayCount
      });

      done(err);
    }
  );
}
