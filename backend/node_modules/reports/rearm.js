// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');
const shifts = require('util/shifts');

exports.models = [
  require('prodShiftOrders/models/prodShiftOrder'),
  require('prodDowntimes/models/prodDowntime'),
  require('prodSerialNumbers/models/prodSerialNumber')
];

exports.report = (app, {mongoose}, options, done) =>
{
  const ProdShiftOrder = mongoose.model('ProdShiftOrder');
  const ProdDowntime = mongoose.model('ProdDowntime');
  const ProdSerialNumber = mongoose.model('ProdSerialNumber');

  const results = {
    options,
    lines: []
  };
  const psos = {};
  const lines = {};

  step(
    function()
    {
      const conditions = {};
      const sort = {};

      if (options.mrps.length)
      {
        conditions['orderData.mrp'] = {$in: options.mrps};
        sort['orderData.mrp'] = 1;
      }

      conditions.startedAt = {
        $gte: new Date(options.fromTime),
        $lt: new Date(options.toTime)
      };
      sort.startedAt = -1;

      const psoDone = _.once(this.parallel());
      const dtDone = _.once(this.parallel());

      const psoCursor = ProdShiftOrder
        .find(conditions)
        .select({
          startedAt: 1,
          finishedAt: 1,
          avgTaktTime: 1
        })
        .lean()
        .cursor();

      const dtCursor = ProdDowntime
        .find(conditions)
        .select({
          _id: 0,
          prodShiftOrder: 1,
          startedAt: 1,
          finishedAt: 1
        })
        .sort(sort)
        .lean()
        .cursor();

      psoCursor.on('data', handlePso);
      psoCursor.on('error', psoDone);
      psoCursor.on('end', psoDone);

      dtCursor.on('data', handleDt);
      dtCursor.on('error', dtDone);
      dtCursor.on('end', dtDone);
    },
    function(err)
    {
      if (err)
      {
        return this.skip(err);
      }

      const $match = {};

      if (options.mrps.length)
      {
        $match.mrp = {$in: options.mrps};
      }

      $match.scannedAt = {
        $gte: new Date(options.fromTime),
        $lt: new Date(options.toTime)
      };

      const pipeline = [
        {$match},
        {$group: {
          _id: '$prodShiftOrder',
          firstAt: {$min: '$scannedAt'},
          lastAt: {$max: '$scannedAt'},
          orderNo: {$first: '$orderNo'},
          mrp: {$first: '$mrp'},
          line: {$first: '$prodLine'}
        }},
        {$sort: {
          firstAt: 1
        }}
      ];

      const cursor = ProdSerialNumber.aggregate(pipeline).cursor().exec();
      const next = _.once(this.next());

      cursor.on('data', handlePsn);
      cursor.on('error', next);
      cursor.on('end', next);
    },
    function(err)
    {
      if (err)
      {
        return this.skip(err);
      }

      results.lines = Object.values(lines);
    },
    function(err)
    {
      if (err)
      {
        done(err, null);
      }
      else
      {
        done(null, results);
      }
    }
  );

  function getPso(id)
  {
    if (!psos[id])
    {
      psos[id] = {
        _id: id,
        startedAt: null,
        finishedAt: null,
        avgTaktTime: 0,
        downtimes: []
      };
    }

    return psos[id];
  }

  function handlePso(pso)
  {
    Object.assign(getPso(pso._id), pso);
  }

  function handleDt(dt)
  {
    getPso(dt.prodShiftOrder).downtimes.push(dt);
  }

  function handlePsn(psn)
  {
    if (!lines[psn.line])
    {
      lines[psn.line] = {
        _id: psn.line,
        orders: []
      };
    }

    const shiftAt = shifts.getShiftInfo(psn.firstAt, false).startTime;
    const pso = psos[psn._id] && psos[psn._id].startedAt ? psos[psn._id] : null;
    const prev = _.last(lines[psn.line].orders);
    const avgTaktTime = Math.round((pso ? pso.avgTaktTime : 0) / 1000);
    const idle = prev && prev[6] && pso ? Math.round((pso.startedAt - prev[6]) / 1000) : 0;
    let downtime = 0;

    for (let i = 0; i < pso.downtimes.length; ++i)
    {
      const dt = pso.downtimes[i];

      if (dt.startedAt >= psn.firstAt)
      {
        break;
      }

      downtime += (dt.finishedAt - dt.startedAt) / 1000;
    }

    const extraTime = prev && shiftAt !== prev[4] ? Math.round(idle + downtime) : 0;
    const metric1 = prev ? (Math.round((psn.firstAt - prev[3]) / 1000) - extraTime) : null;
    const metric2 = metric1 ? (metric1 - avgTaktTime) : null;
    const order = [
      psn.orderNo,
      psn.mrp,
      psn.firstAt.getTime(),
      psn.lastAt.getTime(),
      shiftAt,
      pso ? pso.startedAt.getTime() : 0,
      pso ? pso.finishedAt.getTime() : 0,
      Math.round((pso ? pso.avgTaktTime : 0) / 1000),
      idle,
      downtime,
      metric1,
      metric2
    ];

    lines[psn.line].orders.push(order);
  }
};
