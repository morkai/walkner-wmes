// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const vm = require('vm');
const _ = require('lodash');
const step = require('h5.step');
const shifts = require('util/shifts');
const median = require('util/median');

exports.models = [
  require('prodShiftOrders/models/prodShiftOrder'),
  require('prodDowntimes/models/prodDowntime'),
  require('prodSerialNumbers/models/prodSerialNumber'),
  require('downtimeReasons/models/downtimeReason'),
  require('settings/models/setting')
];

exports.report = (app, module, options, done) =>
{
  const {
    Setting,
    ProdShiftOrder,
    ProdDowntime,
    ProdSerialNumber
  } = module;

  const results = {
    options,
    settings: {
      downtimeColumns: [],
      metricColumns: []
    },
    lines: []
  };
  const psos = {};
  const lines = {};
  const columns = {
    downtime: [],
    metric: []
  };

  step(
    function()
    {
      Setting.findValues('reports.rearm.', this.parallel());

      const conditions = {};
      const sort = {};

      if (options.mrps.length)
      {
        conditions['orderData.mrp'] = {$in: options.mrps};
        sort['orderData.mrp'] = 1;
      }

      conditions.startedAt = {
        $gte: new Date(options.fromTime),
        $lt: new Date(options.toTime)
      };
      sort.startedAt = -1;

      const psoDone = _.once(this.parallel());
      const dtDone = _.once(this.parallel());

      const psoCursor = ProdShiftOrder
        .find(conditions)
        .select({
          prodShift: 1,
          startedAt: 1,
          finishedAt: 1,
          avgTaktTime: 1,
          sapTaktTime: 1,
          laborTime: 1,
          totalQuantity: 1,
          workDuration: 1,
          workerCount: 1,
          orderId: 1,
          operationNo: 1,
          prodLine: 1,
          'orderData.taktTimeCoeff': 1,
          'orderData.operations': 1,
          'orderData.mrp': 1
        })
        .lean()
        .cursor();

      const dtCursor = ProdDowntime
        .find(conditions)
        .select({
          _id: 0,
          prodShiftOrder: 1,
          startedAt: 1,
          finishedAt: 1,
          reason: 1
        })
        .sort(sort)
        .lean()
        .cursor();

      psoCursor.on('data', handlePso);
      psoCursor.on('error', psoDone);
      psoCursor.on('end', psoDone);

      dtCursor.on('data', handleDt);
      dtCursor.on('error', dtDone);
      dtCursor.on('end', dtDone);
    },
    function(err, settings)
    {
      if (err)
      {
        return this.skip(err);
      }

      Object.assign(results.settings, settings);

      results.settings.downtimeColumns.forEach(column =>
      {
        columns.downtime.push({...column});
      });

      results.settings.metricColumns.forEach(column =>
      {
        let script;

        try
        {
          script = new vm.Script(column.formula);
        }
        catch (err)
        {
          script = new vm.Script('0');
        }

        columns.metric.push({
          ...column,
          script
        });
      });

      const $match = {};

      if (options.mrps.length)
      {
        $match.mrp = {$in: options.mrps};
      }

      $match.scannedAt = {
        $gte: new Date(options.fromTime),
        $lt: new Date(options.toTime)
      };

      const pipeline = [
        {$match},
        {$sort: {scannedAt: 1}},
        {$group: {
          _id: '$prodShiftOrder',
          taktTime: {$push: '$taktTime'},
          firstAt: {$first: '$scannedAt'},
          lastAt: {$last: '$scannedAt'}
        }},
        {$sort: {
          firstAt: 1
        }}
      ];

      const cursor = ProdSerialNumber.aggregate(pipeline).cursor().exec();
      const next = _.once(this.next());

      cursor.on('data', handlePsn);
      cursor.on('error', next);
      cursor.on('end', next);
    },
    function(err)
    {
      if (err)
      {
        return this.skip(err);
      }

      results.lines = Object.values(lines);
    },
    function(err)
    {
      if (err)
      {
        done(err, null);
      }
      else
      {
        done(null, results);
      }
    }
  );

  function getPso(id)
  {
    if (!psos[id])
    {
      psos[id] = {
        _id: id,
        downtimes: []
      };
    }

    return psos[id];
  }

  function handlePso(pso)
  {
    const taktTimeCoeff = ProdShiftOrder.getTaktTimeCoeff(pso);
    const efficiency = (pso.laborTime * taktTimeCoeff / 100 * pso.totalQuantity)
      / (pso.workDuration * pso.workerCount);

    pso.taktTimeCoeff = taktTimeCoeff;
    pso.efficiency = isNaN(efficiency) || !isFinite(efficiency) ? 0 : Math.round(efficiency * 100);

    Object.assign(getPso(pso._id), pso);
  }

  function handleDt(dt)
  {
    getPso(dt.prodShiftOrder).downtimes.unshift(dt);
  }

  function handlePsn(psn)
  {
    const pso = psos[psn._id];

    if (!pso || !pso.finishedAt)
    {
      return;
    }

    if (!lines[pso.prodLine])
    {
      lines[pso.prodLine] = {
        _id: pso.prodLine,
        orders: []
      };
    }

    const startedAt = pso.startedAt.getTime();
    const finishedAt = pso.finishedAt.getTime();
    const avgTaktTime = Math.round(pso.avgTaktTime / 1000);
    const medTaktTime = Math.round(median(psn.taktTime, false) / 1000);
    const shiftAt = shifts.getShiftInfo(startedAt, false).startTime;
    const shiftOrders = lines[pso.prodLine].orders.filter(o => o[0] === pso.prodShift);
    const prev = _.last(lines[pso.prodLine].orders);
    const prevShift = prev && prev[6] === shiftAt ? prev : null;
    const prevFinishedAt = prev ? prev[8] : startedAt;
    const idle = Math.round((startedAt - prevFinishedAt) / 1000);
    const downtimes = [];
    const metrics = [];
    const vars = {
      IDLE: idle,
      TT_SAP: pso.sapTaktTime,
      TT_AVG: avgTaktTime,
      TT_MED: medTaktTime,
      FIRST_AT: psn.firstAt.getTime() / 1000,
      LAST_AT: psn.lastAt.getTime() / 1000,
      PREV_AT: (prevShift ? prevShift[5] : startedAt) / 1000,
      STARTED_AT: startedAt / 1000,
      FINISHED_AT: finishedAt / 1000,
      QTY_DONE: pso.totalQuantity,
      WORKER_COUNT: pso.workerCount,
      EFF: pso.efficiency,
      EFF_COEFF: pso.taktTimeCoeff,
      LABOR_TIME: pso.laborTime,
      IDX_OVERALL: lines[pso.prodLine].orders.length + 1,
      IDX_SHIFT: shiftOrders.length + 1
    };

    columns.downtime.forEach(downtime =>
    {
      vars[downtime.variable] = 0;
    });

    columns.metric.forEach(metric =>
    {
      vars[metric.variable] = 0;
    });

    for (let i = 0; i < pso.downtimes.length; ++i)
    {
      const dt = pso.downtimes[i];

      if (dt.startedAt >= psn.firstAt)
      {
        break;
      }

      const duration = (dt.finishedAt - dt.startedAt) / 1000;

      columns.downtime.forEach(downtime =>
      {
        if (!downtime.reasons.length)
        {
          vars[downtime.variable] += duration;

          return;
        }

        if (downtime.exclude)
        {
          if (downtime.reasons.includes(dt.reason))
          {
            return;
          }

          vars[downtime.variable] += duration;

          return;
        }

        if (!downtime.reasons.includes(dt.reason))
        {
          return;
        }

        vars[downtime.variable] += duration;
      });
    }

    columns.downtime.forEach(downtime =>
    {
      downtimes.push(Math.round(vars[downtime.variable]));
    });

    vm.createContext(vars, {
      codeGeneration: {
        strings: false,
        wasm: false
      }
    });

    columns.metric.forEach(metric =>
    {
      let value = 0;

      try
      {
        value = metric.script.runInContext(vars, {
          displayErrors: false,
          timeout: 100
        });

        value = isNaN(value) || !isFinite(value) ? 0 : Math.round(value);
      }
      catch (err) {} // eslint-disable-line no-empty

      vars[metric.variable] = value;
      metrics.push(value);
    });

    const order = [
      pso.prodShift,
      pso._id,
      pso.orderId,
      pso.orderData.mrp,
      psn.firstAt.getTime(),
      psn.lastAt.getTime(),
      shiftAt,
      startedAt,
      finishedAt,
      pso.sapTaktTime,
      avgTaktTime,
      medTaktTime,
      pso.totalQuantity,
      pso.workerCount,
      pso.efficiency,
      idle,
      downtimes,
      metrics
    ];

    lines[pso.prodLine].orders.push(order);
  }
};
