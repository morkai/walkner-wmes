// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');
const shifts = require('util/shifts');

exports.models = [
  require('prodShiftOrders/models/prodShiftOrder'),
  require('prodDowntimes/models/prodDowntime'),
  require('prodSerialNumbers/models/prodSerialNumber'),
  require('downtimeReasons/models/downtimeReason')
];

exports.report = (app, {mongoose}, options, done) =>
{
  const ProdShiftOrder = mongoose.model('ProdShiftOrder');
  const ProdDowntime = mongoose.model('ProdDowntime');
  const ProdSerialNumber = mongoose.model('ProdSerialNumber');
  const DowntimeReason = mongoose.model('DowntimeReason');

  const results = {
    options,
    lines: []
  };
  const psos = {};
  const lines = {};
  const now = new Date();
  const breakReasons = new Set();

  step(
    function()
    {
      DowntimeReason
        .find({type: 'break'})
        .select({_id: 1})
        .lean()
        .exec(this.parallel());

      const conditions = {};
      const sort = {};

      if (options.mrps.length)
      {
        conditions['orderData.mrp'] = {$in: options.mrps};
        sort['orderData.mrp'] = 1;
      }

      conditions.startedAt = {
        $gte: new Date(options.fromTime),
        $lt: new Date(options.toTime)
      };
      sort.startedAt = -1;

      const psoDone = _.once(this.parallel());
      const dtDone = _.once(this.parallel());

      const psoCursor = ProdShiftOrder
        .find(conditions)
        .select({
          startedAt: 1,
          finishedAt: 1,
          avgTaktTime: 1
        })
        .lean()
        .cursor();

      const dtCursor = ProdDowntime
        .find(conditions)
        .select({
          _id: 0,
          prodShiftOrder: 1,
          startedAt: 1,
          finishedAt: 1,
          reason: 1
        })
        .sort(sort)
        .lean()
        .cursor();

      psoCursor.on('data', handlePso);
      psoCursor.on('error', psoDone);
      psoCursor.on('end', psoDone);

      dtCursor.on('data', handleDt);
      dtCursor.on('error', dtDone);
      dtCursor.on('end', dtDone);
    },
    function(err, downtimeReasons)
    {
      if (err)
      {
        return this.skip(err);
      }

      downtimeReasons.forEach(downtimeReason =>
      {
        breakReasons.add(downtimeReason._id);
      });

      const $match = {};

      if (options.mrps.length)
      {
        $match.mrp = {$in: options.mrps};
      }

      $match.scannedAt = {
        $gte: new Date(options.fromTime),
        $lt: new Date(options.toTime)
      };

      const pipeline = [
        {$match},
        {$group: {
          _id: '$prodShiftOrder',
          firstAt: {$min: '$scannedAt'},
          lastAt: {$max: '$scannedAt'},
          orderNo: {$first: '$orderNo'},
          mrp: {$first: '$mrp'},
          line: {$first: '$prodLine'}
        }},
        {$sort: {
          firstAt: 1
        }}
      ];

      const cursor = ProdSerialNumber.aggregate(pipeline).cursor().exec();
      const next = _.once(this.next());

      cursor.on('data', handlePsn);
      cursor.on('error', next);
      cursor.on('end', next);
    },
    function(err)
    {
      if (err)
      {
        return this.skip(err);
      }

      results.lines = Object.values(lines);
    },
    function(err)
    {
      if (err)
      {
        done(err, null);
      }
      else
      {
        done(null, results);
      }
    }
  );

  function getPso(id)
  {
    if (!psos[id])
    {
      psos[id] = {
        _id: id,
        startedAt: null,
        finishedAt: null,
        avgTaktTime: 0,
        downtimes: []
      };
    }

    return psos[id];
  }

  function handlePso(pso)
  {
    Object.assign(getPso(pso._id), pso);
  }

  function handleDt(dt)
  {
    getPso(dt.prodShiftOrder).downtimes.push(dt);
  }

  function handlePsn(psn)
  {
    if (!lines[psn.line])
    {
      lines[psn.line] = {
        _id: psn.line,
        orders: []
      };
    }

    const shiftAt = shifts.getShiftInfo(psn.firstAt, false).startTime;
    const pso = psos[psn._id] && psos[psn._id].startedAt ? psos[psn._id] : null;
    const prev = _.last(lines[psn.line].orders);
    const avgTaktTime = Math.round((pso ? pso.avgTaktTime : 0) / 1000);
    const idle = prev && prev[6] && pso ? Math.round((pso.startedAt - prev[6]) / 1000) : 0;
    let downtime = 0;
    let breaks = 0;

    if (pso)
    {
      for (let i = 0; i < pso.downtimes.length; ++i)
      {
        const dt = pso.downtimes[i];

        if (dt.startedAt >= psn.firstAt)
        {
          break;
        }

        const duration = (dt.finishedAt - dt.startedAt) / 1000;

        if (breakReasons.has(dt.reason))
        {
          breaks += duration;
        }
        else
        {
          downtime += duration;
        }
      }
    }

    const extraTime = prev && shiftAt !== prev[4] ? Math.round(idle + downtime + breaks) : 0;
    const metric0 = prev ? Math.round((psn.firstAt - prev[3]) / 1000) : null;
    const metric1 = metric0 !== null ? (metric0 - extraTime) : null;
    const metric2 = metric1 !== null ? (metric1 - avgTaktTime) : null;
    const metric3 = metric2 !== null ? (metric2 - (extraTime ? 0 : Math.round(idle + downtime + breaks))) : null;
    const order = [
      psn.orderNo,
      psn.mrp,
      psn.firstAt.getTime(),
      psn.lastAt.getTime(),
      shiftAt,
      pso ? pso.startedAt.getTime() : 0,
      pso ? (pso.finishedAt || now).getTime() : 0,
      Math.round((pso ? pso.avgTaktTime : 0) / 1000),
      idle,
      downtime,
      breaks,
      metric0,
      metric1,
      metric2,
      metric3
    ];

    lines[psn.line].orders.push(order);
  }
};
