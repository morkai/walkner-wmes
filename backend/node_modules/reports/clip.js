// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');
const moment = require('moment');
const resolveProductName = require('util/resolveProductName');
const businessDays = require('./businessDays');
const util = require('./util');

const ORDER_BLACKLIST = new Set([
  '122762293',
  '122762414',
  '122762335',
  '122762391',
  '122762239'
]);

exports.models = [
  require('./models/dailyMrpCount'),
  require('./models/clipOrderCache'),
  require('orders/models/order'),
  require('orders/models/orderEto'),
  require('settings/models/setting'),
  require('delayReasons/models/delayReason'),
  require('wmes-fap/models/fapEntry')
];

exports.report = (app, {mongoose}, options, done) =>
{
  const DailyMrpCount = mongoose.model('DailyMrpCount');
  const ClipOrderCache = mongoose.model('ClipOrderCache');
  const Order = mongoose.model('Order');
  const OrderEto = mongoose.model('OrderEto');
  const Setting = mongoose.model('Setting');
  const DelayReason = mongoose.model('DelayReason');

  Object.assign(options, {
    dateProperty: 'finishDate',
    findDateProperty: 'scheduledStartDate',
    dataDateProperty: 'scheduledFinishDate',
    dataHoursOffset: '30: *',
    ignoreDone: true,
    ignoredMrps: 'KS1,KS2,KS3,KS4,KS5,KS6,KS7,KS9,KSA,KSB,KSC,KSD,KSE,KSH'.split(','),
    ignoredDelayReasons: [],
    ignoredStatuses: 'TECO,DEL,DLT,DLFL'.split(','),
    requiredStatuses: 'REL'.split(','),
    productionStatuses: 'CNF'.split(','),
    endToEndStatuses: 'DLV'.split(','),
    orderFilterMode: 'red',
    orderFilterStatuses: []
  });

  const dataHoursOffset = {
    '*': 30
  };

  const results = {
    options,
    fromTimeLocal: 0,
    toTimeLocal: 0,
    orderCount: 0,
    orderHash: null,
    parent: [],
    children: {},
    mrps: new Set(),
    groups: {},
    delayReasons: {},
    m4s: {},
    drms: {},
    orders: []
  };
  const expireAt = moment().add(1, 'hours').toDate();
  const orderFilters = {};

  let fromLocal;
  let toLocal;

  step(
    function()
    {
      Setting.find({_id: /^reports\.clip\./}, {value: 1}).lean().exec(this.next());
    },
    function(err, settings)
    {
      if (err)
      {
        return this.skip(err);
      }

      settings.forEach(setting =>
      {
        const id = setting._id.replace('reports.clip.', '');

        if (!/PropertyOffset$/.test(id) || options[id] === null)
        {
          options[id] = setting.value;
        }
      });

      fromLocal = moment(options.fromTime);
      toLocal = moment(options.toTime);

      const fromUtc = moment.utc(fromLocal.format('YYYY-MM-DD'), 'YYYY-MM-DD');
      const toUtc = moment.utc(toLocal.format('YYYY-MM-DD'), 'YYYY-MM-DD');

      const countProperty = options.orgUnitType
        ? `count.${options.orgUnitType}.${options.orgUnitId}`
        : 'count.all';
      const conditions = {
        _id: {
          $gte: fromUtc.toDate(),
          $lt: toUtc.toDate()
        }
      };

      DailyMrpCount.find(conditions, {[countProperty]: 1}).lean().exec(this.parallel());

      DelayReason.find({}).lean().exec(this.parallel());

      OrderEto.findSet(this.parallel());
    },
    function(err, dailyMrpCounts, delayReasons, orderEtos)
    {
      if (err)
      {
        return this.skip(err);
      }

      options.dataHoursOffset.split('\n').forEach(line =>
      {
        const parts = line.split(':');
        const hours = parseInt(parts[0], 10);
        const mrps = parts[1].trim().split(', ');

        mrps.forEach(mrp => dataHoursOffset[mrp] = hours);
      });

      dailyMrpCounts.forEach(dailyMrpCount =>
      {
        let mrps = dailyMrpCount.count;

        if (!options.orgUnitType)
        {
          mrps = mrps.all;
        }
        else if (mrps[options.orgUnitType] && mrps[options.orgUnitType][options.orgUnitId])
        {
          mrps = mrps[options.orgUnitType][options.orgUnitId];
        }
        else
        {
          mrps = [];
        }

        if (options.orgUnitType === 'mrpController')
        {
          if (!_.isEmpty(mrps) && !options.ignoredMrps.includes(options.orgUnitId))
          {
            mrps.prodFlow.forEach(prodFlow => results.children[prodFlow] = true);
            results.parent = mrps.subdivision;
            results.mrps.add(options.orgUnitId);
          }

          return;
        }

        mrps.forEach(mrp =>
        {
          if (!options.ignoredMrps.includes(mrp))
          {
            results.mrps.add(mrp);
          }
        });
      });

      this.delayReasons = {};

      delayReasons.forEach(delayReason =>
      {
        this.delayReasons[delayReason._id] = delayReason.drm;
      });

      this.orderEtos = orderEtos;

      setImmediate(this.next());
    },
    function()
    {
      fromLocal = addBusinessDays(fromLocal, options.findDatePropertyOffset);
      toLocal = addBusinessDays(toLocal, options.findDatePropertyOffset);

      const conditions = {
        [options.findDateProperty]: {
          $gte: fromLocal.toDate(),
          $lt: toLocal.toDate()
        }
      };

      if (options.orgUnitType)
      {
        conditions.mrp = {$in: Array.from(results.mrps)};
      }
      else if (options.ignoredMrps.length)
      {
        conditions.mrp = {$nin: options.ignoredMrps};
      }

      if (!_.isEmpty(options.requiredStatuses))
      {
        conditions.statuses = {$in: options.requiredStatuses};
      }

      if (!_.isEmpty(options.ignoredStatuses))
      {
        if (!conditions.statuses)
        {
          conditions.statuses = {};
        }

        conditions.statuses.$nin = options.ignoredStatuses;
      }

      if (!_.isEmpty(options.ignoredStatuses))
      {
        if (!conditions.statuses)
        {
          conditions.statuses = {};
        }

        conditions.statuses.$nin = options.ignoredStatuses;
      }

      if (!_.isEmpty(options.ignoredDelayReasons))
      {
        conditions.delayReason = {$nin: options.ignoredDelayReasons};
      }

      const fields = {
        nc12: 1,
        name: 1,
        description: 1,
        qty: 1,
        'qtyDone.total': 1,
        mrp: 1,
        scheduledStartDate: 1,
        scheduledFinishDate: 1,
        startDate: 1,
        finishDate: 1,
        delayReason: 1,
        delayComponent: 1,
        m4: 1,
        statuses: 1,
        'changes.time': 1,
        'changes.oldValues.statuses': 1,
        'changes.newValues.statuses': 1,
        'changes.comment': 1
      };
      const hint = {
        [options.findDateProperty]: -1
      };
      const cursor = Order.find(conditions).select(fields).lean().hint(hint).cursor({batchSize: 20});
      const next = _.once(this.next());

      cursor.on('error', next);
      cursor.on('end', next);
      cursor.on('data', order =>
      {
        if (ORDER_BLACKLIST.has(order._id))
        {
          return;
        }

        results.mrps.add(order.mrp);

        const dataMoment = moment(order[options.dataDateProperty]);
        const hoursOffset = dataHoursOffset[order.mrp] || dataHoursOffset['*'];
        const daysOffset = options.dataDatePropertyOffset + Math.floor(hoursOffset / 24);

        addBusinessDays(dataMoment, daysOffset);

        dataMoment.add(hoursOffset % 24, 'hours');

        const dataTime = dataMoment.valueOf();

        order.productionStatus = null;
        order.endToEndStatus = null;

        order.statuses.forEach(status =>
        {
          if (options.productionStatuses.includes(status))
          {
            order.productionStatus = status;
          }

          if (options.endToEndStatuses.includes(status))
          {
            order.endToEndStatus = status;
          }
        });

        order.confirmed = !!orderFilters[options.orderFilterMode] && !orderFilters[options.orderFilterMode](order);
        order.comment = null;
        order.productionTime = null;
        order.productionStatus = null;
        order.endToEndTime = null;
        order.endToEndStatus = null;

        for (let i = 0; i < order.changes.length; ++i)
        {
          if (order.changes[i].oldValues.statuses)
          {
            order.statuses = order.changes[i].oldValues.statuses;

            break;
          }
        }

        order.changes.forEach(change =>
        {
          if (!_.isEmpty(change.comment))
          {
            order.comment = change.comment;
          }

          if (!change.newValues.statuses || change.time > dataTime)
          {
            return;
          }

          order.statuses = change.newValues.statuses;

          order.statuses.forEach(status =>
          {
            if (options.productionStatuses.includes(status)
              && (!order.productionTime || status !== order.productionStatus))
            {
              order.productionTime = change.time.getTime();
              order.productionStatus = status;
            }

            if (options.endToEndStatuses.includes(status)
              && (!order.endToEndTime || status !== order.endToEndStatus))
            {
              order.endToEndTime = change.time.getTime();
              order.endToEndStatus = status;
            }
          });
        });

        order._id = {
          hash: options.hash,
          no: order._id
        };
        order.expireAt = expireAt;
        order.name = resolveProductName(order);
        order.startDate = Date.parse(order.startDate);
        order.finishDate = Date.parse(order.finishDate);
        order.scheduledStartDate = Date.parse(order.scheduledStartDate);
        order.scheduledFinishDate = Date.parse(order.scheduledFinishDate);
        order.qtyDone = order.qtyDone ? order.qtyDone.total : 0;
        order.drm = '';
        order.eto = this.orderEtos.has(order.nc12);
        order.description = undefined;
        order.changes = undefined;

        order[options.dateProperty] = addBusinessDays(
          moment(order[options.dateProperty]),
          options.datePropertyOffset
        ).valueOf();

        if (order.delayReason)
        {
          if (!results.delayReasons[order.delayReason])
          {
            results.delayReasons[order.delayReason] = 0;
          }

          results.delayReasons[order.delayReason] += 1;
        }

        if (order.m4)
        {
          if (!results.m4s[order.m4])
          {
            results.m4s[order.m4] = 0;
          }

          results.m4s[order.m4] += 1;

          const drm = this.delayReasons[order.delayReason];

          if (drm)
          {
            order.drm = drm;

            if (!results.drms[drm])
            {
              results.drms[drm] = 0;
            }

            results.drms[drm] += 1;
          }
        }

        const group = getGroup(order[options.findDateProperty]);

        group.orderCount += 1;

        order.statuses.forEach(status =>
        {
          if (options.productionStatuses.includes(status))
          {
            group.productionCount += 1;
          }

          if (options.endToEndStatuses.includes(status))
          {
            group.endToEndCount += 1;
          }
        });

        if (options.ignoreDone && order.qtyDone >= order.qty)
        {
          return;
        }

        if (orderFilters[options.orderFilterMode] && orderFilters[options.orderFilterMode](order))
        {
          results.orders.push(order);
        }
      });
    },
    function(err)
    {
      if (err)
      {
        return this.skip(err);
      }

      if (options.hash)
      {
        ClipOrderCache.collection.deleteMany({'_id.hash': options.hash}, this.next());
      }
    },
    function(err)
    {
      if (err)
      {
        return this.skip(err);
      }

      if (options.hash && results.orders.length)
      {
        ClipOrderCache.collection.insertMany(results.orders, {ordered: false}, this.next());
      }
    },
    function(err)
    {
      if (err)
      {
        return this.skip(err);
      }

      const createNextGroupKey = util.createCreateNextGroupKey(options.interval);
      const groupKeys = Object.keys(results.groups).map(k => +k).sort();
      const groups = [];
      const toGroupKey = _.last(groupKeys);
      let groupKey = groupKeys[0];

      while (groupKey <= toGroupKey)
      {
        groups.push(getGroup(groupKey));

        groupKey = createNextGroupKey(groupKey);
      }

      results.groups = groups;
      results.parent = results.parent[0] || null;
      results.mrps = Array.from(results.mrps);
      results.children = Object.keys(results.children);

      if (!results.children.length && results.mrps.length)
      {
        results.children = results.mrps;
      }

      ['delayReasons', 'm4s', 'drms'].forEach(prop =>
      {
        results[prop] = Object
          .keys(results[prop])
          .sort((a, b) => results[prop][b] - results[prop][a])
          .map(k => ({_id: k, count: results[prop][k]}));
      });

      results.orderHash = options.hash;
      results.orderCount = results.orders.length;
      results.orders = undefined;
      options.hash = undefined;

      setImmediate(this.next());
    },
    function(err)
    {
      if (err)
      {
        done(err, null);
      }
      else
      {
        results.fromTimeLocal = Date.parse(fromLocal);
        results.toTimeLocal = Date.parse(toLocal);

        done(null, results);
      }
    }
  );

  function getGroup(date)
  {
    const key = util.createGroupKey(options.interval, date, false);

    if (!results.groups[key])
    {
      results.groups[key] = {
        key: key,
        orderCount: 0,
        productionCount: 0,
        endToEndCount: 0
      };
    }

    return results.groups[key];
  }

  function addBusinessDays(dateMoment, daysOffset)
  {
    if (daysOffset === 0)
    {
      return dateMoment;
    }

    const offset = daysOffset > 0 ? 1 : -1;
    let remainingDays = Math.abs(daysOffset);

    while (remainingDays > 0)
    {
      dateMoment.add(offset, 'days');

      if (businessDays.countInDay(dateMoment.toDate()))
      {
        remainingDays -= 1;
      }
    }

    return dateMoment;
  }

  // Not confirmed by the production or not confirmed by the warehouse
  orderFilters.red = function(order)
  {
    return !order.productionStatus || !order.endToEndStatus;
  };

  // Has all of the specified statuses
  orderFilters.all = function(order)
  {
    const requiredStatuses = options.orderFilterStatuses;
    const actualStatuses = order.statuses;

    for (let i = 0; i < requiredStatuses.length; ++i)
    {
      if (!actualStatuses.includes(requiredStatuses[i]))
      {
        return false;
      }
    }

    return true;
  };

  // Does not have all of the specified statuses
  orderFilters.none = function(order)
  {
    const requiredStatuses = options.orderFilterStatuses;
    const actualStatuses = order.statuses;

    for (let i = 0; i < requiredStatuses.length; ++i)
    {
      if (actualStatuses.includes(requiredStatuses[i]))
      {
        return false;
      }
    }

    return true;
  };

  // Does not have one of the specified statuses
  orderFilters.without = function(order)
  {
    const requiredStatuses = options.orderFilterStatuses;
    const actualStatuses = order.statuses;

    for (let i = 0; i < requiredStatuses.length; ++i)
    {
      if (!actualStatuses.includes(requiredStatuses[i]))
      {
        return true;
      }
    }

    return false;
  };

  // Has any specified status
  orderFilters.any = function(order)
  {
    const requiredStatuses = options.orderFilterStatuses;
    const actualStatuses = order.statuses;

    for (let i = 0; i < requiredStatuses.length; ++i)
    {
      if (actualStatuses.includes(requiredStatuses[i]))
      {
        return true;
      }
    }

    return false;
  };
};
