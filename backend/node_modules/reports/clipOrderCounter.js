// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const moment = require('moment');
const step = require('h5.step');

exports.DEFAULT_CONFIG = {
  mongooseId: 'mongoose',
  importerId: 'orders/importer/orders',
  syncHour: 6
};

exports.models = [
  require('./models/clipOrderCount'),
  require('orders/models/order'),
  require('mrpControllers/models/mrpController')
];

exports.recordTopics = {
  info: ['clipOrderCount.created']
};

exports.requiredModules = 'mongoose';

exports.start = (app, module) =>
{
  const {Order, MrpController, ClipOrderCount} = module;

  app.broker.subscribe('app.started', scheduleClipOrderCountCheck).setLimit(1);

  app.broker.subscribe('orders.synced', () => countAllOrders()).setFilter((message) =>
  {
    return message.moduleName === module.config.importerId
      && new Date().getHours() === module.config.syncHour;
  });

  function yesterday()
  {
    return moment().startOf('day').subtract(1, 'days').toDate();
  }

  function scheduleClipOrderCountCheck()
  {
    const now = new Date();

    if (now.getHours() > module.config.syncHour)
    {
      checkClipOrderCount();
    }

    const nowTime = now.getTime();
    const nextCheckMoment = moment(now)
      .hours(module.config.syncHour + 1)
      .minutes(1)
      .seconds(0)
      .milliseconds(0)
      .add(1, 'days');

    setTimeout(scheduleClipOrderCountCheck, nextCheckMoment.diff(nowTime));

    module.info('Scheduled the next CLIP order count check.', {nextCheckAt: nextCheckMoment.toDate()});
  }

  function checkClipOrderCount()
  {
    const startDate = yesterday();

    module.info('Checking the CLIP order count...', {startDate});

    ClipOrderCount.countDocuments({date: startDate}, function(err, count)
    {
      if (err)
      {
        return module.error(err, 'Failed to count ClipOrderCount.', {startDate});
      }

      if (count === 0)
      {
        countAllOrders(startDate);
      }
    });
  }

  function countAllOrders(startDate)
  {
    if (!startDate)
    {
      startDate = yesterday();
    }

    module.info('Preparing CLIP...', {startDate});

    step(
      function()
      {
        MrpController.find({replacedBy: {$ne: null}}, {replacedBy: 1}).lean().exec(this.parallel());

        Order.aggregate(
          [
            {$match: {scheduledStartDate: startDate}},
            {$group: {_id: '$mrp', count: {$sum: 1}}}
          ],
          this.parallel()
        );
      },
      function(err, mrpControllers, results)
      {
        if (err)
        {
          return module.error(err, 'Failed to count all orders.');
        }

        const replacedMrpMap = {};

        _.forEach(mrpControllers, function(mrpController)
        {
          replacedMrpMap[mrpController._id] = mrpController.replacedBy;
        });

        const mrpToCountMap = {};

        _.forEach(results, function(result)
        {
          mrpToCountMap[replacedMrpMap[result._id] || result._id] = {
            all: result.count,
            cnf: 0,
            dlv: 0
          };
        });

        countOrdersByStatuses(startDate, replacedMrpMap, mrpToCountMap);
      }
    );
  }

  function countOrdersByStatuses(startDate, replacedMrpMap, mrpToCountMap)
  {
    Order.aggregate(
      [
        {$match: {scheduledStartDate: startDate}},
        {$project: {_id: 0, mrp: 1, statuses: 1}},
        {$unwind: '$statuses'},
        {$match: {statuses: {$in: ['CNF', 'DLV']}}},
        {$group: {
          _id: {status: '$statuses', mrp: '$mrp'},
          count: {$sum: 1}
        }}
      ],
      function(err, results)
      {
        if (err)
        {
          return module.error(err, 'Failed to count orders by statuses.');
        }

        _.forEach(results, function(result)
        {
          const mrp = replacedMrpMap[result._id.mrp] || result._id.mrp;
          const status = result._id.status.toLowerCase();

          mrpToCountMap[mrp][status] = result.count;
        });

        createClipOrderCounts(startDate, mrpToCountMap);
      }
    );
  }

  function createClipOrderCounts(startDate, mrpToCountMap)
  {
    const models = [];

    _.forEach(mrpToCountMap, function(count, mrp)
    {
      models.push({
        date: startDate,
        tzOffsetMs: startDate.getTimezoneOffset() * 60 * 1000 * -1,
        mrp: mrp,
        all: count.all,
        cnf: count.cnf,
        dlv: count.dlv
      });
    });

    ClipOrderCount.create(models, function(err)
    {
      if (err)
      {
        return module.error(err, 'Failed to create ClipOrderCounts.', {startDate, count: models.length});
      }

      module.info('Created new ClipOrderCounts.', {startDate, count: models.length});

      app.broker.publish('clipOrderCount.created', {
        date: startDate,
        total: models.length
      });
    });
  }
};
