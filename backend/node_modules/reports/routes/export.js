// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const path = require('path');
const fs = require('fs');
const {tmpdir} = require('os');
const {exec} = require('child_process');
const step = require('h5.step');

const DIACRITICS = {
  ę: 'e',
  ą: 'a',
  ś: 's',
  ł: 'l',
  ż: 'z',
  ź: 'z',
  ć: 'c',
  ń: 'n',
  Ę: 'E',
  Ą: 'A',
  Ś: 'S',
  Ł: 'L',
  Ż: 'Z',
  Ź: 'Z',
  Ć: 'C',
  Ń: 'N'
};

module.exports = (app, module, req, res, next) =>
{
  const input = {...req.query, ...req.body};
  const svg = input.svg;

  if (typeof svg !== 'string'
    || svg.length === 0
    || svg.indexOf('<!ENTITY') !== -1
    || svg.indexOf('<!DOCTYPE') !== -1)
  {
    return res.sendStatus(400);
  }

  const filename = typeof input.filename === 'string' ? cleanFilename(input.filename) : 'chart';
  let typeArg = null;
  let ext = null;

  switch (input.type)
  {
    case 'image/png':
      typeArg = '-m image/png';
      ext = 'png';
      break;

    case 'image/jpeg':
      typeArg = '-m image/jpeg';
      ext = 'jpg';
      break;

    case 'application/pdf':
      typeArg = '-m application/pdf';
      ext = 'pdf';
      break;
  }

  if (typeArg === null)
  {
    res.attachment(filename + '.svg');

    return res.send(svg);
  }

  const tmpDir = tmpdir();
  const tmpFilename = (Date.now() + Math.random()).toString();
  const tmpFile = path.join(tmpDir, tmpFilename) + '.svg';
  const outFile = path.join(tmpDir, tmpFilename + '.' + ext);

  let cmd = module.config.javaBatik + ' ' + typeArg + ' -d "' + outFile + '"';

  const width = parseInt(input.width, 10);

  if (width > 0)
  {
    cmd += ' -w ' + width;
  }

  const height = parseInt(input.height, 10);

  if (width > 0)
  {
    cmd += ' -h ' + height;
  }

  cmd += ' "' + tmpFile + '"';

  step(
    function()
    {
      fs.writeFile(tmpFile, svg, this.next());
    },
    function(err)
    {
      if (err)
      {
        return this.skip(err);
      }

      const next = this.next();

      exec(cmd, (err, stdout, stderr) =>
      {
        if (err)
        {
          next(err);
        }
        else
        {
          next(null, {stdout, stderr});
        }
      });
    },
    function(err, std)
    {
      if (err)
      {
        return this.skip(err);
      }

      if (std.stderr)
      {
        return this.skip(std.stderr, 'STDERR', 500);
      }
    },
    function(err)
    {
      if (err)
      {
        cleanup();

        return next(err);
      }

      if (res.headersSent)
      {
        cleanup();

        return next(app.createError('Headers already sent.', 'HEADERS_SENT', 500));
      }

      if (input.inline === '1')
      {
        if (input.base64 === '1')
        {
          return base64();
        }

        return res.sendFile(outFile, cleanup);
      }

      const attachment = `${filename}.${ext}`;

      if (input.delay === '1')
      {
        return res.json(module.downloads.set(null, {
          cleanup,
          cleanupDelay: 10000,
          attachment,
          file: outFile
        }));
      }

      res.attachment(attachment);
      res.sendFile(outFile, cleanup);
    }
  );

  function base64()
  {
    fs.readFile(outFile, 'base64', (err, data) =>
    {
      if (err)
      {
        return next(err);
      }

      res.type('text/plain');
      res.end(data);

      cleanup();
    });
  }

  function cleanup()
  {
    fs.unlink(tmpFile, () => {});
    fs.unlink(outFile, () => {});
  }
};

function cleanFilename(filename)
{
  return filename
    .replace(/[^a-zA-Z0-9_\-]/g, function(c) { return DIACRITICS[c] || ' '; })
    .replace(/\s+/g, '_')
    .replace(/_{2,}/g, '_');
}
