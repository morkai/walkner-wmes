// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');
const request = require('request');
const resolveProductName = require('util/resolveProductName');

module.exports = (app, module) =>
{
  const {
    settings,
    messengerServer,
    ProdShiftOrder,
    Order,
    KanbanEntry,
    KanbanSupplyArea
  } = module;

  const orderCache = new Map();

  messengerServer.handle('luca.setLineOrder', handleSetLineOrder);
  messengerServer.handle('luca.getLineOrder', handleGetLineOrder);

  app.broker.subscribe('app.started', onAppStarted);
  app.broker.subscribe('luca.orderChanged', onLineOrderChanged);
  app.broker.subscribe('luca.kanbanChanged', onKanbanChanged);

  setInterval(() => orderCache.clear(), 24 * 3600 * 1000);

  function onAppStarted()
  {
    settings.findById('luca.lines', (err, setting) =>
    {
      if (err)
      {
        return module.error(err, `Failed to find lines.`);
      }

      if (!Array.isArray(setting.value) || !setting.value.length)
      {
        return;
      }

      setting.value.forEach(lineId => setLineOrder(lineId, null, null));
    });
  }

  function onLineOrderChanged({lineId})
  {
    setLineOrder(lineId, null, null);
  }

  function onKanbanChanged()
  {
    orderCache.clear();
  }

  function handleSetLineOrder({lineId, orderNo}, done)
  {
    setLineOrder(lineId, orderNo, done);
  }

  function handleGetLineOrder({lineId, orderNo}, done)
  {
    getLineOrder(lineId, orderNo, done);
  }

  function setLineOrder(lineId, orderNo, done)
  {
    step(
      function()
      {
        settings.findValues('luca.', this.next());
      },
      function(err, settings)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!Array.isArray(settings.lines) || !settings.lines.includes(lineId))
        {
          return this.skip(app.createError(`Invalid line.`, 'INVALID_INPUT', 400));
        }

        if (!_.isString(settings.setLineOrderUrl) || _.isEmpty(settings.setLineOrderUrl))
        {
          return this.skip(app.createError(`Set line order URL not configured.`, 'INVALID_SETTINGS', 500));
        }

        this.settings = settings;
      },
      function()
      {
        getLineOrder(lineId, orderNo, this.next());
      },
      function(err, result)
      {
        if (err)
        {
          return this.skip(err);
        }

        setImmediate(this.parallel(), null, result);

        request({
          method: 'POST',
          url: this.settings.setLineOrderUrl,
          headers: {
            'User-Agent': 'WMES'
          },
          json: true,
          body: result
        }, this.parallel());
      },
      function(err, result, res)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (res.statusCode >= 300)
        {
          return this.skip(app.createError('Invalid response status code.', 'INVALID_RESPONSE', 500, {
            expectedStatusCode: 200,
            actualStatusCode: res.statusCode
          }));
        }

        setImmediate(this.next(), null, result);
      },
      function(err, result)
      {
        if (err)
        {
          if (done || err.code !== 'INVALID_INPUT')
          {
            module.error(err, `Failed to set line order.`, {lineId, orderNo});
          }
        }
        else
        {
          module.info(`Line order set.`, result);
        }

        if (done)
        {
          done(err, result);
        }
      }
    );
  }

  function getLineOrder(lineId, orderNo, done)
  {
    if (orderCache.has(`${lineId}:${orderNo}`))
    {
      return done(null, orderCache.get(`${lineId}:${orderNo}`));
    }

    step(
      function()
      {
        if (_.isString(orderNo) && orderNo.length)
        {
          return setImmediate(this.next(), null, {orderId: orderNo});
        }

        ProdShiftOrder
          .findOne({
            prodLine: lineId,
            finishedAt: null
          })
          .select({
            _id: 0,
            orderId: 1
          })
          .sort({finishedAt: -1})
          .lean()
          .exec(this.next());
      },
      function(err, pso)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!pso)
        {
          return this.skip(app.createError('ProdShiftOrder not found.', 'INVALID_STATE', 400));
        }

        if (orderCache.has(`${lineId}:${pso.orderId}`))
        {
          return this.skip(null, orderCache.get(`${lineId}:${pso.orderId}`));
        }

        Order
          .findById(pso.orderId)
          .select({
            name: 1,
            description: 1,
            nc12: 1,
            bom: 1,
            qty: 1
          })
          .lean()
          .exec(this.next());
      },
      function(err, sapOrder)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!sapOrder)
        {
          return this.skip(app.createError('SAP order not found.', 'INVALID_INPUT', 400));
        }

        Order.assignPkhdStrategies(sapOrder, this.next());
      },
      function(err, sapOrder)
      {
        if (err)
        {
          return this.skip(err);
        }

        const result = {
          line: lineId,
          order: {
            no: sapOrder._id,
            nc12: sapOrder.nc12,
            name: resolveProductName(sapOrder),
            quantity: sapOrder.qty
          },
          components: []
        };

        const kanbans = new Map();
        const fifos = new Map();

        sapOrder.bom.forEach(component =>
        {
          if (!component.nc12.length)
          {
            return;
          }

          component.qty /= sapOrder.qty;
          component.type = component.distStrategy.toLowerCase();
          component.unit = component.unit.toUpperCase();

          if (component.type === 'kanban')
          {
            kanbans.set(component.nc12, component);
          }
          else if (component.type === 'fifo')
          {
            fifos.set(component.nc12, component);
          }
        });

        setImmediate(this.parallel(), null, result);
        resolveKanbanComponents(result, kanbans, this.parallel());
        resolveFifoComponents(result, fifos, this.parallel());
      },
      function(err, wmesResult)
      {
        if (err)
        {
          return done(err);
        }

        const lucaResult = prepareLucaResult(wmesResult);

        orderCache.set(`${wmesResult.line}:${wmesResult.order.no}`, wmesResult);

        done(err, lucaResult);
      }
    );
  }

  function resolveKanbanComponents(result, components, done)
  {
    step(
      function()
      {
        const supplyAreas = new Set();

        components.forEach(component => supplyAreas.add(component.supplyArea));

        KanbanSupplyArea
          .find({
            name: {$in: Array.from(supplyAreas)},
            lines: result.line
          })
          .select({
            _id: 0,
            name: 1,
            workCenter: 1
          })
          .lean()
          .exec(this.next());
      },
      function(err, supplyAreaList)
      {
        if (err)
        {
          return this.skip(err);
        }

        const supplyAreaMap = new Map();

        supplyAreaList.forEach(supplyArea =>
        {
          if (!supplyAreaMap.has(supplyArea.name))
          {
            supplyAreaMap.set(supplyArea.name, []);
          }

          supplyAreaMap.get(supplyArea.name).push(supplyArea.workCenter);
        });

        setImmediate(this.parallel(), null, supplyAreaMap);

        KanbanEntry
          .find({
            nc12: {$in: Array.from(components.keys())},
            supplyArea: {$in: Array.from(supplyAreaMap.keys())},
            workCenter: {$in: [''].concat(supplyAreaList.map(sa => sa.workCenter))}
          })
          .select({
            nc12: 1,
            supplyArea: 1,
            workCenter: 1,
            locations: 1
          })
          .lean()
          .exec(this.parallel());
      },
      function(err, supplyAreas, kanbans)
      {
        if (err)
        {
          return this.skip(err);
        }

        kanbans.forEach(kanban =>
        {
          const component = components.get(kanban.nc12);

          if (kanban.supplyArea !== component.supplyArea)
          {
            return;
          }

          const workCenters = supplyAreas.get(component.supplyArea);

          if (!kanban.workCenter && workCenters.length > 1)
          {
            return;
          }

          if (kanban.workCenter && !workCenters.includes(kanban.workCenter))
          {
            return;
          }

          const locations = [];

          kanban.locations.forEach((location, i) =>
          {
            if (!location.length)
            {
              return;
            }

            locations.push({
              workstation: i + 1,
              location
            });
          });

          result.components.push({
            type: component.type,
            nc12: component.nc12,
            name: component.name,
            quantity: component.qty,
            unit: component.unit,
            locations
          });
        });
      },
      done
    );
  }

  function resolveFifoComponents(result, components, done)
  {
    components.forEach(component =>
    {
      result.components.push({
        type: component.type,
        nc12: component.nc12,
        name: component.name,
        quantity: component.qty,
        unit: component.unit,
        locations: []
      });
    });

    done();
  }

  function prepareLucaResult(wmesResult)
  {
    const lucaResult = {
      line: wmesResult.line,
      data12NC: wmesResult.order.nc12,
      components: []
    };

    wmesResult.components.forEach(wmesComponent =>
    {
      wmesComponent.locations.forEach(wmesLocation =>
      {
        const workstation = wmesLocation.workstation.toString().padStart(2, '0');

        lucaResult.components.push({
          data12NC: wmesComponent.nc12,
          locationID: `${wmesResult.line}:${workstation}:${wmesLocation.location}`,
          unit: wmesComponent.unit,
          pieces: wmesComponent.quantity,
          type: wmesComponent.type.toUpperCase()
        });
      });
    });

    return lucaResult;
  }
};
