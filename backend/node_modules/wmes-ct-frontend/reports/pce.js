// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');

exports.id = 'wmes-ct/pce';

exports.models = [
  require('wmes-ct-backend/models/ctPce'),
  require('orders/models/order'),
  require('prodShiftOrders/models/prodShiftOrder')
];

exports.report = (app, {CtPce, Order, ProdShiftOrder}, options, done) =>
{
  const results = {
    options,
    stationCount: 0,
    products: {},
    orders: {},
    psos: {}
  };

  step(
    function()
    {
      const conditions = {};
      let validFilters = false;

      if (options.fromTime)
      {
        conditions.startedAt = {
          $gte: new Date(options.fromTime)
        };
      }

      if (options.toTime)
      {
        if (!conditions.startedAt)
        {
          conditions.startedAt = {};
        }

        conditions.startedAt.$lt = new Date(options.toTime);
      }

      if (Array.isArray(options.orders) && options.orders.length)
      {
        const orderProp = options.orders.some(o => o.length === 9) ? '_id' : 'nc12';

        conditions[`order.${orderProp}`] = {$in: options.orders};

        validFilters = true;
      }

      if (Array.isArray(options.lines) && options.lines.length)
      {
        conditions.line = {$in: options.lines};

        validFilters = validFilters || !!conditions.startedAt;
      }

      if (!validFilters)
      {
        return this.skip();
      }

      const stream = CtPce
        .find(conditions)
        .select({
          line: 1,
          station: 1,
          order: 1,
          pce: 1,
          startedAt: 1,
          durations: 1
        })
        .sort({startedAt: 1})
        .lean()
        .stream();

      const next = _.once(this.next());

      stream.on('error', next);
      stream.on('end', next);
      stream.on('data', handlePce);
    },
    function(err)
    {
      if (err)
      {
        return this.skip(err);
      }

      minimizeNextPso(Object.keys(results.psos), this.next());
    },
    function()
    {
      Order
        .find({
          _id: {$in: Object.keys(results.orders)}
        })
        .select({
          qty: 1,
          'qtyDone.total': 1
        })
        .lean()
        .exec(this.parallel());

      ProdShiftOrder
        .find({
          _id: {$in: Object.keys(results.psos)}
        })
        .select({
          prodShift: 1,
          date: 1,
          shift: 1,
          startedAt: 1,
          finishedAt: 1,
          master: 1,
          leader: 1,
          operators: 1,
          quantityDone: 1
        })
        .lean()
        .exec(this.parallel());
    },
    function(err, sapOrders, shiftOrders)
    {
      if (err)
      {
        return this.skip(err);
      }

      sapOrders.forEach(sapOrder =>
      {
        const order = results.orders[sapOrder._id];

        order.qtyTodo = sapOrder.qty;
        order.qtyDone = sapOrder.qtyDone && sapOrder.qtyDone.total || 0;
      });

      shiftOrders.forEach(shiftOrder =>
      {
        const pso = results.psos[shiftOrder._id];

        pso.shift._id = shiftOrder.prodShift;
        pso.shift.date = shiftOrder.date.getTime();
        pso.shift.no = shiftOrder.shift;
        pso.startedAt = shiftOrder.startedAt;
        pso.finishedAt = shiftOrder.finishedAt;
        pso.master = shiftOrder.master;
        pso.leader = shiftOrder.leader;
        pso.operators = shiftOrder.operators;
        pso.qtyDone = shiftOrder.quantityDone;
      });
    },
    function(err)
    {
      if (err)
      {
        return done(err);
      }

      results.products = Object.values(results.products).sort((a, b) => a.name.localeCompare(b.name, undefined, {
        numeric: true,
        ignorePunctuation: true
      }));
      results.orders = Object.values(results.orders);
      results.psos = Object.values(results.psos);

      done(null, results);
    }
  );

  function handlePce(ctPce)
  {
    if (!ctPce.order._id)
    {
      return;
    }

    if (ctPce.station > results.stationCount)
    {
      results.stationCount = ctPce.station;
    }

    if (!results.products[ctPce.order.nc12])
    {
      results.products[ctPce.order.nc12] = {
        _id: ctPce.order.nc12,
        name: ctPce.order.name,
        sapTaktTime: ctPce.order.sapTaktTime,
        qtyTodo: 0,
        qtyDone: 0,
        orders: {}
      };
    }

    if (!results.orders[ctPce.order._id])
    {
      results.orders[ctPce.order._id] = {
        _id: ctPce.order._id,
        nc12: ctPce.order.nc12,
        qtyTodo: 0,
        qtyDone: 0,
        psos: {}
      };
    }

    if (!results.psos[ctPce.order.pso])
    {
      results.psos[ctPce.order.pso] = {
        _id: ctPce.order.pso,
        orderNo: ctPce.order._id,
        line: ctPce.line,
        shift: {
          _id: '',
          date: null,
          no: 0
        },
        startedAt: null,
        finishedAt: null,
        master: null,
        leader: null,
        operators: null,
        qtyDone: 0,
        pces: {}
      };
    }

    const pso = results.psos[ctPce.order.pso];

    pso.qtyDone = Math.max(pso.qtyDone, ctPce.pce);

    if (!pso.pces[ctPce.pce])
    {
      pso.pces[ctPce.pce] = {};
    }

    results.products[ctPce.order.nc12].orders[ctPce.order._id] = 1;
    results.orders[ctPce.order._id].psos[ctPce.order.pso] = 1;
    pso.pces[ctPce.pce][ctPce.station] = ctPce;
  }

  function minimizeNextPso(queue, done)
  {
    const psoId = queue.shift();

    if (!psoId)
    {
      return done();
    }

    const pso = results.psos[psoId];
    const pces = [];

    for (let pceNo = 1; pceNo <= pso.qtyDone; ++pceNo)
    {
      const pce = pso.pces[pceNo];
      const stations = new Array(results.stationCount);

      for (let stationNo = 1; stationNo <= results.stationCount; ++stationNo)
      {
        const stationPce = pce && pce[stationNo];

        stations[stationNo - 1] = !stationPce ? 0 : {
          t: stationPce.startedAt.getTime(),
          d: [
            stationPce.durations.total,
            stationPce.durations.work,
            stationPce.durations.downtime,
            stationPce.durations.scheduled
          ]
        };
      }

      pces.push(stations);
    }

    pso.pces = pces;

    setImmediate(minimizeNextPso, queue, done);
  }
};
