// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');
const median = require('util/median');

exports.id = 'wmes-ct/groups';

exports.models = [
  require('wmes-ct-backend/models/ctPce'),
  require('planning/models/planOrderGroup'),
  require('orders/models/order'),
  require('prodShiftOrders/models/prodShiftOrder')
];

exports.report = (app, module, options, done) =>
{
  const {
    CtPce,
    PlanOrderGroup,
    Order,
    ProdShiftOrder
  } = module;

  const results = {
    options,
    stationCount: 0,
    sapOrders: {},
    shiftOrders: {},
    groups: {}
  };

  let matchMinT = () => true;
  let matchMaxT = () => true;

  if (options.minT)
  {
    if (options.minT.startsWith('~'))
    {
      const delta = parseInt(options.minT.substring(1), 10);

      matchMinT = (actualT, targetT) => Math.abs(targetT - actualT) >= delta;
    }
    else if (options.minT.endsWith('%'))
    {
      const minT = parseInt(options.minT, 10) / 100;

      matchMinT = (actualT, targetT) => actualT >= (targetT * minT);
    }
    else
    {
      const minT = parseInt(options.minT, 10);

      matchMinT = actualT => actualT >= minT;
    }
  }

  if (options.maxT)
  {
    if (options.maxT.startsWith('~'))
    {
      const delta = parseInt(options.maxT.substring(1), 10);

      matchMaxT = (actualT, targetT) => Math.abs(targetT - actualT) <= delta;
    }
    else if (options.maxT.endsWith('%'))
    {
      const maxT = parseInt(options.maxT, 10) / 100;

      matchMaxT = (actualT, targetT) => actualT <= (targetT * maxT);
    }
    else
    {
      const maxT = parseInt(options.maxT, 10);

      matchMaxT = actualT => actualT <= maxT;
    }
  }

  step(
    function()
    {
      this.sapOrders = new Map();
      this.shiftOrders = new Map();

      const conditions = {};

      if (options.fromTime)
      {
        conditions.startedAt = {
          $gte: new Date(options.fromTime)
        };
      }

      if (options.toTime)
      {
        if (!conditions.startedAt)
        {
          conditions.startedAt = {};
        }

        conditions.startedAt.$lt = new Date(options.toTime);
      }

      if (!conditions.startedAt)
      {
        return this.skip();
      }

      if (Array.isArray(options.lines) && options.lines.length)
      {
        conditions.line = {$in: options.lines};
      }

      if (options.minQty > 0)
      {
        conditions['order.qty'] = {$gte: options.minQty};
      }

      if (options.maxQty > 0)
      {
        if (!conditions['order.qty'])
        {
          conditions['order.qty'] = {};
        }

        conditions['order.qty'].$lte = options.maxQty;
      }

      this.pceConditions = conditions;

      const pipeline = [
        {$match: conditions},
        {$group: {_id: '$order._id', shiftOrders: {$addToSet: '$order.pso'}}}
      ];

      CtPce.aggregate(pipeline, this.next());
    },
    function(err, ctOrders)
    {
      if (err)
      {
        return this.skip(err);
      }

      if (!ctOrders.length)
      {
        return this.skip();
      }

      ctOrders.forEach(order =>
      {
        if (!order._id)
        {
          return;
        }

        const sapOrder = {
          _id: order._id,
          nc12: '',
          name: '',
          description: '',
          mrp: '',
          qtyTodo: 0,
          qtyDone: new Set(),
          qtyMatched: new Set(),
          bom: null,
          shiftOrders: order.shiftOrders,
          groups: []
        };

        this.sapOrders.set(order._id, sapOrder);

        order.shiftOrders.forEach(pso =>
        {
          this.shiftOrders.set(pso, {
            _id: pso,
            sapOrder: order._id
          });
        });
      });

      Order
        .find({
          _id: {$in: Array.from(this.sapOrders.keys())}
        })
        .select({
          nc12: 1,
          name: 1,
          description: 1,
          mrp: 1,
          bom: 1,
          qty: 1
        })
        .lean()
        .exec(this.parallel());

      PlanOrderGroup
        .find({active: true, target: 'ct'})
        .select({target: 0})
        .lean()
        .exec(this.parallel());
    },
    function(err, sapOrders, orderGroups)
    {
      if (err)
      {
        return this.skip(err);
      }

      orderGroups.forEach(orderGroup =>
      {
        orderGroup._id = orderGroup._id.toString();
        orderGroup.sapOrders = [];

        results.groups[orderGroup._id] = orderGroup;
      });

      sapOrders.forEach(sapOrderData =>
      {
        const sapOrder = this.sapOrders.get(sapOrderData._id);

        sapOrderData.qtyTodo = sapOrderData.qty;
        sapOrderData.qty = undefined;

        Object.assign(sapOrder, sapOrderData);

        const orderData = {
          mrp: sapOrder.mrp,
          product: `${sapOrder.nc12} ${sapOrder.name} ${sapOrder.description}`.trim().toUpperCase(),
          bom: []
        };

        (sapOrder.bom || []).forEach(component =>
        {
          const item = component.item || '0000';
          const nc12 = component.nc12 || '000000000000';
          const name = component.name || '?';

          orderData.bom.push(
            `ITEM ${item} 12NC ${nc12} NAME ${name}`
          );
        });

        orderGroups.forEach(orderGroup =>
        {
          if (PlanOrderGroup.matchOrder(orderGroup, orderData))
          {
            sapOrder.groups.push(orderGroup._id);
            orderGroup.sapOrders.push(sapOrder._id);
          }
        });

        sapOrder.bom = undefined;

        if (!sapOrder.groups.length)
        {
          sapOrder.shiftOrders.forEach(shiftOrder =>
          {
            this.shiftOrders.delete(shiftOrder._id);
          });

          this.sapOrders.delete(sapOrder._id);
        }
      });

      ProdShiftOrder
        .find({
          _id: {$in: Array.from(this.shiftOrders.keys())}
        })
        .select({
          sapTaktTime: 1
        })
        .lean()
        .exec(this.parallel());
    },
    function(err, shiftOrders)
    {
      if (err)
      {
        return this.skip(err);
      }

      shiftOrders.forEach(shiftOrderData =>
      {
        const shiftOrder = this.shiftOrders.get(shiftOrderData._id);

        if (this.sapOrders.has(shiftOrder.sapOrder))
        {
          Object.assign(shiftOrder, shiftOrderData);
        }
        else
        {
          this.shiftOrders.delete(shiftOrder._id);
        }
      });

      const stream = CtPce
        .find(this.pceConditions)
        .select({
          line: 1,
          station: 1,
          order: 1,
          pce: 1,
          startedAt: 1,
          durations: 1
        })
        .sort({startedAt: 1})
        .lean()
        .stream();

      const next = _.once(this.next());

      stream.on('error', next);
      stream.on('end', next);
      stream.on('data', handlePce.bind(this));
    },
    function(err)
    {
      if (err)
      {
        return done(err);
      }

      results.groups = Object.values(results.groups).filter(group => group.sapOrders.length > 0);

      results.groups.forEach(group =>
      {
        ensureMetrics(group);
        calcMetrics(group.target);
        calcMetrics(group.actual);

        group.sapOrders.forEach(sapOrderId =>
        {
          const sapOrder = this.sapOrders.get(sapOrderId);

          ensureMetrics(sapOrder);
          calcMetrics(sapOrder.target);
          calcMetrics(sapOrder.actual);

          sapOrder.shiftOrders.forEach(shiftOrderId =>
          {
            const shiftOrder = this.shiftOrders.get(shiftOrderId);

            ensureMetrics(shiftOrder);
            calcMetrics(shiftOrder.target);
            calcMetrics(shiftOrder.actual);
          });
        });
      });

      results.sapOrders = Array.from(this.sapOrders.values());
      results.shiftOrders = Array.from(this.shiftOrders.values());

      results.sapOrders.forEach(sapOrder =>
      {
        sapOrder.qtyDone = sapOrder.qtyDone.size;
        sapOrder.qtyMatched = sapOrder.qtyMatched.size;
      });

      done(null, results);
    }
  );

  function handlePce(ctPce)
  {
    if (!ctPce.order._id)
    {
      return;
    }

    const sapOrder = this.sapOrders.get(ctPce.order._id);

    if (!sapOrder)
    {
      return;
    }

    const shiftOrder = this.shiftOrders.get(ctPce.order.pso);

    if (!shiftOrder)
    {
      return;
    }

    const targetT = shiftOrder.sapTaktTime;
    const actualT = Math.round(ctPce.durations.work / 1000);

    sapOrder.qtyDone.add(`${shiftOrder._id}:${ctPce.pce}`);

    if (targetT < 1 || actualT < 1 || !matchMinT(actualT, targetT) || !matchMaxT(actualT, targetT))
    {
      return;
    }

    sapOrder.qtyMatched.add(`${shiftOrder._id}:${ctPce.pce}`);

    if (ctPce.station > results.stationCount)
    {
      results.stationCount = ctPce.station;
    }

    sapOrder.groups.forEach(groupId =>
    {
      [results.groups[groupId], sapOrder, shiftOrder].forEach(metricGroup =>
      {
        ensureMetrics(metricGroup);
        handleMetrics(metricGroup.target, 0, targetT);
        handleMetrics(metricGroup.actual, 0, actualT);
        handleMetrics(metricGroup.target, ctPce.station, targetT);
        handleMetrics(metricGroup.actual, ctPce.station, actualT);
      });
    });
  }

  function handleMetrics(metrics, station, duration)
  {
    if (!metrics.med[station])
    {
      metrics.med[station] = [];
      metrics.sum[station] = 0;
      metrics.cnt[station] = 0;
      metrics.avg[station] = 0;
      metrics.min[station] = Number.MAX_SAFE_INTEGER;
      metrics.max[station] = Number.MIN_SAFE_INTEGER;
    }

    metrics.med[station].push(duration);
    metrics.sum[station] += duration;
    metrics.cnt[station] += 1;
    metrics.min[station] = Math.min(metrics.min[station], duration);
    metrics.max[station] = Math.max(metrics.max[station], duration);
  }

  function calcMetrics(metrics)
  {
    Object.keys(metrics.med).forEach(stationNo =>
    {
      if (typeof metrics.med[stationNo] === 'number')
      {
        return;
      }

      metrics.med[stationNo] = Math.round(median(metrics.med[stationNo], false));
      metrics.avg[stationNo] = metrics.cnt[stationNo]
        ? Math.round(metrics.sum[stationNo] / metrics.cnt[stationNo])
        : 0;
      metrics.sum[stationNo] = Math.round(metrics.sum[stationNo]);

      if (metrics.min[stationNo] === Number.MAX_SAFE_INTEGER)
      {
        metrics.min[stationNo] = 0;
      }

      if (metrics.max[stationNo] === Number.MIN_SAFE_INTEGER)
      {
        metrics.max[stationNo] = 0;
      }

      metrics.min[stationNo] = Math.round(metrics.min[stationNo]);
      metrics.max[stationNo] = Math.round(metrics.max[stationNo]);
    });
  }

  function ensureMetrics(group)
  {
    if (group.target)
    {
      return;
    }

    group.target = {
      med: {},
      sum: {},
      cnt: {},
      avg: {},
      min: {},
      max: {}
    };

    group.actual = {
      med: {},
      sum: {},
      cnt: {},
      avg: {},
      min: {},
      max: {}
    };
  }
};
