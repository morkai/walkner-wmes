// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');
const {transliterate} = require('transliteration');

exports.id = 'wmes-ct/groups';

exports.models = [
  require('wmes-ct-backend/models/ctPce'),
  require('wmes-ct-frontend/models/ctOrderGroup'),
  require('orders/models/order'),
  require('prodShiftOrders/models/prodShiftOrder')
];

exports.report = (app, {CtPce, CtOrderGroup, Order, ProdShiftOrder}, options, done) =>
{
  const results = {
    options,
    stationCount: 0,
    sapOrders: {},
    shiftOrders: {},
    groups: {}
  };

  const bomCache = new Map();
  let matchMinT = () => true;
  let matchMaxT = () => true;

  if (options.matchMinT)
  {
    if (options.minT.endsWith('%'))
    {
      const minT = parseInt(options.minT, 10) / 100;

      matchMinT = (actualT, targetT) => actualT >= (targetT * minT);
    }
    else
    {
      const minT = parseInt(options.minT, 10);

      matchMinT = actualT => actualT >= minT;
    }
  }

  if (options.matchMaxT)
  {
    if (options.maxT.endsWith('%'))
    {
      const maxT = parseInt(options.maxT, 10) / 100;

      matchMaxT = (actualT, targetT) => actualT <= (targetT * maxT);
    }
    else
    {
      const maxT = parseInt(options.maxT, 10);

      matchMaxT = actualT => actualT <= maxT;
    }
  }

  step(
    function()
    {
      const conditions = {};

      if (options.fromTime)
      {
        conditions.startedAt = {
          $gte: new Date(options.fromTime)
        };
      }

      if (options.toTime)
      {
        if (!conditions.startedAt)
        {
          conditions.startedAt = {};
        }

        conditions.startedAt.$lt = new Date(options.toTime);
      }

      if (Array.isArray(options.lines) && options.lines.length)
      {
        conditions.line = {$in: options.lines};
      }

      if (options.minQty > 0)
      {
        conditions['order.qty'] = {$gte: options.minQty};
      }

      if (options.maxQty > 0)
      {
        if (!conditions['order.qty'])
        {
          conditions['order.qty'] = {};
        }

        conditions['order.qty'].$lte = options.maxQty;
      }

      this.pceConditions = conditions;

      const pipeline = [
        {$match: conditions},
        {$group: {_id: '$order._id', shiftOrders: {$addToSet: '$order.pso'}}}
      ];

      CtPce.aggregate(pipeline, this.next());
    },
    function(err, ctOrders)
    {
      if (err)
      {
        return this.skip(err);
      }

      if (!ctOrders.length)
      {
        return this.skip();
      }

      this.sapOrders = new Map();
      this.shiftOrders = new Map();

      ctOrders.forEach(order =>
      {
        if (!order._id)
        {
          return;
        }

        const sapOrder = {
          _id: order._id,
          nc12: '',
          name: '',
          description: '',
          qty: 0,
          bom: null,
          shiftOrders: order.shiftOrders,
          groups: []
        };

        this.sapOrders.set(order._id, sapOrder);

        order.shiftOrders.forEach(pso =>
        {
          this.shiftOrders.set(pso, {
            _id: pso,
            sapOrder: order._id
          });
        });
      });

      Order
        .find({
          _id: {$in: Array.from(this.sapOrders.keys())}
        })
        .select({
          nc12: 1,
          name: 1,
          bom: 1,
          qty: 1
        })
        .lean()
        .exec(this.parallel());

      CtOrderGroup.find({active: true}).lean().exec(this.parallel());
    },
    function(err, sapOrders, orderGroups)
    {
      if (err)
      {
        return this.skip(err);
      }

      orderGroups.forEach(orderGroup =>
      {
        orderGroup._id = orderGroup._id.toString();
        orderGroup.sapOrders = [];

        results.groups[orderGroup._id] = orderGroup;
      });

      sapOrders.forEach(sapOrderData =>
      {
        const sapOrder = this.sapOrders.get(sapOrderData._id);

        Object.assign(sapOrder, sapOrderData);

        orderGroups.forEach(orderGroup =>
        {
          if (matchesName(orderGroup, sapOrder)
            && matchesNc12(orderGroup, sapOrder)
            && matchesBom(orderGroup, sapOrder))
          {
            sapOrder.groups.push(orderGroup._id);
            orderGroup.sapOrders.push(sapOrder._id);
          }
        });

        sapOrder.bom = undefined;

        if (!sapOrder.groups.length)
        {
          sapOrder.shiftOrders.forEach(shiftOrder =>
          {
            this.shiftOrders.delete(shiftOrder._id);
          });

          this.sapOrders.delete(sapOrder._id);
        }
      });

      ProdShiftOrder
        .find({
          _id: {$in: Array.from(this.shiftOrders.keys())}
        })
        .select({
          sapTaktTime: 1
        })
        .lean()
        .exec(this.parallel());
    },
    function(err, shiftOrders)
    {
      if (err)
      {
        return this.skip(err);
      }

      shiftOrders.forEach(shiftOrderData =>
      {
        const shiftOrder = this.shiftOrders.get(shiftOrderData._id);

        if (this.sapOrders.has(shiftOrder.sapOrder))
        {
          Object.assign(shiftOrder, shiftOrderData);

          shiftOrder.sapTaktTime *= 1000;
        }
        else
        {
          this.shiftOrders.delete(shiftOrder._id);
        }
      });

      const stream = CtPce
        .find(this.pceConditions)
        .select({
          line: 1,
          station: 1,
          order: 1,
          pce: 1,
          startedAt: 1,
          durations: 1
        })
        .sort({startedAt: 1})
        .lean()
        .stream();

      const next = _.once(this.next());

      stream.on('error', next);
      stream.on('end', next);
      stream.on('data', handlePce.bind(this));
    },
    function(err)
    {
      if (err)
      {
        return done(err);
      }

      results.groups = Object.values(results.groups);

      results.groups.forEach(group =>
      {
        calcMetrics(group.target);
        calcMetrics(group.actual);

        group.sapOrders.forEach(sapOrderId =>
        {
          const sapOrder = this.sapOrders.get(sapOrderId);

          calcMetrics(sapOrder.target);
          calcMetrics(sapOrder.actual);

          sapOrder.shiftOrders.forEach(shiftOrderId =>
          {
            const shiftOrder = this.shiftOrders.get(shiftOrderId);

            calcMetrics(shiftOrder.target);
            calcMetrics(shiftOrder.actual);
          });
        });
      });

      results.sapOrders = Array.from(this.sapOrders.values());
      results.shiftOrders = Array.from(this.shiftOrders.values());

      done(null, results);
    }
  );

  function handlePce(ctPce)
  {
    if (!ctPce.order._id)
    {
      return;
    }

    const sapOrder = this.sapOrders.get(ctPce.order._id);

    if (!sapOrder)
    {
      return;
    }

    const shiftOrder = this.shiftOrders.get(ctPce.order.pso);

    if (!shiftOrder)
    {
      return;
    }

    const targetT = shiftOrder.sapTaktTime;
    const actualT = ctPce.durations.work;

    if (!matchMinT(actualT, targetT) || !matchMaxT(actualT, targetT))
    {
      return;
    }

    if (ctPce.station > results.stationCount)
    {
      results.stationCount = ctPce.station;
    }

    sapOrder.groups.forEach(groupId =>
    {
      [results.groups[groupId], sapOrder, shiftOrder].forEach(metricGroup =>
      {
        if (!metricGroup.actual)
        {
          metricGroup.target = {
            med: {},
            sum: {},
            cnt: {},
            avg: {},
            min: {},
            max: {}
          };
          metricGroup.actual = {
            med: [],
            sum: {},
            cnt: {},
            avg: {},
            min: {},
            max: {}
          };
        }

        handleMetrics(metricGroup.target, 0, targetT);
        handleMetrics(metricGroup.actual, 0, actualT);
        handleMetrics(metricGroup.target, ctPce.station, targetT);
        handleMetrics(metricGroup.actual, ctPce.station, actualT);
      });
    });
  }

  function handleMetrics(metrics, station, duration)
  {
    if (!duration || duration < 1000)
    {
      return;
    }

    if (!metrics.med[station])
    {
      metrics.med[station] = [];
      metrics.sum[station] = 0;
      metrics.cnt[station] = 0;
      metrics.avg[station] = 0;
      metrics.min[station] = Number.MAX_SAFE_INTEGER;
      metrics.max[station] = Number.MIN_SAFE_INTEGER;
    }

    metrics.med[station].push(duration);
    metrics.sum[station] += duration;
    metrics.cnt[station] += 1;
    metrics.min[station] = Math.min(metrics.min[station], duration);
    metrics.max[station] = Math.max(metrics.max[station], duration);
  }

  function calcMetrics(metrics)
  {
    Object.keys(metrics.med).forEach(stationNo =>
    {
      metrics.med[stationNo] = calcMedian(metrics.med[stationNo]);
      metrics.avg[stationNo] = metrics.cnt[stationNo]
        ? Math.round(metrics.sum[stationNo] / metrics.cnt[stationNo])
        : 0;

      if (metrics.min[stationNo] === Number.MAX_SAFE_INTEGER)
      {
        metrics.min[stationNo] = 0;
      }

      if (metrics.max[stationNo] === Number.MIN_SAFE_INTEGER)
      {
        metrics.max[stationNo] = 0;
      }
    });
  }

  function calcMedian(med)
  {
    if (med.length === 0)
    {
      return 0;
    }

    if (med.length === 1)
    {
      return med[0];
    }

    med.sort((a, b) => a - b);

    if (med.length % 2 === 0)
    {
      return Math.round((med[med.length / 2 - 1] + med[med.length / 2]) / 2);
    }

    return med[(med.length + 1) / 2 - 1];
  }

  function matchesName({nameInclude, nameExclude}, {name, description})
  {
    const input = transliterate(`${name} ${description}`, {unknown: ''}).toUpperCase();

    if (nameInclude.length
      && !nameInclude.some(patterns => patterns.every(pattern => input.includes(pattern))))
    {
      return false;
    }

    if (nameExclude.length
      && nameExclude.some(patterns => patterns.every(pattern => input.includes(pattern))))
    {
      return false;
    }

    return true;
  }

  function matchesNc12({nc12Include, nc12Exclude}, {nc12})
  {
    if (nc12Include.length && !nc12Include.includes(nc12))
    {
      return false;
    }

    if (nc12Exclude.length && nc12Exclude.includes(nc12))
    {
      return false;
    }

    return true;
  }

  function matchesBom({bomInclude, bomExclude}, {bom})
  {
    return includesBom(bomInclude, bom) && excludesBom(bomExclude, bom);
  }

  function includesBom(orPatterns, bom)
  {
    if (orPatterns.length === 0)
    {
      return true;
    }

    const cachedBom = cacheBom(bom);

    return orPatterns.some(andPatterns =>
    {
      return andPatterns.every(pattern =>
      {
        if (/^[0-9]{4}$/.test(pattern))
        {
          return cachedBom.item.has(pattern);
        }

        if (/^[0-9]{12}$/.test(pattern))
        {
          return cachedBom.nc12.has(pattern);
        }

        return cachedBom.name.some(name => name.includes(pattern));
      });
    });
  }

  function excludesBom(orPatterns, bom)
  {
    if (orPatterns.length === 0)
    {
      return true;
    }

    const cachedBom = cacheBom(bom);

    return !orPatterns.some(andPatterns =>
    {
      return andPatterns.every(pattern =>
      {
        if (/^[0-9]{4}$/.test(pattern))
        {
          return cachedBom.item.has(pattern);
        }

        if (/^[0-9]{12}$/.test(pattern))
        {
          return cachedBom.nc12.has(pattern);
        }

        return cachedBom.name.some(name => name.includes(pattern));
      });
    });
  }

  function cacheBom(bom)
  {
    if (bomCache.has(bom))
    {
      return bomCache.get(bom);
    }

    const cachedBom = {
      item: new Set(),
      nc12: new Set(),
      name: new Set()
    };

    bom.forEach(component =>
    {
      cachedBom.item.add(component.item.padStart('0', 4));
      cachedBom.nc12.add(component.nc12.padStart('0', 12));
      cachedBom.name.add(transliterate(component.name, {unknown: ''}).toUpperCase());
    });

    cachedBom.name = Array.from(cachedBom.name);

    bomCache.set(bom, cachedBom);

    return cachedBom;
  }
};
