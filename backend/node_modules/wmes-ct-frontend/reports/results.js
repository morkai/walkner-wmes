// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');
const moment = require('moment');
const businessDays = require('reports/businessDays');

exports.id = 'wmes-ct/results';

exports.models = [
  require('settings/models/setting'),
  require('prodShifts/models/prodShift'),
  require('prodShiftOrders/models/prodShiftOrder'),
  require('wmes-ct-backend/models/ctPce'),
  require('wmes-ct-frontend/models/ctMrpConfig'),
  require('wmes-ct-frontend/models/ctUpphQuarterlyConfig')
];

exports.report = (app, module, options, done) =>
{
  const MIN_CYCLE_TIME = 1001;
  const MAX_CYCLE_TIME = 8 * 3600 * 1000;

  const {
    Setting,
    ProdShift,
    ProdShiftOrder,
    CtPce,
    CtMrpConfig,
    CtUpphQuarterlyConfig
  } = module;

  const results = {
    options,
    lines: {},
    upph: {
      total: {}
    },
    mrps: {},
    stationCount: 0,
    shiftCount: 0,
    allLineCount: 0,
    workingLineCount: 0,
    availableLineUsage: 0,
    unbalancedMrpCount: 0,
    bottleneckedMrpCount: 0,
    efficientMrpCount: 0
  };

  const defaultOptions = {
    ignoredMrps: [],
    includedMrps: [],
    minLineWorkDuration: 0,
    minUpphWorkDuration: 0,
    shiftCount: 3,
    availableWorkDuration: 7.5,
    minMrpUnbalance: 50,
    minMrpEfficiency: 90
  };

  const mrpConfigMap = new Map();
  const upphCoeffMap = new Map();
  const upphShiftOrders = new Map();

  step(
    function()
    {
      if (!options.fromTime && !options.toTime)
      {
        return this.skip();
      }

      const maxToMoment = moment();

      if (maxToMoment.hours() >= 6)
      {
        maxToMoment.add(1, 'days');
      }

      maxToMoment.hours(0).startOf('hour');

      if (!options.toTime || options.toTime > maxToMoment.valueOf())
      {
        options.toTime = maxToMoment.valueOf();
      }

      if (!options.fromTime)
      {
        options.fromTime = moment(options.toTime).subtract(12, 'months').valueOf();
      }
    },
    function()
    {
      Setting
        .find({_id: /^ct\.reports\.results\./})
        .select({value: 1})
        .lean()
        .exec(this.parallel());

      CtMrpConfig
        .find()
        .lean()
        .exec(this.parallel());

      CtUpphQuarterlyConfig
        .find({
          _id: {
            $gte: moment(options.fromTime).utc().startOf('quarter').toDate(),
            $lte: moment(options.toTime).utc().startOf('quarter').toDate()
          }
        })
        .lean()
        .exec(this.parallel());

      const days = Math.floor((options.toTime - options.fromTime) / (24 * 3600 * 1000));

      if (days >= 93)
      {
        return;
      }

      ProdShift.aggregate([
        {$match: {
          date: {
            $gte: moment(options.fromTime).subtract(93 - days, 'days').hours(6).toDate(),
            $lt: moment(options.toTime).hours(6).toDate()
          },
          prodLine: {$in: options.lines}
        }},
        {$unwind: '$orderMrp'},
        {$group: {
          _id: '$prodLine',
          mrp: {$addToSet: '$orderMrp'}
        }}
      ], this.parallel());
    },
    function(err, settings, mrpConfigList, upphConfigList, lineMrps)
    {
      if (err)
      {
        return this.skip(err);
      }

      this.lineMrps = new Map();

      options.lines.forEach(line =>
      {
        this.lineMrps.set(line, new Set());
      });

      if (lineMrps && lineMrps.length)
      {
        lineMrps.forEach(line =>
        {
          const mrps = this.lineMrps.get(line._id);

          line.mrp.forEach(mrp =>
          {
            mrps.add(mrp);
          });
        });
      }

      settings.forEach(setting =>
      {
        const k = setting._id.replace('ct.reports.results.', '');
        const v = options[k];

        if (k === 'includedMrps'
          && (!options.includedMrps || options.includedMrps.length === 0)
          && Array.isArray(setting.value))
        {
          options.includedMrps = setting.value;

          return;
        }

        if (v == null || (isNaN(v) && !Array.isArray(v)))
        {
          options[k] = setting.value;
        }
      });

      _.forEach(defaultOptions, (defaultValue, k) =>
      {
        const v = options[k];

        if (v == null || (isNaN(v) && !Array.isArray(v)))
        {
          options[k] = defaultValue;
        }
      });

      const firstConfigDate = new Date('2010-01-01T00:00:00Z');

      mrpConfigList.forEach(mrpConfig =>
      {
        if (!mrpConfig.configs.length)
        {
          return;
        }

        mrpConfig.configs.forEach((config, i) =>
        {
          config.nextConfig = mrpConfig.configs[i + 1] || null;
        });

        mrpConfigMap.set(mrpConfig._id, {
          nextConfig: {
            date: firstConfigDate,
            unbalance: 0,
            bottleneck: 0,
            nextConfig: mrpConfig.configs[0]
          },
          workDays: new Map()
        });
      });

      upphConfigList.forEach(upphConfig =>
      {
        const quarter = upphConfig._id.getTime();

        upphCoeffMap.set(`${quarter}:*`, 1);

        upphConfig.configs.forEach(config =>
        {
          config.mrps.forEach(mrp =>
          {
            upphCoeffMap.set(`${quarter}:${mrp}`, config.qtyCoeff);
          });
        });
      });

      const conditions = {
        startedAt: {
          $gte: moment(options.fromTime).hours(6).toDate(),
          $lt: moment(options.toTime).hours(6).toDate()
        },
        quantityDone: {$gt: 0},
        workDuration: {$gt: 0},
        subdivisionType: 'assembly'
      };

      const psoCursor = ProdShiftOrder
        .find(conditions)
        .select({
          _id: 0,
          'orderData.qty': 1,
          'orderData.mrp': 1,
          'orderData.operations': 1,
          'orderData.taktTimeCoeff': 1,
          'orderData.cycleTime': 1,
          prodLine: 1,
          date: 1,
          orderId: 1,
          operationNo: 1,
          workDuration: 1,
          breakDuration: 1,
          workerCount: 1,
          totalQuantity: 1,
          quantityDone: 1,
          laborTime: 1
        })
        .sort({startedAt: 1})
        .lean()
        .cursor();

      const pceCursor = CtPce
        .aggregate([
          {$match: {startedAt: conditions.startedAt}},
          {$project: {
            pso: '$order.pso',
            line: '$line',
            mrp: '$order.mrp',
            pce: '$pce',
            station: '$station',
            duration: '$durations.work'
          }},
          {$group: {
            _id: '$pso',
            line: {$first: '$line'},
            mrp: {$first: '$mrp'},
            pces: {$push: {
              pce: '$pce',
              station: '$station',
              duration: '$duration'
            }}
          }}
        ])
        .allowDiskUse(true)
        .cursor({
          batchSize: 10
        })
        .exec();

      const psoDone = _.once(this.parallel());
      const pceDone = _.once(this.parallel());

      psoCursor.on('error', psoDone);
      psoCursor.on('end', psoDone);
      psoCursor.on('data', handleShiftOrder.bind(this));

      pceCursor.on('error', pceDone);
      pceCursor.on('end', pceDone);
      pceCursor.on('data', handlePceCycleTime.bind(this));
    },
    function(err)
    {
      if (err)
      {
        return done(err);
      }

      const now = Date.now();
      const dayCount = businessDays.countBetweenDates(
        new Date(options.fromTime),
        new Date(options.toTime > now ? now : options.toTime)
      );

      results.shiftCount = options.shiftCount * dayCount;

      results.lines = Object.values(results.lines);

      results.lines.forEach(line =>
      {
        line.workDuration = _.round(line.workDuration, 1);
        line.breakDuration = _.round(line.breakDuration, 1);
        line.shiftCount = line.shiftCount.size;
        line.mrps = Array.from(line.mrps);
        line.efficiency = line.efficiency[1] ? Math.round(line.efficiency[0] / line.efficiency[1] * 100) : 0;
        line.usage = _.round(line.workDuration / (options.availableWorkDuration * results.shiftCount) * 100, 2);

        if (isNaN(line.usage) || !isFinite(line.usage))
        {
          line.usage = 0;
        }

        if (line.workDuration > options.minLineWorkDuration)
        {
          results.workingLineCount += 1;
        }

        results.availableLineUsage += line.workDuration;

        calcAvgMed(line);
        calcUnbalance(line);
        calcBottleneck(line);
      });

      results.lines.sort(sortById);

      results.allLineCount = countAllLines(
        this.lineMrps,
        results.lines,
        options.ignoredMrps
      );

      results.availableLineUsage = _.round(
        results.availableLineUsage
          / (results.allLineCount * options.availableWorkDuration * results.shiftCount)
          * 100,
        1
      );

      results.mrps = Object.values(results.mrps);

      results.mrps.forEach(mrp =>
      {
        mrp.lines = Array.from(mrp.lines).sort(sortStrings);
        mrp.efficiency = mrp.efficiency[1] ? Math.round(mrp.efficiency[0] / mrp.efficiency[1] * 100) : 0;

        if (mrp.efficiency > options.minMrpEfficiency)
        {
          results.efficientMrpCount += 1;
        }

        calcAvgMed(mrp);
        calcUnbalance(mrp);
        calcBottleneck(mrp);

        if (mrp.bottleneck.length)
        {
          results.bottleneckedMrpCount += 1;
        }

        if (mrp.unbalance.value > options.minMrpUnbalance)
        {
          results.unbalancedMrpCount += 1;
        }
      });

      results.mrps.sort(sortById);

      calcUpph();

      _.forEach(results.upph, (weeks, mrp) =>
      {
        const upphList = [];

        _.forEach(weeks, (upph, week) =>
        {
          const std = _.round(upph[0] / upph[1], 2);
          const norm = _.round(upph[2] / upph[3], 2);

          if (std || norm)
          {
            upphList.push({_id: week, std, norm});
          }
        });

        upphList.sort(sortById);

        results.upph[mrp] = upphList;
      });

      options.lines = undefined;
      options.ignoredMrps = undefined;

      done(null, results);
    }
  );

  function getLine(lineId)
  {
    if (!results.lines[lineId])
    {
      results.lines[lineId] = {
        _id: lineId,
        mrps: new Set(),
        workDuration: 0,
        breakDuration: 0,
        quantityDone: 0,
        efficiency: [0, 0],
        unbalance: {
          num: 0,
          den: 0,
          min: null,
          max: null,
          value: 0
        },
        bottleneck: {},
        avgMed: {},
        shiftCount: new Set()
      };
    }

    return results.lines[lineId];
  }

  function getMrp(mrpId)
  {
    if (!mrpId)
    {
      mrpId = 'NIL';
    }

    if (!results.mrps[mrpId])
    {
      results.mrps[mrpId] = {
        _id: mrpId,
        lines: new Set(),
        efficiency: [0, 0],
        unbalance: {
          num: 0,
          den: 0,
          min: null,
          max: null,
          value: 0
        },
        bottleneck: {},
        avgMed: {}
      };
    }

    return results.mrps[mrpId];
  }

  function handleShiftOrder(shiftOrder)
  {
    const date = moment(shiftOrder.date);
    const orderData = shiftOrder.orderData || {};

    if (!orderData.mrp)
    {
      return;
    }

    if (!this.lineMrps.has(shiftOrder.prodLine))
    {
      this.lineMrps.set(shiftOrder.prodLine, new Set());
    }

    this.lineMrps.get(shiftOrder.prodLine).add(orderData.mrp);

    if (!options.ignoredMrps.length || !options.ignoredMrps.includes(orderData.mrp))
    {
      const mrp = getMrp(orderData.mrp);
      const mrpConfig = mrpConfigMap.get(mrp._id);

      if (mrpConfig)
      {
        const day = moment(shiftOrder.date.getTime()).startOf('day').valueOf();

        if (!mrpConfig.workDays.has(day))
        {
          mrpConfig.workDays.set(day, {
            workDuration: 0,
            orderCount: 0
          });
        }

        const workDay = mrpConfig.workDays.get(day);

        workDay.workDuration += shiftOrder.workDuration;
        workDay.orderCount += 1;
      }

      const line = getLine(shiftOrder.prodLine);
      const effNum = adjustLaborTime(shiftOrder) / 100 * shiftOrder.totalQuantity;
      const effDen = shiftOrder.workDuration * shiftOrder.workerCount;

      line.workDuration += shiftOrder.workDuration;
      line.breakDuration += shiftOrder.breakDuration;
      line.quantityDone += shiftOrder.quantityDone;

      line.shiftCount.add(date.valueOf());

      line.mrps.add(mrp._id);
      mrp.lines.add(line._id);

      line.efficiency[0] += effNum;
      line.efficiency[1] += effDen;

      mrp.efficiency[0] += effNum;
      mrp.efficiency[1] += effDen;

      handlePsoCycleTime(orderData.cycleTime, mrp, line);
    }

    if (!options.includedMrps.length || options.includedMrps.includes(shiftOrder.orderData.mrp))
    {
      if (!upphShiftOrders.has(shiftOrder.orderId))
      {
        upphShiftOrders.set(shiftOrder.orderId, []);
      }

      upphShiftOrders.get(shiftOrder.orderId).push(shiftOrder);
    }
  }

  function calcUpph()
  {
    upphShiftOrders.forEach(shiftOrders =>
    {
      const orderWithData = shiftOrders.find(o => !!o.orderData && !!o.orderData.operations && !!o.orderData.qty);

      if (!orderWithData)
      {
        return;
      }

      const assemblyOp = Object
        .values(orderWithData.orderData.operations)
        .sort((a, b) => b.laborTime - a.laborTime)[0];

      const {mrp, qty} = orderWithData.orderData;
      let workerCount = 0;
      let workDuration = 0;
      let assemblyDuration = 0;

      shiftOrders.forEach(o =>
      {
        workerCount += o.quantityDone / qty * o.workerCount;
        workDuration += o.workDuration;
        assemblyDuration += o.operationNo === assemblyOp.no ? o.workDuration : 0;
      });

      if (!assemblyDuration
        || (options.minUpphWorkDuration && assemblyDuration <= (options.minUpphWorkDuration / 60)))
      {
        return;
      }

      const date = moment(orderWithData.date);
      const week = `${date.isoWeekYear()}-W${date.isoWeek().toString().padStart(2, '0')}`;

      if (!results.upph.total[week])
      {
        results.upph.total[week] = [0, 0, 0, 0];
      }

      if (!results.upph[mrp])
      {
        results.upph[mrp] = {};
      }

      if (!results.upph[mrp][week])
      {
        results.upph[mrp][week] = [0, 0, 0, 0];
      }

      const quarter = date.utc().startOf('quarter').valueOf();
      const coeff = upphCoeffMap.get(`${quarter}:${mrp}`) || upphCoeffMap.get(`${quarter}:*`) || 1;
      const num = qty / workerCount / workDuration;

      results.upph.total[week][0] += num;
      results.upph.total[week][1] += 1;
      results.upph.total[week][2] += num * coeff;
      results.upph.total[week][3] += 1;
      results.upph[mrp][week][0] += num;
      results.upph[mrp][week][1] += 1;
      results.upph[mrp][week][2] += num * coeff;
      results.upph[mrp][week][3] += 1;
    });
  }

  function handlePsoCycleTime(cycleTime, mrp, line)
  {
    if (!cycleTime)
    {
      return;
    }

    let bottleneckStation = 0;
    let bottleneckValue = 0;

    cycleTime.med.forEach((med, s) =>
    {
      if (s === 0 || med < MIN_CYCLE_TIME || med > MAX_CYCLE_TIME)
      {
        return;
      }

      if (med > bottleneckValue)
      {
        bottleneckStation = s;
        bottleneckValue = med;
      }

      [mrp, line].forEach(group =>
      {
        if (group.avgMed[s] === undefined)
        {
          group.avgMed[s] = [0, 0];
        }

        group.avgMed[s][0] += med;
        group.avgMed[s][1] += 1;
      });
    });

    if (bottleneckStation !== 0)
    {
      [mrp, line].forEach(group =>
      {
        if (group.bottleneck[bottleneckStation] === undefined)
        {
          group.bottleneck[bottleneckStation] = 0;
        }

        group.bottleneck[bottleneckStation] += 1;
      });
    }
  }

  function handlePceCycleTime(pso)
  {
    if (!pso.mrp || options.ignoredMrps.includes(pso.mrp))
    {
      return;
    }

    const pces = new Map();

    pso.pces.forEach(stationPce =>
    {
      if (stationPce.duration < MIN_CYCLE_TIME || stationPce.duration > MAX_CYCLE_TIME)
      {
        return;
      }

      if (!pces.has(stationPce.pce))
      {
        pces.set(stationPce.pce, {
          max: 0,
          sum: 0,
          stations: 0
        });
      }

      const pce = pces.get(stationPce.pce);

      pce.stations += 1;
      pce.sum += stationPce.duration;

      if (stationPce.duration > pce.max)
      {
        pce.max = stationPce.duration;
      }
    });

    const mrp = getMrp(pso.mrp);
    const line = getLine(pso.line);

    pces.forEach(pce =>
    {
      const den = pce.max * pce.stations;

      if (den === 0)
      {
        return;
      }

      const num = den - pce.sum;

      mrp.unbalance.num += num;
      mrp.unbalance.den += den;
      line.unbalance.num += num;
      line.unbalance.den += den;
    });
  }

  function calcAvgMed(group)
  {
    const avgMed = [];

    _.forEach(group.avgMed, (b, s) =>
    {
      avgMed.push({
        station: +s,
        value: Math.round(b[0] / b[1]) || 0
      });

      results.stationCount = Math.max(results.stationCount, +s);
    });

    avgMed.sort((a, b) => b.value - a.value);

    group.avgMed = avgMed;
  }

  function calcUnbalance(group)
  {
    if (group.unbalance.den === 0)
    {
      if (group.lines)
      {
        calcFromConfig(group);
      }

      return;
    }

    group.unbalance.min = _.last(group.avgMed);
    group.unbalance.max = _.first(group.avgMed);

    const num = group.unbalance.num;
    const den = group.unbalance.den;

    group.unbalance.value = Math.round(num / den * 100);
  }

  function calcFromConfig(mrp)
  {
    const mrpConfig = mrpConfigMap.get(mrp._id);

    if (!mrpConfig)
    {
      return;
    }

    if (!mrpConfig.sortedWorkDays)
    {
      mrpConfig.sortedWorkDays = Array.from(mrpConfig.workDays.keys()).sort((a, b) => a - b).map(localTime =>
      {
        return {
          localTime,
          utcTime: moment.utc(moment(localTime).format('YYYY-MM-DD'), 'YYYY-MM-DD').valueOf()
        };
      });
    }

    let config = mrpConfig.nextConfig;
    let weightedUnbalance = 0;
    let totalWorkDuration = 0;

    mrpConfig.sortedWorkDays.forEach(({localTime, utcTime}) =>
    {
      while (config.nextConfig && utcTime >= config.nextConfig.date.getTime())
      {
        config = config.nextConfig;
      }

      const {workDuration, orderCount} = mrpConfig.workDays.get(localTime);

      weightedUnbalance += workDuration * config.unbalance;
      totalWorkDuration += workDuration;

      if (config.bottleneck)
      {
        if (mrp.bottleneck[config.bottleneck] === undefined)
        {
          mrp.bottleneck[config.bottleneck] = 0;
        }

        mrp.bottleneck[config.bottleneck] += orderCount;
      }
    });

    mrp.unbalance.value = Math.round(weightedUnbalance / totalWorkDuration);
  }

  function calcBottleneck(group)
  {
    const bottleneck = [];

    _.forEach(group.bottleneck, (count, s) =>
    {
      bottleneck.push({
        station: +s,
        count
      });

      results.stationCount = Math.max(results.stationCount, +s);
    });

    bottleneck.sort((a, b) => b.count - a.count);

    group.bottleneck = bottleneck;
  }

  function adjustLaborTime(shiftOrder)
  {
    shiftOrder.laborTime *= ProdShiftOrder.getTaktTimeCoeff(shiftOrder);

    return shiftOrder.laborTime;
  }

  function sortById(a, b)
  {
    return a._id.localeCompare(b._id, undefined, {numeric: true, ignorePunctuation: true});
  }

  function sortStrings(a, b)
  {
    return a.localeCompare(b, undefined, {numeric: true, ignorePunctuation: true});
  }

  function countAllLines(lineMrps, usedLines, excludedMrps)
  {
    let allLineCount = usedLines.length;

    if (lineMrps.size === 0)
    {
      return allLineCount;
    }

    usedLines.forEach(line => lineMrps.delete(line._id));

    if (excludedMrps.length)
    {
      allLineCount += countExcludedMrps(lineMrps, excludedMrps);
    }

    return allLineCount;
  }

  function countExcludedMrps(lineMrps, excludedMrps)
  {
    let count = 0;

    lineMrps.forEach((mrps) =>
    {
      count += mrps.size === 0 || Array.from(mrps).some(mrp => !excludedMrps.includes(mrp)) ? 1 : 0;
    });

    return count;
  }
};
