// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');
const moment = require('moment');
const businessDays = require('reports/businessDays');

exports.id = 'wmes-ct/results';

exports.models = [
  require('settings/models/setting'),
  require('prodShiftOrders/models/prodShiftOrder')
];

exports.report = (app, {Setting, ProdShiftOrder}, options, done) =>
{
  const results = {
    options,
    lines: {},
    upph: {},
    mrps: {},
    stationCount: 0,
    shiftCount: 0,
    workingLineCount: 0,
    availableLineUsage: 0,
    unbalancedMrpCount: 0,
    bottleneckedMrpCount: 0,
    efficientMrpCount: 0
  };

  const defaultOptions = {
    ignoredMrps: [],
    minLineWorkDuration: 0,
    minUpphWorkDuration: 0,
    shiftCount: 3,
    availableWorkDuration: 7.5,
    minMrpUnbalance: 50,
    minMrpEfficiency: 90
  };

  _.forEach(defaultOptions, (v, k) =>
  {
    if (options[k] == null)
    {
      options[k] = v;
    }
  });

  step(
    function()
    {
      Setting
        .find({_id: /^ct\.reports\.results\./})
        .select({value: 1})
        .lean()
        .exec(this.next());
    },
    function(err, settings)
    {
      if (err)
      {
        return this.skip(err);
      }

      settings.forEach(setting =>
      {
        options[setting._id.replace('ct.reports.results.')] = setting.value;
      });

      const conditions = {
        quantityDone: {$gt: 0},
        workDuration: {$gt: 0},
        subdivisionType: 'assembly'
      };

      if (options.fromTime)
      {
        conditions.startedAt = {
          $gte: moment(options.fromTime).hours(6).toDate()
        };
      }

      if (options.toTime)
      {
        if (!conditions.startedAt)
        {
          conditions.startedAt = {};
        }

        conditions.startedAt.$lt = moment(options.toTime).hours(6).toDate();
      }

      if (!conditions.startedAt)
      {
        return this.skip();
      }

      const stream = ProdShiftOrder
        .find(conditions)
        .select({
          'orderData.mrp': 1,
          'orderData.operations': 1,
          'orderData.taktTimeCoeff': 1,
          'orderData.cycleTime': 1,
          prodLine: 1,
          date: 1,
          workDuration: 1,
          breakDuration: 1,
          workerCount: 1,
          totalQuantity: 1,
          quantityDone: 1,
          laborTime: 1
        })
        .lean()
        .stream();

      const next = _.once(this.next());

      stream.on('error', next);
      stream.on('end', next);
      stream.on('data', handleShiftOrder.bind(this));
    },
    function(err)
    {
      if (err)
      {
        return done(err);
      }

      const now = Date.now();
      const dayCount = businessDays.countBetweenDates(
        new Date(options.fromTime),
        new Date(options.toTime > now ? now : options.toTime)
      );

      results.shiftCount = options.shiftCount * dayCount;

      results.lines = Object.values(results.lines);

      results.lines.forEach(line =>
      {
        line.workDuration = _.round(line.workDuration, 1);
        line.breakDuration = _.round(line.breakDuration, 1);
        line.shiftCount = line.shiftCount.size;
        line.mrps = Array.from(line.mrps);
        line.efficiency = line.efficiency[1] ? Math.round(line.efficiency[0] / line.efficiency[1] * 100) : 0;
        line.usage = _.round(line.workDuration / (options.availableWorkDuration * results.shiftCount) * 100, 2);

        if (line.workDuration > options.minLineWorkDuration)
        {
          results.workingLineCount += 1;
          results.availableLineUsage += line.workDuration;
        }

        calcAvgMed(line);
        calcUnbalance(line);
        calcBottleneck(line);
      });

      results.lines.sort(sortById);

      results.availableLineUsage = _.round(
        results.availableLineUsage
          / (results.workingLineCount * options.availableWorkDuration * results.shiftCount)
          * 100,
        1
      );

      results.mrps = Object.values(results.mrps);

      results.mrps.forEach(mrp =>
      {
        mrp.lines = Array.from(mrp.lines).sort(sortStrings);
        mrp.efficiency = mrp.efficiency[1] ? Math.round(mrp.efficiency[0] / mrp.efficiency[1] * 100) : 0;

        if (mrp.efficiency > options.minMrpEfficiency)
        {
          results.efficientMrpCount += 1;
        }

        calcAvgMed(mrp);
        calcUnbalance(mrp);
        calcBottleneck(mrp);

        if (mrp.bottleneck.length)
        {
          results.bottleneckedMrpCount += 1;
        }

        if (mrp.unbalance.value > options.minMrpUnbalance)
        {
          results.unbalancedMrpCount += 1;
        }
      });

      results.mrps.sort(sortById);

      const upphList = [];

      _.forEach(results.upph, (upph, week) =>
      {
        upph = _.round(upph[0] / upph[1], 2);

        if (upph)
        {
          upphList.push({_id: week, upph});
        }
      });

      upphList.sort(sortById);

      results.upph = upphList;

      done(null, results);
    }
  );

  function getLine(lineId)
  {
    if (!results.lines[lineId])
    {
      results.lines[lineId] = {
        _id: lineId,
        mrps: new Set(),
        workDuration: 0,
        breakDuration: 0,
        quantityDone: 0,
        efficiency: [0, 0],
        unbalance: {
          min: null,
          max: null,
          value: 0
        },
        bottleneck: {},
        avgMed: {},
        shiftCount: new Set()
      };
    }

    return results.lines[lineId];
  }

  function getMrp(mrpId)
  {
    if (!mrpId)
    {
      mrpId = 'NIL';
    }

    if (!results.mrps[mrpId])
    {
      results.mrps[mrpId] = {
        _id: mrpId,
        lines: new Set(),
        efficiency: [0, 0],
        unbalance: {
          min: null,
          max: null,
          value: 0
        },
        bottleneck: {},
        avgMed: {}
      };
    }

    return results.mrps[mrpId];
  }

  function handleShiftOrder(shiftOrder)
  {
    const orderData = shiftOrder.orderData || {};
    const mrp = getMrp(orderData.mrp);

    if (options.ignoredMrps.includes(mrp))
    {
      return;
    }

    const line = getLine(shiftOrder.prodLine);

    const date = moment(shiftOrder.date);
    const effNum = adjustLaborTime(shiftOrder) / 100 * shiftOrder.totalQuantity;
    const effDen = shiftOrder.workDuration * shiftOrder.workerCount;

    line.workDuration += shiftOrder.workDuration;
    line.breakDuration += shiftOrder.breakDuration;
    line.quantityDone += shiftOrder.quantityDone;

    line.shiftCount.add(date.valueOf());

    line.mrps.add(mrp._id);
    mrp.lines.add(line._id);

    line.efficiency[0] += effNum;
    line.efficiency[1] += effDen;

    mrp.efficiency[0] += effNum;
    mrp.efficiency[1] += effDen;

    const week = `${date.isoWeekYear()}-W${date.isoWeek().toString().padStart(2, '0')}`;

    if (!results.upph[week])
    {
      results.upph[week] = [0, 0];
    }

    results.upph[week][0] += shiftOrder.quantityDone / shiftOrder.workerCount / shiftOrder.workDuration;

    if (shiftOrder.workDuration > options.minUpphWorkDuration)
    {
      results.upph[week][1] += 1;
    }

    handleCycleTime(orderData.cycleTime, mrp, line);
  }

  function handleCycleTime(cycleTime, mrp, line)
  {
    if (!cycleTime)
    {
      return;
    }

    let bottleneckStation = 0;
    let bottleneckValue = 0;

    cycleTime.med.forEach((med, s) =>
    {
      if (s === 0 || med < 1001 || med > (8 * 3600 * 1000))
      {
        return;
      }

      if (med > bottleneckValue)
      {
        bottleneckStation = s;
        bottleneckValue = med;
      }

      [mrp, line].forEach(group =>
      {
        if (group.avgMed[s] === undefined)
        {
          group.avgMed[s] = [0, 0];
        }

        group.avgMed[s][0] += med;
        group.avgMed[s][1] += 1;
      });
    });

    if (bottleneckStation !== 0)
    {
      [mrp, line].forEach(group =>
      {
        if (group.bottleneck[bottleneckStation] === undefined)
        {
          group.bottleneck[bottleneckStation] = 0;
        }

        group.bottleneck[bottleneckStation] += 1;
      });
    }
  }

  function calcAvgMed(group)
  {
    const avgMed = [];

    _.forEach(group.avgMed, (b, s) =>
    {
      avgMed.push({
        station: +s,
        value: Math.round(b[0] / b[1]) || 0
      });

      results.stationCount = Math.max(results.stationCount, +s);
    });

    avgMed.sort((a, b) => b.value - a.value);

    group.avgMed = avgMed;
  }

  function calcUnbalance(group)
  {
    if (!group.avgMed.length)
    {
      return;
    }

    group.unbalance.min = _.last(group.avgMed);
    group.unbalance.max = _.first(group.avgMed);

    const num = group.unbalance.max.value - group.unbalance.min.value;
    const den = group.unbalance.max.value;

    group.unbalance.value = Math.round(num / den * 100);
  }

  function calcBottleneck(group)
  {
    const bottleneck = [];

    _.forEach(group.bottleneck, (count, s) =>
    {
      bottleneck.push({
        station: +s,
        count
      });

      results.stationCount = Math.max(results.stationCount, +s);
    });

    bottleneck.sort((a, b) => b.count - a.count);

    group.bottleneck = bottleneck;
  }

  function adjustLaborTime(shiftOrder)
  {
    if (shiftOrder.orderData
      && shiftOrder.orderData.taktTimeCoeff
      && shiftOrder.orderData.operations)
    {
      const op = shiftOrder.orderData.operations[shiftOrder.operationNo];

      if (op)
      {
        const taktTimeCoeff = shiftOrder.orderData.taktTimeCoeff[op.workCenter]
          || shiftOrder.orderData.taktTimeCoeff['*']
          || 1;

        shiftOrder.laborTime *= taktTimeCoeff;
      }
    }

    return shiftOrder.laborTime;
  }

  function sortById(a, b)
  {
    return a._id.localeCompare(b._id, undefined, {numeric: true, ignorePunctuation: true});
  }

  function sortStrings(a, b)
  {
    return a.localeCompare(b, undefined, {numeric: true, ignorePunctuation: true});
  }
};
