// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');
const deepEqual = require('deep-equal');
const {ObjectId} = require('mongoose').Types;

module.exports = (app, {Order}, orderNo, data, userInfo, done) =>
{
  if (_.isEmpty(data.comment))
  {
    data.comment = '';
  }

  if (!validateEditInput(data))
  {
    return done(app.createError('INPUT', 400));
  }

  data.comment = data.comment.trim();

  step(
    function findOrderStep()
    {
      const fields = {
        qtyMax: 1,
        delayReason: 1,
        delayComponent: 1,
        m4: 1,
        whStatus: 1,
        whTime: 1,
        whDropZone: 1,
        notes: 1,
        documents: 1
      };

      if (data.change)
      {
        fields.changes = 1;
      }

      Order.findById(orderNo).select(fields).lean().exec(this.next());
    },
    function editOrderStep(err, order)
    {
      if (err)
      {
        return this.skip(err);
      }

      if (!order)
      {
        return this.skip(app.createError('NOT_FOUND', 404));
      }

      const change = {
        time: new Date(),
        user: userInfo,
        oldValues: {},
        newValues: {},
        comment: data.comment,
        source: data.source || 'other'
      };
      const update = {};

      const valuesToCheck = {
        qtyMax: {
          old: order.qtyMax && order.qtyMax[data.operationNo] || 0,
          new: data.qtyMax,
          value: value => Object.assign({}, order.qtyMax || {}, {[data.operationNo]: value}),
          change: value => ({operationNo: data.operationNo, value})
        },
        delayReason: {
          old: order.delayReason ? order.delayReason.toString() : '',
          new: data.delayReason,
          value: v => v === '' ? null : new ObjectId(v),
          change: v => v === '' ? null : new ObjectId(v)
        },
        delayComponent: {
          old: order.delayComponent,
          new: data.delayComponent,
          value: v => v,
          change: v => v
        },
        m4: {
          old: order.m4,
          new: data.m4,
          value: v => v,
          change: v => v
        },
        whStatus: {
          old: order.whStatus,
          new: data.whStatus,
          value: v => v,
          change: v => v
        },
        whTime: {
          old: order.whTime,
          new: data.whTime ? new Date(data.whTime) : data.whTime,
          value: v => v,
          change: v => v
        },
        whDropZone: {
          old: order.whDropZone,
          new: data.whDropZone,
          value: v => v,
          change: v => v
        },
        change: {
          old: order.changes && order.changes[data.change.index]
            ? order.changes[data.change.index].time.getTime()
            : undefined,
          new: data.change ? data.change.time : undefined,
          set: values =>
          {
            const time = new Date(data.change.time);
            const changedChange = order.changes[data.change.index];

            changedChange.time = time;

            order.changes.sort((a, b) => a.time - b.time);

            const newIndex = order.changes.indexOf(changedChange);

            if (newIndex === data.change.index)
            {
              update.$set[`changes.${data.change.index}.time`] = time;
            }

            change.oldValues.change = {
              oldIndex: data.change.index,
              newIndex,
              time: values.old
            };
            change.newValues.change = {
              oldIndex: data.change.index,
              newIndex,
              time: values.new
            };
          }
        },
        notes: {
          old: order.notes,
          new: data.notes,
          value: v => v,
          change: v => v
        },
        documents: {
          old: data.documents ? order.documents.sort(sortDocuments) : undefined,
          new: data.documents ? data.documents.sort(sortDocuments) : undefined,
          value: v => v,
          change: v => v
        }
      };

      Object.keys(valuesToCheck).forEach(k =>
      {
        const values = valuesToCheck[k];

        if (values.new === undefined || deepEqual(values.new, values.old))
        {
          return;
        }

        if (!update.$set)
        {
          update.$set = {};
        }

        if (values.set)
        {
          values.set(values, k);
        }
        else
        {
          update.$set[k] = values.value(values.new);
          change.oldValues[k] = values.change(values.old);
          change.newValues[k] = values.change(values.new);
        }
      });

      if (_.isEmpty(change.newValues) && !change.comment.length)
      {
        return this.skip();
      }

      const newChange = change.newValues.change;

      if (newChange)
      {
        if (newChange.oldIndex === newChange.newIndex)
        {
          update.$set[`changes.${order.changes.length}`] = change;
        }
        else
        {
          order.changes.push(change);

          update.$set.changes = order.changes;
        }
      }
      else
      {
        update.$push = {changes: change};
      }

      setImmediate(this.parallel(), null, change);

      Order.collection.updateOne({_id: order._id}, update, this.parallel());
    },
    function sendResultsStep(err, change)
    {
      if (err)
      {
        return done(err);
      }

      if (change)
      {
        app.broker.publish(`orders.updated.${orderNo}`, {
          _id: orderNo,
          change
        });

        if (change.newValues.documents)
        {
          app.broker.publish('orders.documentsChanged', {
            orders: [orderNo]
          });
        }
      }

      done();
    }
  );
};

function validateEditInput(input)
{
  const {
    comment,
    delayReason,
    delayComponent,
    m4,
    qtyMax,
    operationNo,
    whStatus,
    whTime,
    whDropZone,
    change,
    notes,
    documents
  } = input;

  if (!_.isString(comment))
  {
    return false;
  }

  if (delayReason !== undefined
    && delayReason !== ''
    && !/^[a-f0-9]{24}$/.test(delayReason))
  {
    return false;
  }

  if (delayComponent !== undefined
    && delayComponent !== ''
    && !/^([A-Z0-9]{7}|[0-9]{12})$/.test(delayComponent))
  {
    return false;
  }

  if (m4 !== undefined
    && m4 !== ''
    && !['man', 'machine', 'material', 'method'].includes(m4))
  {
    return false;
  }

  if (qtyMax !== undefined
    && (qtyMax < 0 || qtyMax > 9999 || !/^[0-9]{4}$/.test(operationNo)))
  {
    return false;
  }

  if (whStatus !== undefined
    && !_.isString(whStatus))
  {
    return false;
  }

  if (whTime !== undefined
    && whTime !== null
    && isNaN(Date.parse(whTime)))
  {
    return false;
  }

  if (whDropZone !== undefined
    && !_.isString(whDropZone))
  {
    return false;
  }

  if (change !== undefined
    && !_.isPlainObject(change)
    && !_.isNumber(change.index)
    && !_.isNumber(change.time))
  {
    return false;
  }

  if (notes !== undefined
    && !_.isArray(notes)
    && !notes.every(text => _.isString(text)))
  {
    return false;
  }

  if (documents !== undefined
    && !_.isArray(documents))
  {
    return false;
  }

  return true;
}

function sortDocuments(a, b)
{
  if (a.item !== b.item)
  {
    return a.item - b.item;
  }

  if (a.name !== b.name)
  {
    return a.name.localeCompare(b.name);
  }

  return a.nc15.localeCompare(b.nc15);
}
