// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');

module.exports = (app, module) =>
{
  if (module.config.syncDrillStatus.updater)
  {
    app.broker.subscribe('drilling.events.saved', e => updateDrillStatus(e));
  }

  if (module.config.syncDrillStatus.generator)
  {
    app.broker.subscribe('drilling.orders.changed.*', onDrillingChanged);
  }

  function updateDrillStatus(drillingEvent, done)
  {
    const {DrillingOrder, Order} = module;

    step(
      function()
      {
        DrillingOrder
          .findById(drillingEvent.order)
          .select({status: 1, order: 1, qty: 1, qtyDone: 1})
          .lean()
          .exec(this.next());
      },
      function(err, drillingOrder)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!drillingOrder)
        {
          if (!drillingEvent.data.sapOrder)
          {
            return this.skip(app.createError(`Drilling order not found.`, {
              psOrder: drillingEvent.order,
              sapOrder: drillingEvent.data.sapOrder
            }));
          }

          drillingOrder = {
            _id: drillingEvent.order,
            status: 'unknown',
            order: drillingEvent.data.sapOrder,
            qty: 0,
            qtyDone: 0
          };
        }

        let comment = drillingEvent.data.comment || '';

        if (_.isEmpty(comment.replace(/[^A-Za-z0-9]+/g, '')))
        {
          comment = '';
        }

        this.defaultComment = resolveDrillingComment(drillingOrder);
        this.newStatus = drillingOrder.status;
        this.orderNo = drillingOrder.order;
        this.eventChange = {
          time: drillingEvent.time,
          user: drillingEvent.user,
          oldValues: {},
          newValues: {},
          comment,
          source: 'ps'
        };

        Order
          .findOne({_id: this.orderNo})
          .select({
            _id: 1,
            leadingOrder: 1,
            drillStatus: 1
          })
          .lean()
          .exec(this.next());
      },
      function(err, eventSapOrder)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!eventSapOrder)
        {
          return this.skip(app.createError(`Event SAP order not found.`));
        }

        if (!eventSapOrder.leadingOrder)
        {
          return setImmediate(this.next(), null, [eventSapOrder]);
        }

        Order
          .find({
            $or: [
              {_id: eventSapOrder.leadingOrder},
              {leadingOrder: eventSapOrder.leadingOrder}
            ]
          })
          .select({
            _id: 1,
            leadingOrder: 1,
            drillStatus: 1
          })
          .lean()
          .exec(this.next());
      },
      function(err, sapOrders)
      {
        if (err)
        {
          return this.skip(app.createError(`Failed to find SAP orders: ${err.message}`));
        }

        this.eventSapOrder = sapOrders.find(o => o._id === this.orderNo);

        if (this.newStatus !== this.eventSapOrder.drillStatus)
        {
          this.eventChange.oldValues.drillStatus = this.eventSapOrder.drillStatus;
          this.eventChange.newValues.drillStatus = this.newStatus;
        }

        this.leadingSapOrder = sapOrders.find(o => o._id === o.leadingOrder);

        DrillingOrder
          .find({order: {$in: sapOrders.map(o => o._id)}})
          .select({status: 1})
          .lean()
          .exec(this.next());
      },
      function(err, drillingOrders)
      {
        if (err)
        {
          return this.skip(app.createError(`Failed to find drilling orders: ${err.message}`));
        }

        const eventChange = this.eventChange;

        if (this.eventSapOrder !== this.leadingSapOrder)
        {
          const eventUpdate = {
            $push: {changes: eventChange}
          };

          if (Object.keys(eventChange.newValues).length)
          {
            eventUpdate.$set = eventChange.newValues;
          }
          else if (!eventChange.user.id)
          {
            this.eventChange = null;
          }

          if (this.eventChange)
          {
            Order.collection.updateOne({_id: this.orderNo}, eventUpdate, this.group());
          }
        }
        else
        {
          this.eventSapOrder = null;
          this.eventChange = null;
        }

        if (!this.leadingSapOrder)
        {
          return;
        }

        const statuses = {
          new: 0,
          started: 0,
          partial: 0,
          finished: 0,
          aside: 0,
          cancelled: 0
        };

        drillingOrders.forEach(o => statuses[o.status] += 1);

        const oldStatus = this.leadingSapOrder.drillStatus;
        const newStatus = resolveDrillingStatus(statuses, drillingOrders);

        const oldValues = {};
        const newValues = {};

        if (newStatus !== oldStatus)
        {
          oldValues.drillStatus = oldStatus;
          newValues.drillStatus = newStatus;
        }

        if (_.isEmpty(newValues) && _.isEmpty(eventChange.comment))
        {
          return;
        }

        if (_.isEmpty(eventChange.comment))
        {
          eventChange.comment = oldStatus === 'unknown' && newStatus === 'new' ? '' : this.defaultComment;
        }

        this.leadingChange = {
          time: drillingEvent.time,
          user: drillingEvent.user,
          oldValues,
          newValues,
          comment: eventChange.comment,
          source: 'ps'
        };

        const leadingUpdate = {
          $push: {changes: this.leadingChange},
          $set: {drillStatus: newStatus}
        };

        Order.collection.updateOne({_id: this.leadingSapOrder._id}, leadingUpdate, this.group());
      },
      function(err)
      {
        if (err)
        {
          err.drillingEvent = drillingEvent;

          module.error(err, `Failed to update drilling status.`);
        }
        else
        {
          if (this.eventChange)
          {
            app.broker.publish(`orders.updated.${this.eventSapOrder._id}`, {
              _id: this.eventSapOrder._id,
              change: this.eventChange
            });
          }

          if (this.leadingChange)
          {
            app.broker.publish(`orders.updated.${this.leadingSapOrder._id}`, {
              _id: this.leadingSapOrder._id,
              change: this.leadingChange
            });
          }
        }

        if (done)
        {
          done();
        }
      }
    );
  }

  function resolveDrillingStatus(statuses, drillingOrders)
  {
    if (drillingOrders.length === 0)
    {
      return 'unknown';
    }

    if (statuses.partial)
    {
      return 'partial';
    }

    if (statuses.started)
    {
      return 'started';
    }

    if (statuses.aside === drillingOrders.length)
    {
      return 'aside';
    }

    if (statuses.finished)
    {
      return (statuses.finished + statuses.cancelled) === drillingOrders.length ? 'finished' : 'partial';
    }

    if (statuses.aside)
    {
      return 'aside';
    }

    if (statuses.cancelled === drillingOrders.length)
    {
      return 'cancelled';
    }

    return 'new';
  }

  function resolveDrillingComment(o)
  {
    switch (o.status)
    {
      case 'new':
        return 'Zresetowano wiercenie.';

      case 'started':
        return o.qtyDone ? `Wznowiono wiercenie. Pozostało ${o.qty - o.qtyDone} szt.` : 'Rozpoczęto wiercenie.';

      case 'partial':
        return `Zakończono wiercenie ${o.qtyDone}/${o.qty} szt.`;

      case 'finished':
        return 'Zakończono wiercenie.';

      case 'aside':
        return 'Odstawiono wiercenie.';

      case 'cancelled':
        return 'Anulowano wiercenie.';

      case 'unknown':
        return 'Usunięto wiercenie.';
    }
  }

  function onDrillingChanged({changes})
  {
    const drillingEvent = {
      _id: null,
      type: null,
      time: new Date(),
      user: {
        id: null,
        label: 'System'
      },
      order: null,
      data: {}
    };

    const reorderProps = {
      _id: true,
      order: true,
      no: true,
      startTime: true
    };

    const drillingOrderQueue = [].concat(
      changes.removed,
      changes.added,
      changes.changed.filter(change => Object.keys(change).filter(k => !reorderProps[k]).length > 0)
    );

    updateNextDrillStatus(drillingEvent, drillingOrderQueue);
  }

  function updateNextDrillStatus(drillingEvent, drillingOrderQueue)
  {
    if (!drillingOrderQueue.length)
    {
      return;
    }

    const drillingOrder = drillingOrderQueue.shift();

    drillingEvent.order = drillingOrder._id;
    drillingEvent.data.sapOrder = drillingOrder.order;

    updateDrillStatus(drillingEvent, () => updateNextDrillStatus(drillingEvent, drillingOrderQueue));
  }
};
