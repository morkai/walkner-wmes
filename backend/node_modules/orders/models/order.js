// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const step = require('h5.step');

exports.name = 'Order';

exports.setUp = (app, mongoose) =>
{
  const operationSchema = new mongoose.Schema({
    no: {
      type: String,
      trim: true
    },
    workCenter: {
      type: String,
      trim: true
    },
    name: {
      type: String,
      trim: true
    },
    qty: Number,
    unit: {
      type: String,
      trim: true
    },
    machineSetupTime: Number,
    laborSetupTime: Number,
    machineTime: Number,
    laborTime: Number,
    sapMachineSetupTime: Number,
    sapLaborSetupTime: Number,
    sapMachineTime: Number,
    sapLaborTime: Number
  }, {
    _id: false
  });

  const documentSchema = new mongoose.Schema({
    item: String,
    name: String,
    nc15: String,
    added: {
      type: Boolean,
      default: false
    }
  }, {
    _id: false
  });

  const componentSchema = new mongoose.Schema({
    nc12: String,
    item: String,
    qty: Number,
    unit: String,
    name: String,
    unloadingPoint: String,
    supplyArea: String
  }, {
    _id: false
  });

  const noteSchema = new mongoose.Schema({
    target: String,
    priority: String,
    text: String
  }, {
    _id: false
  });

  const tagSchema = new mongoose.Schema({
    _id: String,
    label: String
  }, {
    _id: false
  });

  const changeSchema = new mongoose.Schema({
    time: Date,
    user: {},
    oldValues: {},
    newValues: {},
    comment: {
      type: String,
      default: ''
    },
    source: {
      type: String,
      default: 'system',
      enum: ['system', 'other', 'ps', 'wh']
    }
  }, {
    _id: false
  });

  const orderSchema = new mongoose.Schema({
    _id: String,
    createdAt: Date,
    updatedAt: Date,
    nc12: String,
    name: String,
    mrp: String,
    qty: Number,
    qtyDone: {},
    qtyMax: {},
    unit: String,
    startDate: Date,
    finishDate: Date,
    tzOffsetMs: Number,
    scheduledStartDate: Date,
    scheduledFinishDate: Date,
    leadingOrder: String,
    salesOrder: String,
    salesOrderItem: String,
    priority: String,
    etoCont: Boolean,
    description: String,
    soldToParty: String,
    sapCreatedAt: Date,
    statuses: [String],
    statusesSetAt: {},
    delayReason: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'DelayReason',
      default: null
    },
    delayComponent: String,
    m4: String,
    whStatus: String,
    whTime: Date,
    whDropZone: String,
    psStatus: String,
    drillStatus: String,
    enteredBy: String,
    changedBy: String,
    operations: [operationSchema],
    documents: [documentSchema],
    bom: [componentSchema],
    notes: [noteSchema],
    tags: [tagSchema],
    changes: [changeSchema],
    importTs: Date
  }, {
    id: false
  });

  orderSchema.statics.TOPIC_PREFIX = 'orders';
  orderSchema.statics.COMPLETED_STATUSES = ['CNF', 'DLV', 'TECO', 'DLT', 'DLFL', 'DEL'];
  orderSchema.statics.DELETED_STATUSES = ['TECO', 'DLT', 'DLFL', 'DEL'];

  orderSchema.index({scheduledStartDate: -1});
  orderSchema.index({scheduledFinishDate: -1});
  orderSchema.index({startDate: -1});
  orderSchema.index({finishDate: -1});
  orderSchema.index({nc12: 1, scheduledStartDate: -1});
  orderSchema.index({mrp: 1, scheduledStartDate: -1});
  orderSchema.index({salesOrder: 1, salesOrderItem: 1});
  orderSchema.index({leadingOrder: 1});
  orderSchema.index({'bom.nc12': 1});
  orderSchema.index({'documents.nc15': 1});
  orderSchema.index({'operations.workCenter': 1, scheduledStartDate: -1});

  orderSchema.statics.IGNORED_IMPORT_PROPS = {
    createdAt: true,
    updatedAt: true,
    tzOffsetMs: true,
    statusesSetAt: true,
    delayReason: true,
    m4: true,
    documents: true,
    bom: true,
    changes: true,
    importTs: true,
    description: true,
    soldToParty: true,
    sapCreatedAt: true,
    qtyDone: true,
    qtyMax: true,
    whStatus: true,
    whTime: true,
    whDropZone: true,
    psStatus: true,
    drillStatus: true,
    notes: true
  };

  orderSchema.statics.createForInsert = function(obj, importTs)
  {
    const scheduledStart = obj.scheduledStartDate;
    const scheduledFinish = obj.scheduledFinishDate;

    return {
      _id: obj.no,
      createdAt: null,
      updatedAt: null,
      nc12: obj.nc12,
      name: obj.name,
      mrp: obj.mrp,
      qty: obj.qty,
      qtyDone: {
        total: 0,
        byLine: {},
        byOperation: {}
      },
      qtyMax: {},
      unit: obj.unit,
      startDate: obj.startDate
        ? new Date(obj.startDate.y, obj.startDate.m - 1, obj.startDate.d)
        : null,
      finishDate: obj.finishDate
        ? new Date(obj.finishDate.y, obj.finishDate.m - 1, obj.finishDate.d)
        : null,
      tzOffsetMs: 0,
      scheduledStartDate: scheduledStart
        ? new Date(scheduledStart.y, scheduledStart.m - 1, scheduledStart.d)
        : null,
      scheduledFinishDate: scheduledFinish
        ? new Date(scheduledFinish.y, scheduledFinish.m - 1, scheduledFinish.d)
        : null,
      leadingOrder: obj.leadingOrder || null,
      salesOrder: obj.salesOrder || null,
      salesOrderItem: obj.salesOrderItem || null,
      priority: obj.priority,
      etoCont: false,
      description: null,
      soldToParty: null,
      sapCreatedAt: null,
      statuses: obj.statuses,
      statusesSetAt: {},
      delayReason: null,
      delayComponent: '',
      m4: '',
      whStatus: 'unknown',
      whTime: null,
      whDropZone: '',
      psStatus: 'unknown',
      drillStatus: 'unknown',
      enteredBy: obj.enteredBy.includes('SYSBTC') ? 'System' : obj.enteredBy,
      changedBy: obj.changedBy.includes('SYSBTC') ? 'System' : obj.changedBy,
      operations: [],
      documents: [],
      bom: [],
      notes: [],
      tags: [],
      changes: [],
      importTs: importTs
    };
  };

  orderSchema.statics.createMissingForInsert = function(missingOrder, createdAt)
  {
    return {
      _id: missingOrder._id,
      createdAt: createdAt,
      updatedAt: null,
      nc12: null,
      name: null,
      mrp: null,
      qty: null,
      qtyDone: {
        total: 0,
        byLine: {},
        byOperation: {}
      },
      qtyMax: {},
      unit: null,
      startDate: null,
      finishDate: null,
      tzOffsetMs: 0,
      scheduledStartDate: null,
      scheduledFinishDate: null,
      leadingOrder: null,
      salesOrder: null,
      salesOrderItem: null,
      priority: null,
      etoCont: false,
      description: null,
      soldToParty: null,
      sapCreatedAt: null,
      statuses: [],
      statusesSetAt: {},
      delayReason: null,
      delayComponent: '',
      m4: '',
      whStatus: 'unknown',
      whTime: null,
      whDropZone: '',
      psStatus: 'unknown',
      drillStatus: 'unknown',
      enteredBy: '',
      changedBy: '',
      operations: missingOrder.operations,
      documents: [],
      bom: [],
      notes: [],
      tags: [],
      changes: [],
      importTs: missingOrder.importTs
    };
  };

  orderSchema.statics.prepareForInsert = function(order, createdAt)
  {
    order.createdAt = createdAt;
    order.tzOffsetMs = (order.startDate ? order.startDate.getTimezoneOffset() : 0) * 60 * 1000 * -1;
    order.changes = [];

    orderSchema.statics.resetStatusesSetAt(order);

    return order;
  };

  orderSchema.statics.prepareForUpdate = function(orderModel, newOrderData, updatedAt, change, $set)
  {
    $set.updatedAt = updatedAt;
    $set.importTs = newOrderData.importTs;

    if ($set.scheduledStartDate)
    {
      $set.tzOffsetMs = $set.scheduledStartDate.getTimezoneOffset() * 60 * 1000 * -1;
    }

    if ($set.statuses)
    {
      $set.statusesSetAt = orderSchema.statics.prepareStatusesSetAt(
        orderModel.statusesSetAt,
        change.time,
        change.newValues.statuses
      );
    }

    return $set;
  };

  orderSchema.statics.copyOrderIntake = function(order, orderIntake)
  {
    order.description = orderIntake.description;
    order.soldToParty = orderIntake.soldToParty;
    order.sapCreatedAt = orderIntake.sapCreatedAt;
  };

  orderSchema.statics.resetStatusesSetAt = function(order)
  {
    const statusSetAt = order.importTs;
    const statusesSetAt = {};

    for (let i = 0; i < order.statuses.length; ++i)
    {
      statusesSetAt[order.statuses[i]] = statusSetAt;
    }

    order.statusesSetAt = statusesSetAt;
  };

  orderSchema.statics.prepareStatusesSetAt = function(oldStatusesSetAt, newStatusSetAt, newStatuses)
  {
    const newStatusesSetAt = {};

    for (let i = 0; i < newStatuses.length; ++i)
    {
      const status = newStatuses[i];
      const oldStatusSetAt = oldStatusesSetAt[status];

      newStatusesSetAt[status] = oldStatusSetAt || newStatusSetAt;
    }

    return newStatusesSetAt;
  };

  orderSchema.statics.recountQtyDone = function(orderNo, done)
  {
    const qtyDone = {
      total: Number.MAX_SAFE_INTEGER,
      byLine: {},
      byOperation: {}
    };

    step(
      function()
      {
        const conditions = {
          orderId: orderNo
        };
        const fields = {
          quantityDone: 1,
          operationNo: 1,
          prodLine: 1
        };

        mongoose.model('ProdShiftOrder').find(conditions, fields).lean().exec(this.next());
      },
      function(err, psos)
      {
        if (err)
        {
          return this.skip(err);
        }

        psos.forEach(pso =>
        {
          if (!qtyDone.byLine[pso.prodLine])
          {
            qtyDone.byLine[pso.prodLine] = 0;
          }

          qtyDone.byLine[pso.prodLine] += pso.quantityDone;

          if (!qtyDone.byOperation[pso.operationNo])
          {
            qtyDone.byOperation[pso.operationNo] = 0;
          }

          qtyDone.byOperation[pso.operationNo] += pso.quantityDone;
        });

        Object.keys(qtyDone.byOperation).forEach(operationNo =>
        {
          const operationQtyDone = qtyDone.byOperation[operationNo];

          if (operationQtyDone > 0 && operationQtyDone < qtyDone.total)
          {
            qtyDone.total = operationQtyDone;
          }
        });

        if (qtyDone.total === Number.MAX_SAFE_INTEGER)
        {
          qtyDone.total = 0;
        }

        mongoose.model('Order').updateOne({_id: orderNo}, {$set: {qtyDone: qtyDone}}, this.next());
      },
      function(err)
      {
        if (!err)
        {
          app.broker.publish(`orders.quantityDone.${orderNo}`, qtyDone);
        }

        done(err, qtyDone);
      }
    );
  };

  orderSchema.statics.assignPkhdStrategies = function(order, done)
  {
    if (!Array.isArray(order.bom) || !order.bom.length)
    {
      return done(null, order);
    }

    const ids = (order.bom || [])
      .filter(c => !!c.nc12 && !!c.supplyArea)
      .map(component => ({
        nc: component.nc12,
        sa: component.supplyArea
      }));

    if (!ids.length)
    {
      return done(null, order);
    }

    step(
      function()
      {
        mongoose.model('PkhdComponent').find({_id: {$in: ids}}).lean().exec(this.next());
      },
      function(err, pkhdComponents)
      {
        if (err)
        {
          return this.skip(err);
        }

        const strategyIds = new Map();

        this.strategies = new Map();

        pkhdComponents.forEach(pkhdComponent =>
        {
          const key = `${pkhdComponent.s}:${pkhdComponent.t}`;

          strategyIds.set(key, {
            s: pkhdComponent.s,
            t: pkhdComponent.t
          });

          if (!this.strategies.has(key))
          {
            this.strategies.set(key, []);
          }

          this.strategies.get(key).push(pkhdComponent._id.nc);
        });

        if (strategyIds.size === 0)
        {
          return this.skip();
        }

        mongoose.model('PkhdStrategy')
          .find({$or: Array.from(strategyIds.values())}, {_id: 0})
          .lean()
          .exec(this.next());
      },
      function(err, pkhdStrategies)
      {
        if (err)
        {
          return this.skip(err);
        }

        const nc12ToStrategy = new Map();

        pkhdStrategies.forEach(pkhdStrategy =>
        {
          this.strategies.get(`${pkhdStrategy.s}:${pkhdStrategy.t}`).forEach(nc12 =>
          {
            nc12ToStrategy.set(nc12, pkhdStrategy.name);
          });
        });

        order.bom.forEach(component =>
        {
          component.distStrategy = nc12ToStrategy.get(component.nc12) || '';
        });
      },
      function(err)
      {
        done(err, order);
      }
    );
  };

  orderSchema.statics.assignNotes = function(order, target, done)
  {
    if (!Array.isArray(order.notes))
    {
      return done(null, order);
    }

    if (order.notes.length)
    {
      if (!target)
      {
        return done(null, order);
      }

      order.notes = order.notes.filter(note => note.target === target);

      return done(null, order);
    }

    const codes = [];
    const bomNotes = [];

    if (order._id)
    {
      codes.push(order._id);
    }

    if (order.nc12)
    {
      codes.push(order.nc12);
    }

    if (Array.isArray(order.bom))
    {
      const docsTarget = !target || target === 'docs';

      for (const component of order.bom)
      {
        if (component.nc12)
        {
          codes.push(component.nc12);
        }
        else if (docsTarget && component.name)
        {
          bomNotes.push({
            target: 'docs',
            priority: 'warning',
            text: component.name
          });
        }
      }
    }

    const ProductNote = mongoose.model('ProductNote');

    step(
      function()
      {
        if (!codes.length)
        {
          setImmediate(this.next(), null, []);

          return;
        }

        const conditions = {
          codes: {$in: codes}
        };

        if (target)
        {
          conditions.target = target;
        }

        ProductNote
          .find(conditions)
          .select({_id: 0, codes: 0})
          .lean()
          .exec(this.next());
      },
      function(err, productNotes)
      {
        if (err)
        {
          return done(err);
        }

        const keysByTarget = {};

        order.notes = [];

        [...productNotes, ...bomNotes].forEach(note =>
        {
          if (!keysByTarget[note.target])
          {
            keysByTarget[note.target] = new Set();
          }

          const keys = keysByTarget[note.target];
          const key = note.text.replace(/[^0-9a-zA-Z]+/g, '').toUpperCase();

          if (keys.has(key))
          {
            return;
          }

          keys.add(key);

          order.notes.push(note);
        });

        done(null, order);
      }
    );
  };

  orderSchema.statics.assignCompRelEntries = function(order, done)
  {
    const CompRelEntry = mongoose.model('CompRelEntry');

    step(
      function()
      {
        const $or = [{
          status: 'accepted',
          'orders.orderNo': order._id
        }];

        if (order.mrp && order.scheduledStartDate)
        {
          $or.push({
            status: 'accepted',
            mrps: order.mrp,
            'orders.orderNo': '000000000',
            orders: {$elemMatch: {
              orderNo: '000000000',
              validFrom: {$lte: order.scheduledStartDate},
              validTo: {$gte: order.scheduledStartDate}
            }}
          });
        }

        CompRelEntry
          .find({$or})
          .select({
            rid: 1,
            oldComponents: 1,
            newCode: 1,
            newName: 1,
            reason: 1,
            orders: 1
          })
          .lean()
          .exec(this.next());
      },
      function(err, compRelEntries)
      {
        if (err)
        {
          return done(err);
        }

        compRelEntries.forEach(entry =>
        {
          const o = entry.orders.find(o => o.orderNo === order._id) || entry.orders.find(o =>
          {
            return o.orderNo === '000000000'
              && o.validFrom <= order.scheduledStartDate
              && o.validTo >= order.scheduledStartDate;
          });

          entry.releasedBy = o.releasedBy;
          entry.releasedAt = o.releasedAt;
          entry.orders = undefined;
        });

        order.compRels = compRelEntries;

        done(null, order);
      }
    );
  };

  mongoose.model(exports.name, orderSchema);
};
