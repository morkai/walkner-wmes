// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const os = require('os');
const fs = require('fs');
const _ = require('lodash');
const multer = require('multer');
const csv = require('csv');
const step = require('h5.step');

module.exports = (app, module) =>
{
  const {
    express,
    user,
    MechOrder
  } = module;

  let importing = null;

  express.get('/mechOrders', express.crud.browseRoute.bind(null, app, MechOrder));

  express.get('/mechOrders/:id', express.crud.readRoute.bind(null, app, MechOrder));

  express.post(
    '/mechOrders;import',
    user.auth('ORDERS:MANAGE'),
    multer({
      dest: os.tmpdir(),
      limits: {
        files: 1,
        fileSize: 5 * 1024 * 1024
      }
    }).single('mechOrders'),
    importRoute
  );

  express.patch('/mechOrders/:id', express.crud.editRoute.bind(null, app, MechOrder));

  function removeFile(req)
  {
    if (req.file)
    {
      fs.unlink(req.file.path, _.noop);
    }
  }

  function importRoute(req, res, next)
  {
    if (importing !== null)
    {
      removeFile(req);

      return res.sendStatus(400);
    }

    const mechOrdersFile = req.file;

    if (!mechOrdersFile || !/\.csv$/i.test(mechOrdersFile.originalname))
    {
      removeFile(req);

      return res.sendStatus(400);
    }

    importing = 0;

    module.info('Importing mech orders...');

    const importTs = new Date();
    const mechOrders = {};
    const nc12Queue = [];

    step(
      function()
      {
        fs.readFile(mechOrdersFile.path, 'utf8', this.next());
      },
      function(err, data)
      {
        if (err)
        {
          return this.skip(err);
        }

        csv.parse(data, {delimiter: ';'}, this.next());
      },
      function(err, rows)
      {
        if (err)
        {
          return this.skip(err);
        }

        rows.forEach(addMechOrder);

        setImmediate(this.next());
      },
      function(err)
      {
        if (err)
        {
          importing = null;

          return next(err);
        }

        upsertNextMechOrder();
      }
    );

    function addMechOrder(row)
    {
      if (row.length < 12 || !/^[0-9]{12}$/.test(row[0]))
      {
        return;
      }

      const nc12 = row[0];

      if (typeof mechOrders[nc12] === 'undefined')
      {
        nc12Queue.push(nc12);

        let mrp = row[11].trim();

        if (mrp.length === 0 || mrp.toUpperCase() === 'BRAK')
        {
          mrp = null;
        }

        mechOrders[nc12] = {
          _id: nc12,
          name: row[1],
          mrp: mrp,
          materialNorm: parseTime(row[10]),
          operations: [],
          importTs: importTs
        };
      }

      mechOrders[nc12].operations.push({
        no: row[2],
        workCenter: row[3],
        name: row[4],
        machineSetupTime: parseTime(row[6]),
        laborSetupTime: parseTime(row[7]),
        machineTime: parseTime(row[8]),
        laborTime: parseTime(row[9])
      });
    }

    function upsertNextMechOrder()
    {
      if (nc12Queue.length === 0)
      {
        app.broker.publish('mechOrders.synced', {count: importing});

        module.info(`Imported ${importing} mech orders.`);

        importing = null;

        return res.sendStatus(204);
      }

      const mechOrder = mechOrders[nc12Queue.shift()];

      MechOrder.collection.updateOne({_id: mechOrder._id}, {$set: mechOrder}, {upsert: true}, err =>
      {
        if (err)
        {
          module.warn(err, `Failed to upsert mech order.`, {mechOrder});
        }
        else
        {
          ++importing;
        }

        upsertNextMechOrder();
      });
    }
  }

  function parseTime(time)
  {
    time = parseFloat(time.replace(',', '.'));

    return isNaN(time) || time < 0 ? -1 : time;
  }
};
