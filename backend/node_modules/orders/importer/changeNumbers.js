// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const path = require('path');
const moment = require('moment');
const step = require('h5.step');
const fs = require('fs-extra');
const parseSapTextTable = require('sap/util/parseSapTextTable');
const parseSapDate = require('sap/util/parseSapDate');
const parseSapString = require('sap/util/parseSapString');

exports.DEFAULT_CONFIG = {
  mongooseId: 'mongoose',
  filterRe: /^CHANGE_NUMBERS\.txt$/,
  parsedOutputDir: null
};

exports.models = [
  require('../models/changeNumber')
];

exports.recordTopics = {
  info: ['orders.changeNumbers.synced'],
  error: ['orders.changeNumbers.syncFailed']
};

exports.requiredModules = 'mongoose';

exports.start = (app, module) =>
{
  const {
    ChangeNumber
  } = module;

  const filePathCache = {};
  const queue = [];
  let locked = false;

  app.broker.subscribe('directoryWatcher.changed', queueFile).setFilter(filterFile);

  function filterFile(fileInfo)
  {
    if (filePathCache[fileInfo.filePath] || !module.config.filterRe.test(fileInfo.fileName))
    {
      return false;
    }

    fileInfo.timeKey = createTimeKey(fileInfo.timestamp);

    return true;
  }

  function createTimeKey(timestamp)
  {
    return moment(timestamp).format('YYMMDDHH');
  }

  function queueFile(fileInfo)
  {
    filePathCache[fileInfo.filePath] = true;

    queue.push(fileInfo);

    module.info('Queued...', {key: fileInfo.timeKey});

    setImmediate(importNext);
  }

  function importNext()
  {
    if (locked)
    {
      return;
    }

    const fileInfo = queue.shift();

    if (!fileInfo)
    {
      return;
    }

    locked = true;

    const startTime = Date.now();

    module.info('Importing...', {key: fileInfo.timeKey});

    importFile(fileInfo, function(err, count)
    {
      cleanUpFileInfoFile(fileInfo);

      if (err)
      {
        module.error(err, 'Failed to import.', {key: fileInfo.timeKey});

        app.broker.publish(`${ChangeNumber.TOPIC_PREFIX}.syncFailed`, {
          timestamp: fileInfo.timestamp,
          error: err.message
        });
      }
      else
      {
        module.info('Imported!', {
          key: fileInfo.timeKey,
          count,
          duration: Date.now() - startTime
        });

        app.broker.publish(`${ChangeNumber.TOPIC_PREFIX}.synced`, {
          timestamp: fileInfo.timestamp,
          count
        });
      }

      locked = false;

      setImmediate(importNext);
    });
  }

  function importFile(fileInfo, done)
  {
    step(
      function readFileStep()
      {
        fs.readFile(fileInfo.filePath, {encoding: 'utf8'}, this.next());
      },
      function parseFileStep(err, fileContents)
      {
        if (err)
        {
          return this.skip(err);
        }

        module.info('Parsing...', {key: fileInfo.timeKey, fileSize: fileContents.length});

        const t = Date.now();

        this.changeNumbers = parseChangeNumbersTable(fileContents);

        module.info('Parsed!', {
          key: fileInfo.timeKey,
          count: this.changeNumbers.length,
          duration: Date.now() - t
        });
      },
      function updateStep(err)
      {
        if (err)
        {
          return this.skip(err);
        }

        module.info('Updating...', {key: fileInfo.timeKey});

        const ops = this.changeNumbers.map(cn =>
        {
          return {
            updateOne: {
              filter: {_id: cn._id},
              update: {$set: cn},
              upsert: true
            }
          };
        });

        ChangeNumber.collection.bulkWrite(ops, this.parallel());
      },
      function finalizeStep(err)
      {
        done(err, this.changeNumbers ? this.changeNumbers.length : 0);
      }
    );
  }

  function cleanUpFileInfoFile(fileInfo)
  {
    setTimeout(removeFilePathFromCache, 15000, fileInfo.filePath);

    if (module.config.parsedOutputDir)
    {
      moveFileInfoFile(fileInfo.filePath);
    }
    else
    {
      deleteFileInfoFile(fileInfo.filePath);
    }
  }

  function moveFileInfoFile(oldFilePath)
  {
    const newFilePath = path.join(module.config.parsedOutputDir, path.basename(oldFilePath));

    fs.move(oldFilePath, newFilePath, {overwrite: true}, function(err)
    {
      if (err)
      {
        module.error(err, 'Failed to rename file.', {oldFilePath, newFilePath});
      }
    });
  }

  function deleteFileInfoFile(filePath)
  {
    fs.unlink(filePath, function(err)
    {
      if (err)
      {
        module.error(err, 'Failed to delete file.', {filePath});
      }
    });
  }

  function removeFilePathFromCache(filePath)
  {
    delete filePathCache[filePath];
  }

  function parseChangeNumbersTable(input)
  {
    return parseSapTextTable(input, {
      columnMatchers: {
        _id: /^Change No/,
        authGroup: /^Auth/,
        validFrom: /^Valid F/i,
        createdOn: /^Created on/i,
        createdBy: /^of$/,
        changedOn: /^Changed on/i,
        changedBy: /^of$/,
        description: /^Change.*?Desc/i,
        reason: /^Reason/i
      },
      valueParsers: {
        _id: parseSapString,
        authGroup: parseSapString,
        validFrom: parseSapDate,
        createdOn: parseSapDate,
        createdBy: parseSapString,
        changedOn: parseSapDate,
        changedBy: parseSapString,
        description: parseSapString,
        reason: parseSapString
      },
      itemDecorator: cn =>
      {
        cn.validFrom = new Date(Date.UTC(cn.validFrom.y, cn.validFrom.m - 1, cn.validFrom.d));
        cn.createdOn = new Date(Date.UTC(cn.createdOn.y, cn.createdOn.m - 1, cn.createdOn.d));
        cn.changedOn = cn.changedOn ? new Date(Date.UTC(cn.changedOn.y, cn.changedOn.m - 1, cn.changedOn.d)) : null;

        return cn;
      }
    });
  }
};
