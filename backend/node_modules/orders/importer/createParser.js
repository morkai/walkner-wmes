// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const path = require('path');
const _ = require('lodash');
const step = require('h5.step');
const moment = require('moment');
const fs = require('fs-extra');
const parseOrders = require('./parseOrders');
const parseStatuses = require('./parseStatuses');
const parseOperations = require('./parseOperations');

module.exports = (app, module, callback) =>
{
  const {Order} = module;

  const LATE_DATA_PARSE_DELAY = 15 * 60 * 1000;
  const timeKeyToFileInfoMap = {};
  const filePathCache = {};
  const parseQueue = [];
  const parseDataTimers = {};
  let parseDataLock = false;
  let restarting = false;

  app.broker.subscribe('updater.restarting', () =>
  {
    restarting = true;
  });

  app.broker.subscribe('directoryWatcher.changed', importFile).setFilter(filterFile);

  function filterFile(fileInfo)
  {
    if (filePathCache[fileInfo.filePath])
    {
      return false;
    }

    const matches = fileInfo.fileName.match(module.config.filterRe);

    if (matches === null)
    {
      return false;
    }

    fileInfo.step = parseInt(matches[2], 10) || 0;
    fileInfo.type = /STATUS/i.test(matches[1])
      ? 'STATUSES'
      : /OPER/i.test(matches[1])
        ? 'OPERS'
        : 'ORDERS';
    fileInfo.timeKey = createTimeKey(fileInfo.timestamp, fileInfo.type);

    return true;
  }

  function importFile(fileInfo)
  {
    filePathCache[fileInfo.filePath] = true;

    const timeKey = fileInfo.timeKey;
    let timeKeyFileInfo = timeKeyToFileInfoMap[timeKey];

    if (typeof timeKeyFileInfo === 'undefined')
    {
      timeKeyToFileInfoMap[timeKey] = {
        orders: null,
        operations: null
      };

      timeKeyFileInfo = timeKeyToFileInfoMap[timeKey];
    }

    if (fileInfo.type === 'OPERS')
    {
      timeKeyFileInfo.operations = fileInfo;
    }
    else
    {
      timeKeyFileInfo.orders = fileInfo;
    }

    module.info(`Handling ${fileInfo.type}...`, {key: timeKey});

    if (fileInfo.type !== 'STATUSES' && (timeKeyFileInfo.orders === null || timeKeyFileInfo.operations === null))
    {
      if (typeof parseDataTimers[timeKey] !== 'undefined' && parseDataTimers[timeKey] !== null)
      {
        clearTimeout(parseDataTimers[timeKey]);
      }

      module.info('Delaying...', {
        key: timeKey,
        orders: timeKeyFileInfo.orders !== null,
        operations: timeKeyFileInfo.operations !== null
      });

      parseDataTimers[timeKey] = setTimeout(enqueueAndParse, LATE_DATA_PARSE_DELAY, timeKey, true);

      return;
    }

    enqueueAndParse(timeKey, false);
  }

  function enqueueAndParse(timeKey, delayed)
  {
    if (parseDataTimers[timeKey] !== null)
    {
      clearTimeout(parseDataTimers[timeKey]);
      delete parseDataTimers[timeKey];
    }

    if (delayed)
    {
      module.info('Queued (delayed)...', {key: timeKey});
    }
    else
    {
      module.info('Queued...', {key: timeKey});
    }

    parseQueue.push(timeKey);
    parseData();
  }

  function parseData()
  {
    if (parseDataLock || restarting)
    {
      return;
    }

    const timeKey = parseQueue.shift();

    if (typeof timeKey === 'undefined')
    {
      return;
    }

    const startTime = Date.now();

    module.info('Parsing...', {key: timeKey});

    parseDataLock = true;

    const timeKeyFileInfo = timeKeyToFileInfoMap[timeKey];

    delete timeKeyToFileInfoMap[timeKey];

    parseOrdersAndOperations(timeKeyFileInfo.orders, timeKeyFileInfo.operations, (err, orders, missingOrders) =>
    {
      parseDataLock = false;

      const filePaths = collectFileInfoPaths(timeKeyFileInfo);

      deleteFileInfoStepFiles(filePaths);
      setTimeout(removeFilePathsFromCache, 15000, filePaths);

      if (!err)
      {
        module.info('Parsed!', {key: timeKey, duration: Date.now() - startTime});
      }

      setImmediate(parseData);

      callback(null, orders, missingOrders);
    });
  }

  function parseOrdersAndOperations(ordersFileInfo, operationsFileInfo, done)
  {
    const orders = {};
    const missingOrders = {};

    step(
      function readOrdersFileStep()
      {
        if (ordersFileInfo)
        {
          fs.readFile(ordersFileInfo.filePath, 'utf8', this.next());
        }
        else
        {
          setImmediate(this.next(), null, '');
        }
      },
      function parseOrdersStep(err, ordersFileContents)
      {
        if (err)
        {
          module.error(err, 'Failed to read the orders input file.');
        }
        else if (ordersFileInfo)
        {
          if (ordersFileInfo.type === 'STATUSES')
          {
            parseStatuses(
              ordersFileContents,
              orders,
              ordersFileInfo.timestamp ? new Date(ordersFileInfo.timestamp) : new Date()
            );
          }
          else
          {
            parseOrders(
              ordersFileContents,
              orders,
              ordersFileInfo.timestamp ? new Date(ordersFileInfo.timestamp) : new Date(),
              Order
            );
          }
        }
      },
      function readOperationsFileStep()
      {
        if (operationsFileInfo)
        {
          fs.readFile(operationsFileInfo.filePath, 'utf8', this.next());
        }
        else
        {
          setImmediate(this.next(), null, '');
        }
      },
      function parseOperationsStep(err, operationsFileContents)
      {
        if (err)
        {
          module.error(err, 'Failed to read the operations input file.');
        }
        else if (operationsFileInfo)
        {
          parseOperations(
            operationsFileContents,
            orders,
            missingOrders,
            operationsFileInfo.timestamp ? new Date(operationsFileInfo.timestamp) : new Date()
          );
        }
      },
      function()
      {
        setImmediate(done, null, orders, missingOrders);
      }
    );
  }

  function createTimeKey(timestamp, type)
  {
    return moment(timestamp || Date.now()).format(type === 'STATUSES' ? 'YYYYMMDDHHmm' : 'YYYYMMDDHH');
  }

  function collectFileInfoPaths(timeKeyFileInfo)
  {
    const filePaths = [];

    if (timeKeyFileInfo.orders)
    {
      filePaths.push(timeKeyFileInfo.orders.filePath);
    }

    if (timeKeyFileInfo.operations)
    {
      filePaths.push(timeKeyFileInfo.operations.filePath);
    }

    return filePaths;
  }

  function deleteFileInfoStepFiles(filePaths)
  {
    _.forEach(filePaths, function(filePath)
    {
      if (module.config.parsedOutputDir)
      {
        moveFileInfoStepFile(filePath);
      }
      else
      {
        deleteFileInfoStepFile(filePath);
      }
    });
  }

  function moveFileInfoStepFile(oldFilePath)
  {
    const newFilePath = path.join(module.config.parsedOutputDir, path.basename(oldFilePath));

    fs.move(oldFilePath, newFilePath, {overwrite: true}, function(err)
    {
      if (err)
      {
        module.error(err, 'Failed to rename file.', {oldFilePath, newFilePath});
      }
    });
  }

  function deleteFileInfoStepFile(filePath)
  {
    fs.unlink(filePath, function(err)
    {
      if (err)
      {
        module.error(err, 'Failed to delete file.', {filePath});
      }
    });
  }

  function removeFilePathsFromCache(filePaths)
  {
    _.forEach(filePaths, function(filePath)
    {
      delete filePathCache[filePath];
    });
  }
};
