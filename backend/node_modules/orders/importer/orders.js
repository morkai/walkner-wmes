// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const fs = require('fs');
const _ = require('lodash');
const step = require('h5.step');
const jsonDeepEqual = require('util/jsonDeepEqual');
const createParser = require('./createParser');
const parseOperationTimeCoeffs = require('../parseOperationTimeCoeffs');

exports.DEFAULT_CONFIG = {
  mongooseId: 'mongoose',
  filterRe: /^T_WMES_(ORDERS|OPERS|STATUSES)_([0-9]+)\.txt$/,
  parsedOutputDir: null,
  orderDocumentsFilePathPattern: './{timestamp}@T_COOIS_DOCS.txt'
};

exports.models = [
  require('../models/order'),
  require('../models/orderEtoContinuation'),
  require('../models/orderIntake'),
  require('../models/productTag'),
  require('xiconf/models/xiconfOrder'),
  require('settings/models/setting'),
  require('wh/models/oldWhOrder'),
  require('wh/models/oldWhCancelQueue')
];

exports.recordTopics = {
  info: ['orders.synced']
};

exports.requiredModules = 'mongoose';

exports.start = (app, module) =>
{
  const ORDER_DOCUMENTS_FILE_PATH_PATTERN = module.config.orderDocumentsFilePathPattern;

  const {
    Order,
    OrderEtoContinuation,
    OrderIntake,
    ProductTag,
    XiconfOrder,
    Setting,
    OldWhOrder: WhOrder,
    OldWhCancelQueue: WhCancelQueue
  } = module;

  const queue = [];
  let lock = false;

  createParser(app, module, enqueueAndCompare);

  function enqueueAndCompare(err, orders, missingOrders)
  {
    if (!err && orders && missingOrders && (_.size(orders) || _.size(missingOrders)))
    {
      queue.push(orders, missingOrders);

      compareNext();
    }
  }

  function compareNext()
  {
    if (lock)
    {
      return;
    }

    lock = true;

    const orders = queue.shift();
    const missingOrders = queue.shift();
    const orderIds = Object.keys(orders);
    const missingOrderIds = Object.keys(missingOrders);
    const allOrderIds = orderIds.concat(missingOrderIds);
    const firstOrder = orders[allOrderIds[0]] || missingOrders[allOrderIds[0]];
    const timestamp = firstOrder.importTs;
    const statuses = typeof firstOrder.statusesSetAt === 'undefined' && Array.isArray(firstOrder.statuses);

    if (statuses)
    {
      module.info(`Comparing order statuses...`, {
        orderCount: orderIds.length
      });
    }
    else
    {
      module.info(`Comparing orders and missing orders...`, {
        orderCount: orderIds.length,
        missingOrderCount: missingOrderIds.length
      });
    }

    step(
      function findDelayedOrders()
      {
        this.removeList = [];
        this.mrpToTimeCoeffs = {};

        if (statuses)
        {
          return;
        }

        module.debug('Finding delayed orders...');

        let minStartDate = Number.MAX_SAFE_INTEGER;
        let maxStartDate = Number.MIN_SAFE_INTEGER;

        orderIds.forEach(oId =>
        {
          const order = orders[oId];

          if (order.scheduledStartDate < minStartDate)
          {
            minStartDate = order.scheduledStartDate;
          }

          if (order.scheduledStartDate > maxStartDate)
          {
            maxStartDate = order.scheduledStartDate;
          }
        });

        const conditions = {
          scheduledStartDate: {
            $gte: minStartDate,
            $lte: maxStartDate
          },
          _id: {
            $nin: allOrderIds
          },
          statuses: {
            $nin: ['TECO', 'CNF', 'DLV']
          }
        };

        Order
          .find(conditions)
          .select({_id: 1})
          .lean()
          .exec(this.next());
      },
      function findSettingsStep(err, delayedOrders)
      {
        if (statuses)
        {
          return;
        }

        if (err)
        {
          module.error(err, `Failed to find delayed orders.`);
        }

        this.removeList = (delayedOrders || []).map(o => o._id);

        if (this.removeList.length)
        {
          module.debug('Found delayed orders.', {count: this.removeList.length});
        }

        Setting.findById('orders.operations.timeCoeffs').lean().exec(this.next());
      },
      function updateEtoContinuationStep(err, setting)
      {
        if (statuses)
        {
          return;
        }

        if (err)
        {
          module.error(err, `Failed to find settings.`);
        }

        module.debug('Updating ETO continuations...');

        if (setting)
        {
          this.mrpToTimeCoeffs = parseOperationTimeCoeffs(setting.value);
        }

        updateEtoContinuation(Object.values(orders), this.next());
      },
      function findOrdersStep(err)
      {
        if (err)
        {
          module.error(err, `Failed to update ETO.`);
        }

        module.debug('Finding orders...');

        Order
          .find({_id: {$in: allOrderIds}})
          .select({
            documents: 0,
            notes: 0,
            changes: 0
          })
          .lean()
          .exec(this.next());
      },
      function assignTagsStep(err, orderModels)
      {
        if (err)
        {
          module.error(err, `Failed to find orders.`);

          return this.skip(err);
        }

        if (statuses)
        {
          return setImmediate(this.next(), null, orderModels);
        }

        module.debug('Assigning tags...');

        assignTags(orderModels, orders, this.next());
      },
      function compareOrdersStep(err, orderModels)
      {
        if (err)
        {
          module.error(err, `Failed to assign tags.`);

          return this.skip(err);
        }

        module.debug('Comparing orders...');

        const ts = new Date();

        this.insertList = [];
        this.updateList = [];
        this.ordersWithNewQty = [];
        this.completedOrders = [];
        this.leadingOrders = new Set();

        for (let i = 0; i < orderModels.length; ++i)
        {
          compareOrder(
            statuses,
            ts,
            this.mrpToTimeCoeffs,
            this.updateList,
            orders,
            missingOrders,
            this.ordersWithNewQty,
            this.completedOrders,
            this.leadingOrders,
            orderModels[i]
          );
        }

        if (!statuses)
        {
          createOrdersForInsertion(ts, this.insertList, orders, missingOrders);
        }

        setImmediate(this.next());
      },
      function prepareOrderIntakeSearchStep()
      {
        if (statuses)
        {
          return;
        }

        const intakeKeyToIdMap = {};
        const intakeKeyToOrderMap = {};

        module.debug('Preparing order intake...');

        this.insertList.forEach(order =>
        {
          const salesOrder = order.salesOrder;
          const salesOrderItem = order.salesOrderItem;

          if (!salesOrder || !salesOrderItem)
          {
            return;
          }

          const intakeKey = `${salesOrder}/${salesOrderItem}`;

          intakeKeyToIdMap[intakeKey] = {
            no: salesOrder,
            item: salesOrderItem
          };

          if (intakeKeyToOrderMap[intakeKey])
          {
            intakeKeyToOrderMap[intakeKey].push(order);
          }
          else
          {
            intakeKeyToOrderMap[intakeKey] = [order];
          }
        });

        setImmediate(assignOrderIntakeData, _.values(intakeKeyToIdMap), intakeKeyToOrderMap, this.next());
      },
      function saveOrdersStep()
      {
        module.debug('Saving orders...');

        const createdOrdersCount = this.insertList.length;
        const updatedOrdersCount = this.updateList.length;
        const removedOrdersCount = this.removeList.length;
        const insertBatchCount = Math.ceil(createdOrdersCount / 100);
        const next = this.next();
        const steps = [
          _.partial(removeOrdersStep, this.removeList)
        ];

        for (let i = 0; i < insertBatchCount; ++i)
        {
          steps.push(_.partial(createOrdersStep, this.insertList.splice(0, 100)));
        }

        const ordersWithChangedOperations = [];

        this.updateList.forEach(update =>
        {
          if (update.update.$set.operations)
          {
            ordersWithChangedOperations.push(update.conditions._id);
          }

          steps.push(_.partial(updateOrderStep, update));
        });

        steps.push(function unlockStep(err)
        {
          if (err)
          {
            module.error(`Failed to sync data: ${err.message}`);
          }
          else
          {
            module.info(
              `Created ${createdOrdersCount}, updated ${updatedOrdersCount} and removed ${removedOrdersCount} orders.`
            );

            if (!statuses || updatedOrdersCount)
            {
              app.broker.publish('orders.synced', {
                created: createdOrdersCount,
                updated: updatedOrdersCount,
                removed: removedOrdersCount,
                moduleName: module.name
              });
            }

            if (ordersWithChangedOperations.length)
            {
              app.broker.publish('orders.operationsChanged', {
                orders: ordersWithChangedOperations
              });
            }
          }

          next(err);
        });

        step(steps);
      },
      function(err)
      {
        if (!err)
        {
          setImmediate(updateXiconfOrderQty, timestamp, this.ordersWithNewQty);
          setImmediate(updateCompletedWhOrders, this.completedOrders);
          setImmediate(handleLeadingOrders, this.leadingOrders);
        }

        setImmediate(unlock);
      }
    );
  }

  function unlock()
  {
    lock = false;

    if (queue.length !== 0)
    {
      setImmediate(compareNext);
    }
  }

  function compareOrder(
    statuses,
    ts,
    mrpToTimeCoeffs,
    updateList,
    orders,
    missingOrders,
    ordersWithNewQty,
    completedOrders,
    leadingOrders,
    orderModel
  )
  {
    const orderNo = orderModel._id;

    if (typeof orders[orderNo] === 'object')
    {
      compareOrderWithDoc(
        statuses,
        ts,
        mrpToTimeCoeffs,
        updateList,
        orderModel,
        orders[orderNo],
        ordersWithNewQty,
        completedOrders,
        leadingOrders
      );

      delete orders[orderNo];
    }
    else if (typeof missingOrders[orderNo] === 'object')
    {
      compareMissingOrderWithDoc(ts, mrpToTimeCoeffs, updateList, orderModel, missingOrders[orderNo]);

      delete missingOrders[orderNo];
    }
  }

  function compareOrderWithDoc(
    statuses,
    ts,
    mrpToTimeCoeffs,
    updateList,
    orderModel,
    newOrderData,
    ordersWithNewQty,
    completedOrders,
    leadingOrders
  )
  {
    if (!statuses && orderModel.importTs > newOrderData.importTs)
    {
      return;
    }

    const changes = {
      time: newOrderData.importTs,
      user: null,
      oldValues: {},
      newValues: {},
      comment: '',
      source: 'system'
    };
    const $set = {
      updatedAt: ts,
      importTs: newOrderData.importTs
    };
    let different = false;

    if (newOrderData.operations)
    {
      adjustOperationTimes(newOrderData.operations, mrpToTimeCoeffs[newOrderData.mrp]);
    }

    _.forEach(newOrderData, function(newValue, key)
    {
      if (Order.IGNORED_IMPORT_PROPS[key])
      {
        return;
      }

      if (key === 'operations' && _.isEmpty(newValue))
      {
        return;
      }

      let oldValue = orderModel[key];

      if (oldValue != null && typeof oldValue.toObject === 'function')
      {
        oldValue = oldValue.toObject();
      }

      if (compareOrderProperty(key, oldValue, newValue))
      {
        different = true;
        $set[key] = newValue;
        changes.oldValues[key] = oldValue;
        changes.newValues[key] = newValue;
      }
    });

    if (different)
    {
      updateList.push({
        conditions: {_id: orderModel._id},
        update: {
          $set: Order.prepareForUpdate(orderModel, newOrderData, ts, changes, $set),
          $push: {changes}
        }
      });

      if (changes.newValues.qty)
      {
        ordersWithNewQty.push(orderModel._id);
      }

      if (changes.newValues.statuses)
      {
        const oldStatus = _.intersection(changes.oldValues.statuses, Order.COMPLETED_STATUSES);
        const newStatus = _.intersection(changes.newValues.statuses, Order.COMPLETED_STATUSES);

        if (newStatus.length && _.intersection(oldStatus, newStatus).length === 0)
        {
          completedOrders.push(orderModel._id);
        }
      }

      if (changes.oldValues.leadingOrder)
      {
        leadingOrders.add(changes.oldValues.leadingOrder);
      }

      if (changes.newValues.leadingOrder)
      {
        leadingOrders.add(changes.newValues.leadingOrder);
      }
    }
  }

  function compareOrderProperty(property, oldValue, newValue)
  {
    return !jsonDeepEqual(oldValue, newValue);
  }

  function compareMissingOrderWithDoc(ts, mrpToTimeCoeffs, updateList, orderModel, missingOrder)
  {
    if (orderModel.importTs > missingOrder.importTs)
    {
      return;
    }

    adjustOperationTimes(missingOrder.operations, mrpToTimeCoeffs[orderModel.mrp]);

    let oldOperations = orderModel.operations;

    if (!Array.isArray(oldOperations))
    {
      oldOperations = [];
    }

    if (jsonDeepEqual(oldOperations, missingOrder.operations))
    {
      return;
    }

    updateList.push({
      conditions: {_id: orderModel._id},
      update: {
        $set: {
          updatedAt: ts,
          operations: missingOrder.operations,
          importTs: missingOrder.importTs
        },
        $push: {
          changes: {
            time: ts,
            user: null,
            oldValues: {operations: oldOperations},
            newValues: {operations: missingOrder.operations},
            comment: '',
            source: 'system'
          }
        }
      }
    });
  }

  function adjustOperationTimes(operations, timeCoeffs)
  {
    if (!operations || !timeCoeffs)
    {
      return;
    }

    const laborCoeff = timeCoeffs.labor || 1;
    const laborSetupCoeff = timeCoeffs.laborSetup || 1;
    const machineCoeff = timeCoeffs.machine || 1;
    const machineSetupCoeff = timeCoeffs.machineSetup || 1;

    _.forEach(operations, function(operation)
    {
      operation.laborTime = Math.round(operation.laborTime * laborCoeff * 1000) / 1000;
      operation.laborSetupTime = Math.round(operation.laborSetupTime * laborSetupCoeff * 1000) / 1000;
      operation.machineTime = Math.round(operation.machineTime * machineCoeff * 1000) / 1000;
      operation.machineSetupTime = Math.round(operation.machineSetupTime * machineSetupCoeff * 1000) / 1000;
    });
  }

  function createOrdersForInsertion(ts, insertList, orders, missingOrders)
  {
    _.forEach(orders, function(order)
    {
      insertList.push(Order.prepareForInsert(order, ts));
    });

    _.forEach(missingOrders, function(missingOrder)
    {
      insertList.push(Order.createMissingForInsert(missingOrder, ts));
    });
  }

  function assignOrderIntakeData(intakeIds, intakeKeyToOrderMap, done)
  {
    step(
      function findOrderIntakesStep()
      {
        if (!intakeIds.length)
        {
          return this.skip();
        }

        OrderIntake.collection.find({_id: {$in: intakeIds}}).toArray(this.next());
      },
      function assignOrderIntakeDataStep(err, orderIntakes)
      {
        if (err)
        {
          module.error(`Failed to find order intakes: ${err.message}`);

          return this.skip();
        }

        if (orderIntakes.length !== intakeIds.length)
        {
          module.info(`Found only ${orderIntakes.length} of ${intakeIds.length} Order Intakes!`);
        }

        orderIntakes.forEach(orderIntake =>
        {
          intakeKeyToOrderMap[`${orderIntake._id.no}/${orderIntake._id.item}`].forEach(order =>
          {
            Order.copyOrderIntake(order, orderIntake);
          });
        });
      },
      function()
      {
        setImmediate(done);
      }
    );
  }

  function removeOrdersStep(orderIds, err)
  {
    if (err)
    {
      return this.skip(err);
    }

    if (orderIds.length)
    {
      Order.collection.deleteMany({_id: {$in: orderIds}}, this.next());
    }
  }

  function createOrdersStep(orders, err)
  {
    if (err)
    {
      return this.skip(err);
    }

    Order.collection.insertMany(orders, this.next());
  }

  function updateOrderStep(update, err)
  {
    if (err)
    {
      return this.skip(err);
    }

    Order.collection.updateOne(update.conditions, update.update, this.next());
  }

  function updateXiconfOrderQty(timestamp, ordersWithNewQty)
  {
    if (ordersWithNewQty.length === 0)
    {
      return;
    }

    step(
      function()
      {
        XiconfOrder
          .find({_id: {$in: ordersWithNewQty}, 'items.source': 'docs'})
          .lean()
          .exec(this.next());
      },
      function(err, xiconfOrders)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (xiconfOrders.length === 0)
        {
          return this.skip();
        }

        Order
          .find({_id: {$in: _.map(xiconfOrders, '_id')}}, {documents: 1})
          .lean()
          .exec(this.next());
      },
      function(err, orders)
      {
        if (err)
        {
          return this.skip(err);
        }

        const filePath = ORDER_DOCUMENTS_FILE_PATH_PATTERN.replace('{timestamp}', String(Math.ceil(timestamp / 1000)));
        const fileContents = [
          '-------------------------------------------------------------------------',
          '|Order    |Item|Document       |Description                             |',
          '-------------------------------------------------------------------------'
        ];

        for (let i = 0; i < orders.length; ++i)
        {
          const order = orders[i];
          const documents = order.documents;

          if (!documents)
          {
            continue;
          }

          for (let ii = 0; ii < documents.length; ++ii)
          {
            const document = documents[ii];
            const row = [
              '',
              order._id,
              document.item,
              document.nc15,
              _.padEnd(document.name, 40, ' '),
              ''
            ];

            fileContents.push(row.join('|'));
          }
        }

        fileContents.push(fileContents[0]);

        fs.writeFile(filePath, fileContents.join('\r\n'), this.next());
      },
      function(err)
      {
        if (err)
        {
          module.error(`Failed to update quantities of XiconfOrders: ${err.message}`);
        }
      }
    );
  }

  function updateEtoContinuation(orders, done)
  {
    const etoMap = new Map();
    const timeMap = new Map();

    orders.forEach(order =>
    {
      const time = order.scheduledStartDate.getTime();

      if (!timeMap.has(time))
      {
        timeMap.set(time, []);
      }

      timeMap.get(time).push(order);

      if (order.priority === 'E')
      {
        if (!etoMap.has(order.nc12) || time < etoMap.get(order.nc12))
        {
          etoMap.set(order.nc12, order.scheduledStartDate);
        }
      }
    });

    step(
      function()
      {
        const newEtoContinuations = Array.from(etoMap.keys()).map(nc12 => ({
          _id: nc12,
          firstAt: etoMap.get(nc12),
          continuedAt: null
        }));

        if (newEtoContinuations.length)
        {
          OrderEtoContinuation.collection.insertMany(newEtoContinuations, {ordered: false}, this.next());
        }
      },
      function(err)
      {
        if (err && err.code !== 11000)
        {
          return this.skip(err);
        }

        updateNextEtoContinuation(Array.from(timeMap.keys()).sort(), timeMap, this.next());
      },
      done
    );
  }

  function updateNextEtoContinuation(queue, timeMap, done)
  {
    if (queue.length === 0)
    {
      return done();
    }

    const time = queue.shift();
    const date = new Date(time);
    const orders = timeMap.get(time);
    const ncMap = new Map();

    orders.forEach(order =>
    {
      if (!ncMap.has(order.nc12))
      {
        ncMap.set(order.nc12, []);
      }

      ncMap.get(order.nc12).push(order);
    });

    const conditions = {
      _id: Array.from(ncMap.keys()),
      firstAt: {$lt: date}
    };

    OrderEtoContinuation.find(conditions).lean().exec((err, continuations) =>
    {
      if (err)
      {
        return done(err);
      }

      const continued = [];

      continuations.forEach(continuation =>
      {
        const etoCont = continuation.continuedAt === null || continuation.continuedAt.getTime() === time;

        ncMap.get(continuation._id).forEach(order =>
        {
          order.etoCont = order.priority !== 'E' && etoCont;
        });

        if (continuation.continuedAt === null)
        {
          continued.push(continuation._id);
        }
      });

      if (!continued.length)
      {
        return updateNextEtoContinuation(queue, timeMap, done);
      }

      OrderEtoContinuation.collection.updateMany(
        {_id: {$in: continued}},
        {$set: {continuedAt: date}},
        err =>
        {
          if (err)
          {
            done(err);
          }
          else
          {
            updateNextEtoContinuation(queue, timeMap, done);
          }
        }
      );
    });
  }

  async function assignTags(oldOrderList, newOrderMap, done)
  {
    try
    {
      const productTags = await ProductTag.find({}).lean().exec();

      productTags.forEach(productTag =>
      {
        productTag.match = ProductTag.createMatcher(productTag.conditions);
      });

      oldOrderList.forEach(oldOrder =>
      {
        if (!oldOrder.tags)
        {
          oldOrder.tags = [];
        }

        const newOrder = newOrderMap[oldOrder._id];

        if (!newOrder)
        {
          return;
        }

        const bom = new Set();

        oldOrder.bom.forEach(component =>
        {
          if (component.nc12)
          {
            bom.add(component.nc12);
          }
        });

        productTags.forEach(productTag =>
        {
          if (productTag.match(newOrder, bom))
          {
            newOrder.tags.push({
              _id: productTag._id,
              label: productTag.label
            });
          }
        });

        newOrder.tags.sort((a, b) => a._id.localeCompare(b._id, undefined, {numeric: true, ignorePunctuation: true}));
      });
    }
    catch (err)
    {
      return done(err);
    }

    done(null, oldOrderList);
  }

  async function updateCompletedWhOrders(completedOrders)
  {
    if (!completedOrders.length)
    {
      return;
    }

    try
    {
      const whOrders = await WhOrder
        .find({order: {$in: completedOrders}})
        .select({_id: 0, order: 1})
        .lean()
        .exec();

      if (!whOrders.length)
      {
        return;
      }

      const cancelQueue = whOrders.map(o => ({_id: o.order}));

      module.debug('Scheduling WH orders for cancellation...', {cancelQueue});

      await WhCancelQueue.collection.insertMany(cancelQueue);

      app.broker.publish('old.wh.cancelQueue.updated', {
        added: cancelQueue
      });
    }
    catch (err)
    {
      if (err.code !== 11000)
      {
        module.error(err, 'Failed to schedule WH orders for cancellation.');
      }
    }
  }

  function handleLeadingOrders(leadingOrders)
  {
    if (leadingOrders.size)
    {
      leadingOrders = Array.from(leadingOrders);

      module.debug('Leading orders changed.', {leadingOrders});

      app.broker.publish('orders.leadingOrdersChanged', {leadingOrders});
    }
  }
};
