// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const path = require('path');
const moment = require('moment');
const step = require('h5.step');
const fs = require('fs-extra');
const parseOrderZlf1 = require('sapGui/util/parseOrderZlf1');

exports.DEFAULT_CONFIG = {
  mongooseId: 'mongoose',
  filterRe: /^(T_ZLF1\.json|[0-9]{9}\.DAT)$/,
  parsedOutputDir: null
};

exports.models = [
  require('orders/models/orderZlf1')
];

exports.recordTopics = {
  info: ['orders.zlf1.synced'],
  error: ['orders.zlf1.syncFailed']
};

exports.start = (app, module) =>
{
  const {OrderZlf1} = module;

  const filePathCache = {};
  let locked = false;
  const queue = [];

  app.broker.subscribe('directoryWatcher.changed', queueFile).setFilter(filterFile);

  function filterFile(fileInfo)
  {
    if (filePathCache[fileInfo.filePath] || !module.config.filterRe.test(fileInfo.fileName))
    {
      return false;
    }

    fileInfo.timeKey = createTimeKey(fileInfo.timestamp);

    return true;
  }

  function createTimeKey(timestamp)
  {
    return moment(timestamp).format('YYMMDDHH');
  }

  function queueFile(fileInfo)
  {
    filePathCache[fileInfo.filePath] = true;

    queue.push(fileInfo);

    module.info('Queued...', {fileInfo});

    setImmediate(importNext);
  }

  function importNext()
  {
    if (locked)
    {
      return;
    }

    const fileInfo = queue.shift();

    if (!fileInfo)
    {
      return;
    }

    locked = true;

    const startTime = Date.now();

    module.info('Importing...', {fileInfo});

    importFile(fileInfo, (err, count) =>
    {
      cleanUpFileInfoFile(fileInfo);

      if (err)
      {
        module.error(err, 'Failed to import.', {fileInfo});

        app.broker.publish('orders.zlf1.syncFailed', {
          timestamp: fileInfo.timestamp,
          error: err.message
        });
      }
      else
      {
        module.info('Imported.', {fileInfo, count, duration: Date.now() - startTime});

        app.broker.publish('orders.zlf1.synced', {
          timestamp: fileInfo.timestamp,
          count: count
        });
      }

      locked = false;

      setImmediate(importNext);
    });
  }

  function importFile(fileInfo, done)
  {
    step(
      function readFileStep()
      {
        fs.readFile(fileInfo.filePath, {encoding: 'utf8'}, this.next());
      },
      function parseFileStep(err, fileContents)
      {
        if (err)
        {
          return this.skip(err);
        }

        module.info('Parsing...', {fileInfo, fileSize: fileContents.length});

        const t = Date.now();

        try
        {
          if (/\.dat$/i.test(fileInfo.filePath))
          {
            this.orders = [parseOrderZlf1(fileContents)];
          }
          else
          {
            this.orders = JSON.parse(fileContents);
          }

          if (!Array.isArray(this.orders))
          {
            throw new Error('Expected an array.');
          }
        }
        catch (err)
        {
          this.orders = [];

          return this.skip(err);
        }

        module.info('Parsed!', {fileInfo, count: this.orders.length, duration: Date.now() - t});

        setImmediate(this.next());
      },
      function upsertOrdersStep()
      {
        if (this.orders.length === 0)
        {
          return this.skip();
        }

        module.info('Upserting orders...', {fileInfo});

        const t = Date.now();

        upsertNextOrderBatch(this.orders, 0, 20, this.next());

        function upsertNextOrderBatch(orders, batchNo, batchSize, done)
        {
          const startIndex = batchNo * batchSize;
          const endIndex = Math.min(startIndex + batchSize, orders.length);

          step(
            function()
            {
              for (let i = startIndex; i < endIndex; ++i)
              {
                const orderZlf1 = OrderZlf1.prepareForInsert(orders[i], t);

                if (!orderZlf1._id)
                {
                  continue;
                }

                OrderZlf1.replaceOne(
                  {_id: orderZlf1._id},
                  orderZlf1,
                  {upsert: true},
                  this.group()
                );
              }
            },
            function(err)
            {
              if (err)
              {
                module.error(err, 'Failed to upsert order.');
              }

              if (endIndex === orders.length)
              {
                module.info('Upserted!', {fileInfo, count: orders.length, duration: Date.now() - t});

                return done();
              }

              setImmediate(upsertNextOrderBatch, orders, batchNo + 1, batchSize, done);
            }
          );
        }
      },
      function finalizeStep(err)
      {
        return done(err, this.orders.length);
      }
    );
  }

  function cleanUpFileInfoFile(fileInfo)
  {
    setTimeout(removeFilePathFromCache, 15000, fileInfo.filePath);

    if (module.config.parsedOutputDir)
    {
      moveFileInfoFile(fileInfo.filePath);
    }
    else
    {
      deleteFileInfoFile(fileInfo.filePath);
    }
  }

  function moveFileInfoFile(oldFilePath)
  {
    const newFilePath = path.join(module.config.parsedOutputDir, path.basename(oldFilePath));

    fs.move(oldFilePath, newFilePath, {overwrite: true}, err =>
    {
      if (err)
      {
        module.error(err, 'Failed to rename file.', {oldFilePath, newFilePath});
      }
    });
  }

  function deleteFileInfoFile(filePath)
  {
    fs.unlink(filePath, err =>
    {
      if (err)
      {
        module.error(err, 'Failed to delete file.', {filePath});
      }
    });
  }

  function removeFilePathFromCache(filePath)
  {
    delete filePathCache[filePath];
  }
};
