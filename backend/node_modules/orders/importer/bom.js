// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const path = require('path');
const moment = require('moment');
const step = require('h5.step');
const deepEqual = require('deep-equal');
const fs = require('fs-extra');
const parseSapTextTable = require('sap/util/parseSapTextTable');
const parseSapNumber = require('sap/util/parseSapNumber');
const parseSapString = require('sap/util/parseSapString');

exports.DEFAULT_CONFIG = {
  mongooseId: 'mongoose',
  filterRe: /^T_COOIS_BOM\.txt$/,
  parsedOutputDir: null
};

exports.models = [
  require('../models/order'),
  require('../models/component')
];

exports.recordTopics = {
  info: ['orders.bom.synced'],
  error: ['orders.bom.syncFailed']
};

exports.start = function startOrderBomImporterModule(app, module)
{
  const mongoose = app[module.config.mongooseId];

  if (!mongoose)
  {
    throw new Error('orders/importer/bom module requires the mongoose module!');
  }

  const Order = mongoose.model('Order');
  const Component = mongoose.model('Component');

  const filePathCache = {};
  let locked = false;
  const queue = [];

  app.broker.subscribe('directoryWatcher.changed', queueFile).setFilter(filterFile);

  function filterFile(fileInfo)
  {
    if (filePathCache[fileInfo.filePath] || !module.config.filterRe.test(fileInfo.fileName))
    {
      return false;
    }

    fileInfo.timeKey = createTimeKey(fileInfo.timestamp);

    return true;
  }

  function createTimeKey(timestamp)
  {
    return moment(timestamp).format('YYMMDDHH');
  }

  function queueFile(fileInfo)
  {
    filePathCache[fileInfo.filePath] = true;

    queue.push(fileInfo);

    module.info('Queued...', {key: fileInfo.timeKey});

    setImmediate(importNext);
  }

  function importNext()
  {
    if (locked)
    {
      return;
    }

    const fileInfo = queue.shift();

    if (!fileInfo)
    {
      return;
    }

    locked = true;

    const startTime = Date.now();

    module.info('Importing...', {key: fileInfo.timeKey});

    importFile(fileInfo, function(err, count)
    {
      cleanUpFileInfoFile(fileInfo);

      if (err)
      {
        module.error(err, 'Failed to import.', {key: fileInfo.timeKey});

        app.broker.publish('orders.bom.syncFailed', {
          timestamp: fileInfo.timestamp,
          error: err.message
        });
      }
      else
      {
        module.info('Imported!', {key: fileInfo.timeKey, count, duration: Date.now() - startTime});

        app.broker.publish('orders.bom.synced', {
          timestamp: fileInfo.timestamp,
          count: count
        });
      }

      locked = false;

      setImmediate(importNext);
    });
  }

  function importFile(fileInfo, done)
  {
    step(
      function readFileStep()
      {
        fs.readFile(fileInfo.filePath, {encoding: 'utf8'}, this.next());
      },
      function parseFileStep(err, fileContents)
      {
        if (err)
        {
          return this.skip(err);
        }

        module.info('Parsing...', {key: fileInfo.timeKey, fileSize: fileContents.length});

        const bom = {};
        const components = {};
        const t = Date.now();

        this.count = parseOrderBomTable(fileContents, bom, components);

        module.info('Parsed!', {
          key: fileInfo.timeKey,
          count: this.count,
          duration: Date.now() - t
        });

        setImmediate(this.parallel(), null, bom);
        setImmediate(this.parallel(), null, components);
      },
      function updateOrdersStep(noop, bom, components)
      {
        module.info('Updating orders...', {key: fileInfo.timeKey});

        updateNextOrder(fileInfo, new Date(), Object.keys(bom), bom, this.parallel());
        updateComponents(components, this.parallel());
      },
      function finalizeStep(err)
      {
        return done(err, this.count);
      }
    );
  }

  function updateNextOrder(fileInfo, t, orderNos, bom, done)
  {
    const orderNo = orderNos.shift();
    const newBom = bom[orderNo];
    let oldBom = null;

    delete bom[orderNo];

    step(
      function findOldBomStep()
      {
        Order.findById(orderNo, {bom: 1}).lean().exec(this.next());
      },
      function compareBomStep(err, order)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!order)
        {
          return this.skip();
        }

        oldBom = order.bom || [];

        if (deepEqual(newBom, oldBom))
        {
          return this.skip();
        }

        setImmediate(this.next());
      },
      function updateOrderStep()
      {
        const changes = {
          time: t,
          user: null,
          oldValues: {bom: oldBom},
          newValues: {bom: newBom},
          comment: ''
        };
        const $set = {
          bom: newBom,
          updatedAt: t
        };

        Order.updateOne({_id: orderNo}, {$set: $set, $push: {changes: changes}}, this.next());
      },
      function finalizeStep(err)
      {
        if (err)
        {
          module.error(err, 'Failed update BOM.', {key: fileInfo.timeKey, orderNo});
        }

        if (orderNos.length)
        {
          setImmediate(updateNextOrder, fileInfo, t, orderNos, bom, done);
        }
        else
        {
          setImmediate(done);
        }
      }
    );
  }

  function updateComponents(map, done)
  {
    const list = [];

    Object.keys(map).forEach(nc12 => list.push({
      _id: nc12,
      name: map[nc12]
    }));

    if (!list.length)
    {
      return done();
    }

    Component.insertMany(list, {ordered: false}, (err) =>
    {
      if (err && err.code !== 11000)
      {
        return done(err);
      }

      done();
    });
  }

  function cleanUpFileInfoFile(fileInfo)
  {
    setTimeout(removeFilePathFromCache, 15000, fileInfo.filePath);

    if (module.config.parsedOutputDir)
    {
      moveFileInfoFile(fileInfo.filePath);
    }
    else
    {
      deleteFileInfoFile(fileInfo.filePath);
    }
  }

  function moveFileInfoFile(oldFilePath)
  {
    const newFilePath = path.join(module.config.parsedOutputDir, path.basename(oldFilePath));

    fs.move(oldFilePath, newFilePath, {overwrite: true}, function(err)
    {
      if (err)
      {
        module.error(err, 'Failed to rename file.', {oldFilePath, newFilePath});
      }
    });
  }

  function deleteFileInfoFile(filePath)
  {
    fs.unlink(filePath, function(err)
    {
      if (err)
      {
        module.error(err, 'Failed to delete file.', {filePath});
      }
    });
  }

  function removeFilePathFromCache(filePath)
  {
    delete filePathCache[filePath];
  }

  function parseOrderBomTable(input, bom, components)
  {
    let count = 0;

    parseSapTextTable(input, {
      columnMatchers: {
        orderNo: /^Order$/,
        nc12: /^Material$/,
        item: /^BOM item$/,
        qty: /^Req.*?qty$/,
        unit: /^Unit$/,
        description: /^Material Desc/,
        unloadingPoint: /^Unl.*?Point/,
        supplyArea: /^Sup.*?Area/
      },
      valueParsers: {
        nc12: function(input) { return input.replace(/^0+/, ''); },
        qty: parseSapNumber,
        description: parseSapString,
        unloadingPoint: parseSapString,
        supplyArea: parseSapString
      },
      itemDecorator: function(obj)
      {
        ++count;

        components[obj.nc12] = obj.description;

        if (!bom[obj.orderNo])
        {
          bom[obj.orderNo] = [];
        }

        bom[obj.orderNo].push({
          nc12: obj.nc12,
          item: obj.item,
          qty: obj.qty,
          unit: obj.unit,
          name: obj.description,
          unloadingPoint: obj.unloadingPoint,
          supplyArea: obj.supplyArea
        });
      }
    });

    return count;
  }
};
