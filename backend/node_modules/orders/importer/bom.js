// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const path = require('path');
const moment = require('moment');
const step = require('h5.step');
const fs = require('fs-extra');
const jsonDeepEqual = require('util/jsonDeepEqual');
const parseSapTextTable = require('sap/util/parseSapTextTable');
const parseSapNumber = require('sap/util/parseSapNumber');
const parseSapString = require('sap/util/parseSapString');

exports.DEFAULT_CONFIG = {
  mongooseId: 'mongoose',
  filterRe: /^T_COOIS_BOM\.txt$/,
  parsedOutputDir: null,
  xiconfFilePathPattern: './{timestamp}@T_COOIS_XICONF.txt'
};

exports.models = [
  require('../models/order'),
  require('../models/component'),
  require('settings/models/setting'),
  require('xiconf/models/xiconfOrder'),
  require('wmes-compRel/models/compRelEntry')
];

exports.recordTopics = {
  info: ['orders.bom.synced'],
  error: ['orders.bom.syncFailed']
};

exports.requiredModules = 'mongoose';

exports.start = (app, module) =>
{
  const {
    Order,
    Component,
    Setting,
    CompRelEntry
  } = module;

  const filePathCache = {};
  const queue = [];
  let locked = false;

  app.broker.subscribe('directoryWatcher.changed', queueFile).setFilter(filterFile);

  function filterFile(fileInfo)
  {
    if (filePathCache[fileInfo.filePath] || !module.config.filterRe.test(fileInfo.fileName))
    {
      return false;
    }

    fileInfo.timeKey = createTimeKey(fileInfo.timestamp);

    return true;
  }

  function createTimeKey(timestamp)
  {
    return moment(timestamp).format('YYMMDDHH');
  }

  function queueFile(fileInfo)
  {
    filePathCache[fileInfo.filePath] = true;

    queue.push(fileInfo);

    module.info('Queued...', {key: fileInfo.timeKey});

    setImmediate(importNext);
  }

  function importNext()
  {
    if (locked)
    {
      return;
    }

    const fileInfo = queue.shift();

    if (!fileInfo)
    {
      return;
    }

    locked = true;

    const startTime = Date.now();

    module.info('Importing...', {key: fileInfo.timeKey});

    importFile(fileInfo, function(err, count)
    {
      cleanUpFileInfoFile(fileInfo);

      if (err)
      {
        module.error(err, 'Failed to import.', {key: fileInfo.timeKey});

        app.broker.publish('orders.bom.syncFailed', {
          timestamp: fileInfo.timestamp,
          error: err.message
        });
      }
      else
      {
        module.info('Imported!', {key: fileInfo.timeKey, count, duration: Date.now() - startTime});

        app.broker.publish('orders.bom.synced', {
          timestamp: fileInfo.timestamp,
          count: count
        });
      }

      locked = false;

      setImmediate(importNext);
    });
  }

  function importFile(fileInfo, done)
  {
    step(
      function readFileStep()
      {
        fs.readFile(fileInfo.filePath, {encoding: 'utf8'}, this.next());
      },
      function parseFileStep(err, fileContents)
      {
        if (err)
        {
          return this.skip(err);
        }

        module.info('Parsing...', {key: fileInfo.timeKey, fileSize: fileContents.length});

        const bom = {};
        const components = {};
        const t = Date.now();

        this.count = parseOrderBomTable(fileContents, bom, components);

        module.info('Parsed!', {
          key: fileInfo.timeKey,
          count: this.count,
          duration: Date.now() - t
        });

        setImmediate(this.parallel(), null, bom);
        setImmediate(this.parallel(), null, components);

        Setting.findById('xiconf.importer.componentPatterns').lean().exec(this.parallel());
      },
      function updateOrdersStep(err, bom, components, componentPatterns)
      {
        if (err)
        {
          return this.skip(err);
        }

        module.info('Updating orders...', {key: fileInfo.timeKey});

        const xiconfItems = {};
        const changedOrders = new Map();

        setImmediate(this.parallel(), null, xiconfItems);
        setImmediate(this.parallel(), null, changedOrders);

        updateNextOrder({
          fileInfo,
          time: new Date(),
          remaining: Object.keys(bom),
          bom,
          xiconfItems,
          xiconfPatterns: parseXiconfPatterns(componentPatterns),
          changedOrders
        }, this.parallel());

        updateComponents(components, this.parallel());
      },
      function(err, orderToXiconfItems, changedOrders)
      {
        if (err)
        {
          return this.skip(err);
        }

        buildXiconfItemsDumpFile(fileInfo.timestamp, orderToXiconfItems, this.parallel());

        if (changedOrders.size)
        {
          updateCompRelValidity(changedOrders, this.parallel());
        }
      },
      function finalizeStep(err)
      {
        return done(err, this.count);
      }
    );
  }

  function updateNextOrder(options, done)
  {
    const orderNo = options.remaining.shift();
    const newBom = options.bom[orderNo];
    let oldBom = null;

    delete options.bom[orderNo];

    step(
      function findOldBomStep()
      {
        Order
          .findById(orderNo)
          .select({
            mrp: 1,
            scheduledStartDate: 1,
            bom: 1
          })
          .lean()
          .exec(this.next());
      },
      function compareBomStep(err, order)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!order)
        {
          return this.skip();
        }

        const components = new Set();

        newBom.forEach(component =>
        {
          components.add(component.nc12);

          matchXiconfComponent(order, component, options.xiconfItems, options.xiconfPatterns);
        });

        oldBom = order.bom || [];

        if (jsonDeepEqual(newBom, oldBom))
        {
          return this.skip();
        }

        options.changedOrders.set(order._id, components);
      },
      function updateOrderStep()
      {
        const changes = {
          time: options.time,
          user: null,
          oldValues: {bom: oldBom},
          newValues: {bom: newBom},
          comment: ''
        };
        const $set = {
          bom: newBom,
          updatedAt: options.time
        };

        Order.updateOne({_id: orderNo}, {$set, $push: {changes}}, this.next());
      },
      function finalizeStep(err)
      {
        if (err)
        {
          module.error(err, 'Failed update BOM.', {key: options.fileInfo.timeKey, orderNo});
        }

        if (options.remaining.length)
        {
          updateNextOrder(options, done);
        }
        else
        {
          done();
        }
      }
    );
  }

  function updateComponents(map, done)
  {
    const list = Object.keys(map).map(nc12 => ({
      _id: nc12,
      name: map[nc12]
    }));

    if (!list.length)
    {
      return done();
    }

    Component.insertMany(list, {ordered: false}, (err) =>
    {
      if (err && err.code !== 11000)
      {
        return done(err);
      }

      done();
    });
  }

  function cleanUpFileInfoFile(fileInfo)
  {
    setTimeout(removeFilePathFromCache, 15000, fileInfo.filePath);

    if (module.config.parsedOutputDir)
    {
      moveFileInfoFile(fileInfo.filePath);
    }
    else
    {
      deleteFileInfoFile(fileInfo.filePath);
    }
  }

  function moveFileInfoFile(oldFilePath)
  {
    const newFilePath = path.join(module.config.parsedOutputDir, path.basename(oldFilePath));

    fs.move(oldFilePath, newFilePath, {overwrite: true}, function(err)
    {
      if (err)
      {
        module.error(err, 'Failed to rename file.', {oldFilePath, newFilePath});
      }
    });
  }

  function deleteFileInfoFile(filePath)
  {
    fs.unlink(filePath, function(err)
    {
      if (err)
      {
        module.error(err, 'Failed to delete file.', {filePath});
      }
    });
  }

  function removeFilePathFromCache(filePath)
  {
    delete filePathCache[filePath];
  }

  function parseOrderBomTable(input, bom, components)
  {
    let count = 0;

    parseSapTextTable(input, {
      columnMatchers: {
        orderNo: /^Order$/,
        nc12: /^Material$/,
        item: /^BOM item$/,
        qty: /^Req.*?qty$/,
        unit: /^Unit$/,
        description: /^Material Desc/,
        unloadingPoint: /^Unl.*?Point/,
        supplyArea: /^Sup.*?Area/
      },
      valueParsers: {
        nc12: input => input.replace(/^0+/, ''),
        qty: parseSapNumber,
        description: parseSapString,
        unloadingPoint: parseSapString,
        supplyArea: parseSapString
      },
      itemDecorator: obj =>
      {
        ++count;

        if (obj.nc12.length > 0 && obj.nc12.length < 12)
        {
          obj.nc12 = obj.nc12.padStart(12, '0');
        }

        components[obj.nc12] = obj.description;

        if (!bom[obj.orderNo])
        {
          bom[obj.orderNo] = [];
        }

        bom[obj.orderNo].push({
          nc12: obj.nc12,
          item: obj.item,
          qty: obj.qty,
          unit: obj.unit,
          name: obj.description,
          unloadingPoint: obj.unloadingPoint,
          supplyArea: obj.supplyArea
        });
      }
    });

    return count;
  }

  function parseXiconfPatterns(setting)
  {
    if (!setting || typeof setting.value !== 'string')
    {
      setting.value = '';
    }

    const patterns = {
      nc12: {
        include: {},
        exclude: {}
      },
      name: {
        include: [],
        exclude: []
      }
    };

    setting.value.split('\n').forEach(line =>
    {
      line = line.trim();

      if (!line.length)
      {
        return;
      }

      const type = line.startsWith('-') ? 'exclude' : 'include';
      let mrps = [];

      if (line.startsWith('-') || line.startsWith('+'))
      {
        line = line.substring(1);
      }

      if (line.includes(' @ '))
      {
        const parts = line.split(' @ ');

        line = parts[0];
        mrps = (parts[1] || '').split(',').map(v => v.trim()).filter(v => !!v.length);
      }

      if (/^[0-9]{12}$/.test(line))
      {
        patterns.nc12[type][line] = mrps;

        return;
      }

      try
      {
        const pattern = line.startsWith('/') && line.endsWith('/')
          ? line.substring(1, -1)
          : `^${line.replace(/\*+/g, '.*?')}$`;

        patterns.name[type].push({
          re: new RegExp(pattern, 'i'),
          mrps
        });
      }
      catch (err) {} // eslint-disable-line no-empty
    });

    return patterns;
  }

  function matchXiconfComponent(order, component, orderNoToComponentMap, patterns)
  {
    if (!component.nc12 || !component.name || component.unit !== 'PCE')
    {
      return;
    }

    const exCode = patterns.nc12.exclude[component.nc12];

    if (exCode && (exCode.length === 0 || exCode.includes(order.mrp)))
    {
      return;
    }

    if (patterns.name.exclude.some(
      ({re, mrps}) => re.test(component.name) && (mrps.length === 0 || mrps.includes(order.mrp))
    ))
    {
      return;
    }

    const incCode = patterns.nc12.include[component.nc12];
    const codeMatches = !!incCode && (incCode.length === 0 || incCode.includes(order.mrp));
    const nameMatches = patterns.name.include.some(({re, mrps}) =>
    {
      return re.test(component.name)
        && (mrps.length === 0 || mrps.includes(order.mrp));
    });

    if (!codeMatches && !nameMatches)
    {
      return;
    }

    if (!orderNoToComponentMap[order._id])
    {
      orderNoToComponentMap[order._id] = {
        reqDate: moment(order.scheduledStartDate).format('DD.MM.YYYY'),
        components: []
      };
    }

    orderNoToComponentMap[order._id].components.push(component);
  }

  function buildXiconfItemsDumpFile(timestamp, orderNoToComponentMap, done)
  {
    if (!module.config.xiconfFilePathPattern)
    {
      return done();
    }

    const orderNos = Object.keys(orderNoToComponentMap);

    if (!orderNos.length)
    {
      return done();
    }

    const filePath = module.config.xiconfFilePathPattern.replace('{timestamp}', Math.ceil(timestamp / 1000));
    const fileContents = [
      'BOM',
      '-----------------------------------------------------------------------------------------------------------',
      '|Order    |Material       |Reqmts qty|Material Description                             |Reqmt Date|Deleted|',
      '-----------------------------------------------------------------------------------------------------------'
    ];

    orderNos.forEach(orderNo =>
    {
      const {reqDate, components} = orderNoToComponentMap[orderNo];

      if (reqDate === 'Invalid date')
      {
        return;
      }

      components.forEach(component =>
      {
        const row = [
          '',
          orderNo,
          component.nc12.padStart(15, '0'),
          component.qty.toString().padStart(9, ' ') + ' ',
          component.name.padEnd(49, ' '),
          reqDate,
          '       ',
          ''
        ];

        fileContents.push(row.join('|'));
      });
    });

    fileContents.push(fileContents[0]);

    fs.writeFile(filePath, fileContents.join('\r\n'), done);
  }

  function updateCompRelValidity(orderToBom, done)
  {
    const remaining = Array.from(orderToBom.keys());
    const crEntryRids = new Set();

    module.debug('Updating component release validity...', {orderCount: remaining.length});

    step(
      function()
      {
        findNextCompRelEntries(remaining, crEntryRids, this.next());
      },
      function(err)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!crEntryRids.size)
        {
          module.debug('No component release entries found.');

          return this.skip();
        }

        module.debug('Component release entries found.', {entryCount: crEntryRids.size});

        updateNextCompRelEntry(Array.from(crEntryRids), orderToBom, this.next());
      },
      function(err)
      {
        if (err)
        {
          module.error(err, 'Failed to update component release validity.');
        }

        done();
      }
    );
  }

  function findNextCompRelEntries(remaining, crEntryRids, done)
  {
    const batch = remaining.splice(0, 200);

    CompRelEntry.find({'orders.orderNo': {$in: batch}}).select({_id: 0, rid: 1}).lean().exec((err, crEntries) =>
    {
      if (err)
      {
        return done(err);
      }

      crEntries.forEach(crEntry =>
      {
        crEntryRids.add(crEntry.rid);
      });

      if (remaining.length)
      {
        findNextCompRelEntries(remaining, crEntryRids, done);
      }
      else
      {
        done();
      }
    });
  }

  async function updateNextCompRelEntry(crEntryRids, orderToBom, done)
  {
    try
    {
      const rid = crEntryRids.shift();
      const entry = await CompRelEntry
        .findOne({rid})
        .select({
          valid: 1,
          oldComponents: 1,
          orders: 1
        })
        .lean()
        .exec();

      if (!entry)
      {
        return;
      }

      const update = {
        $set: {},
        $push: {}
      };
      const validOrders = [];
      const invalidOrders = [];
      let valid = true;

      entry.orders.forEach((o, i) =>
      {
        if (!o.orderNo)
        {
          return;
        }

        const bom = orderToBom.get(o.orderNo);

        if (!bom)
        {
          valid = valid && o.valid;

          return;
        }

        const oldValid = o.valid;
        const newValid = entry.oldComponents.every(c => !bom.has(c._id));

        if (newValid === oldValid)
        {
          return;
        }

        o.valid = newValid;
        valid = valid && newValid;

        if (newValid)
        {
          validOrders.push(o.orderNo);
        }
        else
        {
          invalidOrders.push(o.orderNo);
        }

        update.$set[`orders.${i}.valid`] = newValid;
      });

      if (!validOrders.length && !invalidOrders.length)
      {
        return;
      }

      const change = {
        date: new Date(),
        user: {id: null, label: 'System'},
        data: {},
        comment: ''
      };

      if (valid !== entry.valid)
      {
        update.$set.valid = valid;
        change.data.valid = [entry.valid, valid];
      }

      if (validOrders.length)
      {
        change.data.validOrders = [null, validOrders];
      }

      if (invalidOrders.length)
      {
        change.data.invalidOrders = [null, invalidOrders];
      }

      update.$push.changes = change;

      await CompRelEntry.collection.updateOne({_id: entry._id}, update);

      app.broker.publish(`${CompRelEntry.TOPIC_PREFIX}.updated.${entry._id}`, {
        _id: entry._id,
        change
      });

      module.debug('Component release entry updated.', {
        entry: rid,
        valid: valid
      });
    }
    catch (err)
    {
      module.error(err, 'Failed to update component release entry.');
    }
    finally
    {
      if (crEntryRids.length)
      {
        updateNextCompRelEntry(crEntryRids, orderToBom, done);
      }
      else
      {
        done();
      }
    }
  }
};
