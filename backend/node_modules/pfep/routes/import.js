// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');
const xlsx = require('xlsx');
const fs = require('fs-extra');
const jsonDeepEqual = require('util/jsonDeepEqual');

module.exports = (app, module, req, res, next) =>
{
  const {
    user,
    PfepEntry
  } = module;

  const updatedAt = new Date();
  const updater = user.createUserInfo(req.session.user, req);

  const DEFAULTS = {
    creator: updater,
    createdAt: updatedAt,
    updater: null,
    updatedAt: null,
    nc12: '',
    description: '',
    unit: '',
    packType: '',
    externalPackQty: 0,
    internalPackQty: 0,
    packLength: 0,
    packWidth: 0,
    packHeight: 0,
    packGrossWeight: 0,
    componentNetWeight: 0,
    componentGrossWeight: 0,
    qtyPerLayer: 0,
    qtyOnPallet: 0,
    palletLength: 0,
    palletWidth: 0,
    palletHeight: 0,
    moq: 0,
    roundingValue: 0,
    vendor: '',
    notes: '',
    changes: []
  };

  step(
    function()
    {
      fs.readFile(req.file.path, this.next());
    },
    function(err, buffer)
    {
      if (err)
      {
        return this.skip(err);
      }

      try
      {
        const workbook = xlsx.read(buffer, {
          type: 'buffer',
          cellFormula: false,
          cellHTML: false,
          cellText: false
        });

        this.sheet = workbook.Sheets[workbook.SheetNames[0]];

        setImmediate(this.next());
      }
      catch (err)
      {
        this.skip(err);
      }
    },
    function()
    {
      const addresses = {
        rid: null,
        nc12: null,
        description: null,
        unit: null,
        packType: null,
        externalPackQty: null,
        internalPackQty: null,
        packLength: null,
        packWidth: null,
        packHeight: null,
        packGrossWeight: null,
        componentNetWeight: null,
        componentGrossWeight: null,
        qtyPerLayer: null,
        qtyOnPallet: null,
        palletLength: null,
        palletWidth: null,
        palletHeight: null,
        moq: null,
        roundingValue: null,
        vendor: null,
        notes: null
      };
      const range = xlsx.utils.decode_range(this.sheet['!ref']);

      for (let c = range.s.c; c <= range.e.c; ++c)
      {
        const col = xlsx.utils.encode_col(c);
        const row = range.s.r + 1;
        const cell = this.sheet[col + row];

        if (!cell)
        {
          continue;
        }

        const v = String(cell.v).trim();

        if (addresses[v] === null)
        {
          addresses[v] = col;
        }
      }

      Object.keys(addresses).forEach(k =>
      {
        const address = addresses[k];

        if (address === null)
        {
          delete addresses[k];
        }
      });

      if (!addresses.nc12)
      {
        return this.skip(app.createError('Missing the 12NC column.', 'INPUT', 400));
      }

      const columns = Object.keys(addresses);

      if (columns.length === 1)
      {
        return this.skip(app.createError('Missing at least one data column.', 'INPUT', 400));
      }

      const rows = {
        insert: [],
        update: new Map()
      };
      let emptyCount = 0;

      for (let r = range.s.r + 2; r <= range.e.r + 1; ++r)
      {
        const row = {};

        for (let c = 0; c < columns.length; ++c)
        {
          const column = columns[c];
          const address = addresses[column];

          if (Array.isArray(address))
          {
            if (!Array.isArray(row[column]))
            {
              row[column] = address.map(() => null);
            }

            for (let i = 0; i < address.length; ++i)
            {
              const cell = this.sheet[address[i] + r];

              row[column][i] = parseCellValue(column, cell);
            }
          }
          else
          {
            const cell = this.sheet[address + r];

            row[column] = parseCellValue(column, cell);
          }
        }

        emptyCount = row.nc12 ? 0 : (emptyCount + 1);

        if (emptyCount >= 5)
        {
          break;
        }

        if (row.rid)
        {
          rows.update.set(row.rid, row);
        }
        else
        {
          rows.insert.push(row);
        }
      }

      this.columns = columns;
      this.rows = rows;
      this.sheet = null;

      setImmediate(this.next());
    },
    function()
    {
      if (!this.rows.update.size)
      {
        return;
      }

      const columns = {};

      this.columns.forEach(c => columns[c] = 1);

      PfepEntry
        .find({rid: {$in: Array.from(this.rows.update.keys())}})
        .select(columns)
        .lean()
        .exec(this.next());
    },
    function(err, entries)
    {
      if (err)
      {
        return this.skip(err);
      }

      this.message = {
        rows: this.rows.insert.length + this.rows.update.size,
        added: 0,
        updated: 0
      };

      if (!entries || !entries.length)
      {
        return;
      }

      updateNext(this.message, entries, this.rows.update, this.columns, this.next());
    },
    function(err)
    {
      if (err)
      {
        return next(err);
      }

      if (this.rows.insert.length)
      {
        insertNext(this.message, this.rows.insert, this.next());
      }
    },
    function(err)
    {
      fs.unlink(req.file.path, () => {});

      if (err)
      {
        return next(err);
      }

      app.broker.publish(`${PfepEntry.TOPIC_PREFIX}.imported`, this.message);

      res.sendStatus(204);
    }
  );

  function parseCellValue(column, cell)
  {
    if (!cell)
    {
      cell = {v: null};
    }
    else if (cell.v == null)
    {
      cell.v = null;
    }

    switch (column)
    {
      case 'rid':
        return cell.v && parseInt(cell.v, 10) || null;

      case 'nc12':
        return cell && /^[0-9]{12}$/.test(String(cell.v)) ? String(cell.v) : null;

      case 'description':
      case 'unit':
      case 'packType':
      case 'vendor':
      case 'notes':
        return cell && typeof cell.v === 'string' ? cell.v.trim() : '';

      case 'externalPackQty':
      case 'internalPackQty':
      case 'packLength':
      case 'packWidth':
      case 'packHeight':
      case 'qtyPerLayer':
      case 'qtyOnPallet':
      case 'palletLength':
      case 'palletWidth':
      case 'palletHeight':
      case 'moq':
      case 'roundingValue':
      case 'packGrossWeight':
      case 'componentNetWeight':
      case 'componentGrossWeight':
      {
        if (typeof cell.v !== 'number')
        {
          cell.v = parseFloat(cell.v) || 0;

          if (!isFinite(cell.v))
          {
            cell.v = 0;
          }
        }

        return Math.round(cell.v * 1000) / 1000;
      }

      default:
        return null;
    }
  }

  function updateNext(message, oldDocs, newDocs, columns, done)
  {
    if (!oldDocs.length)
    {
      return done();
    }

    const oldDoc = oldDocs.shift();
    const newDoc = newDocs.get(oldDoc.rid);

    const update = {
      $set: {
        updater,
        updatedAt
      },
      $push: {
        changes: {
          date: updatedAt,
          user: updater,
          data: {},
          comment: ''
        }
      }
    };

    let changed = false;

    columns.forEach(column =>
    {
      const oldValue = oldDoc[column];
      const newValue = newDoc[column];

      if (!jsonDeepEqual(newValue, oldValue))
      {
        update.$set[column] = newValue;
        update.$push.changes.data[column] = [oldValue, newValue];

        changed = true;
      }
    });

    if (!changed)
    {
      return setImmediate(updateNext, message, oldDocs, newDocs, columns, done);
    }

    PfepEntry.updateOne({_id: oldDoc._id}, update, err =>
    {
      if (err)
      {
        return done(err);
      }

      message.updated += 1;

      setImmediate(updateNext, message, oldDocs, newDocs, columns, done);
    });
  }

  function insertNext(message, newDocs, done)
  {
    const batch = newDocs.splice(0, 100);

    step(
      function()
      {
        const conditions = {
          model: 'PfepEntry',
          field: 'rid',
          groupingField: ''
        };
        const update = {
          $inc: {count: batch.length}
        };
        const options = {
          upsert: true,
          returnOriginal: false
        };

        PfepEntry.db.collection('identitycounters').findOneAndUpdate(conditions, update, options, this.next());
      },
      function(err, res)
      {
        if (err)
        {
          return this.skip(err);
        }

        let rid = res.value.count - batch.length;

        batch.forEach(doc =>
        {
          doc.rid = ++rid;

          _.defaults(doc, DEFAULTS);
        });

        PfepEntry.collection.insertMany(batch, this.next());
      },
      function(err)
      {
        if (err)
        {
          return done(err);
        }

        message.added += batch.length;

        if (newDocs.length)
        {
          setImmediate(insertNext, message, newDocs, done);
        }
        else
        {
          done();
        }
      }
    );
  }
};
