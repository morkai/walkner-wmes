// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');
const moment = require('moment');

const DUPLICATE_FIELDS = {
  searchName: 1,
  email: 1,
  privileges: 1,
  kdId: 1,
  prodFunction: 1,
  mobile: 1
};

module.exports = (app, module, input, done) =>
{
  const mor = app[module.config.morId];

  if (!mor)
  {
    return setImmediate(done, app.createError('No mor module.', 'DISABLED', 500));
  }

  const {User, Order, OrderEto, FapCategory} = module;

  const requestedSubdivisions = Array.isArray(input.subdivisions) && input.subdivisions.length
    ? input.subdivisions
    : null;
  const requestedMoment = moment(input.date || Date.now());
  const requestedDate = requestedMoment.format('YYYY-MM-DD');
  const requestedDay = requestedMoment.isoWeekday();

  const subdivisions = new Set();
  const users = new Map();

  step(
    function()
    {
      if (input.orderNo)
      {
        Order.findById(input.orderNo).select({mrp: 1, nc12: 1}).lean().exec(this.parallel());
      }
      else
      {
        setImmediate(this.parallel(), null, {
          mrp: (input.mrp || '').toUpperCase(),
          nc12: input.nc12
        });
      }

      if (input.category)
      {
        FapCategory.findById(input.category, {users: 1, notifications: 1}).lean().exec(this.parallel());
      }
    },
    function(err, sapOrder, category)
    {
      if (err)
      {
        return this.skip(err);
      }

      if (category)
      {
        input.users = (input.users || []).concat(category.users || []);
        input.notifications = (input.notifications || []).concat(category.notifications || []);
      }

      if (!input.mrp && sapOrder)
      {
        input.mrp = sapOrder.mrp;
      }

      if (!input.nc12 && sapOrder)
      {
        input.nc12 = sapOrder.nc12;
      }

      if (input.users.length)
      {
        loadUsers({_id: {$in: input.users.map(u => u.id)}}, false, this.group());
      }

      if (input.nc12)
      {
        resolveEtoConstructor(input.nc12, this.group());
      }

      resolveMorParticipants(mapSubdivisionToFunctions(input.notifications));
    },
    function(err)
    {
      done(err, {
        subdivisions: Array.from(subdivisions),
        users: Array.from(users.values())
      });
    }
  );

  function loadUsers(conditions, sms, done)
  {
    User.find(conditions).select({...DUPLICATE_FIELDS, ...mor.USER_FIELDS}).lean().exec((err, foundUsers) =>
    {
      if (err)
      {
        return done(err);
      }

      if (!foundUsers.length)
      {
        return done();
      }

      filterDuplicateUsers(foundUsers).forEach((user) =>
      {
        const userId = user._id.toString();

        if (users.has(userId))
        {
          return;
        }

        const morUser = mor.getUser(userId);

        if (morUser)
        {
          users.set(userId, {sms, ...morUser});
        }
        else
        {
          user._id = userId;

          users.set(userId, {sms, ...user});
        }
      });

      done();
    });
  }

  function filterDuplicateUsers(allUsers)
  {
    const filteredUsers = [];
    const groupedUsers = new Map();
    const duplicateFields = Object.keys(DUPLICATE_FIELDS);

    allUsers.forEach(user =>
    {
      if (!groupedUsers.has(user.searchName))
      {
        groupedUsers.set(user.searchName, []);
      }

      groupedUsers.get(user.searchName).push({
        user,
        score: scoreUser(user)
      });

      duplicateFields.forEach(field =>
      {
        if (!mor.USER_FIELDS[field])
        {
          delete user[field];
        }
      });
    });

    groupedUsers.forEach(users =>
    {
      users.sort((a, b) => b.score - a.score);

      filteredUsers.push(users[0].user);
    });

    return filteredUsers;
  }

  function scoreUser(user)
  {
    let score = 0;

    if (user.email)
    {
      score += 1;
    }

    if (user.privileges && user.privileges.length)
    {
      score += 1;
    }

    if (user.kdId === -1)
    {
      score += 1;
    }

    if (user.active)
    {
      score += 1;
    }
    else
    {
      score -= 2;
    }

    if (user.prodFunction)
    {
      score += 1;
    }

    if (user.mobile && user.mobile.length)
    {
      score += 2;
    }

    return score;
  }

  function resolveEtoConstructor(nc12, done)
  {
    step(
      function()
      {
        OrderEto.findById(nc12).select({constructorUser: 1}).lean().exec(this.next());
      },
      function(err, orderEto)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!orderEto || !orderEto.constructorUser)
        {
          return this.skip();
        }

        const words = orderEto.constructorUser.split(/\s+/);
        const first = words.shift();
        const last = words.join(' ');
        const searchNames = [
          User.transliterateName(`${first} ${last}`),
          User.transliterateName(`${last} ${first}`)
        ];
        const conditions = {
          searchName: {$in: searchNames},
          active: true,
          email: /@/
        };

        loadUsers(conditions, false, this.next());
      },
      done
    );
  }

  function resolveMorParticipants(subdivisionToFunctions)
  {
    const watchSections = [];
    const watchProdFunctions = new Set();

    mor.state.sections.forEach(section =>
    {
      if (section.watchEnabled && !section.mrpsEnabled)
      {
        watchSections.push(section);

        return;
      }

      if (requestedSubdivisions && !_.intersection(section.subdivisions, requestedSubdivisions).length)
      {
        return;
      }

      const prodFunctions = matchSubdivisions(subdivisionToFunctions, section.subdivisions);

      if (!prodFunctions.size)
      {
        if (!requestedSubdivisions || (!section.commonProdFunctions.length && !section.prodFunctions.length))
        {
          return;
        }

        section.commonProdFunctions.forEach(prodFunction => prodFunctions.add(prodFunction));
        section.prodFunctions.forEach(prodFunction => prodFunctions.add(prodFunction));
      }

      prodFunctions.forEach(prodFunction => watchProdFunctions.add(prodFunction));

      let hasAllMrp = false;
      let hasMrp = false;

      section.mrps.forEach(sectionMrp =>
      {
        hasAllMrp = hasAllMrp || sectionMrp._id.toUpperCase() === '$ALL';
        hasMrp = hasMrp || sectionMrp._id === input.mrp;
      });

      if (hasMrp || (hasAllMrp && section.mrps.length === 1))
      {
        collectSectionProdFunctionUsers(users, prodFunctions, section.commonProdFunctions);
        collectSectionWatchUsers(users, prodFunctions, section.watch);
      }

      if (hasMrp || hasAllMrp)
      {
        collectSectionMrpUsers(users, prodFunctions, section.mrps);

        section.subdivisions.forEach(subdivision => subdivisions.add(subdivision));
      }
    });

    watchSections.forEach(watchSection =>
    {
      collectSectionWatchUsers(users, watchProdFunctions, watchSection.watch);
    });
  }

  function mapSubdivisionToFunctions(notifications)
  {
    const subdivisionToFunctions = new Map();

    notifications.forEach(notification =>
    {
      const subdivisions = notification.subdivisions.length
        ? notification.subdivisions.map(v => String(v))
        : ['ANY'];

      subdivisions.forEach(subdivision =>
      {
        if (!subdivisionToFunctions.has(subdivision))
        {
          subdivisionToFunctions.set(subdivision, new Set());
        }

        const subdivisionFunctions = subdivisionToFunctions.get(subdivision);

        notification.prodFunctions.forEach(prodFunction =>
        {
          subdivisionFunctions.add(prodFunction);
        });
      });
    });

    return subdivisionToFunctions;
  }

  function matchSubdivisions(subdivisionToFunctions, sectionSubdivisions)
  {
    const prodFunctions = new Set(subdivisionToFunctions.get('ANY') || []);

    sectionSubdivisions.forEach(sectionSubdivision =>
    {
      (subdivisionToFunctions.get(sectionSubdivision) || []).forEach(prodFunction =>
      {
        prodFunctions.add(prodFunction);
      });
    });

    return prodFunctions;
  }

  function collectSectionMrpUsers(users, prodFunctions, sectionMrps)
  {
    sectionMrps.forEach(sectionMrp =>
    {
      if (sectionMrp._id !== input.mrp && sectionMrp._id.toUpperCase() !== '$ALL')
      {
        return;
      }

      collectSectionProdFunctionUsers(users, prodFunctions, sectionMrp.prodFunctions);
    });
  }

  function collectSectionProdFunctionUsers(users, prodFunctions, sectionProdFunction)
  {
    sectionProdFunction.forEach(sectionProdFunction =>
    {
      if (!prodFunctions.has(sectionProdFunction._id))
      {
        return;
      }

      sectionProdFunction.users.forEach(userId =>
      {
        if (users.has(userId))
        {
          return;
        }

        const user = mor.getUser(userId);

        if (user)
        {
          users.set(userId, {sms: false, ...user});
        }
      });
    });
  }

  function collectSectionWatchUsers(users, prodFunctions, sectionWatch)
  {
    sectionWatch.forEach(watchUser =>
    {
      const morUser = mor.getUser(watchUser.user);

      if (!morUser
        || !prodFunctions.has(morUser.prodFunction)
        || !matchWatch(watchUser))
      {
        return;
      }

      const user = users.get(morUser._id);
      const sms = watchUser.days.length !== 0;

      if (!user)
      {
        users.set(morUser._id, {sms, ...morUser});
      }
      else if (!user.sms)
      {
        user.sms = sms;
      }
    });
  }

  function matchWatch(watchUser)
  {
    return matchWatchDay(watchUser.days) && matchWatchTime(watchUser.from, watchUser.to);
  }

  function matchWatchDay(days)
  {
    return days.length === 0 || days.includes(requestedDay);
  }

  function matchWatchTime(from, to)
  {
    if (from === '06:00' && to === '06:00')
    {
      return true;
    }

    const fromMoment = moment(`${requestedDate} ${from}`, 'YYYY-MM-DD HH:mm');
    const toMoment = moment(`${requestedDate} ${to}`, 'YYYY-MM-DD HH:mm');

    return requestedMoment.isBetween(fromMoment, toMoment, null, '[)');
  }
};
