// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');
const moment = require('moment');

const DUPLICATE_FIELDS = {
  searchName: 1,
  email: 1,
  privileges: 1,
  kdId: 1,
  prodFunction: 1,
  mobile: 1
};

module.exports = (app, module, input, done) =>
{
  const mor = app[module.config.morId];

  if (!mor)
  {
    return setImmediate(done, app.createError('No mor module.', 'DISABLED', 500));
  }

  const orgUnits = app[module.config.orgUnitsId];
  const {
    User,
    Order,
    OrderEto,
    FapCategory,
    FapSubCategory,
    DailyMrpCount
  } = module;

  const requestedSubdivisions = Array.isArray(input.subdivisions) && input.subdivisions.length
    ? input.subdivisions
    : null;
  const requestedMoment = moment(+input.date || Date.now());
  const requestedDate = requestedMoment.format('YYYY-MM-DD');
  const requestedDay = requestedMoment.isoWeekday();

  const mrpDivisions = new Set();
  const subdivisions = new Set();
  const users = new Map();

  step(
    function()
    {
      if (input.orderNo)
      {
        Order
          .findById(input.orderNo)
          .select({mrp: 1, nc12: 1})
          .lean()
          .exec(this.parallel());
      }
      else
      {
        setImmediate(this.parallel(), null, {
          mrp: (input.mrp || '').toUpperCase(),
          nc12: input.nc12
        });
      }

      if (input.category)
      {
        FapCategory
          .findById(input.category)
          .select({users: 1, notifications: 1})
          .lean()
          .exec(this.parallel());
      }

      if (input.subCategory)
      {
        FapSubCategory
          .findById(input.subCategory)
          .select({users: 1, notifications: 1})
          .lean()
          .exec(this.parallel());
      }
    },
    function(err, sapOrder, category, subCategory)
    {
      if (err)
      {
        return this.skip(err);
      }

      if (!Array.isArray(input.users))
      {
        input.users = [];
      }

      if (!Array.isArray(input.notifications))
      {
        input.notifications = [];
      }

      if (category)
      {
        input.users = input.users.concat(category.users || []);
        input.notifications = input.notifications.concat(category.notifications || []);
      }

      if (subCategory)
      {
        input.users = input.users.concat(subCategory.users || []);
        input.notifications = input.notifications.concat(subCategory.notifications || []);
      }

      input.users = _.uniqBy(input.users, 'id');

      if (!input.mrp && sapOrder)
      {
        input.mrp = sapOrder.mrp;
      }

      if (!input.nc12 && sapOrder)
      {
        input.nc12 = sapOrder.nc12;
      }

      if (Array.isArray(input.users) && input.users.length)
      {
        loadUsers({_id: {$in: input.users.map(u => u.id)}}, false, this.group());
      }

      if (input.nc12)
      {
        resolveEtoConstructor(input.nc12, this.group());
      }

      if (input.mrp)
      {
        resolveMrpDivisions(input.mrp, this.group());
      }
    },
    function(err)
    {
      if (err)
      {
        return this.skip(err);
      }

      resolveMorParticipants(mapSubdivisionToFunctions(input.notifications));
    },
    function(err)
    {
      done(err, {
        subdivisions: Array.from(subdivisions),
        users: Array.from(users.values())
      });
    }
  );

  function loadUsers(conditions, sms, done)
  {
    User.find(conditions).select({...DUPLICATE_FIELDS, ...mor.USER_FIELDS}).lean().exec((err, foundUsers) =>
    {
      if (err)
      {
        return done(err);
      }

      if (!foundUsers.length)
      {
        return done();
      }

      filterDuplicateUsers(foundUsers).forEach((user) =>
      {
        const userId = user._id.toString();

        if (users.has(userId))
        {
          return;
        }

        const morUser = mor.getUser(userId);

        if (morUser)
        {
          users.set(userId, {sms, ...morUser});
        }
        else
        {
          user._id = userId;

          users.set(userId, {sms, ...user});
        }
      });

      done();
    });
  }

  function filterDuplicateUsers(allUsers)
  {
    const filteredUsers = [];
    const groupedUsers = new Map();
    const duplicateFields = Object.keys(DUPLICATE_FIELDS);

    allUsers.forEach(user =>
    {
      if (!groupedUsers.has(user.searchName))
      {
        groupedUsers.set(user.searchName, []);
      }

      groupedUsers.get(user.searchName).push({
        user,
        score: scoreUser(user)
      });

      duplicateFields.forEach(field =>
      {
        if (!mor.USER_FIELDS[field])
        {
          delete user[field];
        }
      });
    });

    groupedUsers.forEach(users =>
    {
      users.sort((a, b) => b.score - a.score);

      filteredUsers.push(users[0].user);
    });

    return filteredUsers;
  }

  function scoreUser(user)
  {
    let score = 0;

    if (user.email)
    {
      score += 1;
    }

    if (user.privileges && user.privileges.length)
    {
      score += 1;
    }

    if (user.kdId === -1)
    {
      score += 1;
    }

    if (user.active)
    {
      score += 1;
    }
    else
    {
      score -= 2;
    }

    if (user.prodFunction)
    {
      score += 1;
    }

    if (user.mobile && user.mobile.length)
    {
      score += 2;
    }

    return score;
  }

  function resolveEtoConstructor(nc12, done)
  {
    step(
      function()
      {
        OrderEto.findById(nc12).select({constructorUser: 1}).lean().exec(this.next());
      },
      function(err, orderEto)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!orderEto || !orderEto.constructorUser)
        {
          return this.skip();
        }

        const words = orderEto.constructorUser.split(/\s+/);
        const first = words.shift();
        const last = words.join(' ');
        const searchNames = [
          User.transliterateName(`${first} ${last}`),
          User.transliterateName(`${last} ${first}`)
        ];
        const conditions = {
          searchName: {$in: searchNames},
          active: true,
          email: /@/
        };

        loadUsers(conditions, false, this.next());
      },
      done
    );
  }

  function resolveMorParticipants(subdivisionToFunctions)
  {
    const watchSections = [];
    const watchProdFunctions = new Set();

    const anySectionHasMrp = !!input.mrp && mor.state.sections.some(
      section => section.mrps.some(sectionMrp => sectionMrp._id === input.mrp)
    );

    mor.state.sections.forEach(section =>
    {
      if (section.watchEnabled && !section.mrpsEnabled)
      {
        watchSections.push(section);

        return;
      }

      if (requestedSubdivisions && !_.intersection(section.subdivisions, requestedSubdivisions).length)
      {
        return;
      }

      const prodFunctions = matchSubdivisions(subdivisionToFunctions, section.subdivisions);

      if (!prodFunctions.size)
      {
        if (!requestedSubdivisions || (!section.commonProdFunctions.length && !section.prodFunctions.length))
        {
          return;
        }

        section.commonProdFunctions.forEach(prodFunction => prodFunctions.add(prodFunction));
        section.prodFunctions.forEach(prodFunction => prodFunctions.add(prodFunction));
      }

      prodFunctions.forEach(prodFunction => watchProdFunctions.add(prodFunction));

      let hasAllMrp = false;
      let hasMrp = false;

      section.mrps.forEach(sectionMrp =>
      {
        hasAllMrp = hasAllMrp || sectionMrp._id.toUpperCase() === '$ALL';
        hasMrp = hasMrp || sectionMrp._id === input.mrp;
      });

      if (!anySectionHasMrp || hasMrp || (hasAllMrp && section.mrps.length === 1))
      {
        collectSectionProdFunctionUsers(users, prodFunctions, mor.state.globalProdFunctions);
        collectSectionProdFunctionUsers(users, prodFunctions, section.commonProdFunctions);
        collectSectionWatchUsers(users, prodFunctions, section.watch);
      }

      if (!anySectionHasMrp || hasMrp || hasAllMrp)
      {
        collectSectionMrpUsers(users, prodFunctions, section.mrps);

        section.subdivisions.forEach(subdivisionId =>
        {
          const subdivision = orgUnits.getByTypeAndId('subdivision', subdivisionId);

          if (subdivision
            && (subdivision.type === 'press' || subdivision.type === 'paintShop')
            && mrpDivisions.size
            && !mrpDivisions.has(subdivision.division))
          {
            return;
          }

          subdivisions.add(subdivisionId);
        });
      }
    });

    watchSections.forEach(watchSection =>
    {
      collectSectionWatchUsers(users, null, watchSection.watch);
    });
  }

  function resolveMrpDivisions(mrp, done)
  {
    const conditions = {
      [`count.mrpController.${mrp}`]: {$exists: true}
    };
    const fields = {
      [`count.mrpController.${mrp}.division`]: 1
    };

    DailyMrpCount.findOne(conditions).select(fields).sort({_id: -1}).lean().exec((err, dailyMrpCount) =>
    {
      if (err)
      {
        return done(err);
      }

      if (!dailyMrpCount)
      {
        return done();
      }

      dailyMrpCount.count.mrpController[mrp].division.forEach(division =>
      {
        mrpDivisions.add(division);
      });

      done();
    });
  }

  function mapSubdivisionToFunctions(notifications)
  {
    const subdivisionToFunctions = new Map();

    if (!Array.isArray(notifications))
    {
      return subdivisionToFunctions;
    }

    notifications.forEach(notification =>
    {
      const subdivisions = notification.subdivisions.length
        ? notification.subdivisions.map(v => String(v))
        : ['ANY'];

      subdivisions.forEach(subdivision =>
      {
        if (!subdivisionToFunctions.has(subdivision))
        {
          subdivisionToFunctions.set(subdivision, new Set());
        }

        const subdivisionFunctions = subdivisionToFunctions.get(subdivision);

        notification.prodFunctions.forEach(prodFunction =>
        {
          subdivisionFunctions.add(prodFunction);
        });
      });
    });

    return subdivisionToFunctions;
  }

  function matchSubdivisions(subdivisionToFunctions, sectionSubdivisions)
  {
    const prodFunctions = new Set(subdivisionToFunctions.get('ANY') || []);

    sectionSubdivisions.forEach(sectionSubdivision =>
    {
      (subdivisionToFunctions.get(sectionSubdivision) || []).forEach(prodFunction =>
      {
        prodFunctions.add(prodFunction);
      });
    });

    return prodFunctions;
  }

  function collectSectionMrpUsers(users, prodFunctions, sectionMrps)
  {
    sectionMrps.forEach(sectionMrp =>
    {
      if (sectionMrp._id !== input.mrp && sectionMrp._id.toUpperCase() !== '$ALL')
      {
        return;
      }

      collectSectionProdFunctionUsers(users, prodFunctions, mor.state.globalProdFunctions);
      collectSectionProdFunctionUsers(users, prodFunctions, sectionMrp.prodFunctions);
    });
  }

  function collectSectionProdFunctionUsers(users, prodFunctions, sectionProdFunction)
  {
    sectionProdFunction.forEach(sectionProdFunction =>
    {
      if (!prodFunctions.has(sectionProdFunction._id))
      {
        return;
      }

      sectionProdFunction.users.forEach(userId =>
      {
        if (users.has(userId))
        {
          return;
        }

        const user = mor.getUser(userId);

        if (user)
        {
          users.set(userId, {sms: false, ...user});
        }
      });
    });
  }

  function collectSectionWatchUsers(users, prodFunctions, sectionWatch)
  {
    sectionWatch.forEach(watchUser =>
    {
      const morUser = mor.getUser(watchUser.user);

      if (!morUser
        || (prodFunctions && !prodFunctions.has(morUser.prodFunction))
        || !matchWatch(watchUser))
      {
        return;
      }

      const userId = morUser._id.toString();
      const user = users.get(userId);
      const sms = watchUser.days.length !== 0
        || watchUser.from !== '06:00'
        || watchUser.to !== '06:00';

      if (!user)
      {
        users.set(userId, {sms, ...morUser});
      }
      else if (!user.sms)
      {
        user.sms = sms;
      }
    });
  }

  function matchWatch(watchUser)
  {
    return matchWatchDay(watchUser.days) && matchWatchTime(watchUser.from, watchUser.to);
  }

  function matchWatchDay(days)
  {
    return days.length === 0 || days.includes(requestedDay);
  }

  function matchWatchTime(from, to)
  {
    if (from === '06:00' && to === '06:00')
    {
      return true;
    }

    const fromMoment = moment(`${requestedDate} ${from}`, 'YYYY-MM-DD HH:mm');
    const toMoment = moment(`${requestedDate} ${to}`, 'YYYY-MM-DD HH:mm');

    return requestedMoment.isBetween(fromMoment, toMoment, null, '[)');
  }
};
