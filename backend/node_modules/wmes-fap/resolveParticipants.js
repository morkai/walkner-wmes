// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const step = require('h5.step');
const moment = require('moment');

module.exports = (app, {config, FapCategory}, {mrp, category, date, notifications}, done) =>
{
  const mor = app[config.morId];

  if (!mor)
  {
    return setImmediate(done, app.createError('No mor module.', 'DISABLED', 500));
  }

  const requestedMoment = moment(date || Date.now());
  const requestedDate = requestedMoment.format('YYYY-MM-DD');
  const requestedDay = requestedMoment.isoWeekday();

  step(
    function()
    {
      if (!notifications)
      {
        FapCategory.findById(category, {notifications: 1}).lean().exec(this.next());
      }
      else
      {
        setImmediate(this.next(), null, {notifications});
      }
    },
    function(err, category)
    {
      if (err)
      {
        return this.skip(err);
      }

      if (!category || !category.notifications)
      {
        return this.skip(null, []);
      }

      const subdivisionToFunctions = mapSubdivisionToFunctions(category.notifications);
      const users = new Map();
      const watchSections = [];
      const watchProdFunctions = new Set();

      mor.state.sections.forEach(section =>
      {
        if (section.watchEnabled && !section.mrpsEnabled)
        {
          watchSections.push(section);

          return;
        }

        const prodFunctions = matchSubdivisions(subdivisionToFunctions, section.subdivisions);

        if (!prodFunctions.size)
        {
          return;
        }

        prodFunctions.forEach(prodFunction => watchProdFunctions.add(prodFunction));

        let hasAllMrp = false;
        let hasMrp = false;

        section.mrps.forEach(sectionMrp =>
        {
          hasAllMrp = hasAllMrp || sectionMrp._id.toUpperCase() === '$ALL';
          hasMrp = hasMrp || sectionMrp._id === mrp;
        });

        if (hasMrp || (hasAllMrp && section.mrps.length === 1))
        {
          collectSectionProdFunctionUsers(users, prodFunctions, section.commonProdFunctions);
          collectSectionWatchUsers(users, prodFunctions, section.watch);
        }

        if (hasMrp || hasAllMrp)
        {
          collectSectionMrpUsers(users, prodFunctions, section.mrps);
        }
      });

      watchSections.forEach(watchSection =>
      {
        collectSectionWatchUsers(users, watchProdFunctions, watchSection.watch);
      });

      setImmediate(this.next(), null, Array.from(users.values()));
    },
    done
  );

  function mapSubdivisionToFunctions(notifications)
  {
    const subdivisionToFunctions = new Map();

    notifications.forEach(notification =>
    {
      const subdivisions = notification.subdivisions.length
        ? notification.subdivisions.map(v => String(v))
        : ['ANY'];

      subdivisions.forEach(subdivision =>
      {
        if (!subdivisionToFunctions.has(subdivision))
        {
          subdivisionToFunctions.set(subdivision, new Set());
        }

        const subdivisionFunctions = subdivisionToFunctions.get(subdivision);

        notification.prodFunctions.forEach(prodFunction =>
        {
          subdivisionFunctions.add(prodFunction);
        });
      });
    });

    return subdivisionToFunctions;
  }

  function matchSubdivisions(subdivisionToFunctions, sectionSubdivisions)
  {
    const prodFunctions = new Set(subdivisionToFunctions.get('ANY') || []);

    sectionSubdivisions.forEach(sectionSubdivision =>
    {
      (subdivisionToFunctions.get(sectionSubdivision) || []).forEach(prodFunction =>
      {
        prodFunctions.add(prodFunction);
      });
    });

    return prodFunctions;
  }

  function collectSectionMrpUsers(users, prodFunctions, sectionMrps)
  {
    sectionMrps.forEach(sectionMrp =>
    {
      if (sectionMrp._id !== mrp && sectionMrp._id.toUpperCase() !== '$ALL')
      {
        return;
      }

      collectSectionProdFunctionUsers(users, prodFunctions, sectionMrp.prodFunctions);
    });
  }

  function collectSectionProdFunctionUsers(users, prodFunctions, sectionProdFunction)
  {
    sectionProdFunction.forEach(sectionProdFunction =>
    {
      if (!prodFunctions.has(sectionProdFunction._id))
      {
        return;
      }

      sectionProdFunction.users.forEach(userId =>
      {
        if (users.has(userId))
        {
          return;
        }

        const user = mor.getUser(userId);

        if (user)
        {
          users.set(userId, {sms: false, ...user});
        }
      });
    });
  }

  function collectSectionWatchUsers(users, prodFunctions, sectionWatch)
  {
    sectionWatch.forEach(watchUser =>
    {
      const morUser = mor.getUser(watchUser.user);

      if (!morUser
        || !prodFunctions.has(morUser.prodFunction)
        || !matchWatch(watchUser))
      {
        return;
      }

      const user = users.get(morUser._id);
      const sms = watchUser.days.length !== 0;

      if (!user)
      {
        users.set(morUser._id, {sms, ...morUser});
      }
      else if (!user.sms)
      {
        user.sms = sms;
      }
    });
  }

  function matchWatch(watchUser)
  {
    return matchWatchDay(watchUser.days) && matchWatchTime(watchUser.from, watchUser.to);
  }

  function matchWatchDay(days)
  {
    return days.length === 0 || days.includes(requestedDay);
  }

  function matchWatchTime(from, to)
  {
    if (from === '06:00' && to === '06:00')
    {
      return true;
    }

    const fromMoment = moment(`${requestedDate} ${from}`, 'YYYY-MM-DD HH:mm');
    const toMoment = moment(`${requestedDate} ${to}`, 'YYYY-MM-DD HH:mm');

    return requestedMoment.isBetween(fromMoment, toMoment, null, '[)');
  }
};
