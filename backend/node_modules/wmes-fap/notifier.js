// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const fs = require('fs');
const _ = require('lodash');
const step = require('h5.step');
const ejs = require('ejs');
const moment = require('moment');

module.exports = (app, module) =>
{
  const {mor, User, FapEntry, FapCategory, FapSubCategory} = module;
  const logger = module.logger.create({submodule: 'notifier'});

  const templates = {
    new: ejs.compile(fs.readFileSync(`${__dirname}/templates/notifier/new.pl.ejs`, 'utf8'), {
      cache: true,
      compileDebug: false,
      rmWhitespace: true
    }),
    user: ejs.compile(fs.readFileSync(`${__dirname}/templates/notifier/user.pl.ejs`, 'utf8'), {
      cache: true,
      compileDebug: false,
      rmWhitespace: true
    })
  };

  const pendingNotifications = new Map();
  const lockedNotifications = new Set();

  app.broker.subscribe('fap.entries.added', onEntryAdded);
  app.broker.subscribe('fap.entries.deleted', onEntryDeleted);
  app.broker.subscribe('fap.entries.updated.*', onEntryUpdated);
  app.broker.subscribe('fap.entries.notifications.*', onNotification);
  app.broker.subscribe('fap.entries.presence.*', onPresence);

  app.broker.subscribe('app.started', () => markOldAsSeen(false)).setLimit(1);

  function onNotification({seen}, topic)
  {
    if (Array.isArray(seen))
    {
      seen.forEach(id => clearPendingNotification(id, topic.split('.').pop()));
    }
  }

  function onPresence({entryId, userId})
  {
    lockedNotifications.delete(`${entryId}:${userId}`);
  }

  function onEntryAdded({model})
  {
    const entry = model.toJSON();
    const usersToNotify = entry.observers
      .map(o => o.user && o.user.id ? o.user.id.toString() : null)
      .filter(id => id !== null && id !== entry.creator.id.toString());

    notify(entry, usersToNotify, (err) =>
    {
      if (err)
      {
        logger.error(err, `Failed to notify after add.`, {entry: entry._id});
      }
    });
  }

  function onEntryDeleted({model})
  {
    model.observers.forEach(o =>
    {
      if (o.notify)
      {
        app.broker.publish(`fap.entries.notifications.${o.user.id}`, {
          removed: [model._id]
        });
      }
    });
  }

  function onEntryUpdated(message)
  {
    const {change} = message;

    if (change.data.category || change.data.orderNo)
    {
      swapSubscribers(message._id, change);
    }

    if (change.comment.includes('ðŸ‘¤'))
    {
      scheduleUserNotifications(message._id, change.user.id, change.comment);
    }

    if (message.notify)
    {
      const changed = {
        _id: message._id,
        rid: message.rid,
        updater: change.user.label,
        comment: change.comment
      };

      sendChangedNotifications(changed, Object.keys(message.notify));

      if (change.user.id !== message.creator && change.comment)
      {
        scheduleUserNotification(message._id, message.creator, true);
      }

      app.broker.publish(`fap.entries.notifications.${change.user.id}`, {
        seen: [message._id]
      });
    }

    const subscribers = change.data.subscribers$added || change.data.subscribers;

    if (!subscribers || subscribers[0] || !subscribers[1])
    {
      return;
    }

    const usersToNotify = subscribers[1].map(s => s.id).filter(id => id !== change.user.id);

    if (!usersToNotify.length)
    {
      return;
    }

    step(
      function()
      {
        FapEntry
          .findById(message._id)
          .select({
            changes: 0,
            observers: 0,
            attachments: 0,
            unsubscribed: 0
          })
          .lean()
          .exec(this.next());
      },
      function(err, entry)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!entry)
        {
          return this.skip();
        }

        if (entry.status !== 'finished' || (entry.analysisNeed && !entry.analysisDone))
        {
          notify(entry, usersToNotify, this.next());
        }
      },
      function(err)
      {
        if (err)
        {
          logger.error(err, `Failed to notify after update.`, {entry: message._id});
        }
      }
    );
  }

  function notify(entry, usersToNotify, done)
  {
    step(
      function()
      {
        FapCategory
          .findById(entry.category, {name: 1})
          .lean()
          .exec(this.parallel());

        FapSubCategory
          .findById(entry.subCategory, {name: 1})
          .lean()
          .exec(this.parallel());

        User
          .find({_id: {$in: usersToNotify}})
          .select({
            email: 1,
            mobile: 1,
            'preferences.fap_sms': 1
          })
          .lean()
          .exec(this.parallel());
      },
      function(err, category, subCategory, users)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (category)
        {
          entry.category = category.name;
        }

        if (subCategory)
        {
          entry.subCategory = subCategory.name;
        }

        const emailRecipients = new Set();
        const smsRecipients = new Set();
        const watchUsers = resolveWatchUsers();
        const currentDate = new Date();
        const currentTimeValue = currentDate.getHours() * 1000 + currentDate.getMinutes();
        const added = !entry.changes || entry.changes.length > 0 ? null : {
          _id: entry._id,
          rid: entry.rid,
          owner: entry.owner.label,
          category: entry.category,
          problem: entry.problem
        };

        users.forEach(user =>
        {
          const userId = user._id.toString();

          if (app[module.config.mailSenderId] && user.email)
          {
            emailRecipients.add(user.email);
          }

          if (app[module.config.smsSenderId]
            && (watchUsers.has(userId) || (user.preferences && user.preferences.fap_sms)))
          {
            const mobile = User.resolveMobile(user.mobile, currentTimeValue);

            if (mobile)
            {
              smsRecipients.add(mobile);
            }
          }

          if (added)
          {
            app.broker.publish(`fap.entries.notifications.${userId}`, {added});
          }
        });

        if (emailRecipients.size)
        {
          sendNewEmail(entry, [...emailRecipients], this.group());
        }

        if (smsRecipients.size && currentDate - entry.createdAt < 2 * 3600 * 1000)
        {
          sendSms(entry, [...smsRecipients], this.group());
        }
      },
      done
    );
  }

  function sendNewEmail(entry, recipients, done)
  {
    const createdAt = moment(entry.createdAt);
    const hoursOld = Math.abs(createdAt.diff(Date.now(), 'hours'));
    const email = {
      to: recipients,
      replyTo: recipients,
      subject: `[WMES] [FAP] Nowe zgÅ‚oszenie: ${entry.rid}`,
      html: templates.new({
        urlPrefix: app.options.emailUrlPrefix,
        hoursOld: hoursOld >= 1 ? moment.duration(hoursOld * -1, 'hours').humanize(true) : null,
        createdAt: createdAt.format('L LT'),
        entry
      })
    };

    app[module.config.mailSenderId].send(email, (err) =>
    {
      if (err)
      {
        logger.error(err, `Failed to send e-mail.`, {
          template: 'new',
          entry: entry._id,
          recipients
        });
      }

      done();
    });
  }

  function sendUserEmail(entry, user, creator, done)
  {
    const email = {
      to: [user.email],
      replyTo: [user.email],
      subject: `[WMES] [FAP] Wymagana akcja: ${entry.rid}`,
      html: templates.user({
        urlPrefix: app.options.emailUrlPrefix,
        entry,
        creator
      })
    };

    app[module.config.mailSenderId].send(email, (err) =>
    {
      if (err)
      {
        logger.error(err, `Failed to send e-mail.`, {
          template: 'user',
          entry: entry._id,
          recipient: user
        });
      }
      else if (creator)
      {
        lockedNotifications.add(`${entry._id}:${user._id}`);
      }

      done();
    });
  }

  function sendSms(entry, recipients, done)
  {
    const sms = {
      to: recipients,
      text: `FAP: ${entry.rid} (${entry.category}) ${entry.problem.replace(/\s+/g, ' ')}`
    };

    app[module.config.smsSenderId].send(sms, (err) =>
    {
      if (err)
      {
        logger.error(err, `Failed to send SMS.`, {
          entry: entry._id,
          recipients
        });
      }

      done();
    });
  }

  function resolveWatchUsers()
  {
    const watchUsers = new Set();
    const now = moment();
    const date = now.clone();

    if (date.hours() < 6)
    {
      date.subtract(1, 'days');
    }

    const ymd = date.format('YYYY-MM-DD');
    const day = date.isoWeekday();

    mor.state.sections.forEach(section =>
    {
      if (section.mrpsEnabled || !section.watchEnabled)
      {
        return;
      }

      section.watch.forEach(watch =>
      {
        if (watch.days.length && !watch.days.includes(day))
        {
          return;
        }

        const from = moment(`${ymd} ${watch.from}`, 'YYYY-MM-DD HH:mm');
        const to = moment(`${ymd} ${watch.to}`, 'YYYY-MM-DD HH:mm');

        if (from.hours() < 6)
        {
          from.add(1, 'days');
        }

        if (to.hours() < 6)
        {
          to.add(1, 'days');
        }

        if (now.isBetween(from, to))
        {
          watchUsers.add(watch.user);
        }
      });
    });

    return watchUsers;
  }

  function swapSubscribers(entryId, change)
  {
    step(
      function()
      {
        FapEntry
          .findById(entryId)
          .select({
            category: 1,
            subCategory: 1,
            orderNo: 1,
            mrp: 1,
            subdivisions: 1,
            'observers.role': 1,
            'observers.user': 1,
            'changes.user.id': 1
          })
          .lean()
          .exec(this.next());
      },
      function(err, entry)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!entry)
        {
          return this.skip();
        }

        this.entry = entry;

        const oldCategory = change.data.category
          ? change.data.category[0]
          : entry.category;
        const oldSubCategory = change.data.subCategory
          ? change.data.subCategory[0]
          : entry.subCategory;

        FapCategory
          .findById(oldCategory)
          .select({notifications: 1})
          .lean()
          .exec(this.parallel());

        FapSubCategory
          .findById(oldSubCategory)
          .select({notifications: 1})
          .lean()
          .exec(this.parallel());

        const input = {
          date: change.date,
          orderNo: entry.orderNo,
          mrp: entry.mrp,
          category: entry.category,
          subCategory: entry.subCategory
        };

        module.resolveParticipants(input, this.parallel());
      },
      function(err, oldCategory, oldSubCategory, participants)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!oldCategory && !oldSubCategory)
        {
          return this.skip();
        }

        // All old subdivisions
        const subdivisions = new Set(this.entry.subdivisions);

        // Remove old category subdivisions
        (oldCategory ? oldCategory.notifications : []).forEach(n =>
        {
          n.subdivisions.forEach(s => subdivisions.delete(String(s)));
        });

        // Remove old sub-category subdivisions
        (oldSubCategory ? oldSubCategory.notifications : []).forEach(n =>
        {
          n.subdivisions.forEach(s => subdivisions.delete(String(s)));
        });

        // Add new category subdivisions
        participants.subdivisions.forEach(s => subdivisions.add(s));

        const input = {
          date: change.date,
          orderNo: this.entry.orderNo,
          mrp: this.entry.mrp,
          category: this.entry.category,
          subCategory: this.entry.subCategory,
          subdivisions: [...subdivisions]
        };

        module.resolveParticipants(input, this.parallel());

        setImmediate(this.parallel(), null, input.subdivisions);
      },
      function(err, participants, subdivisions)
      {
        if (err)
        {
          return this.skip(err);
        }

        const updaters = new Set();

        this.entry.changes.forEach(c =>
        {
          if (c.user && c.user.id)
          {
            updaters.add(c.user.id);
          }
        });

        const newSubscribers = new Map();

        participants.users.forEach(u =>
        {
          newSubscribers.set(String(u._id), {
            id: String(u._id),
            label: `${u.lastName} ${u.firstName}`
          });
        });

        const unsubscribers = [];

        this.entry.observers.forEach(o =>
        {
          const newSubscriber = newSubscribers.get(o.user.id);

          newSubscribers.delete(o.user.id);

          if (!newSubscriber && o.role === 'subscriber' && !updaters.has(o.user.id))
          {
            unsubscribers.push(o.user);
          }
        });

        const subscribers = Array.from(newSubscribers.values());

        const input = {
          entryId,
          socketId: null,
          data: {
            subdivisions,
            subscribers,
            unsubscribers
          },
          sessionUser: null,
          updater: change.user
        };

        module.editEntry(input, this.next());
      },
      function(err)
      {
        if (err)
        {
          logger.error(err, `Failed to swap subscribers.`, {entry: entryId, change});
        }
      }
    );
  }

  function markOldAsSeen(publish)
  {
    step(
      function()
      {
        this.lastSeenAt = moment().startOf('day').subtract(7, 'days').toDate();

        const conditions = {
          createdAt: {$lt: moment().startOf('day').subtract(14, 'days').toDate()},
          observers: {$elemMatch: {
            notify: true,
            lastSeenAt: {$lt: this.lastSeenAt}
          }}
        };
        const fields = {
          observers: 1
        };

        FapEntry.find(conditions).select(fields).lean().exec(this.next());
      },
      function(err, entries)
      {
        if (err)
        {
          return this.skip(err);
        }

        this.entryCount = entries.length;

        markNextAsSeen(entries, this.lastSeenAt.getTime(), {}, this.next());
      },
      function(err, usersToNotify)
      {
        if (err)
        {
          logger.error(err, `Failed to mark old entries as seen.`);
        }
        else
        {
          const userIds = Object.keys(usersToNotify);

          if (publish)
          {
            userIds.forEach(userId =>
            {
              app.broker.publish(`fap.entries.notifications.${userId}`, {
                seen: usersToNotify[userId]
              });
            });
          }

          logger.debug(`Marked old entries as seen.`, {
            entryCount: this.entryCount,
            userCount: userIds.length
          });
        }

        setTimeout(
          markOldAsSeen,
          moment().startOf('day').add(24, 'hours').valueOf() - Date.now() + 30000,
          true
        );
      }
    );
  }

  function markNextAsSeen(entries, lastSeenAtLimit, usersToNotify, done)
  {
    if (entries.length === 0)
    {
      return done(null, usersToNotify);
    }

    const entry = entries.shift();

    step(
      function()
      {
        this.unlockEntry = module.lockEntry(entry._id, this.next());
      },
      function()
      {
        const $set = {};
        let anyChanges = false;

        entry.observers.forEach((o, i) =>
        {
          if (o.lastSeenAt > lastSeenAtLimit)
          {
            return;
          }

          anyChanges = true;

          $set[`observers.${i}.notify`] = false;
          $set[`observers.${i}.changes`] = {};

          if (!usersToNotify[o.user.id])
          {
            usersToNotify[o.user.id] = [];
          }

          usersToNotify[o.user.id].push(entry._id);
        });

        if (!anyChanges)
        {
          return;
        }

        FapEntry.collection.updateOne({_id: entry._id}, {$set}, this.next());
      },
      function(err)
      {
        this.unlockEntry();

        if (err)
        {
          return this.skip(err);
        }

        setImmediate(markNextAsSeen, entries, lastSeenAtLimit, usersToNotify, done);
      }
    );
  }

  function sendChangedNotifications(changed, userIds)
  {
    step(
      function()
      {
        FapEntry
          .findById(changed._id)
          .select({unsubscribed: 1})
          .lean()
          .exec(this.next());
      },
      function(err, entry)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!entry)
        {
          return this.skip();
        }

        userIds.forEach(userId =>
        {
          app.broker.publish(`fap.entries.notifications.${userId}`, {
            changed: Object.assign({unsubscribed: !!entry.unsubscribed[userId]}, changed)
          });
        });
      }
    );
  }

  function scheduleUserNotification(entryId, userId, creator)
  {
    if (typeof entryId !== 'string')
    {
      entryId = String(entryId);
    }

    if (!pendingNotifications.has(entryId))
    {
      pendingNotifications.set(entryId, new Map());
    }

    const entryNotifications = pendingNotifications.get(entryId);

    if (!entryNotifications.has(userId))
    {
      entryNotifications.set(userId, {
        entryId,
        userId,
        ts: null,
        creator,
        timer: null
      });
    }

    const userNotification = entryNotifications.get(userId);

    userNotification.ts = new Date();

    if (!creator)
    {
      userNotification.creator = false;
    }

    clearTimeout(userNotification.timer);
    userNotification.timer = setTimeout(notifyUser, (userNotification.creator ? 60 : 30) * 1000, entryId, userId);
  }

  async function scheduleUserNotifications(entryId, updaterId, comment)
  {
    const userLabels = Array.from(comment.matchAll(/ðŸ‘¤(.*?)(?:[, ]|$)/g)).map(
      m => m[1].replace(/[.()\[\]]+$/, '').replace(/\u00A0/g, ' ')
    );

    if (!userLabels.length)
    {
      return;
    }

    try
    {
      const pipeline = [
        {$match: {_id: entryId}},
        {$unwind: '$observers'},
        {$match: {'observers.user.label': {$in: userLabels}}},
        {$group: {
          _id: null,
          userIds: {$addToSet: '$observers.user.id'}
        }}
      ];

      const result = await FapEntry.aggregate(pipeline).exec();

      if (!result.length)
      {
        return;
      }

      const {userIds} = result[0];

      userIds.forEach(userId =>
      {
        if (userId !== updaterId)
        {
          scheduleUserNotification(entryId, userId, false);
        }
      });
    }
    catch (err)
    {
      logger.error(err, 'Failed to find observers by user label.');
    }
  }

  function clearPendingNotification(entryId, userId)
  {
    if (typeof entryId !== 'string')
    {
      entryId = String(entryId);
    }

    lockedNotifications.delete(`${entryId}:${userId}`);

    const entryNotifications = pendingNotifications.get(entryId);

    if (!entryNotifications)
    {
      return null;
    }

    const userNotification = entryNotifications.get(userId);

    if (!userNotification)
    {
      return null;
    }

    clearTimeout(userNotification.timer);
    userNotification.timer = null;

    entryNotifications.delete(userId);

    if (!entryNotifications.size)
    {
      pendingNotifications.delete(entryId);
    }

    return userNotification;
  }

  function notifyUser(entryId, userId)
  {
    const userNotification = clearPendingNotification(entryId, userId);

    if (!userNotification
      || !app[module.config.mailSenderId]
      || module.isUserPresent(entryId, userId))
    {
      return;
    }

    if (userNotification.creator && lockedNotifications.has(`${entryId}:${userId}`))
    {
      return;
    }

    step(
      function()
      {
        const conditions = {
          _id: entryId
        };

        if (userNotification.creator)
        {
          conditions.observers = {
            $elemMatch: {
              'user.id': userId,
              lastSeenAt: {$lt: userNotification.ts}
            }
          };
        }

        FapEntry
          .findOne(conditions)
          .select({
            rid: 1,
            problem: 1,
            'changes.date': 1,
            'changes.user': 1,
            'changes.comment': 1
          })
          .lean()
          .exec(this.parallel());

        User
          .findById(userId)
          .select({email: 1})
          .lean()
          .exec(this.parallel());
      },
      function(err, entry, user)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!entry || !user || !user.email || !user.email.includes('@'))
        {
          return this.skip();
        }

        const changes = [];

        entry.changes.forEach(change =>
        {
          if (!change.comment)
          {
            return;
          }

          const prev = _.last(changes);

          if (prev && prev.user.id === change.user.id)
          {
            prev.comment += '\n' + change.comment;
          }
          else
          {
            changes.push(change);
          }
        });

        entry.changes = changes;

        sendUserEmail(entry, user, userNotification.creator, this.next());
      },
      function(err)
      {
        if (err)
        {
          module.error(err, 'Failed to notify creator.', {
            entryId,
            userId
          });
        }
      }
    );
  }
};
