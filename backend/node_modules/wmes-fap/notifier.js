// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const fs = require('fs');
const step = require('h5.step');
const ejs = require('ejs');
const moment = require('moment');
const transliteration = require('transliteration');

module.exports = (app, module) =>
{
  const {mor, User, FapEntry, FapCategory} = module;
  const logger = module.logger.create({submodule: 'notifier'});

  const emailTemplateFile = `${__dirname}/templates/notifier.email.pl.ejs`;
  const renderEmail = ejs.compile(fs.readFileSync(emailTemplateFile, 'utf8'), {
    cache: true,
    filename: emailTemplateFile,
    compileDebug: false,
    rmWhitespace: true
  });

  app.broker.subscribe('fap.entries.added', onEntryAdded);

  app.broker.subscribe('fap.entries.updated.*', onEntryUpdated);

  function onEntryAdded(message)
  {
    const entry = message.model.toJSON();
    const usersToNotify = entry.observers
      .map(o => o.user.id.toString())
      .filter(id => id !== entry.creator.id.toString());

    notify(entry, usersToNotify, (err) =>
    {
      if (err)
      {
        logger.error(err, `Failed to notify after add.`, {entry: entry._id});
      }
    });
  }

  function onEntryUpdated({_id, change})
  {
    if (change.data.category || change.data.orderNo)
    {
      swapSubscribers(_id, change);
    }

    const subscribers = change.data.subscribers;

    if (!subscribers || subscribers[0] || !subscribers[1])
    {
      return;
    }

    const usersToNotify = subscribers[1].map(s => s.id).filter(id => id !== change.user.id);

    if (!usersToNotify.length)
    {
      return;
    }

    step(
      function()
      {
        FapEntry.findById(_id).select({changes: 0, observers: 0}).lean().exec(this.next());
      },
      function(err, entry)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!entry)
        {
          return this.skip();
        }

        notify(entry, usersToNotify, this.next());
      },
      function(err)
      {
        if (err)
        {
          logger.error(err, `Failed to notify after update.`, {entry: _id});
        }
      }
    );
  }

  function notify(entry, usersToNotify, done)
  {
    step(
      function()
      {
        FapCategory
          .findById(entry.category, {name: 1})
          .lean()
          .exec(this.parallel());

        User
          .find({_id: {$in: usersToNotify}})
          .select({
            email: 1,
            mobile: 1,
            'preferences.fap_sms': 1
          })
          .lean()
          .exec(this.parallel());
      },
      function(err, category, users)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (category)
        {
          entry.category = category.name;
        }

        const emailRecipients = new Set();
        const smsRecipients = new Set();
        const watchUsers = resolveWatchUsers();
        const currentDate = new Date();
        const currentTimeValue = currentDate.getHours() * 1000 + currentDate.getMinutes();

        users.forEach(user =>
        {
          const userId = user._id.toString();

          if (app[module.config.mailSenderId] && user.email)
          {
            emailRecipients.add(user.email);
          }

          if (app[module.config.smsSenderId]
            && (watchUsers.has(userId) || (user.preferences && user.preferences.fap_sms)))
          {
            const mobile = resolveMobile(user._id, user.mobile, currentTimeValue);

            if (mobile)
            {
              smsRecipients.add(mobile);
            }
          }
        });

        if (emailRecipients.size)
        {
          sendEmail(entry, [...emailRecipients], this.group());
        }

        if (smsRecipients.size)
        {
          sendSms(entry, [...smsRecipients], this.group());
        }
      },
      done
    );
  }

  function sendEmail(entry, recipients, done)
  {
    const email = {
      to: recipients,
      replyTo: recipients,
      subject: `[WMES] [FAP] Nowe zgÅ‚oszenie: ${entry.rid}`,
      html: renderEmail({
        urlPrefix: app.options.emailUrlPrefix,
        entry
      })
    };

    app[module.config.mailSenderId].send(email, (err) =>
    {
      if (err)
      {
        logger.error(err, `Failed to send e-mail.`, {
          entry: entry._id,
          recipients
        });
      }

      done();
    });
  }

  function sendSms(entry, recipients, done)
  {
    const category = transliteration.transliterate(entry.category, {unknown: '?'});
    const sms = {
      to: recipients,
      text: `Nowy FAP: ${entry.rid} (${category})`
    };

    app[module.config.smsSenderId].send(sms, (err) =>
    {
      if (err)
      {
        logger.error(err, `Failed to send SMS.`, {
          entry: entry._id,
          recipients
        });
      }

      done();
    });
  }

  function resolveWatchUsers()
  {
    const watchUsers = new Set();
    const now = moment();
    const date = now.clone();

    if (date.hours() < 6)
    {
      date.subtract(1, 'days');
    }

    const ymd = date.format('YYYY-MM-DD');
    const day = date.isoWeekday();

    mor.state.sections.forEach(section =>
    {
      if (section.mrpsEnabled || !section.watchEnabled)
      {
        return;
      }

      section.watch.forEach(watch =>
      {
        if (watch.days.length && !watch.days.includes(day))
        {
          return;
        }

        const from = moment(`${ymd} ${watch.from}`, 'YYYY-MM-DD HH:mm');
        const to = moment(`${ymd} ${watch.to}`, 'YYYY-MM-DD HH:mm');

        if (from.hours() < 6)
        {
          from.add(1, 'days');
        }

        if (to.hours() < 6)
        {
          to.add(1, 'days');
        }

        if (now.isBetween(from, to))
        {
          watchUsers.add(watch.user);
        }
      });
    });

    return watchUsers;
  }

  function resolveMobile(userId, mobileList, currentTimeValue)
  {
    if (!mobileList || !mobileList.length)
    {
      return null;
    }

    const mobile = mobileList.find((mobile) =>
    {
      const fromTime = parseMobileTime(mobile.fromTime);
      const toTime = parseMobileTime(mobile.toTime === '00:00' ? '24:00' : mobile.toTime);
      let match = false;

      if (toTime.value < fromTime.value)
      {
        match = currentTimeValue < toTime.value || currentTimeValue >= fromTime.value;
      }
      else if (fromTime.value < toTime.value)
      {
        match = currentTimeValue >= fromTime.value && currentTimeValue < toTime.value;
      }

      return match;
    });

    return mobile ? mobile.number : null;
  }

  function parseMobileTime(time)
  {
    const parts = time.split(':');
    const hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);

    return {
      hours,
      minutes,
      value: hours * 1000 + minutes
    };
  }

  function swapSubscribers(entryId, change)
  {
    step(
      function()
      {
        FapEntry.findById(entryId).lean().exec(this.next());
      },
      function(err, entry)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!entry)
        {
          return this.skip();
        }

        this.entry = entry;

        const oldCategory = change.data.category
          ? change.data.category[0]
          : entry.category;

        FapCategory.findById(oldCategory).select({notifications: 1}).lean().exec(this.parallel());

        const input = {
          date: change.date,
          orderNo: entry.orderNo,
          mrp: entry.mrp,
          category: entry.category
        };

        module.resolveParticipants(input, this.parallel());
      },
      function(err, oldCategory, result)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!oldCategory)
        {
          return this.skip();
        }

        // All old subdivisions
        const subdivisions = new Set(this.entry.subdivisions);

        // Remove old category subdivisions
        oldCategory.notifications.forEach(n =>
        {
          n.subdivisions.forEach(s => subdivisions.delete(s));
        });

        // Add new category subdivisions
        result.subdivisions.forEach(s => subdivisions.add(s));

        this.entry.subdivisions = [...subdivisions];

        const input = {
          date: change.date,
          orderNo: this.entry.orderNo,
          mrp: this.entry.mrp,
          category: this.entry.category,
          subdivisions: this.entry.subdivisions
        };

        module.resolveParticipants(input, this.next());
      },
      function(err, result)
      {
        if (err)
        {
          return this.skip(err);
        }

        const updaters = new Set();

        this.entry.changes.forEach(c =>
        {
          updaters.add(c.user.id);
        });

        const newSubscribers = new Map();

        result.users.forEach(u =>
        {
          newSubscribers.set(String(u._id), {
            id: String(u._id),
            label: `${u.lastName} ${u.firstName}`
          });
        });

        this.toRemove = [];

        this.entry.observers.forEach(o =>
        {
          const newSubscriber = newSubscribers.get(o.user.id);

          newSubscribers.delete(o.user.id);

          if (!newSubscriber && o.role === 'subscriber' && !updaters.has(o.user.id))
          {
            this.toRemove.push(o.user);
          }
        });

        this.toAdd = Array.from(newSubscribers.values());

        setImmediate(this.next());
      },
      function()
      {
        if (!this.toRemove.length)
        {
          return;
        }

        this.change = {
          date: change.date,
          user: change.user,
          data: {
            subscribers: [this.toRemove, null]
          },
          comment: ''
        };

        const update = {
          $pull: {
            observers: {
              'user.id': {
                $in: this.toRemove.map(u => u.id)
              }
            }
          },
          $push: {
            changes: this.change
          },
          $set: {
            subdivisions: this.entry.subdivisions
          }
        };

        FapEntry.updateOne({_id: entryId}, update, this.next());
      },
      function(err)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (this.change)
        {
          app.broker.publish(`fap.entries.updated.${entryId}`, {
            socketId: null,
            _id: entryId,
            change: this.change,
            notify: {}
          });
        }

        this.change = null;
      },
      function()
      {
        if (!this.toAdd.length)
        {
          return;
        }

        this.change = {
          date: change.date,
          user: change.user,
          data: {
            subscribers: [null, this.toAdd]
          },
          comment: ''
        };

        const update = {
          $push: {
            changes: this.change,
            observers: {$each: FapEntry.prepareSubscribers(this.toAdd)}
          },
          $set: {
            subdivisions: this.entry.subdivisions
          }
        };

        FapEntry.updateOne({_id: entryId}, update, this.next());
      },
      function(err)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (this.change)
        {
          app.broker.publish(`fap.entries.updated.${entryId}`, {
            socketId: null,
            _id: entryId,
            change: this.change,
            notify: {}
          });
        }
      },
      function(err)
      {
        if (err)
        {
          logger.error(err, `Failed to swap subscribers.`, {entry: entryId, change});
        }
      }
    );
  }
};
