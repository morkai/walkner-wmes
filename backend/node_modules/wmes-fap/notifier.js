// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const fs = require('fs');
const step = require('h5.step');
const ejs = require('ejs');
const moment = require('moment');
const transliteration = require('transliteration');

module.exports = (app, module) =>
{
  const {mor, User, FapEntry, FapCategory} = module;
  const logger = module.logger.create({submodule: 'notifier'});

  const emailTemplateFile = `${__dirname}/templates/notifier.email.pl.ejs`;
  const renderEmail = ejs.compile(fs.readFileSync(emailTemplateFile, 'utf8'), {
    cache: true,
    filename: emailTemplateFile,
    compileDebug: false,
    rmWhitespace: true
  });

  app.broker.subscribe('fap.entries.added', onEntryAdded);

  app.broker.subscribe('fap.entries.deleted', onEntryDeleted);

  app.broker.subscribe('fap.entries.updated.*', onEntryUpdated);

  app.broker.subscribe('app.started', () => markOldAsSeen(false)).setLimit(1);

  function onEntryAdded({model})
  {
    const entry = model.toJSON();
    const usersToNotify = entry.observers
      .map(o => o.user.id.toString())
      .filter(id => id !== entry.creator.id.toString());

    notify(entry, usersToNotify, (err) =>
    {
      if (err)
      {
        logger.error(err, `Failed to notify after add.`, {entry: entry._id});
      }
    });
  }

  function onEntryDeleted({model})
  {
    model.observers.forEach(o =>
    {
      if (o.notify)
      {
        app.broker.publish(`fap.entries.notifications.${o.user.id}`, {
          removed: [model._id]
        });
      }
    });
  }

  function onEntryUpdated(message)
  {
    const {change} = message;

    if (change.data.category || change.data.orderNo)
    {
      swapSubscribers(message._id, change);
    }

    if (message.notify)
    {
      const changed = {
        _id: message._id,
        rid: message.rid,
        updater: change.user.label,
        comment: change.comment
      };

      sendChangedNotifications(changed, Object.keys(message.notify));

      app.broker.publish(`fap.entries.notifications.${change.user.id}`, {
        seen: [message._id]
      });
    }

    const subscribers = change.data.subscribers$added || change.data.subscribers;

    if (!subscribers || subscribers[0] || !subscribers[1])
    {
      return;
    }

    const usersToNotify = subscribers[1].map(s => s.id).filter(id => id !== change.user.id);

    if (!usersToNotify.length)
    {
      return;
    }

    step(
      function()
      {
        FapEntry
          .findById(message._id)
          .select({
            changes: 0,
            observers: 0,
            attachments: 0,
            unsubscribed: 0
          })
          .lean()
          .exec(this.next());
      },
      function(err, entry)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!entry)
        {
          return this.skip();
        }

        notify(entry, usersToNotify, this.next());
      },
      function(err)
      {
        if (err)
        {
          logger.error(err, `Failed to notify after update.`, {entry: message._id});
        }
      }
    );
  }

  function notify(entry, usersToNotify, done)
  {
    step(
      function()
      {
        FapCategory
          .findById(entry.category, {name: 1})
          .lean()
          .exec(this.parallel());

        User
          .find({_id: {$in: usersToNotify}})
          .select({
            email: 1,
            mobile: 1,
            'preferences.fap_sms': 1
          })
          .lean()
          .exec(this.parallel());
      },
      function(err, category, users)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (category)
        {
          entry.category = category.name;
        }

        const emailRecipients = new Set();
        const smsRecipients = new Set();
        const watchUsers = resolveWatchUsers();
        const currentDate = new Date();
        const currentTimeValue = currentDate.getHours() * 1000 + currentDate.getMinutes();
        const added = !entry.changes || entry.changes.length > 0 ? null : {
          _id: entry._id,
          rid: entry.rid,
          owner: entry.owner.label,
          category: entry.category,
          problem: entry.problem
        };

        users.forEach(user =>
        {
          const userId = user._id.toString();

          if (app[module.config.mailSenderId] && user.email)
          {
            emailRecipients.add(user.email);
          }

          if (app[module.config.smsSenderId]
            && (watchUsers.has(userId) || (user.preferences && user.preferences.fap_sms)))
          {
            const mobile = resolveMobile(user._id, user.mobile, currentTimeValue);

            if (mobile)
            {
              smsRecipients.add(mobile);
            }
          }

          if (added)
          {
            app.broker.publish(`fap.entries.notifications.${userId}`, {added});
          }
        });

        if (emailRecipients.size)
        {
          sendEmail(entry, [...emailRecipients], this.group());
        }

        if (smsRecipients.size)
        {
          sendSms(entry, [...smsRecipients], this.group());
        }
      },
      done
    );
  }

  function sendEmail(entry, recipients, done)
  {
    const email = {
      to: recipients,
      replyTo: recipients,
      subject: `[WMES] [FAP] Nowe zgÅ‚oszenie: ${entry.rid}`,
      html: renderEmail({
        urlPrefix: app.options.emailUrlPrefix,
        entry
      })
    };

    app[module.config.mailSenderId].send(email, (err) =>
    {
      if (err)
      {
        logger.error(err, `Failed to send e-mail.`, {
          entry: entry._id,
          recipients
        });
      }

      done();
    });
  }

  function sendSms(entry, recipients, done)
  {
    const category = transliteration.transliterate(entry.category, {unknown: '?'});
    const sms = {
      to: recipients,
      text: `Nowy FAP: ${entry.rid} (${category})`
    };

    app[module.config.smsSenderId].send(sms, (err) =>
    {
      if (err)
      {
        logger.error(err, `Failed to send SMS.`, {
          entry: entry._id,
          recipients
        });
      }

      done();
    });
  }

  function resolveWatchUsers()
  {
    const watchUsers = new Set();
    const now = moment();
    const date = now.clone();

    if (date.hours() < 6)
    {
      date.subtract(1, 'days');
    }

    const ymd = date.format('YYYY-MM-DD');
    const day = date.isoWeekday();

    mor.state.sections.forEach(section =>
    {
      if (section.mrpsEnabled || !section.watchEnabled)
      {
        return;
      }

      section.watch.forEach(watch =>
      {
        if (watch.days.length && !watch.days.includes(day))
        {
          return;
        }

        const from = moment(`${ymd} ${watch.from}`, 'YYYY-MM-DD HH:mm');
        const to = moment(`${ymd} ${watch.to}`, 'YYYY-MM-DD HH:mm');

        if (from.hours() < 6)
        {
          from.add(1, 'days');
        }

        if (to.hours() < 6)
        {
          to.add(1, 'days');
        }

        if (now.isBetween(from, to))
        {
          watchUsers.add(watch.user);
        }
      });
    });

    return watchUsers;
  }

  function resolveMobile(userId, mobileList, currentTimeValue)
  {
    if (!mobileList || !mobileList.length)
    {
      return null;
    }

    const mobile = mobileList.find((mobile) =>
    {
      const fromTime = parseMobileTime(mobile.fromTime);
      const toTime = parseMobileTime(mobile.toTime === '00:00' ? '24:00' : mobile.toTime);
      let match = false;

      if (toTime.value < fromTime.value)
      {
        match = currentTimeValue < toTime.value || currentTimeValue >= fromTime.value;
      }
      else if (fromTime.value < toTime.value)
      {
        match = currentTimeValue >= fromTime.value && currentTimeValue < toTime.value;
      }

      return match;
    });

    return mobile ? mobile.number : null;
  }

  function parseMobileTime(time)
  {
    const parts = time.split(':');
    const hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);

    return {
      hours,
      minutes,
      value: hours * 1000 + minutes
    };
  }

  function swapSubscribers(entryId, change)
  {
    step(
      function()
      {
        FapEntry
          .findById(entryId)
          .select({
            category: 1,
            orderNo: 1,
            mrp: 1,
            subdivisions: 1,
            'observers.role': 1,
            'observers.user': 1,
            'changes.user.id': 1
          })
          .lean()
          .exec(this.next());
      },
      function(err, entry)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!entry)
        {
          return this.skip();
        }

        this.entry = entry;

        const oldCategory = change.data.category
          ? change.data.category[0]
          : entry.category;

        FapCategory
          .findById(oldCategory)
          .select({notifications: 1})
          .lean()
          .exec(this.parallel());

        const input = {
          date: change.date,
          orderNo: entry.orderNo,
          mrp: entry.mrp,
          category: entry.category
        };

        module.resolveParticipants(input, this.parallel());
      },
      function(err, oldCategory, participants)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!oldCategory)
        {
          return this.skip();
        }

        // All old subdivisions
        const subdivisions = new Set(this.entry.subdivisions);

        // Remove old category subdivisions
        oldCategory.notifications.forEach(n =>
        {
          n.subdivisions.forEach(s => subdivisions.delete(String(s)));
        });

        // Add new category subdivisions
        participants.subdivisions.forEach(s => subdivisions.add(s));

        const input = {
          date: change.date,
          orderNo: this.entry.orderNo,
          mrp: this.entry.mrp,
          category: this.entry.category,
          subdivisions: [...subdivisions]
        };

        module.resolveParticipants(input, this.parallel());

        setImmediate(this.parallel(), null, input.subdivisions);
      },
      function(err, participants, subdivisions)
      {
        if (err)
        {
          return this.skip(err);
        }

        const updaters = new Set();

        this.entry.changes.forEach(c =>
        {
          if (c.user && c.user.id)
          {
            updaters.add(c.user.id);
          }
        });

        const newSubscribers = new Map();

        participants.users.forEach(u =>
        {
          newSubscribers.set(String(u._id), {
            id: String(u._id),
            label: `${u.lastName} ${u.firstName}`
          });
        });

        const unsubscribers = [];

        this.entry.observers.forEach(o =>
        {
          const newSubscriber = newSubscribers.get(o.user.id);

          newSubscribers.delete(o.user.id);

          if (!newSubscriber && o.role === 'subscriber' && !updaters.has(o.user.id))
          {
            unsubscribers.push(o.user);
          }
        });

        const subscribers = Array.from(newSubscribers.values());

        const input = {
          entryId,
          socketId: null,
          data: {
            subdivisions,
            subscribers,
            unsubscribers
          },
          sessionUser: null,
          updater: change.user
        };

        module.editEntry(input, this.next());
      },
      function(err)
      {
        if (err)
        {
          logger.error(err, `Failed to swap subscribers.`, {entry: entryId, change});
        }
      }
    );
  }

  function markOldAsSeen(publish)
  {
    step(
      function()
      {
        this.lastSeenAt = moment().startOf('day').subtract(7, 'days').toDate();

        const conditions = {
          createdAt: {$lt: moment().startOf('day').subtract(14, 'days').toDate()},
          observers: {$elemMatch: {
            notify: true,
            lastSeenAt: {$lt: this.lastSeenAt}
          }}
        };
        const fields = {
          observers: 1
        };

        FapEntry.find(conditions).select(fields).lean().exec(this.next());
      },
      function(err, entries)
      {
        if (err)
        {
          return this.skip(err);
        }

        this.entryCount = entries.length;

        markNextAsSeen(entries, this.lastSeenAt.getTime(), {}, this.next());
      },
      function(err, usersToNotify)
      {
        if (err)
        {
          logger.error(err, `Failed to mark old entries as seen.`);
        }
        else
        {
          const userIds = Object.keys(usersToNotify);

          if (publish)
          {
            userIds.forEach(userId =>
            {
              app.broker.publish(`fap.entries.notifications.${userId}`, {
                seen: usersToNotify[userId]
              });
            });
          }

          logger.debug(`Marked old entries as seen.`, {
            entryCount: this.entryCount,
            userCount: userIds.length
          });
        }

        setTimeout(
          markOldAsSeen,
          moment().startOf('day').add(24, 'hours').valueOf() - Date.now() + 30000,
          true
        );
      }
    );
  }

  function markNextAsSeen(entries, lastSeenAtLimit, usersToNotify, done)
  {
    if (entries.length === 0)
    {
      return done(null, usersToNotify);
    }

    const entry = entries.shift();

    step(
      function()
      {
        this.unlockEntry = module.lockEntry(entry._id, this.next());
      },
      function()
      {
        const $set = {};
        let anyChanges = false;

        entry.observers.forEach((o, i) =>
        {
          if (o.lastSeenAt > lastSeenAtLimit)
          {
            return;
          }

          anyChanges = true;

          $set[`observers.${i}.notify`] = false;
          $set[`observers.${i}.changes`] = {};

          if (!usersToNotify[o.user.id])
          {
            usersToNotify[o.user.id] = [];
          }

          usersToNotify[o.user.id].push(entry._id);
        });

        if (!anyChanges)
        {
          return;
        }

        FapEntry.collection.updateOne({_id: entry._id}, {$set}, this.next());
      },
      function(err)
      {
        if (err)
        {
          return this.skip(err);
        }

        setImmediate(markNextAsSeen, entries, lastSeenAtLimit, usersToNotify, done);
      }
    );
  }

  function sendChangedNotifications(changed, userIds)
  {
    step(
      function()
      {
        FapEntry
          .findById(changed._id)
          .select({unsubscribed: 1})
          .lean()
          .exec(this.next());
      },
      function(err, entry)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!entry)
        {
          return this.skip();
        }

        userIds.forEach(userId =>
        {
          app.broker.publish(`fap.entries.notifications.${userId}`, {
            changed: Object.assign({unsubscribed: !!entry.unsubscribed[userId]}, changed)
          });
        });
      }
    );
  }
};
