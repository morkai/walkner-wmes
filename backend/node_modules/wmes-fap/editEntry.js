// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');

module.exports = (app, module, input, done) =>
{
  const {user, FapEntry} = module;

  const updatedAt = new Date();
  const {entryId, socketId, data, updater} = input;
  const sessionUser = input.sessionUser || user.root;

  if (!_.isPlainObject(data))
  {
    return done(app.createError(`Invalid data.`, 'INPUT', 400));
  }

  if (Array.isArray(data.attachments))
  {
    data.attachments.forEach(attachment =>
    {
      const upload = module.tmpAttachments[attachment._id];

      if (upload)
      {
        attachment.date = updatedAt;
        attachment.user = updater;
        attachment.type = upload.data.type;
        attachment.size = upload.data.size;

        clearTimeout(upload.timer);

        delete module.tmpAttachments[attachment._id];
      }
    });
  }

  step(
    function()
    {
      this.unlockEntry = module.lockEntry(entryId, this.next());
    },
    function()
    {
      if (_.isEmpty(data))
      {
        markAsSeen(this.next());
      }
      else
      {
        edit(this.next());
      }
    },
    function(err)
    {
      done(err);

      this.unlockEntry();
    }
  );

  function edit(done)
  {
    step(
      function()
      {
        FapEntry.findById(entryId).exec(this.next());
      },
      function(err, entry)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!entry)
        {
          return this.skip(app.createError(`Entry not found.`, 'NOT_FOUND', 404));
        }

        const canManage = user.isAllowedTo(sessionUser, 'FAP:MANAGE');
        const isUser = user.isAllowedTo(sessionUser, 'USER');
        const isProcessEngineer = user.isAllowedTo(sessionUser, [['FN:process-engineer'], ['FN:process-engineer-NPI']]);
        const isDesigner = user.isAllowedTo(sessionUser, [['FN:designer'], ['FN:designer_eto']]);
        const isMaster = user.isAllowedTo(sessionUser, 'FN:master');
        const isLeader = user.isAllowedTo(sessionUser, 'FN:leader');
        const isWhman = user.isAllowedTo(sessionUser, [['FN:whman'], ['FN:prod_whman'], ['FN:in_whman']]);
        const isAnalyzer = entry.analyzers.some(u => sessionUser._id === u.id);
        const isMainAnalyzer = isAnalyzer && entry.analyzers[0].id === sessionUser._id;
        const isWh = entry.subdivisionType === 'wh';
        const props = ['comment'];

        if (canManage)
        {
          props.push('subdivisions');
        }

        if (isUser)
        {
          props.push('subscribers', 'unsubscribers', 'attachments', 'unsubscribed');
        }

        if (canManage || isProcessEngineer || isDesigner || isMaster || isLeader || (isWh && isWhman))
        {
          props.push(
            'status',
            'problem',
            'solution',
            'subdivisionType',
            'componentCode',
            'componentName'
          );
        }

        if (canManage || isProcessEngineer || isDesigner)
        {
          props.push(
            'category',
            'divisions',
            'lines',
            'orderNo',
            'mrp',
            'nc12',
            'productName',
            'qtyTodo',
            'qtyDone'
          );
        }

        if (canManage || isProcessEngineer || isMaster)
        {
          props.push('assessment', 'analysisNeed', 'analysisDone');
        }

        if (canManage || isProcessEngineer || isMaster || isMainAnalyzer)
        {
          props.push('analyzers');
        }

        if (canManage || isProcessEngineer || isMaster || isLeader || isAnalyzer)
        {
          props.push('why5', 'solutionSteps');
        }

        const input = _.pick(data, props);

        input.subscribers = FapEntry.prepareSubscribers(input.subscribers);

        setImmediate(this.parallel(), null, entry);
        setImmediate(this.parallel(), null, input);

        if (entry.status === 'pending' && input.status === 'started')
        {
          resolveRemainingSubscribers(entry, input, this.parallel());
        }
      },
      function(err, entry, input)
      {
        if (err)
        {
          return this.skip(err);
        }

        const usersToNotify = entry.applyChanges(input, updater, updatedAt);

        if (usersToNotify)
        {
          entry.save(this.parallel());

          setImmediate(this.parallel(), null, usersToNotify);
        }
      },
      function(err, entry, notify)
      {
        if (entry)
        {
          app.broker.publish(`fap.entries.updated.${entry._id}`, {
            socketId,
            _id: entry._id,
            rid: entry.rid,
            change: _.last(entry.changes),
            notify
          });
        }

        done(err);
      }
    );
  }

  function markAsSeen(done)
  {
    if (!updater || !updater.id)
    {
      return done();
    }

    FapEntry.markAsSeen(entryId, updater.id, (err, seen) =>
    {
      if (!err)
      {
        app.broker.publish(`fap.entries.notifications.${updater.id}`, {seen});
      }

      done(err);
    });
  }

  function resolveRemainingSubscribers(entry, input, done)
  {
    module.resolveParticipants(entry, (err, result) =>
    {
      if (err)
      {
        return done(err);
      }

      if (!result.users.length)
      {
        return done();
      }

      if (!Array.isArray(input.subscribers))
      {
        input.subscribers = [];
      }

      const participants = new Set();

      input.subscribers.forEach(s => participants.add(String(s.id)));

      entry.observers.forEach(o => participants.add(String(o.user.id)));

      const subscribers = result.users.filter(u => !participants.has(String(u._id))).map(u => ({
        id: String(u._id),
        label: `${u.lastName} ${u.firstName}`
      }));

      if (subscribers.length)
      {
        input.subscribers = input.subscribers.concat(FapEntry.prepareSubscribers(subscribers));
      }

      done();
    });
  }
};
