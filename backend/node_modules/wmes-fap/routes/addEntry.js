// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const step = require('h5.step');
const _ = require('lodash');

module.exports = (app, module, req, res, next) =>
{
  const {user, settings, express, FapEntry} = module;

  const sessionUser = req.session.user;
  const entry = new FapEntry(_.pick(req.body, [
    'level',
    'subdivisionType',
    'owner',
    'orderNo',
    'componentCode',
    'componentName',
    'category',
    'subCategory',
    'problem',
    'divisions',
    'lines',
    'subdivisions'
  ]));

  entry.creator = user.createUserInfo(sessionUser, req);
  entry.createdAt = new Date();
  entry.updater = entry.creator;
  entry.updatedAt = entry.createdAt;

  if (sessionUser.loggedIn || !entry.owner || !entry.owner.id)
  {
    entry.owner = entry.creator;
  }

  if (!Array.isArray(entry.divisions))
  {
    entry.divisions = [];
  }

  if (!Array.isArray(entry.lines))
  {
    entry.lines = [];
  }

  entry.finishedAt = null;
  entry.solver = null;
  entry.analysisStartedAt = null;
  entry.analysisFinishedAt = null;
  entry.analyzers = [];
  entry.why5 = ['', '', '', '', ''];
  entry.attachments = [];
  entry.unsubscribed = {};
  entry.subdivisions = [];
  entry.changes = [];

  if (Array.isArray(req.body.files))
  {
    req.body.files.forEach(file =>
    {
      const attachment = module.tmpAttachments[file._id];

      if (!attachment)
      {
        return;
      }

      entry.attachments.push({
        _id: file._id,
        date: entry.createdAt,
        user: entry.owner,
        type: attachment.data.type,
        size: attachment.data.size,
        name: file.name
      });

      clearTimeout(attachment.timer);

      delete module.tmpAttachments[file._id];
    });
  }

  step(
    function()
    {
      settings.findById('fap.pendingFunctions', this.parallel());

      entry.updateOrderData(this.parallel());
    },
    function(err, pendingFunctions)
    {
      if (err)
      {
        return this.skip(err);
      }

      if (sessionUser.privileges.includes('SUPER'))
      {
        entry.status = 'started';
      }
      else if (!sessionUser.prodFunction && !sessionUser.privileges.length)
      {
        entry.status = 'pending';
      }
      else if (!pendingFunctions)
      {
        entry.status = 'started';
      }
      else if (pendingFunctions.value.includes(sessionUser.prodFunction))
      {
        entry.status = 'pending';
      }
      else
      {
        entry.status = 'started';
      }

      entry.startedAt = entry.status === 'started' ? entry.createdAt : null;

      if (entry.level > 0)
      {
        resolveParticipants(entry, req.body.subdivisions, this.parallel());
      }
      else
      {
        setImmediate(this.parallel(), null, []);
      }

      FapEntry.prepareSearchText(entry, this.parallel());
    },
    function(err, users, search)
    {
      if (err)
      {
        return next(err);
      }

      const subscribers = FapEntry.prepareSubscribers(users.map(user => ({
        id: String(user._id),
        label: `${user.lastName} ${user.firstName}`
      })));

      entry.updateObservers([], {}, subscribers, []);

      entry.search = search;

      req.model = entry;

      express.crud.addRoute(app, FapEntry, req, res, next);
    }
  );

  function resolveParticipants(entry, subdivisions, done)
  {
    step(
      function()
      {
        const input = {
          date: entry.createdAt,
          orderNo: entry.orderNo,
          mrp: entry.mrp,
          category: entry.category,
          subCategory: entry.subCategory,
          notifications: null,
          subdivisions: subdivisions
        };

        module.resolveParticipants(input, this.next());
      },
      function(err, result)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (entry.status !== 'pending')
        {
          return this.skip(null, result.users);
        }

        let leaders = result.users.filter(user => user.prodFunction === 'leader');

        if (leaders.length)
        {
          return this.skip(null, leaders);
        }

        const mor = app[module.config.morId];

        if (!mor)
        {
          return this.skip(null, []);
        }

        const allLeaders = new Set();
        const mrpLeaders = new Set();
        const presentLeaders = new Set();

        mor.state.sections.forEach(section =>
        {
          section.mrps.forEach(sectionMrp =>
          {
            const mrp = sectionMrp._id === entry.mrp;

            sectionMrp.prodFunctions.forEach(sectionFn =>
            {
              if (sectionFn._id !== 'leader')
              {
                return;
              }

              sectionFn.users.forEach(uid =>
              {
                const user = mor.getUser(uid);

                allLeaders.add(user);

                if (mrp)
                {
                  mrpLeaders.add(user);
                }

                if (user.presence)
                {
                  presentLeaders.add(user);
                }
              });
            });
          });
        });

        if (mrpLeaders.size)
        {
          const allMrpLeaders = [...mrpLeaders];
          const presentMrpLeaders = allMrpLeaders.filter(u => u.presence);

          if (presentMrpLeaders.length)
          {
            leaders = presentMrpLeaders;
          }
          else
          {
            leaders = allMrpLeaders;
          }
        }
        else if (presentLeaders.size)
        {
          leaders = [...presentLeaders];
        }
        else
        {
          leaders = [...allLeaders];
        }

        return this.skip(null, leaders);
      },
      done
    );
  }
};
