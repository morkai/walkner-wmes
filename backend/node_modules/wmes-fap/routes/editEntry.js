// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const step = require('h5.step');
const _ = require('lodash');

const editQueues = new Map();

module.exports = (app, module, req, res, next) =>
{
  const {user, FapEntry} = module;

  const updatedAt = new Date();
  const entryId = req.params.id;
  const {data, socketId} = req.body;
  const sessionUser = req.session.user || {};
  const updater = user.createUserInfo(sessionUser, req);

  if (Array.isArray(data.attachments))
  {
    data.attachments.forEach(attachment =>
    {
      const upload = module.tmpAttachments[attachment._id];

      if (upload)
      {
        attachment.date = updatedAt;
        attachment.user = updater;
        attachment.type = upload.data.type;
        attachment.size = upload.data.size;

        clearTimeout(upload.timer);

        delete module.tmpAttachments[attachment._id];
      }
    });
  }

  step(
    function()
    {
      if (editQueues.has(entryId))
      {
        editQueues.get(entryId).push(this.next());
      }
      else
      {
        editQueues.set(entryId, []);
      }
    },
    function()
    {
      FapEntry.findById(entryId).exec(this.next());
    },
    function(err, entry)
    {
      if (err)
      {
        return this.skip(err);
      }

      if (!entry)
      {
        return this.skip(app.createError(`Entry not found.`, 'NOT_FOUND', 404));
      }

      const canManage = user.isAllowedTo(sessionUser, 'FAP:MANAGE');
      const isUser = user.isAllowedTo(sessionUser, 'USER');
      const isProcessEngineer = user.isAllowedTo(sessionUser, [['FN:process-engineer'], ['FN:process-engineer-NPI']]);
      const isDesigner = user.isAllowedTo(sessionUser, [['FN:designer'], ['FN:designer_eto']]);
      const isMaster = user.isAllowedTo(sessionUser, 'FN:master');
      const isLeader = user.isAllowedTo(sessionUser, 'FN:leader');
      const isAnalyzer = entry.analyzers.some(u => sessionUser._id === u.id);
      const isMainAnalyzer = isAnalyzer && entry.analyzers[0].id === sessionUser._id;
      const props = [];

      if (isUser)
      {
        props.push('comment', 'subscribers', 'attachments');
      }

      if (canManage || isProcessEngineer || isDesigner || isMaster || isLeader)
      {
        props.push('status', 'problem', 'solution');
      }

      if (canManage || isProcessEngineer || isDesigner)
      {
        props.push('category', 'divisions', 'lines', 'orderNo', 'mrp', 'nc12', 'productName', 'qtyTodo', 'qtyDone');
      }

      if (canManage || isProcessEngineer || isMaster)
      {
        props.push('assessment', 'analysisNeed', 'analysisDone');
      }

      if (canManage || isProcessEngineer || isMaster || isMainAnalyzer)
      {
        props.push('analyzers');
      }

      if (canManage || isProcessEngineer || isMaster || isLeader || isAnalyzer)
      {
        props.push('why5', 'solutionSteps');
      }

      const input = _.pick(data, props);

      input.subscribers = FapEntry.prepareSubscribers(input.subscribers);

      setImmediate(this.parallel(), null, entry);
      setImmediate(this.parallel(), null, input);

      if (entry.status === 'pending' && input.status === 'started')
      {
        resolveRemainingSubscribers(entry, input, this.parallel());
      }
    },
    function(err, entry, input)
    {
      if (err)
      {
        return this.skip(err);
      }

      const usersToNotify = entry.applyChanges(input, updater, updatedAt);

      if (usersToNotify)
      {
        entry.save(this.parallel());

        setImmediate(this.parallel(), null, usersToNotify);
      }
    },
    function(err, entry, usersToNotify)
    {
      if (err)
      {
        next(err);
      }
      else
      {
        res.sendStatus(204);

        if (entry)
        {
          app.broker.publish(`fap.entries.updated.${entry._id}`, {
            socketId,
            _id: entry._id,
            change: _.last(entry.changes),
            notify: usersToNotify
          });
        }
      }

      const editQueue = editQueues.get(entryId);

      if (editQueue.length)
      {
        setImmediate(editQueue.shift());
      }
      else
      {
        editQueues.delete(entryId);
      }
    }
  );

  function resolveRemainingSubscribers(entry, input, done)
  {
    module.resolveParticipants(entry, (err, result) =>
    {
      if (err)
      {
        return done(err);
      }

      if (!result.users.length)
      {
        return done();
      }

      if (!Array.isArray(input.subscribers))
      {
        input.subscribers = [];
      }

      const participants = new Set();

      input.subscribers.forEach(s => participants.add(String(s.id)));

      entry.observers.forEach(o => participants.add(String(o.user.id)));

      const subscribers = result.users.filter(u => !participants.has(String(u._id))).map(u => ({
        id: String(u._id),
        label: `${u.lastName} ${u.firstName}`
      }));

      if (subscribers.length)
      {
        input.subscribers = input.subscribers.concat(FapEntry.prepareSubscribers(subscribers));
      }

      done();
    });
  }
};
