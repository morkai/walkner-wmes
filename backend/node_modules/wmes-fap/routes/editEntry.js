// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const step = require('h5.step');
const _ = require('lodash');

const editQueues = new Map();

module.exports = (app, module, req, res, next) =>
{
  const {user, FapEntry} = module;

  const updatedAt = new Date();
  const entryId = req.params.id;
  const socketId = req.body.socketId;
  const sessionUser = req.session.user || {};
  const updater = user.createUserInfo(sessionUser, req);

  step(
    function()
    {
      if (editQueues.has(entryId))
      {
        editQueues.get(entryId).push(this.next());
      }
      else
      {
        editQueues.set(entryId, []);
      }
    },
    function()
    {
      FapEntry.findById(entryId).exec(this.next());
    },
    function(err, entry)
    {
      if (err)
      {
        return this.skip(err);
      }

      if (!entry)
      {
        return this.skip(app.createError(`Entry not found.`, 'NOT_FOUND', 404));
      }

      const canManage = user.isAllowedTo(sessionUser, 'FAP:MANAGE');
      const isProcessEngineer = user.isAllowedTo(sessionUser, 'FN:process-engineer');
      const isMaster = user.isAllowedTo(sessionUser, 'FN:master');
      const isLeader = user.isAllowedTo(sessionUser, 'FN:leader');
      const isAnalyzer = entry.analyzers.some(u => sessionUser._id === u.id);
      const props = ['comment', 'subscribers'];

      if (canManage || isProcessEngineer || isMaster || isLeader)
      {
        props.push('status', 'problem');
      }

      if (canManage || isProcessEngineer)
      {
        props.push('category', 'divisions', 'lines');
      }

      if (canManage || isProcessEngineer || isMaster)
      {
        props.push('assessment', 'analysisNeed', 'analysisDone', 'analysers');
      }

      if (canManage || isProcessEngineer || isMaster || isLeader || isAnalyzer)
      {
        props.push('why5', 'solution');
      }

      const input = _.pick(req.body.data, props);

      input.subscribers = prepareSubscribers(input.subscribers);

      this.usersToNotify = entry.applyChanges(input, updater, updatedAt);

      if (this.usersToNotify)
      {
        entry.save(this.next());
      }
    },
    function(err, entry)
    {
      if (err)
      {
        return next(err);
      }

      res.sendStatus(204);

      if (entry)
      {
        app.broker.publish(`fap.entries.updated.${entry._id}`, {
          socketId,
          _id: entry._id,
          change: _.last(entry.changes),
          notify: this.usersToNotify
        });
      }

      const editQueue = editQueues.get(entryId);

      if (editQueue.length)
      {
        setImmediate(editQueue.shift());
      }
      else
      {
        editQueues.delete(entryId);
      }
    }
  );

  function prepareSubscribers(subscribers)
  {
    return (Array.isArray(subscribers) ? subscribers : [])
      .filter(function(subscriber)
      {
        return _.isString(subscriber.id)
          && !_.isEmpty(subscriber.id)
          && _.isString(subscriber.label)
          && !_.isEmpty(subscriber.label);
      })
      .map(function(subscriber)
      {
        return {
          user: subscriber,
          role: 'subscriber',
          lastSeenAt: null,
          notify: true,
          changes: {}
        };
      });
  }
};
