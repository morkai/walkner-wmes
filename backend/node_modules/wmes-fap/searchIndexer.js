// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const step = require('h5.step');
const prepareSearchText = require('util/prepareSearchText');

module.exports = (app, module) =>
{
  const {FapEntry} = module;

  const PROPS = [
    'productName',
    'problem',
    'solution',
    'why5',
    'solutionSteps',
    'componentName'
  ];

  const waiting = new Map();

  app.broker.subscribe('app.started', () => prepareSearchText(['start'], false, () => {})).setLimit(1);

  app.broker.subscribe('fap.entries.updated.*', checkEntry);

  function checkEntry({_id, change})
  {
    if (change.comment || PROPS.some(prop => !!change.data[prop]))
    {
      scheduleEntry(String(_id), change);
    }
  }

  function scheduleEntry(entryId, change)
  {
    if (!waiting.has(entryId))
    {
      waiting.set(entryId, {
        entryId,
        changes: {},
        comments: [],
        timer: null
      });
    }

    const state = waiting.get(entryId);

    if (change.comment)
    {
      state.comments.push(change.comment);
    }

    PROPS.forEach(prop =>
    {
      if (change.data[prop])
      {
        state.changes[prop] = change.data[prop][1];
      }
    });

    clearTimeout(state.timer);

    state.timer = setTimeout(rebuildEntry, 30000, state);
  }

  function rebuildEntry(state)
  {
    const {entryId, changes, comments} = state;

    waiting.delete(entryId);

    const input = [];
    const update = {};

    if (comments.length)
    {
      update.$push = {search: {$each: null}};
    }

    const changedProps = Object.keys(changes);

    changedProps.forEach(prop =>
    {
      input.push(changes[prop]);
    });

    comments.forEach(comment => input.push(comment));

    step(
      function()
      {
        prepareSearchText(input, false, this.parallel());

        FapEntry.findById(entryId).select({search: 1}).lean().exec(this.parallel());
      },
      function(err, result, fapEntry)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!fapEntry)
        {
          return this.skip();
        }

        changedProps.forEach(prop =>
        {
          fapEntry.search[PROPS.indexOf(prop)] = result.shift();
        });

        result.forEach(text => fapEntry.search.push(text));

        FapEntry.updateOne({_id: entryId}, {$set: {search: fapEntry.search}}, this.next());
      },
      function(err)
      {
        if (err)
        {
          module.error(err, `Failed to rebuild search index.`, {entryId});
        }
      }
    );
  }
};
