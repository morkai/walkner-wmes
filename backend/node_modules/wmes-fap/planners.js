// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const step = require('h5.step');

module.exports = (app, module) =>
{
  const {
    sapGui,
    User,
    FapEntry,
    FapCategory,
    FapSubCategory,
    editEntry
  } = module;
  const logger = module.logger.create({submodule: 'planners'});

  app.broker.subscribe('fap.entries.added', onEntryAdded);

  app.broker.subscribe('fap.entries.updated.*', onEntryUpdated);

  function onEntryAdded({model})
  {
    checkPlanners(model);
  }

  function onEntryUpdated({_id, change})
  {
    if (!change.data.category
      && !change.data.subCategory
      && !change.data.componentCode)
    {
      return;
    }

    FapEntry.findById(_id).exec((err, entry) =>
    {
      if (err)
      {
        return logger.error(err, 'Failed to find entry after update.', {entryId: _id});
      }

      if (entry)
      {
        checkPlanners(entry);
      }
    });
  }

  function checkPlanners(entry)
  {
    if (!entry.componentCode)
    {
      return;
    }

    step(
      function()
      {
        FapCategory
          .findOne({_id: entry.category, planners: true})
          .select({_id: 1})
          .lean()
          .exec(this.parallel());

        FapSubCategory
          .findOne({_id: entry.subCategory, planners: true})
          .select({_id: 1})
          .lean()
          .exec(this.parallel());
      },
      function(err, category, subCategory)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!category && !subCategory)
        {
          return this.skip();
        }

        const job = {
          name: 'planners',
          scriptTimeout: 60 * 1000,
          repeatOnFailure: 0,
          waitForResult: true,
          material: entry.componentCode
        };

        sapGui.runRemoteJob(job, this.next());
      },
      function(err, jobResult)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (typeof jobResult !== 'string')
        {
          return this.skip();
        }

        const plannersRe = new RegExp(/planist[0-9]+="(.*?)"/g);
        const planners = new Map();

        do
        {
          const matches = plannersRe.exec(jobResult);

          if (!matches)
          {
            break;
          }

          const candidate = matches[1];

          if (candidate.includes('_'))
          {
            continue;
          }

          const parts = candidate.split(/\s+/);
          const searchName = User.transliterateName(parts.pop() + parts.join(''));

          planners.set(searchName, []);
        }
        while (true); // eslint-disable-line no-constant-condition

        if (!planners.size)
        {
          logger.info('No planners found.', {entryId: entry._id, jobResult});

          return this.skip();
        }

        setImmediate(this.parallel(), null, planners);

        User
          .find({searchName: new RegExp(`^(${Array.from(planners.keys()).join('|')})`)})
          .select({
            kdPosition: 1,
            prodFunction: 1,
            privileges: 1,
            searchName: 1,
            firstName: 1,
            lastName: 1,
            login: 1
          })
          .lean()
          .exec(this.parallel());
      },
      function(err, planners, users)
      {
        if (err)
        {
          return this.skip(err);
        }

        users = new Set(users);

        planners.forEach((plannerUsers, searchName) =>
        {
          users.forEach(user =>
          {
            if (!user.searchName.startsWith(searchName))
            {
              return;
            }

            user.score = 0;

            if (user.kdPosition && /mag|wh|warehouse/i.test(user.kdPosition))
            {
              user.score += 1;
            }

            if (user.prodFunction && user.prodFunction.includes('wh'))
            {
              user.score += 1;
            }

            (user.privileges || []).forEach(privilege =>
            {
              if (privilege.includes('WH'))
              {
                user.score += 1;
              }
            });

            user.label = user.login;

            if (user.lastName)
            {
              user.label = user.lastName;

              if (user.firstName && user.lastName !== user.firstName)
              {
                user.label += ` ${user.firstName}`;
              }
            }

            users.delete(user);

            plannerUsers.push(user);
          });
        });

        const subscribers = [];

        planners.forEach(users =>
        {
          if (!users.length)
          {
            return;
          }

          users.sort((a, b) => b.score - a.score);

          subscribers.push({
            id: users[0]._id.toString(),
            label: users[0].label
          });
        });

        if (!subscribers.length)
        {
          return;
        }

        const input = {
          entryId: entry._id,
          socketId: null,
          data: {subscribers},
          sessionUser: null,
          updater: {
            id: null,
            label: 'System'
          }
        };

        editEntry(input, this.next());
      },
      function(err)
      {
        if (err)
        {
          return logger.error(err, 'Failed to check planners.', {entryId: entry._id});
        }
      }
    );
  }
};
