// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const deepEqual = require('deep-equal');
const step = require('h5.step');
const autoIncrement = require('mongoose-plugin-autoinc-fix');
const userInfoSchema = require('user/models/userInfoSchema');
const resolveProductName = require('util/resolveProductName');
const prepareSearchText = require('util/prepareSearchText');

exports.name = 'FapEntry';

exports.setUp = (app, mongoose) =>
{
  const STATUSES = [
    'pending',
    'started',
    'finished'
  ];

  const observerSchema = new mongoose.Schema({
    user: userInfoSchema,
    role: {
      type: String,
      required: true,
      enum: ['creator', 'owner', 'subscriber', 'analyzer']
    },
    func: {
      type: String,
      ref: 'ProdFunction'
    },
    lastSeenAt: {
      type: Date,
      default: null
    },
    notify: {
      type: Boolean,
      default: false
    },
    changes: {}
  }, {
    _id: false,
    minimize: false
  });

  const attachmentSchema = new mongoose.Schema({
    _id: {
      type: String,
      required: true
    },
    date: {
      type: Date,
      required: true
    },
    user: userInfoSchema,
    type: {
      type: String,
      required: true
    },
    size: {
      type: Number,
      required: true
    },
    name: {
      type: String,
      required: true
    }
  }, {
    id: false,
    minimize: false
  });

  const changeSchema = new mongoose.Schema({
    date: {
      type: Date,
      required: true
    },
    user: userInfoSchema,
    data: {},
    comment: {
      type: String,
      trim: true,
      default: ''
    }
  }, {
    _id: false,
    minimize: false
  });

  const fapEntrySchema = new mongoose.Schema({
    creator: userInfoSchema,
    createdAt: {
      type: Date,
      required: true
    },
    updater: userInfoSchema,
    updatedAt: {
      type: Date,
      required: true
    },
    startedAt: Date,
    finishedAt: Date,
    owner: userInfoSchema,
    status: {
      type: String,
      required: true,
      enum: STATUSES
    },
    orderNo: {
      type: String,
      default: ''
    },
    category: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'FapCategory',
      required: true
    },
    subCategory: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'FapSubCategory',
      default: null
    },
    problem: {
      type: String,
      required: true
    },
    solution: {
      type: String,
      default: ''
    },
    solver: userInfoSchema,
    nc12: {
      type: String,
      default: ''
    },
    divisions: [String],
    subdivisionType: {
      type: String,
      enum: ['unspecified', 'assembly', 'press', 'wh'],
      default: 'unspecified'
    },
    lines: [String],
    mrp: {
      type: String,
      default: ''
    },
    qtyTodo: {
      type: Number,
      default: 0
    },
    qtyDone: {
      type: Number,
      default: 0
    },
    productName: {
      type: String,
      default: ''
    },
    componentCode: {
      type: String,
      default: ''
    },
    componentName: {
      type: String,
      default: ''
    },
    analysisStartedAt: Date,
    analysisFinishedAt: Date,
    assessment: {
      type: String,
      enum: ['unspecified', 'effective', 'ineffective', 'repeatable'],
      default: 'unspecified'
    },
    analysisNeed: {
      type: Boolean,
      default: false
    },
    analysisDone: {
      type: Boolean,
      default: false
    },
    analyzers: [userInfoSchema],
    why5: [String],
    solutionSteps: {
      type: String,
      default: ''
    },
    attachments: [attachmentSchema],
    observers: [observerSchema],
    unsubscribed: {},
    subdivisions: [String],
    changes: [changeSchema],
    search: [String]
  }, {
    id: false,
    minimize: false
  });

  fapEntrySchema.plugin(autoIncrement.plugin, {
    model: exports.name,
    field: 'rid',
    startAt: 1,
    incrementBy: 1
  });

  fapEntrySchema.index({createdAt: -1});
  fapEntrySchema.index({status: 1});
  fapEntrySchema.index({orderNo: 1});
  fapEntrySchema.index({componentCode: 1});
  fapEntrySchema.index({mrp: 1});
  fapEntrySchema.index({category: 1});
  fapEntrySchema.index({subCategory: 1});
  fapEntrySchema.index({assessment: 1});
  fapEntrySchema.index({analysisNeed: 1, analysisDone: 1});
  fapEntrySchema.index({divisions: 1});
  fapEntrySchema.index({subdivisionType: 1});
  fapEntrySchema.index({
    'observers.user.id': 1,
    'observers.notify': 1
  });
  fapEntrySchema.index({search: 'text'});

  fapEntrySchema.statics.TOPIC_PREFIX = 'fap.entries';
  fapEntrySchema.statics.BROWSE_LIMIT = 100;

  fapEntrySchema.pre('save', function(next)
  {
    if (this.observers.length === 0)
    {
      this.createObservers();
    }

    next();
  });

  fapEntrySchema.statics.prepareSearchText = function(entry, done)
  {
    const input = [
      entry.productName,
      entry.problem,
      entry.solution,
      entry.why5.join('\n').trim(),
      entry.solutionSteps,
      entry.componentName
    ];

    entry.changes.forEach(change =>
    {
      if (change.comment)
      {
        input.push(change.comment);
      }
    });

    prepareSearchText(input, false, (err, result) =>
    {
      if (err)
      {
        return done(err);
      }

      done(null, result);
    });
  };

  fapEntrySchema.statics.prepareSubscribers = function(subscribers)
  {
    const lastSeenAt = new Date();

    return (Array.isArray(subscribers) ? subscribers : [])
      .filter((user) =>
        _.isString(user.id)
          && !_.isEmpty(user.id)
          && _.isString(user.label)
          && !_.isEmpty(user.label)
      )
      .map((user) => ({
        user: {
          id: user.id,
          label: user.label
        },
        role: 'subscriber',
        lastSeenAt,
        notify: true,
        changes: {}
      }));
  };

  fapEntrySchema.statics.markAsSeen = function(filter, userId, done)
  {
    const FapEntry = this;

    if (typeof userId !== 'string')
    {
      userId = String(userId);
    }

    const query = {
      observers: {
        $elemMatch: {
          'user.id': userId,
          notify: true
        }
      }
    };

    switch (filter)
    {
      case 'all':
        break;

      case 'finished':
        query.status = 'finished';
        break;

      case 'dayOld':
        query.createdAt = {$lt: new Date(Date.now() - 24 * 3600 * 1000)};
        break;

      case 'weekOld':
        query.createdAt = {$lt: new Date(Date.now() - 7 * 24 * 3600 * 1000)};
        break;

      case 'noComment':
        query.observers.$elemMatch['changes.comment'] = {$exists: false};
        break;

      default:
        try
        {
          query._id = new mongoose.Types.ObjectId(filter);
        }
        catch (err)
        {
          return done(app.createError(`Invalid entry ID.`, 'INPUT', 400));
        }
        break;
    }

    step(
      function()
      {
        FapEntry
          .find(query)
          .select({_id: 1})
          .lean()
          .exec(this.next());
      },
      function(err, entries)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (entries.length === 0)
        {
          return this.skip(null, []);
        }

        const seenEntries = entries.map(e => e._id);

        setImmediate(this.parallel(), null, seenEntries);

        const filter = {
          _id: {$in: seenEntries}
        };
        const update = {
          $set: {
            'observers.$[o].notify': false,
            'observers.$[o].changes': {},
            'observers.$[o].lastSeenAt': new Date()
          }
        };
        const options = {
          arrayFilters: [
            {'o.user.id': userId}
          ]
        };

        FapEntry.collection.updateMany(filter, update, options, this.parallel());
      },
      done
    );
  };

  // TODO
  fapEntrySchema.statics.observe = function(entryId, state, userInfo, done)
  {
    const FapEntry = this;

    FapEntry.findById(entryId, (err, entry) =>
    {
      if (err)
      {
        return done(err);
      }

      if (!entry)
      {
        return done();
      }

      const now = new Date();
      const userId = userInfo.id.toString();
      const observerIndex = _.findIndex(entry.observers, observer => observer.user.id === userId);
      const subscriber = {
        id: userId,
        label: userInfo.label
      };

      if (state)
      {
        if (observerIndex !== -1)
        {
          return done();
        }

        entry.observers.push({
          user: subscriber,
          role: 'subscriber',
          lastSeenAt: now,
          notify: false,
          changes: {}
        });

        entry.changes.push({
          date: now,
          user: userInfo,
          data: {subscribers: [null, [subscriber]]},
          comment: ''
        });

        delete entry.unsubscribed[userId];
      }
      else
      {
        if (observerIndex === -1 || entry.observers[observerIndex].role !== 'subscriber')
        {
          return done();
        }

        entry.observers.splice(observerIndex, 1);

        entry.changes.push({
          date: now,
          user: userInfo,
          data: {subscribers: [[subscriber], null]},
          comment: ''
        });

        entry.unsubscribed[userId] = true;
      }

      entry.markModified('observers');
      entry.markModified('unsubscribed');
      entry.markModified('changes');
      entry.save((err) =>
      {
        if (err)
        {
          return done(err);
        }

        app.broker.publish(`${FapEntry.TOPIC_PREFIX}.edited`, {
          model: entry,
          user: userInfo,
          notify: null
        });
      });
    });
  };

  fapEntrySchema.methods.createObservers = function()
  {
    const observers = {};

    observers[this.owner.id] = {
      user: {
        id: this.owner.id,
        label: this.owner.label
      },
      role: 'owner',
      lastSeenAt: this.createdAt,
      notify: this.owner.id !== this.creator.id,
      changes: {}
    };

    if (!observers[this.creator.id])
    {
      observers[this.creator.id] = {
        user: this.creator,
        role: 'creator',
        lastSeenAt: this.createdAt,
        notify: false,
        changes: {}
      };
    }

    this.analyzers.forEach((analyzer) =>
    {
      if (!observers[analyzer.id])
      {
        observers[analyzer.id] = {
          user: analyzer,
          role: 'analyzer',
          lastSeenAt: this.createdAt,
          notify: true,
          changes: {}
        };
      }
    });

    this.observers.forEach((subscriber) =>
    {
      if (!observers[subscriber.user.id])
      {
        observers[subscriber.user.id] = subscriber;
      }
    });

    if (app.user && app.user.guest)
    {
      delete observers[app.user.guest._id];
    }

    this.observers = Object.values(observers);
  };

  fapEntrySchema.methods.updateObservers = function(
    changedPropertyList,
    changes,
    newSubscribers,
    unsubscribersList)
  {
    const usersToNotify = {};
    const oldNotify = {};

    if (this.observers.length === 0)
    {
      this.createObservers();
    }

    const guestUserId = app.user && app.user.guest && app.user.guest._id || '';
    const unsubscribersMap = {};

    unsubscribersList.forEach(user =>
    {
      if (user && user.id && user.label)
      {
        unsubscribersMap[user.id] = user;
      }
    });

    const changedPropertyMap = {};

    changedPropertyList.forEach(property => { changedPropertyMap[property] = true; });

    if (changedPropertyMap.unsubscribed)
    {
      if (changedPropertyList.length === 1)
      {
        return usersToNotify;
      }

      delete changedPropertyMap.unsubscribed;
    }

    const oldObserverMap = {};
    const newObserverMap = {};

    // Old observers
    _.forEach(this.observers, function(observer)
    {
      oldObserverMap[observer.user.id] = observer;

      if (observer.role === 'subscriber')
      {
        addObserver(observer);
      }
    });

    // Creator
    addObserver(oldObserverMap[this.creator.id]);

    // Owner
    if (this.owner && !newObserverMap[this.owner.id])
    {
      let owner = oldObserverMap[this.owner.id];

      if (!owner)
      {
        owner = {
          user: {
            id: this.owner.id,
            label: this.owner.label
          },
          role: 'owner',
          lastSeenAt: this.updatedAt,
          notify: false,
          changes: {}
        };
      }

      addObserver(owner);
    }

    // Analyzers
    this.analyzers.forEach((user) =>
    {
      let analyzer = oldObserverMap[user.id];

      if (analyzer)
      {
        analyzer.role = 'analyzer';
      }
      else
      {
        analyzer = {
          user: {
            id: user.id,
            label: user.label
          },
          role: 'analyzer',
          lastSeenAt: this.updatedAt,
          notify: false,
          changes: {}
        };
      }

      addObserver(analyzer);
    });

    // Auto-subscribe the updater
    newSubscribers.push({
      user: {
        id: this.updater.id,
        label: this.updater.label
      },
      role: 'subscriber',
      lastSeenAt: this.updatedAt,
      notify: false,
      changes: {}
    });

    // New subscribers specified in the form
    newSubscribers.forEach(addObserver);

    // Don't notify the updater about his own change
    const updater = newObserverMap[this.updater.id];

    if (updater)
    {
      updater.lastSeenAt = this.updatedAt;
      updater.notify = false;
      updater.changes = {};

      delete usersToNotify[updater.user.id];
    }

    this.observers = Object.values(newObserverMap);

    const changedSubscribersOnly = changedPropertyMap.subscribers
      && Object.keys(changedPropertyMap).length === 1;
    const newSubscriberIds = new Set();

    newSubscribers.forEach(newSubscriber => newSubscriberIds.add(newSubscriber.user.id));

    this.observers.forEach(o =>
    {
      if (!changedSubscribersOnly)
      {
        return;
      }

      if (newSubscriberIds.has(o.user.id))
      {
        delete o.changes.subscribers;

        return;
      }

      delete usersToNotify[o.user.id];

      if (oldNotify[o.user.id])
      {
        return;
      }

      o.notify = false;
      o.changes = {};
    });

    this.markModified('observers');

    return usersToNotify;

    function addObserver(observer)
    {
      if (!observer
        || !observer.user.id
        || newObserverMap[observer.user.id]
        || observer.user.id === guestUserId)
      {
        return;
      }

      if (unsubscribersMap[observer.user.id] && observer.role === 'subscriber')
      {
        if (!changes.subscribers$removed)
        {
          changes.subscribers$removed = [[], null];
          changedPropertyMap.subscribers = true;
        }

        changes.subscribers$removed[0].push(unsubscribersMap[observer.user.id]);

        return;
      }

      if (!oldObserverMap[observer.user.id])
      {
        if (!changes.subscribers$added)
        {
          changes.subscribers$added = [null, []];
          changedPropertyMap.subscribers = true;
        }

        changes.subscribers$added[1].push(observer.user);
      }

      Object.assign(observer.changes, changedPropertyMap);

      oldNotify[observer.user.id] = observer.notify;
      observer.notify = true;
      usersToNotify[observer.user.id] = observer.changes;
      newObserverMap[observer.user.id] = observer;
    }
  };

  fapEntrySchema.methods.updateUnsubscribed = function(changes, unsubscribed)
  {
    if (typeof unsubscribed !== 'boolean')
    {
      return;
    }

    if (unsubscribed)
    {
      if (this.unsubscribed[this.updater.id])
      {
        return;
      }

      this.unsubscribed[this.updater.id] = true;
    }
    else
    {
      if (!this.unsubscribed[this.updater.id])
      {
        return;
      }

      delete this.unsubscribed[this.updater.id];
    }

    changes.unsubscribed = [!unsubscribed, unsubscribed];

    this.markModified('unsubscribed');
  };

  fapEntrySchema.methods.updateAttachments = function(changes, attachments)
  {
    const added = [null, []];
    const edited = [[], []];
    const removed = [[], null];
    const map = {};

    this.attachments.forEach(a => map[a._id] = a);

    attachments.forEach(newAttachment =>
    {
      const oldAttachment = map[newAttachment._id];

      if (!oldAttachment)
      {
        added[1].push(newAttachment);

        return;
      }

      if (newAttachment.name === oldAttachment.name)
      {
        removed[0].push(oldAttachment);

        return;
      }

      edited[0].push(oldAttachment);
      edited[1].push(newAttachment);
    });

    if (added[1].length)
    {
      changes.attachments = added;

      added[1].forEach(a => this.attachments.push(a));
    }
    else if (edited[0].length)
    {
      changes.attachments = edited;

      edited[1].forEach(a => Object.assign(map[a._id], a));
    }
    else if (removed[0].length)
    {
      changes.attachments = removed;

      this.attachments = this.attachments.filter(a => !removed[0].includes(a));
    }
  };

  fapEntrySchema.methods.updateStatus = function(changes)
  {
    if (!changes.status)
    {
      return;
    }

    if (changes.status[1] === 'started')
    {
      changes.startedAt = [this.startedAt, this.updatedAt];

      if (this.finishedAt)
      {
        changes.finishedAt = [this.finishedAt, null];
      }

      this.startedAt = this.updatedAt;
      this.finishedAt = null;

      return;
    }

    if (changes.status[1] === 'finished')
    {
      changes.finishedAt = [this.finishedAt, this.updatedAt];
      this.finishedAt = this.updatedAt;
    }
  };

  fapEntrySchema.methods.updateAnalysis = function(changes)
  {
    if (changes.analysisNeed)
    {
      if (this.analysisFinishedAt)
      {
        changes.analysisFinishedAt = [this.analysisFinishedAt, null];
        this.analysisFinishedAt = null;
      }

      if (changes.analysisNeed[1])
      {
        changes.analysisStartedAt = [this.analysisStartedAt, this.updatedAt];
        this.analysisStartedAt = this.updatedAt;
      }
      else if (this.analysisStartedAt)
      {
        changes.analysisStartedAt = [this.analysisStartedAt, null];
        this.analysisStartedAt = null;
      }
    }

    if (changes.analysisDone)
    {
      if (changes.analysisDone[1])
      {
        changes.analysisFinishedAt = [this.analysisFinishedAt, this.updatedAt];
        this.analysisFinishedAt = this.updatedAt;
      }
      else if (this.analysisFinishedAt)
      {
        changes.analysisFinishedAt = [this.analysisFinishedAt, null];
        this.analysisFinishedAt = null;
      }
    }
  };

  fapEntrySchema.methods.applyChanges = function(input, updater, updatedAt)
  {
    this.updater = updater;
    this.updatedAt = updatedAt;

    const changes = this.compareProperties(_.omit(input, [
      'comment',
      'subscribers',
      'unsubscribers',
      'attachments',
      'unsubscribed'
    ]));

    this.updateStatus(changes);
    this.updateAnalysis(changes);
    this.updateAttachments(changes, input.attachments || []);
    this.updateUnsubscribed(changes, input.unsubscribed);

    if (changes.solution && changes.solution[1])
    {
      this.solver = updater;
    }

    const changedProperties = Object.keys(changes);
    const comment = _.isEmpty(input.comment) || !_.isString(input.comment) ? '' : input.comment.trim();

    if (!_.isEmpty(input.comment))
    {
      changedProperties.push('comment');
    }

    if (!changedProperties.length
      && _.isEmpty(input.subscribers)
      && _.isEmpty(input.unsubscribers))
    {
      return null;
    }

    const usersToNotify = this.updateObservers(
      changedProperties,
      changes,
      input.subscribers || [],
      input.unsubscribers || []
    );

    if (_.isEmpty(comment) && _.isEmpty(changes))
    {
      return null;
    }

    this.changes.push({
      date: this.updatedAt,
      user: updater,
      data: changes,
      comment
    });

    return usersToNotify;
  };

  fapEntrySchema.methods.compareProperties = function(input)
  {
    const changes = {};

    _.forEach(input, (value, key) => { this.compareProperty(key, input, changes); });

    return changes;
  };

  fapEntrySchema.methods.compareProperty = function(property, input, changes)
  {
    let oldValue = this[property];
    let newValue = input[property];

    if (_.isObject(oldValue) && _.isFunction(oldValue.toObject))
    {
      oldValue = oldValue.toObject();
    }

    if (_.isObject(newValue) && _.isFunction(newValue.toObject))
    {
      newValue = newValue.toObject();
    }

    if (_.isString(newValue))
    {
      newValue = newValue.trim();
    }

    if (deepEqual(newValue, oldValue, {strict: true}))
    {
      return false;
    }

    changes[property] = [oldValue, newValue];
    this[property] = newValue;

    return true;
  };

  fapEntrySchema.methods.updateOrderData = function(done)
  {
    const entry = this;

    if (!entry.orderNo)
    {
      entry.orderNo = '';
      entry.nc12 = '';
      entry.qtyTodo = 0;
      entry.qtyDone = 0;
      entry.productName = '';

      return done();
    }

    step(
      function()
      {
        mongoose.model('Order')
          .findById(entry.orderNo)
          .select({
            _id: 0,
            mrp: 1,
            nc12: 1,
            name: 1,
            description: 1,
            qtyDone: 1,
            qty: 1
          })
          .lean()
          .exec(this.parallel());
      },
      function(err, sapOrder)
      {
        if (err)
        {
          return this.skip(app.createError(
            `Failed to find order data: ${err.message}`,
            'UPDATE_ORDER_DATA',
            500
          ));
        }

        if (!sapOrder)
        {
          return this.skip(app.createError(
            `Order not found: ${entry.orderNo}`,
            'UPDATE_ORDER_DATA',
            400
          ));
        }

        entry.mrp = sapOrder.mrp;
        entry.nc12 = sapOrder.nc12;
        entry.qtyTodo = sapOrder.qty;
        entry.qtyDone = sapOrder.qtyDone ? sapOrder.qtyDone.total : 0;
        entry.productName = resolveProductName(sapOrder);
      },
      done
    );
  };

  mongoose.model(exports.name, fapEntrySchema);
};
