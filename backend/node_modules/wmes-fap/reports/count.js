// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');
const util = require('reports/util');

exports.models = [
  require('wmes-fap/models/fapEntry'),
  require('wmes-fap/models/fapCategory'),
  require('user/models/user')
];

exports.report = (app, {FapCategory, FapEntry, User}, options, done) =>
{
  const groupProperty = 'createdAt';
  const now = new Date();
  let minGroupKey = Number.MAX_VALUE;
  let maxGroupKey = Number.MIN_VALUE;
  const results = {
    options: options,
    users: {},
    categories: {},
    totals: createGroup(),
    groups: {}
  };

  step(
    function findStep()
    {
      FapCategory
        .find({})
        .select({name: 1})
        .lean()
        .exec(this.parallel());

      const conditions = {};
      const sort = {};

      sort[groupProperty] = 1;

      if (options.fromTime)
      {
        conditions[groupProperty] = {$gte: new Date(options.fromTime)};
      }

      if (options.toTime)
      {
        if (!conditions[groupProperty])
        {
          conditions[groupProperty] = {};
        }

        conditions[groupProperty].$lt = new Date(options.toTime);
      }

      if (options.subdivisionTypes.length)
      {
        conditions.subdivisionType = {$in: options.subdivisionTypes};
      }

      if (options.divisions.length)
      {
        conditions.divisions = {$in: options.divisions};
      }

      if (options.mrps.length)
      {
        conditions.mrp = {$in: options.mrps};
      }

      if (options.categories.length)
      {
        conditions.category = {$in: options.categories};
      }

      const stream = FapEntry
        .find(conditions, {
          owner: 1,
          solver: 1,
          createdAt: 1,
          startedAt: 1,
          finishedAt: 1,
          status: 1,
          category: 1,
          divisions: 1,
          mrp: 1,
          analysisStartedAt: 1,
          analysisFinishedAt: 1,
          assessment: 1,
          subdivisionType: 1
        })
        .sort(sort)
        .lean()
        .cursor();
      const next = _.once(this.parallel());

      stream.on('error', next);
      stream.on('end', next);
      stream.on('data', handleEntry);
    },
    function finalizeStep(err, categories)
    {
      if (err)
      {
        return this.skip(err);
      }

      categories.forEach(category =>
      {
        results.categories[category._id] = category.name;
      });

      const createNextGroupKey = util.createCreateNextGroupKey(options.interval);
      let groupKey = minGroupKey;
      const groups = [];

      while (groupKey <= maxGroupKey)
      {
        const group = results.groups[groupKey];

        if (group)
        {
          group.duration = calcDuration(group.duration, group.count);
          group.analysisDuration = calcDuration(group.analysisDuration, group.analysisCount);
        }

        groups.push(group || groupKey);

        groupKey = createNextGroupKey(groupKey);
      }

      results.groups = groups;

      results.totals.duration = calcDuration(results.totals.duration, results.totals.count);
      results.totals.analysisDuration = calcDuration(results.totals.analysisDuration, results.totals.analysisCount);

      [
        'owner',
        'solver',
        'status',
        'category',
        'subdivisionType',
        'division',
        'mrp',
        'assessment'
      ].forEach(sortTotals);

      return setImmediate(this.next());
    },
    function sendResultsStep(err)
    {
      return done(err, results);
    }
  );

  function calcDuration(duration, count)
  {
    return Math.round(duration / (count || 1) / 3600000 * 10) / 10;
  }

  function createGroup(key)
  {
    return {
      key: key,
      count: 0,
      analysisCount: 0,
      duration: 0,
      analysisDuration: 0,
      owner: {},
      solver: {},
      status: {},
      category: {},
      subdivisionType: {},
      division: {},
      mrp: {},
      assessment: {}
    };
  }

  function handleEntry(entry)
  {
    const totals = results.totals;
    const groupKey = util.createGroupKey(options.interval, entry[groupProperty], false);
    let group = results.groups[groupKey];

    if (groupKey < minGroupKey)
    {
      minGroupKey = groupKey;
    }

    if (groupKey > maxGroupKey)
    {
      maxGroupKey = groupKey;
    }

    if (!group)
    {
      group = results.groups[groupKey] = createGroup(groupKey);
    }

    totals.count += 1;
    group.count += 1;

    const duration = (entry.finishedAt || now) - entry.createdAt;

    totals.duration += duration;
    group.duration += duration;

    if (entry.analysisStartedAt)
    {
      totals.analysisCount += 1;
      group.analysisCount += 1;

      const analysisDuration = (entry.analysisFinishedAt || now) - entry.analysisStartedAt;

      totals.analysisDuration += analysisDuration;
      group.analysisDuration += analysisDuration;
    }

    inc('status');
    inc('category');
    inc('subdivisionType');
    inc('division', entry.divisions.length ? entry.divisions : ['unspecified']);
    inc('mrp', entry.mrp || 'unspecified');
    inc('assessment');
    incUser('owner');
    incUser('solver');

    function inc(metricProperty, metricKey)
    {
      if (metricKey === undefined)
      {
        metricKey = entry[metricProperty];
      }

      if (!metricKey)
      {
        return;
      }

      if (Array.isArray(metricKey))
      {
        _.forEach(metricKey, incMetric);
      }
      else
      {
        incMetric(metricKey);
      }

      function incMetric(key)
      {
        if (!totals[metricProperty][key])
        {
          totals[metricProperty][key] = 1;
        }
        else
        {
          totals[metricProperty][key] += 1;
        }

        if (!group[metricProperty][key])
        {
          group[metricProperty][key] = 1;
        }
        else
        {
          group[metricProperty][key] += 1;
        }
      }
    }

    function incUser(userType)
    {
      const user = entry[userType];

      if (!user)
      {
        return;
      }

      const id = User.transliterateName(user.label);

      results.users[id] = user.label;

      if (!totals[userType][id])
      {
        totals[userType][id] = 0;
      }

      totals[userType][id] += 1;

      if (!group[userType][id])
      {
        group[userType][id] = 0;
      }

      group[userType][id] += 1;
    }
  }

  function sortTotals(property)
  {
    const totals = [];

    _.forEach(results.totals[property], (value, key) =>
    {
      totals.push([key, value]);
    });

    results.totals[property] = totals.sort((a, b) => b[1] - a[1]);
  }
};
