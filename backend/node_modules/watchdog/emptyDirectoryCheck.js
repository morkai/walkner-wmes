// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const fs = require('fs');
const path = require('path');
const _ = require('lodash');

module.exports = (app, module) =>
{
  const logger = module.logger.create({submodule: 'emptyDirectoryCheck'});
  const lastResultMap = {};

  app.broker.subscribe('app.started', createDirectoryWatchers).setLimit(1);

  function createDirectoryWatchers()
  {
    module.config.emptyDirectories.forEach((config) =>
    {
      if (!config.id)
      {
        config.id = path.basename(config.path);
      }

      checkDirectory(config);
    });
  }

  function checkDirectory(config)
  {
    fs.readdir(config.path, (err, files) =>
    {
      if (err)
      {
        logger.error(err, `Failed to read dir.`, {dirId: config.id});

        return scheduleNextCheck(config);
      }

      if (files.length === 0)
      {
        return scheduleNextCheck(config);
      }

      const lastResult = lastResultMap[config.path];

      if (_.isEmpty(lastResult))
      {
        lastResultMap[config.path] = files[0];

        return scheduleNextCheck(config);
      }

      lastResultMap[config.path] = '';

      if (files.includes(lastResult))
      {
        logger.warn(`Not empty!`, {dirId: config.id});

        notify(config);

        return scheduleNextCheck(config, true);
      }

      return scheduleNextCheck(config);
    });
  }

  function scheduleNextCheck(config, notified)
  {
    setTimeout(checkDirectory, notified ? config.notifiedDelay : config.checkInterval, config);
  }

  function notify(config)
  {
    const to = _.uniq([].concat(
      module.config.recipients,
      config.emailRecipients || []
    ));

    if (to.length === 0 && _.isEmpty(config.callRecipient))
    {
      return logger.warn(`Nobody to notify.`, {dirId: config.id});
    }

    const subject = `[${app.options.id}:emptyDirectory] ${config.id}`;
    const text = [
      `Directory is not empty: ${config.id}`
    ].join('\r\n');

    const mailSender = app[module.config.mailSenderId];

    if (mailSender && to.length)
    {
      mailSender.send(to, subject, text, (err) =>
      {
        if (err)
        {
          logger.error(err, `Failed to e-mail!`, {dirId: config.id, recipients: to});
        }
        else
        {
          logger.info(`E-mailed!`, {dirId: config.id, recipients: to});
        }
      });
    }

    const twilio = app[module.config.twilioId];

    if (twilio && config.callRecipient)
    {
      const sayOptions = {
        to: config.callRecipient,
        message: text,
        voice: 'alice',
        language: 'en-US'
      };

      twilio.say(sayOptions, (err) =>
      {
        if (err)
        {
          logger.error(err, `Failed to call!`, {dirId: config.id, recipients: [sayOptions.to]});
        }
        else
        {
          logger.info(`Called!`, {dirId: config.id, recipients: [sayOptions.to]});
        }
      });
    }
  }
};
