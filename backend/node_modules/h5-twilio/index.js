// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const url = require('url');
const _ = require('lodash');
const uuid = require('uuid/v4');
const {Twilio} = require('twilio');

exports.DEFAULT_CONFIG = {
  expressId: 'express',
  mongooseId: 'mongoose',
  accountSid: null,
  authToken: null,
  defaultCaller: null,
  defaultSender: null,
  defaultStatusCallbackEvent: true,
  secretKey: null,
  remoteUrl: null,
  baseUrl: 'http://127.0.0.1/'
};

exports.models = [
  require('./models/twilioRequest'),
  require('./models/twilioResponse')
];

exports.optionalModules = {
  'mongoose express': require('./routes')
};

exports.start = (app, module) =>
{
  const config = module.config;
  const request = _.isEmpty(config.remoteUrl) || _.isEmpty(config.secretKey) ? null : require('request');
  const client = config.accountSid && config.authToken ? new Twilio(config.accountSid, config.authToken) : null;
  const timers = {};

  module.clearTimeout = function(requestId)
  {
    clearTimeout(timers[requestId]);
    delete timers[requestId];
  };

  module.say = function(options, done)
  {
    if (!options.from)
    {
      options.from = config.defaultCaller;
    }

    if (request)
    {
      return sendRemoteRequest('say', options, done);
    }

    if (client)
    {
      return say(options, done);
    }

    return setImmediate(done, new Error('No valid transport.'));
  };

  module.sms = function(options, done)
  {
    if (!options.from)
    {
      options.from = config.defaultSender;
    }

    if (request)
    {
      return sendRemoteRequest('sms', options, done);
    }

    if (client)
    {
      return sms(options, done);
    }

    return setImmediate(done, new Error('No valid transport.'));
  };

  function sendRemoteRequest(operation, options, done)
  {
    const reqOptions = {
      url: config.remoteUrl,
      method: 'POST',
      json: true,
      body: {
        secretKey: config.secretKey,
        operation: operation,
        options: options
      }
    };

    request(reqOptions, function(err, res, body)
    {
      if (err)
      {
        return done(err);
      }

      if (res.statusCode !== 204)
      {
        const error = body && body.error ? ` ${body.error.message}` : ``;

        return done(new Error(
          `Expected response status code 204, got ${res.statusCode}.${error}`,
          'INVALID_REMOTE_RESPONSE'
        ));
      }

      return done();
    });
  }

  function say(sayOptions, done, retryCount)
  {
    const mongoose = app[config.mongooseId];

    if (!mongoose)
    {
      return setImmediate(done, new Error('The `mongoose` module is not available!'));
    }

    if (!retryCount)
    {
      retryCount = 0;
    }

    if (retryCount > 2)
    {
      return setImmediate(done, app.createError(`Say failed ${retryCount} times.`, 'RETRY_LIMIT'));
    }

    const TwilioRequest = mongoose.model('TwilioRequest');
    const twilioRequest = new TwilioRequest({
      _id: uuid().toUpperCase(),
      operation: 'say',
      options: sayOptions,
      status: 'created',
      createdAt: new Date(),
      updatedAt: null
    });

    twilioRequest.save((err) =>
    {
      if (err)
      {
        return done(err);
      }

      const callOptions = _.pick(sayOptions, ['to', 'from', 'statusCallbackEvent', 'timeout', 'record']);

      callOptions.method = 'GET';
      callOptions.url = url.format(_.assign(
        url.parse(config.baseUrl),
        {pathname: '/twilio/' + twilioRequest._id}
      ));

      if (callOptions.statusCallbackEvent
        || (callOptions.statusCallbackEvent === undefined && config.defaultStatusCallbackEvent))
      {
        callOptions.statusCallbackMethod = 'POST';
        callOptions.statusCallback = callOptions.url;
      }

      client.calls.create(callOptions, (err) =>
      {
        if (err)
        {
          return done(err);
        }

        if (callOptions.statusCallback)
        {
          timers[twilioRequest._id] = setTimeout(say, 2 * 60 * 1000, sayOptions, () => {}, retryCount + 1);
        }

        done();
      });
    });
  }

  function sms(smsOptions, done, retryCount)
  {
    const mongoose = app[config.mongooseId];

    if (!mongoose)
    {
      return setImmediate(done, new Error('The `mongoose` module is not available!'));
    }

    if (!retryCount)
    {
      retryCount = 0;
    }

    if (retryCount > 2)
    {
      return setImmediate(done, app.createError(`SMS failed ${retryCount} times.`, 'RETRY_LIMIT'));
    }

    const TwilioRequest = mongoose.model('TwilioRequest');
    const twilioRequest = new TwilioRequest({
      _id: uuid().toUpperCase(),
      operation: 'sms',
      options: smsOptions,
      status: 'created',
      createdAt: new Date(),
      updatedAt: null
    });

    twilioRequest.save((err) =>
    {
      if (err)
      {
        return done(err);
      }

      const messageOptions = _.pick(smsOptions, ['to', 'from', 'body']);

      messageOptions.method = 'GET';
      messageOptions.url = url.format(_.assign(
        url.parse(config.baseUrl),
        {pathname: '/twilio/' + twilioRequest._id}
      ));

      if (messageOptions.statusCallbackEvent === undefined && config.defaultStatusCallbackEvent)
      {
        messageOptions.statusCallback = messageOptions.url;
      }

      client.messages.create(messageOptions, (err) =>
      {
        if (err)
        {
          return done(err);
        }

        if (messageOptions.statusCallback)
        {
          timers[twilioRequest._id] = setTimeout(say, 3 * 60 * 1000, smsOptions, () => {}, retryCount + 1);
        }

        done();
      });
    });
  }
};
