// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const os = require('os');
const path = require('path');
const fs = require('fs-extra');
const shifts = require('util/shifts');
const Tester = require('./Tester');
const Station = require('./Station');
const getOrderData = require('./getOrderData');

exports.DEFAULT_CONFIG = {
  mongooseId: 'mongoose',
  messengerServerId: 'messenger/server',
  tester: {}
};

exports.models = [
  require('wmes-gft-frontend/models/gftTester'),
  require('wmes-gft-frontend/models/gftPcb'),
  require('orders/models/order'),
  require('prodShiftOrders/models/prodShiftOrder')
];

exports.requiredModules = 'mongoose';

exports.optionalModules = {
  'messengerServer': require('./server')
};

exports.start = (app, module) =>
{
  const {
    GftTester
  } = module;

  const DUMP_FILE = path.join(os.tmpdir(), `wmes-gft__dump__${app.options.id}.json`);

  module.stations = new Map();

  module.testers = new Map();

  module.getOrderData = getOrderData.bind(null, app, module);

  module.getStationData = (line, station) =>
  {
    const key = `${line}:${station}`;

    if (!module.stations.has(key))
    {
      return {
        updatedAt: 0,
        line,
        station,
        tester: null,
        orderQueue: [],
        order: {}
      };
    }

    return module.stations.get(key).getState();
  };

  app.broker.subscribe('app.started', onAppStarted);
  app.broker.subscribe('updater.restarting', onAppRestarting);
  app.broker.subscribe('gft.testers.added', onTesterAdded);
  app.broker.subscribe('gft.testers.edited', onTesterEdited);
  app.broker.subscribe('gft.testers.deleted', onTesterDeleted);
  app.broker.subscribe('gft.newOrderStarted', onNewOrderStarted);
  app.broker.subscribe('gft.orderFinished', onOrderFinished);
  app.broker.subscribe('gft.workFinished', onWorkFinished);
  app.broker.subscribe('gft.stationsRequested', onStationsRequested);

  async function onAppStarted()
  {
    let dump = {};

    try
    {
      dump = JSON.parse(fs.readFileSync(DUMP_FILE, 'utf8'));

      if (Date.now() - dump.createdAt > 60000
        || shifts.getShiftInfo(dump.createdAt).startTime !== shifts.getCurrentShiftInfo().startTime)
      {
        dump = {};
      }
    }
    catch (err)
    {
      if (err.code !== 'ENOENT')
      {
        module.error(err, 'Failed to read the dump file.');
      }
    }

    const tester = await GftTester
      .find({active: true})
      .lean()
      .exec();
    const stations = new Map();

    tester.forEach(model =>
    {
      model._id = model._id.toString();

      module.info('Starting tester...', {tester: model._id});

      const tester = new Tester(app, module, model);

      module.testers.set(model._id, tester);

      stations.set(`${model.line}:${model.station}`, model);
    });

    stations.forEach(({line, station}, key) =>
    {
      module.info('Starting station...', {line, station});

      module.stations.set(key, new Station(app, module, line, station, dump[`${line}:${station}`]));
    });
  }

  function onAppRestarting({appId})
  {
    if (appId !== app.options.id)
    {
      return;
    }

    module.testers.forEach(tester => tester.destroy());
    module.testers.clear();

    const dump = {
      createdAt: Date.now(),
      stations: {}
    };

    module.stations.forEach(station =>
    {
      dump[`${station.line}:${station.station}`] = {
        order: station.order.orderNo || null,
        orderQueue: station.orderQueue
      };

      station.destroy();
    });
    module.stations.clear();

    try
    {
      fs.writeFileSync(DUMP_FILE, JSON.stringify(dump));
    }
    catch (err)
    {
      module.error(err, 'Failed to write the dump file.');
    }
  }

  function onTesterAdded({model})
  {
    if (!model.active)
    {
      return;
    }

    model._id = model._id.toString();

    module.info('Adding tester...', {tester: model._id});

    const tester = new Tester(app, module, model);

    module.testers.set(model._id, tester);

    reloadStation(model);
  }

  function onTesterEdited({model})
  {
    model._id = model._id.toString();

    const tester = module.testers.get(model._id);

    if (tester && !model.active)
    {
      module.info('Deactivating tester...', {tester: model._id});

      tester.destroy();

      module.testers.delete(model._id);

      const station = findStationUsingTester(tester);

      if (station)
      {
        station.reloadOrder();
      }

      return;
    }

    if (tester)
    {
      module.info('Editing tester...', {tester: model._id});

      const oldStation = module.stations.get(`${tester.model.line}:${tester.model.station}`);
      const newStation = module.stations.get(`${model.line}:${model.station}`);

      tester.edit(model);

      if (oldStation)
      {
        oldStation.reloadOrder();
      }

      if (oldStation !== newStation)
      {
        reloadStation(model);
      }

      return;
    }

    if (model.active)
    {
      module.info('Activating tester...', {tester: model._id});

      const tester = new Tester(app, module, model);

      module.testers.set(model._id, tester);

      reloadStation(model);
    }
  }

  function onTesterDeleted({model})
  {
    const id = model._id.toString();
    const tester = module.testers.get(id);

    if (tester)
    {
      module.info('Deleting tester...', {tester: model._id});

      tester.destroy();

      module.testers.delete(id);

      const station = findStationUsingTester(tester);

      if (station)
      {
        station.reloadOrder();
      }
    }
  }

  function onNewOrderStarted({line, orderNo})
  {
    module.stations.forEach(station =>
    {
      if (station.line === line)
      {
        station.handleNewOrderStarted(orderNo);
      }
    });
  }

  function onOrderFinished({orderNo})
  {
    module.stations.forEach(station =>
    {
      station.handleOrderFinished(orderNo);
    });
  }

  function onWorkFinished({line})
  {
    module.stations.forEach(station =>
    {
      if (line === null || station.line === line)
      {
        station.handleWorkFinished();
      }
    });
  }

  function onStationsRequested()
  {
    module.stations.forEach(station =>
    {
      app.broker.publish(`gft.stations.updated.${station.line}.${station.station}`, station.getState());
    });
  }

  function findStationUsingTester(tester)
  {
    return Array.from(module.stations.values()).find(station => station.tester === tester);
  }

  function reloadStation({line, station})
  {
    const key = `${line}:${station}`;

    if (module.stations.has(key))
    {
      module.stations.get(key).reloadOrder();
    }
    else
    {
      module.info('Starting station...', {line, station});

      module.stations.set(key, new Station(app, module, line, station));
    }
  }
};
