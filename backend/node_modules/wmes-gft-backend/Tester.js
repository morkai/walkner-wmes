// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const {EventEmitter} = require('events');
const modbus = require('h5.modbus');
const {BufferReader} = require('h5.buffers');
const jsonDeepEqual = require('util/jsonDeepEqual');

module.exports = class Tester extends EventEmitter
{
  constructor(app, module, model)
  {
    super();

    this.app = app;
    this.module = module;
    this.model = model;
    this.logger = module.logger.create({submodule: 'tester', tester: model._id.toString()});
    this.master = null;
    this.connected = false;
    this.destroyed = false;
    this.writting = false;
    this.timers = {};
    this.updatedAt = Date.now();
    this.program = {
      channels: 0,
      leds: 0
    };
    this.outputs = {
      1: [],
      2: [],
      3: []
    };

    this.createMaster();
  }

  destroy()
  {
    Object.values(this.timers).forEach(timer => clearTimeout(timer));

    this.once('outputsWritten', () => this.master.destroy());

    this.setProgram(0, 0);

    this.destroyed = true;
  }

  toJSON()
  {
    return this.getState();
  }

  match(line, station, pattern)
  {
    return line === this.model.line
      && station === this.model.station
      && (!pattern || this.model.name.replace(/[^A-Za-z0-9]+/g, '').toUpperCase().includes(pattern));
  }

  getState()
  {
    return {
      updatedAt: this.updatedAt,
      connected: this.connected,
      model: this.model,
      program: this.program,
      outputs: this.outputs
    };
  }

  edit(model)
  {
    this.update({
      model
    });

    this.writeOutputs();
  }

  bindStation(onChanged)
  {
    this.once('unbound', () => this.removeListener('changed', onChanged));
    this.on('changed', onChanged);
  }

  unbindStation()
  {
    this.emit('unbound');

    this.setProgram(0, 0);
  }

  createMaster()
  {
    this.master = modbus.createMaster({
      connection: {
        type: 'tcp',
        socketOptions: {
          host: this.model.host,
          port: this.model.port
        },
        autoOpen: true,
        autoReconnect: true,
        minConnectTime: 2500,
        maxReconnectTime: 5000,
        noActivityTime: 30000,
        closeOnDestroy: true,
        suppressErrorsAfterDestroy: true
      },
      transport: {
        type: process.env.NODE_ENV === 'development' ? 'ip' : 'rtu',
        eofTimeout: 100
      },
      suppressTransactionErrors: true,
      retryOnException: false,
      maxConcurrentTransactions: 1,
      defaultUnit: 0,
      defaultMaxRetries: 0,
      defaultTimeout: 400
    });

    this.master.on('open', () =>
    {
      this.logger.debug('Connected.');

      this.update({connected: true});

      this.writeOutputs();
    });

    this.master.on('close', () =>
    {
      this.logger.debug('Disconnected.');

      this.update({connected: false});
    });

    this.master.on('error', err =>
    {
      this.logger.warn(err, 'Modbus error.');
    });
  }

  async writeOutputs()
  {
    if (this.writting || this.destroyed || !this.master.isOpen())
    {
      return;
    }

    clearTimeout(this.timers.writeOutputs);

    const channels = this.program.channels;
    const leds = this.program.leds;
    const candidates = this.model.program
      .filter(program => program.leds === leds)
      .sort((a, b) => a.outputs.length - b.outputs.length);
    const requiredOutputs = candidates.length ? candidates[0].outputs : [];

    try
    {
      const actualOutputs = await this.readOutputs();
      const changes = [];

      for (let channel = 1; channel <= 3; ++channel)
      {
        const required = channel <= channels ? requiredOutputs : [];
        const actual = actualOutputs[channel];

        if (!jsonDeepEqual(actual, required))
        {
          changes.push({channel, outputs: required});
        }
      }

      if (changes.length)
      {
        await Promise.all(
          changes.map(({channel}) => this.writeChannel(channel, []))
        );

        await Promise.all(
          changes
            .filter(({outputs}) => !!outputs.length)
            .map(({channel, outputs}) => this.writeChannel(channel, outputs))
        );

        const outputs = await this.readOutputs();

        this.update({
          outputs
        });
      }
    }
    catch (err)
    {
      this.logger.warn(err, 'Failed to write outputs.');
    }

    const delay = this.program.leds === leds && this.program.channels === channels ? 10000 : 100;

    this.timers.writeOutputs = setTimeout(this.writeOutputs.bind(this), delay);

    this.writting = false;

    this.emit('outputsWritten');
  }

  async readOutputs()
  {
    const [c1, c2, c3] = await Promise.all([
      this.readChannel(1),
      this.readChannel(2),
      this.readChannel(3)
    ]);

    return {
      1: c1,
      2: c2,
      3: c3
    };
  }

  readChannel(channel)
  {
    return new Promise((resolve, reject) =>
    {
      if (!this.master.isOpen())
      {
        return reject(this.app.createError('No MODBUS connection.'), 'NO_CONNECTION');
      }

      const t = this.master.readHoldingRegisters(0x0001, 16, {
        unit: channel
      });

      t.once('complete', (err, res) =>
      {
        if (err)
        {
          return reject(err);
        }

        if (res.isException())
        {
          return reject(this.app.createError(res.toString(), 'MODBUS_EXCEPTION'));
        }

        const reader = new BufferReader(res.data);
        const outputs = [];

        for (let output = 1; output <= res.quantity; ++output)
        {
          const state = reader.shiftUInt16();

          if (state)
          {
            outputs.push(output);
          }
        }

        resolve(outputs);
      });
    });
  }

  writeChannel(channel, outputs)
  {
    if (outputs.length === 0)
    {
      if (process.env.NODE_ENV === 'development')
      {
        return this.resetDevOutputs(channel);
      }

      return this.writeOutput(0x0000, 0x0800, channel);
    }

    return Promise.all(outputs.map(
      output => this.writeOutput(output, 0x0100, channel)
    ));
  }

  writeOutput(address, value, unit)
  {
    return new Promise((resolve, reject) =>
    {
      if (!this.master.isOpen())
      {
        return reject(this.app.createError('No MODBUS connection.'), 'NO_CONNECTION');
      }

      const t = this.master.writeSingleRegister(address, value, {unit});

      t.on('complete', (err, res) =>
      {
        if (err)
        {
          return reject(err);
        }

        if (res.isException())
        {
          return reject(this.app.createError(res.toString(), 'MODBUS_EXCEPTION'));
        }

        resolve();
      });
    });
  }

  resetDevOutputs(unit)
  {
    return new Promise((resolve, reject) =>
    {
      if (!this.master.isOpen())
      {
        return reject(this.app.createError('No MODBUS connection.'), 'NO_CONNECTION');
      }

      const t = this.master.writeMultipleRegisters(1, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], {unit});

      t.on('complete', (err, res) =>
      {
        if (err)
        {
          return reject(err);
        }

        if (res.isException())
        {
          return reject(this.app.createError(res.toString(), 'MODBUS_EXCEPTION'));
        }

        resolve();
      });
    });
  }

  setProgram(channels, leds)
  {
    if (this.destroyed)
    {
      return;
    }

    this.update({
      program: {channels, leds}
    });

    this.writeOutputs();
  }

  update(changes)
  {
    this.updatedAt = Date.now();

    Object.assign(this, changes);

    this.emit('changed', {
      _id: this.model._id,
      updatedAt: this.updatedAt,
      ...changes
    });
  }
};
