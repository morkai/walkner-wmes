// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const {EventEmitter} = require('events');

module.exports = class Station extends EventEmitter
{
  constructor(app, module, line, station, initialState)
  {
    super();

    this.module = module;
    this.logger = module.logger.create({submodule: 'station', line, station});
    this.line = line;
    this.station = station;
    this.destroyed = false;
    this.timers = {};
    this.updatedAt = Date.now();
    this.actionQueue = null;
    this.orderQueue = [];
    this.order = {};
    this.tester = null;

    this.on('changed', changes => app.broker.publish(`gft.stations.updated.${line}.${station}`, changes));

    this.timers.validateOrder = setInterval(this.validateOrder.bind(this), 15000);

    if (initialState && initialState.order)
    {
      this.orderQueue = initialState.orderQueue || [];

      this.act(this.loadOrder, initialState.order);
    }
    else
    {
      this.act(this.loadCurrentOrder);
    }
  }

  destroy()
  {
    Object.values(this.timers).forEach(timer => clearTimeout(timer));

    if (this.orderQueue.length)
    {
      this.update({orderQueue: []});
    }

    if (this.order.orderNo)
    {
      if (this.actionQueue)
      {
        this.actionQueue = [];
      }

      this.act(this.loadOrder, null);
    }

    this.destroyed = true;
  }

  getState()
  {
    return {
      updatedAt: this.updatedAt,
      line: this.line,
      station: this.station,
      tester: this.tester ? this.tester.getState() : null,
      orderQueue: this.orderQueue,
      order: this.order
    };
  }

  reloadOrder()
  {
    if (!this.order.orderNo)
    {
      return;
    }

    this.act(this.loadOrder, this.order.orderNo);
  }

  setOrder(orderNo)
  {
    if (this.order.orderNo === orderNo)
    {
      return;
    }

    if (this.orderQueue.includes(orderNo))
    {
      this.update({orderQueue: this.orderQueue.filter(o => o !== orderNo)});
    }

    this.act(this.loadOrder, orderNo);
  }

  handleNewOrderStarted(orderNo)
  {
    if (this.order.orderNo === orderNo)
    {
      return;
    }

    if (this.orderQueue.includes(orderNo))
    {
      return;
    }

    if (this.order.orderNo)
    {
      this.update({
        orderQueue: this.orderQueue.concat([orderNo])
      });
    }
    else
    {
      this.act(this.loadOrder, orderNo);
    }
  }

  handleOrderFinished(orderNo)
  {
    const orderQueue = this.orderQueue.filter(o => o !== orderNo);

    if (orderNo !== this.order.orderNo)
    {
      if (orderQueue.length !== this.orderQueue.length)
      {
        this.update({orderQueue});
      }

      return;
    }

    const nextOrderNo = orderQueue.shift() || null;

    if (orderQueue.length !== this.orderQueue.length)
    {
      this.update({orderQueue});
    }

    this.act(this.loadOrder, nextOrderNo);
  }

  handleWorkFinished()
  {
    if (this.orderQueue.length)
    {
      this.update({orderQueue: []});
    }

    if (this.order.orderNo)
    {
      this.act(this.loadOrder, null);
    }
  }

  update(changes)
  {
    if (!Object.keys(changes).length)
    {
      return;
    }

    this.updatedAt = Date.now();

    Object.assign(this, changes);

    this.emit('changed', {
      line: this.line,
      station: this.station,
      updatedAt: this.updatedAt,
      ...changes
    });
  }

  validateOrder()
  {
    if (this.order.numberOfDrivers && this.order.numberOfLeds)
    {
      return;
    }

    if (this.order.orderNo)
    {
      this.reloadOrder();

      return;
    }

    if (this.orderQueue.length)
    {
      this.act(this.loadOrder, this.orderQueue.shift());

      return;
    }
  }

  act(action, ...params)
  {
    if (this.timers.executeNextAction)
    {
      clearTimeout(this.timers.executeNextAction);
      this.timers.executeNextAction = null;
    }

    if (this.destroyed)
    {
      return;
    }

    if (this.actionQueue)
    {
      this.actionQueue.push({action, params});
    }
    else
    {
      this.actionQueue = [{action, params}];

      this.timers.executeNextAction = setTimeout(this.executeNextAction.bind(this), 1);
    }
  }

  async executeNextAction()
  {
    if (!this.actionQueue)
    {
      return;
    }

    const {action, params} = this.actionQueue.shift() || {action: null, params: null};

    if (!action)
    {
      this.actionQueue = null;

      return;
    }

    try
    {
      await action.apply(this, params);
    }
    catch (err)
    {
      this.logger.warn(err, 'Failed to execute action.');
    }

    if (this.timers.executeNextAction)
    {
      clearTimeout(this.timers.executeNextAction);
    }

    this.timers.executeNextAction = setTimeout(this.executeNextAction.bind(this), 1);
  }

  async loadOrder(orderNo)
  {
    try
    {
      this.logger.debug('Loading order...', {orderNo});

      const order = orderNo ? (await this.module.getOrderData(orderNo)) : {};

      this.logger.info('Order loaded.', {order});

      const newTester = order.numberOfDrivers && order.numberOfLeds ? this.resolveTester(order.tester) : null;
      const oldTester = this.tester;
      const changes = {order};

      if (newTester !== oldTester)
      {
        if (oldTester)
        {
          this.logger.debug('Unbound old tester.', {tester: oldTester.model._id});

          oldTester.unbindStation();

          changes.tester = null;
        }

        if (newTester)
        {
          this.logger.debug('Bound new tester.', {tester: newTester.model._id});

          changes.tester = newTester;

          newTester.bindStation(this.onTesterChanged.bind(this));
        }
      }

      if (newTester)
      {
        newTester.setProgram(order.numberOfDrivers, (order.numberOfLeds / order.numberOfDrivers) || 0);
      }

      this.update(changes);
    }
    catch (err)
    {
      this.logger.error(err, 'Failed to load order.', {orderNo});

      this.timers.executeNextAction = setTimeout(this.loadOrder.bind(this, orderNo), 5000);
    }
  }

  async loadCurrentOrder()
  {
    try
    {
      this.logger.debug('Loading current order...');

      const pso = await this.module.ProdShiftOrder
        .findOne({
          prodLine: this.line,
          startedAt: {$gte: new Date(Date.now() - 8 * 3600 * 1000)},
          finishedAt: null
        })
        .sort({startedAt: -1})
        .select({orderId: 1})
        .lean()
        .exec();

      if (!pso)
      {
        return this.logger.info('No current order.');
      }

      await this.loadOrder(pso.orderId);
    }
    catch (err)
    {
      this.logger.error(err, 'Failed to load current order.');

      this.timers.executeNextAction = setTimeout(this.loadCurrentOrder.bind(this), 10000);
    }
  }

  resolveTester(pattern)
  {
    const stationTesters = [];

    this.module.testers.forEach(tester =>
    {
      if (tester.match(this.line, this.station, pattern))
      {
        stationTesters.push(tester);
      }
    });

    if (stationTesters.length === 1)
    {
      return stationTesters[0];
    }

    return null;
  }

  onTesterChanged(changes)
  {
    this.logger.debug('Tester changed.', {tester: changes});

    this.emit('changed', {
      tester: changes
    });
  }
};
