// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const {fork} = require('child_process');
const _ = require('lodash');
const step = require('h5.step');

const cache = new Map();
const queue = [];
let inProgress = false;
let stemmer = null;

module.exports = function prepareSearchText(data, phrase, done)
{
  let input = data;

  if (!Array.isArray(input))
  {
    input = [input];
  }

  input = input.map(s => s == null ? '' : String(s));

  if (input.length === 1 && cache.has(input[0]))
  {
    return setImmediate(done, null, [cache.get(input[0])]);
  }

  queue.push({input, phrase, done});

  if (!inProgress)
  {
    inProgress = true;

    prepareNext();
  }
};

function prepareNext()
{
  const {input, phrase, done} = queue.shift();

  step(
    function()
    {
      const next = _.once(this.next());

      if (stemmer)
      {
        stem();
      }
      else
      {
        stemmer = fork(`${__dirname}/prepareSearchText.stemmer.js`);

        stemmer.on('error', cleanup);
        stemmer.on('close', cleanup);
        stemmer.once('message', stem);
      }

      function cleanup()
      {
        stemmer.removeAllListeners();
        stemmer.on('error', () => {});
        stemmer.kill();
        stemmer = null;

        next(new Error('Stemmer closed!'));
      }

      function stem()
      {
        const timeout = setTimeout(() =>
        {
          stemmer.removeAllListeners('message');
          next(new Error('Stemmer timeout.'));
        }, 1337);

        stemmer.once('message', result =>
        {
          clearTimeout(timeout);
          next(null, result);
        });
        stemmer.send({input, phrase});
      }
    },
    function(err, result)
    {
      done(err, result);

      if (cache.size > 10000)
      {
        cache.clear();
      }

      input.forEach((input, i) =>
      {
        if (input.length <= 50)
        {
          cache.set(input, result[i]);
        }
      });

      if (queue.length)
      {
        prepareNext();
      }
      else
      {
        inProgress = false;
      }
    }
  );
}
