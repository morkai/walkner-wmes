// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const moment = require('moment');
const axios = require('axios');

module.exports = async (app, module, req, res) =>
{
  const {
    Order,
    ProdShiftOrder,
    GftPcb
  } = module;

  const result = {
    error: null,
    orderNo: '',
    productFamily: '',
    productCode: '',
    productName: '',
    commercialDesignation: '',
    ltuneCode: '',
    driverType: '',
    numberOfDrivers: 0,
    numberOfLeds: 0,
    lampColor: 0,
    pcbName: '',
    pcbCode: '',
    numberOfPcbs: 0
  };

  if (!/^[0-9]{9}$/.test(req.params.id))
  {
    const pso = await ProdShiftOrder
      .findOne({
        prodLine: req.params.id,
        startedAt: {$gte: moment().subtract(8, 'hours').toDate()},
        finishedAt: null
      })
      .select({
        orderId: 1
      })
      .sort({
        startedAt: -1
      })
      .lean()
      .exec();

    if (pso)
    {
      req.params.id = pso.orderId;
    }
    else
    {
      result.error = `No active order on line: ${req.params.id}`;

      return res.json(result);
    }
  }

  result.orderNo = req.params.id;

  const sapOrder = await Order
    .findById(result.orderNo)
    .select({
      nc12: 1,
      name: 1,
      description: 1
    })
    .lean()
    .exec();

  if (!sapOrder)
  {
    result.error = `Production order not found: ${req.params.id}`;

    return res.json(result);
  }

  result.productCode = sapOrder.nc12;
  result.productName = sapOrder.name;
  result.commercialDesignation = sapOrder.description || '';

  const orderRes = await axios.get(`http://ketrzyn.ipt.intra.lighting.com/api/order/${result.orderNo}`, {
    validateStatus: null,
    proxy: false
  });

  if (orderRes.status !== 200)
  {
    result.error = `Invalid order response status: ${orderRes.status}`;

    return res.json(result);
  }

  if (Array.isArray(orderRes.data.order_overrides))
  {
    orderRes.data.order_overrides.forEach(override =>
    {
      const ipt = override.longtext && override.longtext.IPT;

      if (!ipt
        || !ipt.General
        || ipt.General.IPTfunction !== 'TraceabilityData')
      {
        return;
      }

      if (Array.isArray(ipt.ExternalSources))
      {
        ipt.ExternalSources.forEach(externalSource =>
        {
          if (externalSource.source === 'ltune'
            && externalSource.parameters
            && externalSource.parameters.programming
            && externalSource.parameters.programming !== 'NA')
          {
            result.ltuneCode = externalSource.parameters.programming;
          }
        });
      }

      const product = ipt.Data && ipt.Data.product;

      if (product)
      {
        if (product.productFamily)
        {
          result.productFamily = product.productFamily;
        }

        if (product.driverType)
        {
          result.driverType = product.driverType;
          result.numberOfDrivers = result.driverType
            .split('_')
            .filter(part => !!part.length && part !== '0')
            .length;
        }
      }

      const technical = ipt.Data && ipt.Data.technical;

      if (technical)
      {
        if (technical.ltuneCode && technical.ltuneCode !== 'NA')
        {
          result.ltuneCode = technical.ltuneCode;
        }

        if (technical.numberOfLeds > 0)
        {
          result.numberOfLeds = technical.numberOfLeds;
        }

        if (technical.productFamily)
        {
          result.productFamily = technical.productFamily;
        }
      }
    });
  }

  if (Array.isArray(orderRes.data.operations))
  {
    orderRes.data.operations.forEach(op =>
    {
      if (!op.parameters)
      {
        return;
      }

      if (op.operation === 'ProgramDeviceWithXMLFile')
      {
        if (op.parameters.numberOfDrivers)
        {
          result.numberOfDrivers = op.parameters.numberOfDrivers;
        }
      }
      else if (op.operation === 'PrintStandardLabel')
      {
        if (op.parameters.product)
        {
          if (op.parameters.product.productFamily)
          {
            result.productFamily = op.parameters.product.productFamily;
          }

          if (op.parameters.product.driverType)
          {
            result.driverType = op.parameters.product.driverType;
            result.numberOfDrivers = result.driverType
              .split('_')
              .filter(part => !!part.length && part !== '0')
              .length;
          }
        }

        if (op.parameters.technical)
        {
          if (op.parameters.technical.ltuneCode && op.parameters.technical.ltuneCode !== 'NA')
          {
            result.ltuneCode = op.parameters.technical.ltuneCode;
          }

          if (op.parameters.technical.numberOfLeds > 0)
          {
            result.numberOfLeds = op.parameters.technical.numberOfLeds;
          }

          if (op.parameters.technical.productFamily)
          {
            result.productFamily = op.parameters.technical.productFamily;
          }
        }
      }
    });
  }

  if (result.ltuneCode)
  {
    const itisRes = await axios.get(`http://import.ipt.intra.lighting.com/itis/${result.ltuneCode}`, {
      validateStatus: null,
      proxy: false
    });

    if (itisRes.status !== 200)
    {
      result.error = `Invalid itis response status: ${itisRes.status}`;

      return res.json(result);
    }

    if (!itisRes.data.data)
    {
      result.error = `Invalid itis response body.`;

      return res.json(result);
    }

    if (itisRes.data.data.LAMP_COLOUR)
    {
      result.lampColor = +itisRes.data.data.LAMP_COLOUR;
    }

    if (itisRes.data.data.DRIVERS_CODE_KEY)
    {
      result.driverType = itisRes.data.data.DRIVERS_CODE_KEY;
      result.numberOfDrivers = result.driverType
        .split(':')
        .filter(part => !!part.length && part !== '0').length;
    }
  }

  const pcb = await GftPcb
    .findOne({
      productFamily: result.productFamily,
      lampColor: result.lampColor,
      ledCount: result.numberOfLeds
    })
    .select({
      name: 1,
      code: 1,
      quantity: 1
    })
    .lean()
    .exec();

  if (pcb)
  {
    result.pcbName = pcb.name;
    result.pcbCode = pcb.code;
    result.numberOfPcbs = pcb.quantity;
  }

  res.json(result);
};
