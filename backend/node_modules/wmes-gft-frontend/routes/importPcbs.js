// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const step = require('h5.step');
const xlsx = require('xlsx');
const fs = require('fs-extra');
const jsonDeepEqual = require('util/jsonDeepEqual');

module.exports = (app, module, req, res, next) =>
{
  const {
    GftPcb
  } = module;

  step(
    function()
    {
      fs.readFile(req.file.path, this.parallel());
    },
    function(err, buffer)
    {
      if (err)
      {
        return this.skip(err);
      }

      try
      {
        const workbook = xlsx.read(buffer, {
          type: 'buffer',
          cellFormula: false,
          cellHTML: false,
          cellText: false,
          cellStyles: true
        });

        const sheets = workbook.SheetNames.map(name => workbook.Sheets[name]);

        setImmediate(this.next(), null, sheets);
      }
      catch (err)
      {
        this.skip(err);
      }
    },
    function(err, sheets)
    {
      if (err)
      {
        return this.skip(err);
      }

      const pcbs = [];

      sheets.forEach(sheet => parseSheet(sheet, pcbs));

      setImmediate(this.next(), null, pcbs);
    },
    function(err, pcbs)
    {
      if (err)
      {
        return this.skip(err);
      }

      setImmediate(this.parallel(), null, pcbs.length);

      importNext(pcbs, this.parallel());
    },
    function(err, count)
    {
      fs.unlink(req.file.path, () => {});

      if (err)
      {
        return next(err);
      }

      if (count)
      {
        module.info('PCBs imported!', {count});

        app.broker.publish('gft.pcbs.imported', {count});
      }

      res.sendStatus(204);
    }
  );

  function parseSheet(sheet, pcbs)
  {
    const addresses = {
      name: null,
      code: null,
      quantity: null,
      productFamily: [],
      lampColor: [],
      ledCount: []
    };
    let group = '';
    let range = null;

    try
    {
      range = xlsx.utils.decode_range(sheet['!ref']);
    }
    catch (err)
    {
      return this.skip(err);
    }

    for (let c = range.s.c; c <= range.e.c; ++c)
    {
      const col = xlsx.utils.encode_col(c);
      const row1 = range.s.r + 1;
      const row2 = range.s.r + 2;
      const cell1 = sheet[col + row1];
      const cell2 = sheet[col + row2];

      if (!cell1 || !cell2)
      {
        continue;
      }

      const v1 = String(cell1.v || '').trim().replace(/[^0-9A-Za-z]+/g, '').toLowerCase();
      const v2 = String(cell2.v || '').trim().replace(/[^0-9A-Za-z]+/g, '').toLowerCase();

      if (v1.endsWith('pfc'))
      {
        group = 'productFamily';
      }
      else if (v1.endsWith('collamp'))
      {
        group = 'lampColor';
      }
      else if (v1.endsWith('nlp'))
      {
        group = 'ledCount';
      }

      if (group)
      {
        if (v2)
        {
          addresses[group].push({
            col,
            val: v2.toUpperCase()
          });

          continue;
        }

        break;
      }

      if (/omschrijving|name|desc/.test(v2))
      {
        addresses.name = col;

        continue;
      }

      if (/12nc|code/.test(v2))
      {
        addresses.code = col;

        continue;
      }

      if (/aantal|qty|quantity/.test(v2))
      {
        addresses.quantity = col;

        continue;
      }
    }

    const anyAddressMissing = Object.values(addresses).some(
      addr => addr === null || (Array.isArray(addr) && !addr.length)
    );

    if (anyAddressMissing)
    {
      return;
    }

    let emptyCount = 0;
    let lastName = '';

    for (let r = range.s.r + 2; r <= range.e.r + 1; ++r)
    {
      const pcb = {
        code: parseStringCell(sheet[addresses.code + r]),
        name: parseStringCell(sheet[addresses.name + r]),
        quantity: parseNumericCell(sheet[addresses.quantity + r]),
        productFamily: [],
        lampColor: [],
        ledCount: []
      };

      if (pcb.name)
      {
        lastName = pcb.name;
      }
      else if (lastName)
      {
        pcb.name = lastName;
      }

      if (!pcb.quantity)
      {
        continue;
      }

      if (!pcb.code)
      {
        emptyCount += 1;
      }

      if (emptyCount >= 5)
      {
        break;
      }

      addresses.productFamily.forEach(item =>
      {
        if (parseStringCell(sheet[item.col + r]).toLowerCase() !== '')
        {
          pcb.productFamily.push(item.val);
        }
      });

      addresses.lampColor.forEach(item =>
      {
        if (parseStringCell(sheet[item.col + r]).toLowerCase() !== '')
        {
          pcb.lampColor.push(+item.val);
        }
      });

      addresses.ledCount.forEach(item =>
      {
        if (parseStringCell(sheet[item.col + r]).toLowerCase() !== '')
        {
          pcb.ledCount.push(+item.val);
        }
      });

      if (pcb.code
        && pcb.name
        && pcb.quantity
        && pcb.productFamily.length
        && pcb.lampColor.length
        && pcb.ledCount.length)
      {
        pcbs.push(pcb);
      }
    }
  }

  function parseStringCell(cell)
  {
    return !cell || cell.v == null ? '' : cell.v.toString().trim();
  }

  function parseNumericCell(cell)
  {
    if (!cell || cell.v == null)
    {
      return 0;
    }

    if (typeof cell.v === 'number')
    {
      return cell.v;
    }

    return parseInt(cell.v, 10) || 0;
  }

  function importNext(pcbs, done)
  {
    if (!pcbs.length)
    {
      return done();
    }

    const pcb = pcbs.shift();
    const conditions = {
      code: pcb.code,
      quantity: pcb.quantity
    };
    const update = {$set: pcb};

    GftPcb.collection.updateOne(conditions, update, {upsert: true}, err =>
    {
      if (err)
      {
        return done(err);
      }

      importNext(pcbs, done);
    });
  }
};
