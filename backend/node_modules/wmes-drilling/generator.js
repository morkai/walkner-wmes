// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const {createHash} = require('crypto');
const _ = require('lodash');
const moment = require('moment');
const step = require('h5.step');
const jsonDeepEqual = require('util/jsonDeepEqual');
const resolveProductName = require('util/resolveProductName');

const ORDER_COMPARE_PROPERTIES = [
  'followups',
  'no',
  'date',
  'nc12',
  'name',
  'qty',
  'qtyDrill',
  'mrp',
  'placement',
  'startTime',
  'component',
  'painted',
  'childOrders'
];

const SAP_ORDER_FIELDS = {
  leadingOrder: 1,
  name: 1,
  description: 1,
  nc12: 1,
  qty: 1,
  mrp: 1,
  bom: 1,
  statuses: 1,
  operations: 1
};

const LOCKED = {};

module.exports = (app, module) =>
{
  if (!module.config.generator)
  {
    return;
  }

  const logger = module.logger.create({submodule: 'generator'});
  const {
    settings,
    Order,
    Plan,
    PlanSettings,
    DrillingEvent,
    DrillingOrder
  } = module;

  app.broker.subscribe('drilling.generator.requested', handleRequest);

  app.broker.subscribe('planning.changes.created', change =>
  {
    if (change.user !== null || (Object.keys(change.data).length === 1 && change.data.settings))
    {
      return;
    }

    generate(change.plan);
  });

  function handleRequest(message)
  {
    const date = moment.utc(message.date, 'YYYY-MM-DD');

    if (date.isValid())
    {
      generate(date.toDate());
    }
  }

  function createDrillingOrder(date, o)
  {
    return {
      _id: o._id,
      status: 'new',
      startedAt: null,
      finishedAt: null,
      comment: '',
      order: o._id,
      followups: [],
      no: 0,
      date,
      nc12: o.nc12,
      name: o.name,
      qty: o.qty || o.qtyTodo,
      qtyDone: 0,
      qtyDrill: 0,
      mrp: o.mrp,
      placement: '',
      startTime: 0,
      component: null,
      painted: false,
      childOrders: []
    };
  }

  function generate(date)
  {
    const startedAt = Date.now();
    const key = moment.utc(date).format('YYYY-MM-DD');

    logger.info('Generating...', {key});

    app.broker.publish('drilling.generator.started', {
      date: key
    });

    step(
      function()
      {
        if (LOCKED[key])
        {
          return this.skip(new Error('Locked!'));
        }
      },
      function()
      {
        settings.findValues('paintShop.', this.parallel());

        settings.findValues('drilling.', this.parallel());

        PlanSettings
          .findById(date)
          .select({
            requiredStatuses: 1
          })
          .lean()
          .exec(this.parallel());

        Plan.aggregate([
          {$match: {_id: date}},
          {$unwind: '$orders'},
          {$match: {'orders.date': key}},
          {$project: {
            _id: '$orders._id',
            name: '$orders.name',
            nc12: '$orders.nc12',
            qtyTodo: '$orders.quantityTodo',
            qtyDone: '$orders.quantityDone',
            mrp: '$orders.mrp',
            statuses: '$orders.statuses'
          }}
        ], this.parallel());

        Plan.aggregate([
          {$match: {_id: date}},
          {$unwind: '$lines'},
          {$unwind: '$lines.orders'},
          {$group: {
            _id: '$lines.orders.orderNo',
            startAt: {$min: '$lines.orders.startAt'}
          }}
        ], this.parallel());
      },
      function(err, psSettings, drillSettings, planSettings, orders, startTimes)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (_.isEmpty(psSettings.workCenters))
        {
          return this.skip(app.createError('No paint-shop WorkCenters specified.', 'CONFIG', 500));
        }

        if (_.isEmpty(drillSettings.workCenters))
        {
          return this.skip(app.createError('No drilling WorkCenters specified.', 'CONFIG', 500));
        }

        this.settings = {
          ps: psSettings,
          drill: drillSettings,
          plan: planSettings
        };
        this.newOrders = new Map();
        this.deletedOrders = new Set();

        orders.forEach(o =>
        {
          if (isDeletedOrder(o.statuses))
          {
            this.deletedOrders.add(o._id);
          }

          this.newOrders.set(o._id, createDrillingOrder(date, o));
        });

        startTimes.forEach(o =>
        {
          if (this.newOrders.has(o._id))
          {
            this.newOrders.get(o._id).startTime = o.startAt.getTime();
          }
        });

        setImmediate(this.next());
      },
      function()
      {
        const scheduledStartDate = moment(key, 'YYYY-MM-DD').toDate();
        const workCenters = this.settings.drill.workCenters;
        const leadingOrders = Array.from(this.newOrders.keys());
        const statuses = {
          $in: this.settings.plan.requiredStatuses
        };
        const plannedConditions = {
          scheduledStartDate,
          statuses,
          leadingOrder: {$in: leadingOrders}
        };
        const unplannedConditions = {
          scheduledStartDate,
          statuses,
          leadingOrder: null
        };
        const splitConditions = {
          scheduledStartDate,
          statuses,
          leadingOrder: {$nin: [null].concat(leadingOrders)}
        };

        if (!_.isEmpty(workCenters))
        {
          plannedConditions['operations.workCenter'] = {$in: workCenters};
          unplannedConditions['operations.workCenter'] = {$in: workCenters};
          splitConditions['operations.workCenter'] = {$in: workCenters};
        }

        Order
          .find(plannedConditions)
          .select(SAP_ORDER_FIELDS)
          .lean()
          .exec(this.parallel());

        Order
          .find(unplannedConditions)
          .select(SAP_ORDER_FIELDS)
          .lean()
          .exec(this.parallel());

        Order
          .find(splitConditions)
          .select(SAP_ORDER_FIELDS)
          .lean()
          .exec(this.parallel());
      },
      function(err, childOrders, unplannedOrders, splitChildOrders)
      {
        if (err)
        {
          return this.skip(err);
        }

        this.unplannedOrderNos = new Set();

        unplannedOrders.concat(splitChildOrders).forEach(unplannedOrder =>
        {
          if (unplannedOrder.leadingOrder === null || unplannedOrder.leadingOrder === unplannedOrder._id)
          {
            unplannedOrder.leadingOrder = unplannedOrder._id;
          }

          childOrders.push(unplannedOrder);

          this.unplannedOrderNos.add(unplannedOrder._id);

          if (!this.newOrders.has(unplannedOrder._id))
          {
            this.newOrders.set(unplannedOrder._id, createDrillingOrder(date, unplannedOrder));
          }
        });

        const leadingOrders = new Set();

        childOrders.forEach(childOrder =>
        {
          const leadingOrder = this.newOrders.get(childOrder.leadingOrder);

          if (!leadingOrder)
          {
            leadingOrders.add(childOrder.leadingOrder);
          }
        });

        setImmediate(this.parallel(), null, childOrders);

        if (!leadingOrders.size)
        {
          setImmediate(this.parallel(), null, []);

          return;
        }

        Order
          .find({
            scheduledStartDate: moment(key, 'YYYY-MM-DD').toDate(),
            leadingOrder: {$in: Array.from(leadingOrders)}
          })
          .select(SAP_ORDER_FIELDS)
          .lean()
          .exec(this.parallel());
      },
      function(err, childOrders, leadingOrders)
      {
        if (err)
        {
          return this.skip(err);
        }

        leadingOrders.forEach(leadingOrder =>
        {
          this.newOrders.set(leadingOrder._id, createDrillingOrder(date, leadingOrder));
        });

        this.childOrderComponentCounts = new Map();

        childOrders.forEach(childOrder =>
        {
          if (isDeletedOrder(childOrder.statuses))
          {
            this.deletedOrders.add(childOrder._id);
          }

          let leadingOrder = this.newOrders.get(childOrder.leadingOrder);

          if (!leadingOrder)
          {
            childOrder.leadingOrder = childOrder._id;
            leadingOrder = this.newOrders.get(childOrder._id);
          }

          if (_.isEmpty(childOrder.bom)
            || (!this.unplannedOrderNos.has(childOrder._id) && childOrder._id === leadingOrder._id))
          {
            return;
          }

          let component = null;
          let componentCount = 0;

          childOrder.bom.sort((a, b) =>
          {
            if (a.unit === b.unit && a.unit === 'PCE')
            {
              return a.name.localeCompare(b.name);
            }

            return 0;
          });

          const components = childOrder.bom.map(c =>
          {
            if (c.unit === 'PCE')
            {
              componentCount += 1;

              if (!component)
              {
                component = {
                  nc12: c.nc12,
                  name: c.name
                };
              }
            }

            return {
              nc12: c.nc12,
              name: c.name,
              qty: c.qty,
              unit: c.unit
            };
          });

          if (!component)
          {
            return;
          }

          this.childOrderComponentCounts.set(childOrder._id, componentCount);

          leadingOrder.childOrders.push({
            order: childOrder._id,
            nc12: childOrder.nc12,
            name: resolveProductName(childOrder),
            qty: childOrder.qty,
            mrp: childOrder.mrp,
            component,
            components,
            deleted: this.deletedOrders.has(childOrder._id)
          });
        });

        this.newOrders.forEach(newOrder =>
        {
          if (!newOrder.childOrders.length)
          {
            return;
          }

          newOrder.childOrders.sort((a, b) =>
          {
            let cmp = a.component.nc12.localeCompare(b.component.nc12);

            if (cmp === 0)
            {
              cmp = a.order.localeCompare(b.order);
            }

            return cmp;
          });

          newOrder.component = newOrder.childOrders[0].component;
        });

        setImmediate(this.next());
      },
      function()
      {
        this.multiComponentOrders = new Set();

        const newOrders = Array.from(this.newOrders.values());

        this.newOrders.clear();

        newOrders.forEach(newOrder =>
        {
          const originalNewOrder = newOrder;
          const {childOrders} = newOrder;

          if (!childOrders.length)
          {
            return;
          }

          const newOrderIds = [];

          newOrder.childOrders = [];

          childOrders.forEach(childOrder =>
          {
            if (newOrder.component.nc12 === childOrder.component.nc12)
            {
              newOrder._id += `-${childOrder.order}`;

              newOrder.childOrders.push(childOrder);

              delete childOrder.component;
            }
            else
            {
              newOrder._id = createHash('md5').update(newOrder._id).digest('hex').toUpperCase();

              this.newOrders.set(newOrder._id, newOrder);

              newOrderIds.push(newOrder._id);

              newOrder = Object.assign({}, newOrder, {
                _id: `${newOrder.order}-${childOrder.order}`,
                component: childOrder.component,
                childOrders: [childOrder]
              });

              delete childOrder.component;

              this.multiComponentOrders.add(newOrder);
            }
          });

          newOrder._id = createHash('md5').update(newOrder._id).digest('hex').toUpperCase();

          this.newOrders.set(newOrder._id, newOrder);

          if (newOrder !== originalNewOrder)
          {
            this.multiComponentOrders.add(newOrder);
          }

          newOrderIds.push(newOrder._id);

          if (newOrderIds.length === 1)
          {
            return;
          }

          newOrderIds.forEach(newOrderId =>
          {
            this.newOrders.get(newOrderId).followups = _.without(newOrderIds, newOrderId);
          });
        });
      },
      function()
      {
        DrillingOrder
          .find({date})
          .lean()
          .exec(this.parallel());

        const unpaintedComponents = new Set();

        this.sapOrderToDrillOrders = new Map();

        this.newOrders.forEach(leadingOrder =>
        {
          if (leadingOrder.order === leadingOrder.childOrders[0].order)
          {
            return;
          }

          leadingOrder.childOrders.forEach(childOrder =>
          {
            unpaintedComponents.add(childOrder.nc12);
          });

          if (!this.sapOrderToDrillOrders.has(leadingOrder.order))
          {
            this.sapOrderToDrillOrders.set(leadingOrder.order, []);
          }

          this.sapOrderToDrillOrders.get(leadingOrder.order).push(leadingOrder);
        });

        Order
          .find({
            leadingOrder: {$in: Array.from(this.sapOrderToDrillOrders.keys())},
            statuses: {$in: this.settings.plan.requiredStatuses},
            'bom.nc12': {$in: Array.from(unpaintedComponents)},
            'operations.workCenter': {$in: this.settings.ps.workCenters}
          })
          .select({
            leadingOrder: 1,
            'bom.nc12': 1
          })
          .hint({leadingOrder: 1})
          .lean()
          .exec(this.parallel());
      },
      function(err, oldDrillOrders, paintedSapOrders)
      {
        if (err)
        {
          return this.skip(err);
        }

        this.oldOrders = new Map();

        oldDrillOrders.forEach(o => this.oldOrders.set(o._id, o));

        paintedSapOrders.forEach(sapOrder =>
        {
          const drillOrders = this.sapOrderToDrillOrders.get(sapOrder.leadingOrder);
          const components = new Set();

          sapOrder.bom.forEach(component => components.add(component.nc12));

          drillOrders.forEach(drillOrder =>
          {
            drillOrder.painted = drillOrder.painted
              || drillOrder.childOrders.some(childOrder => components.has(childOrder.nc12));
          });
        });

        setImmediate(this.next());
      },
      function()
      {
        const secondShiftTime = moment.utc(date).hours(14).valueOf();
        const groupedOrders = groupOrdersByComponent(this.newOrders, this.multiComponentOrders, secondShiftTime);
        const newOrders = listNewOrders(groupedOrders, this.newOrders);
        const mergedNewOrders = mergeNewOrders(newOrders, this.newOrders);

        mergedNewOrders.forEach((newOrder, i) =>
        {
          newOrder.no = i + 1;

          newOrder.childOrders.forEach(childOrder =>
          {
            newOrder.qtyDrill += childOrder.qty * this.childOrderComponentCounts.get(childOrder.order);
          });
        });

        setImmediate(this.next());
      },
      function()
      {
        this.changeLog = {
          added: [],
          changed: [],
          removed: []
        };
        this.changes = {
          added: [],
          changed: [],
          removed: []
        };
        this.events = [];

        this.oldOrders.forEach(oldOrder =>
        {
          const newOrder = this.newOrders.get(oldOrder._id);

          this.newOrders.delete(oldOrder._id);

          if (!newOrder || newOrder.childOrders.length === 0)
          {
            if (oldOrder.status === 'new')
            {
              this.changes.removed.push({
                _id: oldOrder._id,
                order: oldOrder.order
              });
            }
            else if (oldOrder.status === 'partial')
            {
              this.changes.changed.push({
                _id: oldOrder._id,
                order: oldOrder.order,
                status: 'cancelled',
                comment: recordEvent(this.events, 'cancelled', oldOrder)
              });
            }
            else if (oldOrder.status !== 'cancelled')
            {
              this.changes.changed.push({
                _id: oldOrder._id,
                order: oldOrder.order,
                comment: recordEvent(this.events, 'comment', oldOrder)
              });
            }

            return;
          }

          const changed = compareOrders(oldOrder, newOrder, this.events, this.deletedOrders.has(oldOrder.order));

          if (changed)
          {
            this.changes.changed.push(changed);
          }
        });

        this.newOrders.forEach(newOrder =>
        {
          if (!newOrder.childOrders.length)
          {
            return;
          }

          if (this.deletedOrders.has(newOrder.order))
          {
            newOrder.status = 'cancelled';
            newOrder.comment = recordEvent(this.events, 'cancelled', newOrder);
          }

          this.changes.added.push(newOrder);
        });

        setImmediate(this.next());
      },
      function()
      {
        const {added, changed, removed} = this.changes;

        this.notAdded = new Map();

        if (added.length)
        {
          const next = this.group();

          DrillingOrder.collection.insertMany(added, {ordered: false, w: 'majority'}, (err, res) =>
          {
            if (err && err.result)
            {
              res = err.result;
            }

            if (res && res.hasWriteErrors && res.hasWriteErrors())
            {
              res.getWriteErrors().forEach(writeError =>
              {
                const duplicateOrder = writeError.getOperation();

                this.notAdded.set(duplicateOrder._id, duplicateOrder);
              });

              this.changes.added = added.filter(o => !this.notAdded.has(o._id));
            }

            next(err && err.code === 11000 ? null : err);
          });
        }

        if (this.events.length)
        {
          const next = this.group();

          DrillingEvent.collection.insertMany(this.events, {ordered: false}, err =>
          {
            if (err)
            {
              logger.error(err, `Failed to save events.`, {key});
            }

            next();
          });
        }

        if (removed.length)
        {
          DrillingOrder.collection.deleteMany({_id: {$in: removed.map(o => o._id)}}, {w: 'majority'}, this.group());
        }

        changed.forEach(change =>
        {
          DrillingOrder.collection.updateOne({_id: change._id}, {$set: change}, {w: 'majority'}, this.group());
        });
      },
      function(err)
      {
        if (err)
        {
          return this.skip(err);
        }

        this.notAdded.forEach(duplicateOrder =>
        {
          const next = this.group();
          const filter = {_id: duplicateOrder._id};
          const update = {$set: _.pick(duplicateOrder, ORDER_COMPARE_PROPERTIES)};
          const options = {returnOriginal: false, w: 'majority'};

          DrillingOrder.collection.findOneAndUpdate(filter, update, options, (err, res) =>
          {
            if (err)
            {
              logger.error(err, 'Failed to update duplicate order.', {
                key,
                duplicateOrderId: duplicateOrder._id
              });
            }
            else if (res.ok)
            {
              this.changes.added.push(res.value);
            }

            next();
          });
        });
      },
      function(err)
      {
        if (err)
        {
          return logger.error(err, 'Failed to generate.');
        }

        const added = this.changes.added.length;
        const changed = this.changes.changed.length;
        const removed = this.changes.removed.length;
        const duration = (Date.now() - startedAt) / 1000;

        logger.info('Generated.', {added, changed, removed, duration});

        if (added || changed || removed)
        {
          app.broker.publish(`${DrillingOrder.TOPIC_PREFIX}.changed.${key}`, {
            date: date,
            changes: this.changes
          });
        }

        app.broker.publish('drilling.generator.finished', {
          date: key,
          changeCount: {added, changed, removed},
          duration
        });
      }
    );
  }

  function recordEvent(events, type, order)
  {
    const comment = 'Zlecenie usunięte z planu.';

    if (order.comment !== comment)
    {
      events.push({
        order: order._id,
        type: type,
        time: new Date(),
        user: {
          id: null,
          ip: '127.0.0.1',
          label: 'System'
        },
        data: {comment}
      });
    }

    return comment;
  }

  function isDeletedOrder(statuses)
  {
    return statuses.includes('TECO') || statuses.includes('DLFL') || statuses.includes('DLT');
  }

  function groupOrdersByComponent(newOrders, multiComponentOrders, secondShiftTime)
  {
    const componentToOrders = {};

    newOrders.forEach(newOrder =>
    {
      if (multiComponentOrders.has(newOrder))
      {
        return;
      }

      const component = newOrder.component.nc12;

      if (!componentToOrders[component])
      {
        componentToOrders[component] = {
          firstShiftOrderCount: 0,
          firstShiftQuantity: 0,
          orders: []
        };
      }

      if (!multiComponentOrders.has(newOrder))
      {
        componentToOrders[component].orders.push(newOrder);
      }

      if (newOrder.startTime < secondShiftTime)
      {
        componentToOrders[component].firstShiftOrderCount += 1;

        newOrder.childOrders.forEach(childOrder =>
        {
          componentToOrders[component].firstShiftQuantity += childOrder.qty;
        });
      }
    });

    return sortGroupedOrders(_.values(componentToOrders));
  }

  function sortGroupedOrders(groupedOrders)
  {
    groupedOrders.forEach(group => group.orders.sort(sortByStartTime));

    groupedOrders.sort((groupA, groupB) =>
    {
      if (groupA.firstShiftOrderCount !== groupB.firstShiftOrderCount)
      {
        return groupB.firstShiftOrderCount - groupA.firstShiftOrderCount;
      }

      if (groupA.firstShiftQuantity !== groupB.firstShiftQuantity)
      {
        return groupB.firstShiftQuantity - groupA.firstShiftQuantity;
      }

      return sortByStartTime(groupA.orders[0], groupB.orders[0]);
    });

    return groupedOrders;
  }

  function listNewOrders(groupedOrders, allOrders)
  {
    const newOrders = [];
    const followups = new Set();
    let lastComponent = null;

    groupedOrders.forEach(group =>
    {
      group.orders.forEach(order =>
      {
        if (lastComponent !== null && lastComponent.nc12 !== order.component.nc12)
        {
          Array.from(followups).sort(sortByStartTime).forEach(splitOrder => newOrders.push(splitOrder));

          followups.clear();
        }

        newOrders.push(order);

        order.followups.forEach(followupId =>
        {
          followups.add(allOrders.get(followupId));
        });

        lastComponent = order.component;
      });
    });

    Array.from(followups).sort(sortByStartTime).forEach(splitOrder => newOrders.push(splitOrder));

    return newOrders;
  }

  function mergeNewOrders(newOrders, allOrders)
  {
    if (!newOrders.length)
    {
      return [];
    }

    const mergedOrders = [newOrders[0]];

    for (let i = newOrders.length - 1; i >= 1; --i)
    {
      const nextOrder = newOrders[i];
      const prevOrder = newOrders[i - 1];

      if (nextOrder.order !== prevOrder.order)
      {
        mergedOrders.unshift(nextOrder);

        continue;
      }

      allOrders.delete(nextOrder._id);

      prevOrder.childOrders.push.apply(prevOrder.childOrders, nextOrder.childOrders);

      prevOrder.followups.forEach(followupId =>
      {
        const followup = allOrders.get(followupId);

        if (followup)
        {
          followup.followups = _.without(followup.followups, prevOrder._id);
        }
      });

      prevOrder.followups = _.without(prevOrder.followups, prevOrder._id, nextOrder._id);
    }

    return mergedOrders;
  }

  function sortByStartTime(a, b)
  {
    if (a.startTime === b.startTime)
    {
      return 0;
    }

    if (a.startTime === 0 && b.startTime !== 0)
    {
      return 1;
    }

    if (a.startTime !== 0 && b.startTime === 0)
    {
      return -1;
    }

    return a.startTime - b.startTime;
  }

  function compareOrders(oldOrder, newOrder, events, deleted)
  {
    const changes = {
      _id: oldOrder._id
    };

    if (deleted)
    {
      if (oldOrder.status === 'new' || oldOrder.status === 'partial')
      {
        changes.status = 'cancelled';
        changes.comment = recordEvent(events, 'cancelled', oldOrder);
      }
      else if (oldOrder.status !== 'cancelled')
      {
        changes.comment = recordEvent(events, 'comment', oldOrder);
      }
    }

    ORDER_COMPARE_PROPERTIES.forEach(p =>
    {
      const oldValue = oldOrder[p];
      const newValue = newOrder[p];

      if (p === 'childOrders')
      {
        if (!compareChildOrders(oldValue, newValue))
        {
          changes[p] = newValue;
        }

        return;
      }

      if (!jsonDeepEqual(oldValue, newValue))
      {
        changes[p] = newValue;
      }
    });

    return Object.keys(changes).length > 1 ? changes : null;
  }

  function compareChildOrders(oldChildOrders, newChildOrders)
  {
    if (oldChildOrders.length !== newChildOrders.length)
    {
      return false;
    }

    for (let i = 0; i < oldChildOrders.length; ++i)
    {
      const oldChildOrder = oldChildOrders[i];
      const newChildOrder = newChildOrders.find(o => o.order === oldChildOrder.order);

      if (!newChildOrder)
      {
        return false;
      }

      if (!jsonDeepEqual(oldChildOrder, newChildOrder))
      {
        return false;
      }
    }

    return true;
  }
};
