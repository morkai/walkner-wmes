// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const step = require('h5.step');
const util = require('./util');

module.exports = function(app, productionModule, prodLine, logEntry, done)
{
  const mongoose = app[productionModule.config.mongooseId];
  const Order = mongoose.model('Order');
  const ProdDowntime = mongoose.model('ProdDowntime');

  step(
    function()
    {
      productionModule.getProdData('order', logEntry.prodShiftOrder, this.next());
    },
    function(err, prodShiftOrder)
    {
      if (err)
      {
        productionModule.error(err, 'Failed to get the prod shift order to correct.', {
          prodShiftOrderId: logEntry.prodShiftOrder,
          prodLogEntryId: logEntry._id
        });

        return this.skip(err);
      }

      if (!prodShiftOrder)
      {
        productionModule.warn(`Couldn't find prod shift order to correct.`, {
          prodShiftOrderId: logEntry.prodShiftOrder,
          prodLogEntryId: logEntry._id
        });

        return this.skip();
      }

      setImmediate(this.parallel(), null, prodShiftOrder);

      if (util.isOfflineEntry(logEntry))
      {
        util.fillOrderData(app, productionModule, logEntry, this.parallel());
      }
    },
    function(err, prodShiftOrder)
    {
      if (err)
      {
        return this.skip(err);
      }

      this.oldOrderNo = prodShiftOrder.orderId;

      prodShiftOrder.set(logEntry.data);

      this.newOrderNo = prodShiftOrder.orderId;

      prodShiftOrder.save(this.next());
    },
    function(err)
    {
      if (err)
      {
        productionModule.error(err, 'Failed to save prod shift order after correcting it.', {
          prodShiftOrderId: logEntry.prodShiftOrder,
          prodLogEntryId: logEntry._id
        });

        return this.skip(err);
      }

      Order.recountQtyDone(this.oldOrderNo, this.group());

      if (this.newOrderNo !== this.oldOrderNo)
      {
        Order.recountQtyDone(this.newOrderNo, this.group());
      }

      correctProdDowntimes(this.group());
    },
    util.createRecalcShiftOrderDataStep(productionModule, logEntry),
    done
  );

  function correctProdDowntimes(done)
  {
    const query = ProdDowntime.find({prodShiftOrder: logEntry.prodShiftOrder}, {_id: 1}).lean();

    query.exec((err, prodDowntimes) =>
    {
      if (err)
      {
        productionModule.error(err, 'Failed to find prod downtimes after correcting prod shift order.', {
          prodShiftOrderId: logEntry.prodShiftOrder,
          prodLogEntryId: logEntry._id
        });

        return done();
      }

      if (!prodDowntimes.length)
      {
        return done();
      }

      step(
        function correctProdDowntimesStep()
        {
          prodDowntimes.forEach((prodDowntime) =>
          {
            correctProdDowntime(prodDowntime._id, this.parallel());
          });
        },
        done
      );
    });
  }

  function correctProdDowntime(prodDowntimeId, done)
  {
    productionModule.getProdData('downtime', prodDowntimeId, (err, prodDowntime) =>
    {
      if (err)
      {
        productionModule.error(err, 'Failed to find prod downtime after correcting prod shift order.', {
          prodShiftOrderId: logEntry.prodShiftOrder,
          prodLogEntryId: logEntry._id,
          prodDowntimeId
        });

        return done();
      }

      const changes = {
        mechOrder: !!logEntry.data.mechOrder,
        orderId: logEntry.data.orderId,
        operationNo: logEntry.data.operationNo
      };

      prodDowntime.set(changes);
      prodDowntime.save((err) =>
      {
        if (err)
        {
          productionModule.error(err, 'Failed to save prod downtime after correcting prod shift order.', {
            prodShiftOrderId: logEntry.prodShiftOrder,
            prodLogEntryId: logEntry._id,
            prodDowntimeId
          });
        }

        return done();
      });
    });
  }
};
