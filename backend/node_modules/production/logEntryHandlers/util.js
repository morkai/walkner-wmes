// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');
const orderFinder = require('../orderFinder');

exports.isOfflineEntry = function(logEntry)
{
  const orderData = logEntry.data.orderData;

  return !orderData
    || !orderData.operations
    || typeof orderData.operations !== 'object'
    || Array.isArray(orderData.operations)
    || _.isEmpty(orderData.operations);
};

exports.fillOrderData = function(app, productionModule, logEntry, done)
{
  if (logEntry.data.mechOrder)
  {
    fillMechOrderData(app, productionModule, logEntry, done);
  }
  else
  {
    fillProdOrderData(app, productionModule, logEntry, done);
  }
};

exports.createRecalcShiftTimesStep = function(productionModule, logEntry)
{
  return function recalcShiftTimesStep(err)
  {
    if (err)
    {
      return this.skip(err);
    }

    step(
      function findProdShiftStep()
      {
        productionModule.getProdData('shift', logEntry.prodShift, this.next());
      },
      function recalcProdShiftStep(err, prodShift)
      {
        if (err)
        {
          productionModule.error(err, 'Failed to find prod shift to recalc.', {
            prodShiftId: logEntry.prodShift,
            prodLogEntryId: logEntry._id
          });
        }

        if (prodShift)
        {
          prodShift.recalcTimes(this.next());
        }
      },
      function handleErrorStep(err)
      {
        if (err)
        {
          productionModule.error(err, 'Failed to recalc prod shift.', {
            prodShiftId: logEntry.prodShift,
            prodLogEntryId: logEntry._id
          });
        }
      },
      this.next()
    );
  };
};

exports.createRecalcShiftOrderDataStep = function(productionModule, logEntry)
{
  return function recalcShiftOrderDataStep(err)
  {
    if (err)
    {
      return this.skip(err);
    }

    step(
      function findStep()
      {
        productionModule.getProdData('shift', logEntry.prodShift, this.parallel());
        productionModule.getProdShiftOrders(logEntry.prodShift, this.parallel());
      },
      function recalcProdShiftStep(err, prodShift, prodShiftOrders)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (prodShift && prodShiftOrders)
        {
          prodShift.recalcOrderData(prodShiftOrders);
          prodShift.save(this.next());
        }
      },
      function handleErrorStep(err)
      {
        if (err)
        {
          productionModule.error(err, 'Failed to recalc prod shift order data.', {
            prodShiftId: logEntry.prodShift,
            prodLogEntryId: logEntry._id
          });
        }
      },
      this.next()
    );
  };
};

function fillMechOrderData(app, productionModule, logEntry, done)
{
  const mongoose = app[productionModule.config.mongooseId];
  const Order = mongoose.model('Order');
  const MechOrder = mongoose.model('MechOrder');

  orderFinder.findOrdersByNc12(Order, MechOrder, logEntry.data.orderId, function(err, mechOrders)
  {
    if (err)
    {
      productionModule.error(err, 'Failed to find mech orders to fill order data.', {
        prodLogEntryId: logEntry._id
      });

      return done(err);
    }

    if (mechOrders.length === 0)
    {
      productionModule.warn(`Couldn't find mech order by 12NC.`, {
        orderId: logEntry.data.orderId,
        prodLogEntryId: logEntry._id
      });

      return done();
    }

    const orderData = prepareOperations(mechOrders[0]);

    orderData.nc12 = orderData._id;
    orderData.no = null;

    delete orderData._id;

    logEntry.data.orderData = orderData;

    return done();
  });
}

function fillProdOrderData(app, productionModule, logEntry, done)
{
  const Order = app[productionModule.config.mongooseId].model('Order');

  orderFinder.findOrdersByNo(Order, logEntry.data.orderId, function(err, orders)
  {
    if (err)
    {
      productionModule.error(err, 'Failed to find prod orders to fill order data.', {
        prodLogEntryId: logEntry._id
      });

      return done(err);
    }

    if (orders.length === 0)
    {
      productionModule.warn(`Couldn't find a prod order by no.`, {
        orderId: logEntry.data.orderId,
        prodLogEntryId: logEntry._id
      });

      return done();
    }

    const orderData = prepareOperations(orders[0]);

    orderData.no = orderData._id;

    delete orderData._id;

    logEntry.data.orderData = orderData;

    return done();
  });
}

function prepareOperations(orderData)
{
  if (Array.isArray(orderData.operations))
  {
    const operations = {};

    _.forEach(orderData.operations, function(operation)
    {
      if (operation.workCenter !== '' && operation.laborTime !== -1)
      {
        operations[operation.no] = operation;
      }
    });

    orderData.operations = operations;
  }
  else if (!_.isObject(orderData.operations))
  {
    orderData.operations = {};
  }

  return orderData;
}
