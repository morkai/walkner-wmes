// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const step = require('h5.step');

module.exports = function(app, module, prodLine, logEntry, done)
{
  const {User} = module;
  const newOperators = logEntry.data && Array.isArray(logEntry.data.personnel)
    ? logEntry.data.personnel
    : [];

  module.getProdData('shift', logEntry.prodShift, (err, prodShift) =>
  {
    if (err)
    {
      module.error(err, `Failed to get prod shift to change the operators`, {
        prodShiftId: logEntry.prodShift,
        prodLogEntryId: logEntry._id
      });

      return done(err);
    }

    if (!prodShift)
    {
      module.warn(`Couldn't find prod shift to change the operators.`, {
        prodShiftId: logEntry.prodShift,
        prodLogEntryId: logEntry._id
      });

      return done();
    }

    if (newOperators.length && newOperators[0].id === null)
    {
      fillUserData(prodShift);
    }
    else
    {
      updatePersonnel(prodShift);
    }
  });

  function fillUserData(prodShift)
  {
    const personnelIds = newOperators.map(op => op.label);

    User
      .find({
        personellId: {$in: personnelIds}
      })
      .select({
        _id: 1,
        firstName: 1,
        lastName: 1,
        personellId: 1
      })
      .lean()
      .exec((err, users) =>
      {
        if (err)
        {
          module.error(err, `Failed to find users to fill the operators info.`, {
            personnelIds,
            prodShiftId: logEntry.prodShift,
            prodLogEntryId: logEntry._id
          });

          return done(err);
        }

        if (!users.length)
        {
          module.warn(`Couldn't find operators by personnel ID.`, {
            personnelIds,
            prodShiftId: logEntry.prodShift,
            prodLogEntryId: logEntry._id
          });

          return updatePersonnel(prodShift);
        }

        const usersMap = new Map();

        users.forEach(user =>
        {
          let label = user.personellId;

          if (user.lastName)
          {
            if (user.firstName)
            {
              label = `${user.firstName} ${user.lastName}`;
            }
            else
            {
              label = user.lastName;
            }
          }

          usersMap.set(user.personellId, {
            id: user._id.toString(),
            label
          });
        });

        newOperators.forEach((op, i) =>
        {
          const user = usersMap.get(op.label);

          if (user)
          {
            newOperators[i] = user;
          }
        });

        updatePersonnel(prodShift);
      });
  }

  function updatePersonnel(prodShift)
  {
    step(
      function()
      {
        if (prodLine.prodShiftOrder)
        {
          module.getProdData('order', prodLine.prodShiftOrder, this.parallel());
        }
        else
        {
          this.parallel()(null, null);
        }

        if (prodLine.prodDowntime)
        {
          module.getProdData('downtime', prodLine.prodDowntime, this.parallel());
        }
        else
        {
          this.parallel()(null, null);
        }
      },
      function(err, prodShiftOrder, prodDowntime)
      {
        if (err)
        {
          module.error(err, `Failed to get prod data while changing the operators.`, {
            prodLogEntryId: logEntry._id
          });
        }

        const mainOperator = newOperators.length ? newOperators[0] : null;

        [prodShiftOrder, prodDowntime, prodShift].forEach(model =>
        {
          if (model)
          {
            model.operator = mainOperator;
            model.operators = newOperators;

            model.save(this.parallel());
          }
        });
      },
      function(err)
      {
        if (err)
        {
          module.error(err, `Failed to save prod data after changing the operators.`, {
            prodLogEntryId: logEntry._id
          });
        }

        done(err);
      }
    );
  }
};
