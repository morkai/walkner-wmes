// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const crypto = require('crypto');
const _ = require('lodash');
const step = require('h5.step');

module.exports = (app, module, socket, req, reply) =>
{
  if (!_.isFunction(reply))
  {
    return;
  }

  if (!_.isObject(req))
  {
    return reply(new Error('INVALID_INPUT'));
  }

  const {
    user,
    orgUnits,
    fte,
    ProdShift,
    ProdShiftOrder,
    ProdDowntime
  } = module;

  req.prodLine = orgUnits.fix.prodLine(req.prodLine);

  const res = {
    prodLine: req.prodLine,
    station: req.station >= 1 && req.station <= 7 ? Math.floor(req.station) : 0
  };

  step(
    function checkProdLineStep()
    {
      const prodLine = orgUnits.getByTypeAndId('prodLine', req.prodLine);

      if (!prodLine)
      {
        return this.done(reply, new Error('INVALID_PROD_LINE'));
      }

      if (prodLine.deactivatedAt)
      {
        return this.done(reply, new Error('DEACTIVATED'));
      }

      this.prodLine = prodLine;

      const prodLineState = module.getProdLineState(prodLine._id);

      if (prodLineState && prodLineState.online)
      {
        return this.done(reply, new Error('ALREADY_UNLOCKED'));
      }
    },
    function authenticateStep()
    {
      if (!req.login && user.isAllowedTo(socket.handshake.user, 'SUPER'))
      {
        setImmediate(this.next(), null, socket.handshake.user);
      }
      else
      {
        user.authenticate({login: req.login, password: req.password, apiKey: req.apiKey}, this.next());
      }
    },
    function authorizeStep(err, userData)
    {
      if (err)
      {
        return this.done(reply, err);
      }

      userData.ipAddress = user.getRealIp({}, socket);

      if (!user.isAllowedTo(userData, 'OPERATOR:ACTIVATE'))
      {
        app.broker.publish('production.unlockFailure', {
          user: userData,
          prodLine: this.prodLine._id
        });

        return this.done(reply, new Error('NO_PRIVILEGES'));
      }

      this.user = userData;
    },
    function generateSecretKeyStep()
    {
      crypto.pseudoRandomBytes(64, this.next());
    },
    function updateSecretKeyStep(err, secretBytes)
    {
      if (err)
      {
        module.error(err, 'Failed to generate a secret key.', {prodLineId: this.prodLine._id});

        return this.done(reply, err);
      }

      res.secretKey = crypto.createHash('md5').update(secretBytes).digest('hex');

      module.secretKeys[this.prodLine._id] = res.secretKey;

      this.prodLine.secretKey = res.secretKey;
      this.prodLine.save(this.next());
    },
    function fetchProdShiftStep(err)
    {
      if (err)
      {
        module.error(err, 'Failed to save a secret key.', {prodLineId: this.prodLine._id});

        return this.done(reply, err);
      }

      if (this.prodLine.prodShift)
      {
        ProdShift
          .findById(this.prodLine.prodShift)
          .lean()
          .exec(this.parallel());

        const doneProdShiftOrder = this.parallel();

        if (this.prodLine.prodShiftOrder)
        {
          ProdShiftOrder
            .findById(this.prodLine.prodShiftOrder)
            .lean()
            .exec(doneProdShiftOrder);
        }
        else
        {
          doneProdShiftOrder(null, null);
        }

        ProdDowntime
          .find({prodLine: this.prodLine._id})
          .sort({startedAt: -1})
          .limit(8)
          .lean()
          .exec(this.parallel());
      }
    },
    function fetchDictionaries(err, prodShift, prodShiftOrder, prodDowntimes)
    {
      if (err)
      {
        module.error(err, 'Failed to fetch prod data after unlock.', {prodLineId: this.prodLine._id});

        return this.done(reply, err);
      }

      if (!prodShift || prodShift.date.getTime() !== fte.getCurrentShift().date.getTime())
      {
        prodShift = null;
      }

      res.prodShift = prodShift;
      res.prodShiftOrder = prodShift && prodShiftOrder && !prodShiftOrder.finishedAt ? prodShiftOrder : null;
      res.prodDowntimes = prodShift && !_.isEmpty(prodDowntimes) ? prodDowntimes : [];
      res.dictionaries = {};

      _.forEach(module.config.dictionaryModules, function(dictionaryName, moduleName)
      {
        const {models} = app[moduleName] || {};

        if (!Array.isArray(models))
        {
          return;
        }

        res.dictionaries[dictionaryName] = _.invokeMap(
          models,
          models.length && typeof models[0].toDictionaryObject === 'function' ? 'toDictionaryObject' : 'toJSON'
        );
      });

      setImmediate(this.next());
    },
    function filterSortDictionariesStep()
    {
      _.forEach(res.dictionaries, (models, dictionaryName) =>
      {
        setTimeout(
          sortDictionary,
          Math.round(Math.random() * 20) + 1,
          res.dictionaries,
          dictionaryName,
          this.group()
        );
      });
    },
    function replyStep()
    {
      app.broker.publish('production.unlocked', {
        user: this.user,
        prodLine: this.prodLine._id,
        secretKey: this.prodLine.secretKey
      });

      return this.done(reply, null, res);
    }
  );

  function sortDictionary(dictionaries, dictionaryName, done)
  {
    dictionaries[dictionaryName] = dictionaries[dictionaryName]
      .filter(m => !m.deactivatedAt)
      .sort((a, b) => a._id.toString().localeCompare(b._id.toString()));

    done();
  }
};
