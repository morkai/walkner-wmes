// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');

module.exports = (app, module, socket, req, reply) =>
{
  if (!_.isObject(req))
  {
    return;
  }

  const {
    orgUnits,
    Order,
    ProdDowntime,
    Setting
  } = module;
  const isa = app[module.config.isaId];
  const orderBomMatchers = app[module.config.orderBomMatchersId];

  req.prodLineId = orgUnits.fix.prodLine(req.prodLineId);

  const prodLineState = module.getProdLineState(req.prodLineId);

  if (!prodLineState)
  {
    return module.warn('Client tried to join unknown prod line.', {
      socketId: socket.id,
      prodLineId: req.prodLineId
    });
  }

  prodLineState.onClientJoin(socket, req);

  if (!_.isFunction(reply))
  {
    return;
  }

  const dictionaries = {};

  step(
    function fetchDictionariesStep()
    {
      _.forEach(req.dictionaries, (clientUpdatedAt, moduleName) =>
      {
        const dictionary = app[moduleName];

        if (!dictionary || !Array.isArray(dictionary.models))
        {
          return;
        }

        const serverUpdatedAt = dictionary.updatedAt;

        if (serverUpdatedAt !== -1 && serverUpdatedAt <= clientUpdatedAt)
        {
          return;
        }

        setTimeout(
          done =>
          {
            dictionaries[moduleName] = dictionary.models
              .filter(m => !m.deactivatedAt)
              .sort((a, b) => a._id.toString().localeCompare(b._id.toString()));

            done();
          },
          Math.round(Math.random() * 20) + 1,
          this.group()
        );
      });
    },
    function fetchDataStep()
    {
      Order
        .findOne({_id: req.orderNo})
        .select({qtyDone: 1})
        .lean()
        .exec(this.parallel());

      module.getProdData('shift', req.prodShiftId, this.parallel());

      ProdDowntime
        .find({prodShift: req.prodShiftId})
        .limit(8)
        .sort({startedAt: -1})
        .lean()
        .exec(this.parallel());

      Setting
        .find({_id: /^production/})
        .lean()
        .exec(this.parallel());

      if (isa)
      {
        isa.getLineActiveRequests(req.prodLineId, this.parallel());
      }
      else
      {
        setImmediate(this.parallel(), null, null);
      }

      if (req.orderQueue)
      {
        module.getOrderQueue(req.prodShiftId, this.parallel());
      }
      else
      {
        setImmediate(this.parallel(), null, null);
      }

      if (orderBomMatchers)
      {
        orderBomMatchers.getComponentLabels({
          orderNo: req.orderNo,
          operationNo: req.operationNo,
          line: req.prodLineId
        }, this.parallel());
      }
      else
      {
        setImmediate(this.parallel(), null, null);
      }
    },
    function replyStep(
      err,
      order,
      prodShift,
      prodDowntimes,
      settings,
      isaRequests,
      orderQueue,
      componentLabels)
    {
      if (err)
      {
        module.error(err, 'Error while joining production line.', {req});
      }

      reply({
        totalQuantityDone: order && order.qtyDone || {total: 0, byLine: {}, byOperation: {}},
        plannedQuantities: !prodShift ? undefined : prodShift.quantitiesDone.map(d => d.planned),
        actualQuantities: !prodShift ? undefined : prodShift.quantitiesDone.map(d => d.actual),
        prodDowntimes: prodDowntimes || undefined,
        settings: settings || undefined,
        isaRequests: isaRequests || undefined,
        dictionaries,
        orderQueue: orderQueue ? orderQueue.orderQueue : undefined,
        execution: orderQueue ? orderQueue.execution : undefined,
        componentLabels: componentLabels || undefined
      });
    }
  );
};
