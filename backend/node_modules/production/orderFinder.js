// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const moment = require('moment');
const step = require('h5.step');

const PROD_ORDER_FIELDS = {
  statusesSetAt: 0,
  changes: 0,
  importTs: 0,
  __v: 0
};
const MECH_ORDER_FIELDS = {
  name: 1,
  mrp: 1,
  operations: 1,
  materialNorm: 1
};

exports.getTaktTimeCoeffForOperation = getTaktTimeCoeffForOperation;

exports.getTaktTimeCoeffsForOrder = getTaktTimeCoeffsForOrder;

exports.create = (app, module) =>
{
  const {Order, MechOrder} = module;

  return {
    findOrdersByNo: (orderNo, done) =>
    {
      findOrdersByNo(Order, orderNo, (err, orders) =>
      {
        if (err)
        {
          return done(err);
        }

        prepareSettings(module, orders, done);
      });
    },
    findOrdersByNc12: (nc12, done) =>
    {
      findOrdersByNc12(Order, MechOrder, nc12, (err, orders) =>
      {
        if (err)
        {
          return done(err);
        }

        prepareSettings(module, orders, done);
      });
    }
  };
};

function findOrdersByNo(Order, no, done)
{
  let query;

  if (Array.isArray(no))
  {
    const $in = no.filter(n => /^[0-9]{9}$/.test(n));

    if (!$in.length)
    {
      return done(null, []);
    }

    query = Order.find({_id: {$in}}).sort({_id: 1});
  }
  else if (typeof no === 'string' && no.length)
  {
    if (no.length === 9)
    {
      query = Order.find({_id: no}).limit(1);
    }
    else
    {
      query = Order
        .find({_id: new RegExp(`^${no}`)})
        .sort({_id: 1})
        .limit(10);
    }
  }
  else
  {
    return done(new Error('INVALID_INPUT'));
  }

  query
    .select(PROD_ORDER_FIELDS)
    .lean()
    .exec(done);
}

function findOrdersByNc12(Order, MechOrder, nc12, done)
{
  if (typeof nc12 !== 'string')
  {
    return done(new Error('INVALID_INPUT'));
  }

  if (nc12.length === 12 || /[a-zA-Z]/.test(nc12))
  {
    findOrderByNc12(Order, MechOrder, nc12, done);
  }
  else
  {
    findOrdersStartingWithNc12(Order, MechOrder, nc12, done);
  }
}

function findOrderByNc12(Order, MechOrder, nc12, done)
{
  const query = Order
    .find({nc12: nc12, scheduledStartDate: {$gte: getTwoWeeksAgo()}})
    .select(MECH_ORDER_FIELDS)
    .sort({scheduledStartDate: -1})
    .limit(1)
    .lean();

  query.exec((err, sapOrders) =>
  {
    if (err)
    {
      return done(err);
    }

    if (Array.isArray(sapOrders)
      && sapOrders[0]
      && Array.isArray(sapOrders[0].operations)
      && sapOrders[0].operations.length)
    {
      const orders = sapOrders.map((order) =>
      {
        order._id = nc12;

        return order;
      });

      return setMechOrderData(MechOrder, orders, done);
    }

    findMechOrderByNc12(MechOrder, nc12, done);
  });
}

function findMechOrderByNc12(MechOrder, nc12, done)
{
  MechOrder.findById(nc12).select(MECH_ORDER_FIELDS).lean().exec((err, mechOrder) =>
  {
    if (err)
    {
      return done(err);
    }

    done(null, mechOrder ? [mechOrder] : []);
  });
}

function findOrdersStartingWithNc12(Order, MechOrder, nc12, done)
{
  /* global emit */
  /* eslint-disable no-var */

  const options = {
    query: {nc12: new RegExp(`^${nc12}`), scheduledStartDate: {$gte: getTwoWeeksAgo()}},
    out: {inline: 1},
    map: function()
    {
      if (this.operations && this.operations.length)
      {
        emit(this.nc12, {
          name: this.name,
          mrp: this.mrp,
          operations: this.operations,
          scheduledStartDate: this.scheduledStartDate
        });
      }
    },
    reduce: function(key, orders)
    {
      var latestOrder = null;

      orders.forEach(function(order)
      {
        if (latestOrder === null || order.scheduledStartDate > latestOrder.scheduledStartDate)
        {
          latestOrder = order;
        }
      });

      return latestOrder;
    }
  };

  /* eslint-enable no-var */

  Order.mapReduce(options, (err, res) =>
  {
    if (err)
    {
      return done(err);
    }

    if (!res.results.length)
    {
      return findMechOrdersStartingWithNc12(MechOrder, nc12, done);
    }

    const orders = res.results.map((result) =>
    {
      const order = result.value;

      order._id = result._id;

      delete order.scheduledStartDate;

      return order;
    });

    setMechOrderData(MechOrder, orders, done);
  });
}

function findMechOrdersStartingWithNc12(MechOrder, nc12, done)
{
  const query = MechOrder
    .find({_id: new RegExp(`^${nc12}`)})
    .select(MECH_ORDER_FIELDS)
    .sort({_id: 1})
    .limit(10)
    .lean();

  query.exec((err, mechOrders) =>
  {
    if (err)
    {
      return done(err);
    }

    return done(null, mechOrders);
  });
}

function setMechOrderData(MechOrder, orders, done)
{
  const orderMap = {};

  orders.forEach(order =>
  {
    orderMap[order._id] = order;
  });

  const query = MechOrder
    .find({_id: {$in: Object.keys(orderMap)}})
    .select(MECH_ORDER_FIELDS);

  query.lean().exec((err, mechOrders) =>
  {
    if (err)
    {
      return done(err);
    }

    mechOrders.forEach((mechOrder) =>
    {
      const order = orderMap[mechOrder._id];

      order.mrp = mechOrder.mrp;
      order.materialNorm = mechOrder.materialNorm;

      mergeMechOperations(order, mechOrder);
    });

    return done(null, orders);
  });
}

function getTwoWeeksAgo()
{
  return moment().subtract(2, 'weeks').hours(0).minutes(0).seconds(0).milliseconds(0).toDate();
}

function mergeMechOperations(order, mechOrder)
{
  const orderOperations = {};

  _.forEach(order.operations, (orderOperation) =>
  {
    orderOperations[orderOperation.no] = true;
  });

  _.forEach(mechOrder.operations, (mechOperation) =>
  {
    if (!orderOperations[mechOperation.no])
    {
      order.operations.push(mechOperation);
    }
  });
}

function prepareSettings(module, orderList, done)
{
  const {settingsCache, PlanSettings} = module;
  const noToOrderMap = new Map();
  const dateToOrdersMap = new Map();
  const mrpSet = new Set();
  let defaultDate = null;

  orderList.forEach(order =>
  {
    noToOrderMap.set(order._id, order);

    if (order.mrp)
    {
      mrpSet.add(order.mrp);
    }

    let startDate = order.scheduledStartDate;

    if (startDate && !startDate.getTime)
    {
      module.warn(`Invalid scheduled start date?!!`, {
        submodule: 'orderFinder',
        order
      });

      startDate = null;
    }

    if (!startDate)
    {
      if (!defaultDate)
      {
        defaultDate = moment();

        if (defaultDate.hours() < 6)
        {
          defaultDate.subtract(1, 'days');
        }

        defaultDate = defaultDate.startOf('day').toDate();
      }

      startDate = defaultDate;
    }

    startDate = startDate.getTime();

    if (!dateToOrdersMap.has(startDate))
    {
      dateToOrdersMap.set(startDate, []);
    }

    dateToOrdersMap.get(startDate).push(order);

    order.schedulingRate = 1;
    order.taktTimeCoeff = {'*': 1};
  });

  step(
    function()
    {
      findPlanSettings(PlanSettings, Array.from(dateToOrdersMap.keys()), this.parallel());

      setImmediate(this.parallel(), null, {
        'taktTime.coeffs': settingsCache['taktTime.coeffs']
      });
    },
    function(err, dateToPlanSettings, productionSettings)
    {
      if (err)
      {
        return done(err);
      }

      const taktTimeCoeffs = productionSettings['taktTime.coeffs'] || {};

      dateToOrdersMap.forEach((orders, date) =>
      {
        const planSettings = dateToPlanSettings[date] || {};
        const schedulingRate = planSettings.schedulingRate || {ANY: 1};

        orders.forEach(order =>
        {
          order.schedulingRate = schedulingRate[order.mrp] || schedulingRate.ANY;
          order.taktTimeCoeff = resolveTaktTimeCoeff(taktTimeCoeffs, order);
        });
      });

      done(null, orderList);
    }
  );
}

function findPlanSettings(PlanSettings, localDates, done)
{
  const conditions = {
    _id: {
      $in: localDates.map(localDate => moment.utc(moment(localDate).format('YYYY-MM-DD'), 'YYYY-MM-DD').toDate())
    }
  };
  const fields = {
    schedulingRate: 1
  };

  PlanSettings.find(conditions).select(fields).lean().exec((err, planSettings) =>
  {
    if (err)
    {
      return done(err);
    }

    const dateToSettings = {};

    planSettings.forEach(settings =>
    {
      const date = moment(moment.utc(settings._id).format('YYYY-MM-DD'), 'YYYY-MM-DD').valueOf();

      delete settings._id;

      dateToSettings[date] = settings;
    });

    done(null, dateToSettings);
  });
}

function getTaktTimeCoeffForOperation(mrpToCoeffs, mrp, {no, workCenter, qty})
{
  const wcToCoeff = getTaktTimeCoeffsForOrder(mrpToCoeffs, {mrp, qty});

  return wcToCoeff[`${workCenter}/${no}`]
    || wcToCoeff[`*/${no}`]
    || wcToCoeff[workCenter]
    || wcToCoeff['*']
    || 1;
}

function getTaktTimeCoeffsForOrder(mrpToCoeffs, {mrp, qty})
{
  const wcToCoeff = {'*': 1};

  mergeTaktTimeCoeff(wcToCoeff, mrpToCoeffs['*'], qty);
  mergeTaktTimeCoeff(wcToCoeff, mrpToCoeffs[mrp], qty);

  return wcToCoeff;
}

function mergeTaktTimeCoeff(wcToCoeff, candidates, orderQty)
{
  if (!Array.isArray(candidates))
  {
    return;
  }

  for (let i = 0; i < candidates.length; ++i)
  {
    const {qty, wcs} = candidates[i];

    if (qty === 0 || orderQty < qty)
    {
      Object.assign(wcToCoeff, wcs);
    }
  }
}
