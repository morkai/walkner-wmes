// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');

module.exports = (app, module, req, res, next) =>
{
  const {
    user,
    orgUnits,
    ProdLogEntry,
    Order,
    OrderBomMatcher,
    XiconfHidLamp
  } = module;

  const logEntry = new ProdLogEntry(orgUnits.fix.prodLogEntry({
    ...req.body,
    savedAt: new Date(),
    todo: false,
    creator: user.createUserInfo(req.session.user, req)
  }));
  const extraPsn = !!logEntry.data.extraPsn;

  step(
    function()
    {
      if (logEntry._id)
      {
        return;
      }

      const lineState = module.getProdLineState(logEntry.prodLine);

      if (!lineState)
      {
        return this.skip(null, {
          result: 'INVALID_LINE'
        });
      }

      const hasOrderNo = /^[0-9]+$/.test(logEntry.data.orderNo) && logEntry.data.orderNo !== '000000000';

      if (extraPsn && !hasOrderNo)
      {
        return this.skip(null, {
          result: 'ORDER_NO_REQUIRED'
        });
      }

      const prodShift = lineState.prodShift;
      const currentOrder = lineState.getCurrentOrder();
      const prodShiftOrder = extraPsn
        ? null
        : hasOrderNo
          ? lineState.getLastOrderByNo(logEntry.data.orderNo)
          : currentOrder;

      if (!prodShift || (!prodShiftOrder && !extraPsn))
      {
        return this.skip(null, {
          result: 'INVALID_LINE_STATE'
        });
      }

      if (!extraPsn && lineState.state !== 'working' && prodShiftOrder === currentOrder)
      {
        return this.skip(null, {
          result: `INVALID_STATE:${lineState.state}`
        });
      }

      logEntry._id = ProdLogEntry.generateId(logEntry.createdAt, prodShift._id);
      logEntry.division = prodShift.division;
      logEntry.subdivision = prodShift.subdivision;
      logEntry.mrpControllers = prodShift.mrpControllers;
      logEntry.prodFlow = prodShift.prodFlow;
      logEntry.workCenter = prodShift.workCenter;
      logEntry.prodShift = prodShift._id;

      if (extraPsn)
      {
        logEntry.prodShiftOrder = null;
        logEntry.data.sapTaktTime = 0;
      }
      else
      {
        logEntry.prodShiftOrder = prodShiftOrder._id;

        if (!hasOrderNo)
        {
          logEntry.data.orderNo = prodShiftOrder.orderId;
        }

        if (logEntry.data.sapTaktTime < 0)
        {
          logEntry.data.sapTaktTime = prodShiftOrder.sapTaktTime;
        }
      }

      this.pso = prodShiftOrder;
    },
    function()
    {
      if (Array.isArray(logEntry.data.bom))
      {
        setImmediate(this.next(), null, null);
      }
      else
      {
        getComponentsToMatch(logEntry.data.orderNo, logEntry.prodLine, this.next());
      }
    },
    function(err, components)
    {
      if (err)
      {
        return this.skip(err);
      }

      if (Array.isArray(components) && components.length === 0 && req.query.bomCheck !== '1')
      {
        components = null;
      }

      if (!extraPsn && Array.isArray(components) && components.some(c => c.first))
      {
        const lineState = module.getProdLineState(logEntry.prodLine);
        const pso = lineState && lineState.getLastOrderByNo(logEntry.data.orderNo) || null;

        if (pso && pso.quantityDone > 0)
        {
          components = components.filter(c => !c.first);

          if (components.length === 0)
          {
            components = null;
          }
        }
      }

      module.checkSerialNumber(logEntry, components, this.next());
    },
    function(err, result)
    {
      if (err)
      {
        return next(err);
      }

      res.json(result);

      if (result.result !== 'SUCCESS')
      {
        return;
      }

      logEntry.save(err =>
      {
        if (err)
        {
          module.error(err, 'Failed to save the checkSerialNumber log entry.', {logEntry});
        }
      });
    }
  );

  function getComponentsToMatch(orderNo, lineId, done)
  {
    const cacheKey = `${orderNo}:${lineId}`;

    if (module.bomMatcherCache.has(cacheKey))
    {
      return done(null, module.bomMatcherCache.get(cacheKey));
    }

    step(
      function()
      {
        const fields = {
          nc12: 1,
          mrp: 1,
          name: 1,
          description: 1,
          qty: 1,
          bom: 1
        };

        Order
          .findById(orderNo, fields)
          .lean()
          .exec(this.next());
      },
      function(err, order)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!order)
        {
          return this.skip(app.createError('ORDER_NOT_FOUND', 400));
        }

        setImmediate(this.parallel(), null, order);

        if (module.bomMatcherCache.has('active'))
        {
          setImmediate(this.parallel(), null, module.bomMatcherCache.get('active'));
        }
        else
        {
          OrderBomMatcher
            .find({active: true})
            .lean()
            .exec(this.parallel());
        }
      },
      function(err, order, orderBomMatchers)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!module.bomMatcherCache.has('active'))
        {
          module.bomMatcherCache.set('active', orderBomMatchers);
        }

        const components = matchOrder(orderBomMatchers, order, lineId);

        module.bomMatcherCache.set(cacheKey, components);

        setImmediate(this.group(), null, components);

        const extras = {
          HID: []
        };

        components.forEach(component =>
        {
          if (component.labelPattern.includes('@HID.ID@'))
          {
            extras.HID.push(component);
          }
        });

        if (extras.HID.length)
        {
          replaceHidExtras(order, extras.HID, this.group());
        }
      },
      function(err, results)
      {
        if (err)
        {
          return done(err);
        }

        done(null, results[0]);
      }
    );
  }

  function matchOrder(orderBomMatchers, order, lineId)
  {
    let result = [];

    const bom = new Map();
    const used = new Set();

    if (Array.isArray(order.bom))
    {
      order.bom.forEach(component => bom.set(component.nc12, component.qty));
    }
    else
    {
      module.warn(`Order has no bom.`, {orderNo: order._id});
    }

    orderBomMatchers.forEach(obm =>
    {
      if (obm.matchers.line.length && !obm.matchers.line.includes(lineId))
      {
        return;
      }

      if (obm.matchers.mrp.length && !obm.matchers.mrp.includes(order.mrp))
      {
        return;
      }

      if (obm.matchers.nc12.length && !obm.matchers.nc12.includes(order.nc12))
      {
        return;
      }

      if (obm.matchers.name.length && !obm.matchers.name.find(m => matchName(order, m)))
      {
        return;
      }

      const obmComponents = obm.components.filter(obmComponent => ['pattern', 'notPattern'].every(patternProp =>
      {
        const pattern = obmComponent[patternProp];

        if (pattern === '' || pattern instanceof RegExp)
        {
          return true;
        }

        try
        {
          obmComponent[patternProp] = new RegExp(/^[0-9]{12}$/.test(pattern) ? `^${pattern}$` : pattern);
        }
        catch (err)
        {
          return false;
        }

        return true;
      }));

      const virtual = [];

      obmComponents.forEach(obmComponent =>
      {
        if (obmComponent.pattern !== '' || obmComponent.notPattern !== '')
        {
          return;
        }

        virtual.push({
          nc12: '000000000000',
          description: obmComponent.description
            .replace(/@ORDER\.NO@/g, order._id)
            .replace(/@ORDER\.12NC@/g, order.nc12),
          unique: obmComponent.unique,
          labelPattern: obmComponent.labelPattern
            .replace(/@ORDER\.NO@/g, order._id)
            .replace(/@ORDER\.12NC@/g, order.nc12),
          nc12Index: obmComponent.nc12Index,
          snIndex: obmComponent.snIndex
        });
      });

      const candidates = [];
      const misses = new Set();
      let matches = 0;

      (order.bom || []).forEach(orderComponent =>
      {
        const obmComponent = matchComponent(orderComponent, obmComponents);

        if (!obmComponent)
        {
          return;
        }

        if (obmComponent.missing)
        {
          misses.add(obmComponent);

          return;
        }

        matches += 1;

        if (used.has(orderComponent.nc12))
        {
          return;
        }

        used.add(orderComponent.nc12);

        let qtyPerProduct = orderComponent.qty / order.qty;

        if (obmComponent.single || qtyPerProduct.toString().includes('.'))
        {
          qtyPerProduct = 1;
        }

        const description = obmComponent.description
          .replace(/@COMPONENT\.ITEM@/g, orderComponent.item)
          .replace(/@COMPONENT\.12NC@/g, orderComponent.nc12)
          .replace(/@COMPONENT\.NAME@/g, orderComponent.name)
          .replace(/@ORDER\.NO@/g, order._id)
          .replace(/@ORDER\.12NC@/g, order.nc12);

        const labelPattern = obmComponent.labelPattern
          .replace(/@COMPONENT\.ITEM@/g, orderComponent.item)
          .replace(/@COMPONENT\.12NC@/g, orderComponent.nc12)
          .replace(/@COMPONENT\.NAME@/g, _.escapeRegExp(orderComponent.name))
          .replace(/@ORDER\.NO@/g, order._id)
          .replace(/@ORDER\.12NC@/g, order.nc12);

        for (let j = 0; j < qtyPerProduct; ++j)
        {
          candidates.push({
            nc12: orderComponent.nc12,
            description: qtyPerProduct === 1 ? description : `#${j + 1} ${description}`,
            unique: obmComponent.unique,
            single: obmComponent.single,
            first: obmComponent.first,
            labelPattern,
            nc12Index: obmComponent.nc12Index,
            snIndex: obmComponent.snIndex
          });
        }
      });

      let required = 0;

      obmComponents.forEach(obmComponent =>
      {
        if (!obmComponent.optional)
        {
          required += 1;
        }

        if (obmComponent.missing && !misses.has(obmComponent))
        {
          matches += 1;
        }
      });

      if (misses.size === 0 && (virtual.length + matches) >= required)
      {
        result = result.concat(virtual, candidates);
      }
    });

    return result;
  }

  function matchComponent({nc12, name}, obmComponents)
  {
    return obmComponents.find(({pattern, notPattern}) =>
    {
      if (!pattern && !notPattern)
      {
        return false;
      }

      if (pattern
        && !pattern.test(nc12)
        && !pattern.test(name))
      {
        return false;
      }

      if (notPattern
        && (notPattern.test(nc12) || notPattern.test(name)))
      {
        return false;
      }

      return true;
    });
  }

  function matchName(order, nameMatcher)
  {
    try
    {
      const re = new RegExp(nameMatcher, 'i');

      return re.test(order.name) || re.test(order.description);
    }
    catch (x)
    {
      return false;
    }
  }

  function replaceHidExtras(order, obmComponents, done)
  {
    XiconfHidLamp.find({nc12: {$in: obmComponents.map(c => c.nc12)}}).lean().exec((err, hidLamps) =>
    {
      if (err)
      {
        return done(err);
      }

      const nc12ToHid = new Map();

      hidLamps.forEach(hidLamp => nc12ToHid.set(hidLamp.nc12, hidLamp._id));

      obmComponents.forEach(obmComponent =>
      {
        if (!nc12ToHid.has(obmComponent.nc12))
        {
          return module.warn(`Missing HID for 12NC: ${obmComponent.nc12}`);
        }

        obmComponent.labelPattern = obmComponent.labelPattern.replace(/@HID\.ID@/g, nc12ToHid.get(obmComponent.nc12));
      });

      done();
    });
  }
};
