// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const moment = require('moment');
const step = require('h5.step');
const resolveProductName = require('util/resolveProductName');
const locks = require('util/locks');

const ORDER_LOCKS = {};

module.exports = (app, module, logEntry, components, done) =>
{
  const {
    mysql,
    Order,
    ProdShift,
    ProdDowntime,
    ProdSerialNumber
  } = module;

  const bomCheck = Array.isArray(components);

  step(
    function()
    {
      this.locks = [];

      if (/^[A-Z0-9]+\.0+\.0+$/.test(logEntry.data._id))
      {
        this.virtual = true;

        this.locks.push(handleVirtualSn(logEntry, this.parallel()));
      }
      else
      {
        this.virtual = false;

        setImmediate(this.parallel(), null, null);
      }

      this.locks.push(locks.create(`checkSerialNumber:${logEntry.prodLine}`, this.parallel()));
    },
    function(err, result)
    {
      if (err || result)
      {
        return this.skip(err, result);
      }

      module.getProdData('order', logEntry.prodShiftOrder, this.parallel());

      if (logEntry.data.extraPsn)
      {
        module.orderFinder.findOrderByNo(logEntry.data.orderNo, this.parallel());
      }
      else if (logEntry.data.skipMaxCheck)
      {
        setImmediate(this.parallel(), null, null);
      }
      else
      {
        Order
          .findById(logEntry.data.orderNo)
          .select({
            qty: 1,
            qtyDone: 1,
            qtyMax: 1
          })
          .lean()
          .exec(this.parallel());
      }
    },
    function(err, pso, sapOrder)
    {
      if (err)
      {
        return this.skip(err);
      }

      if (logEntry.data.extraPsn)
      {
        if (!sapOrder)
        {
          return this.skip(null, {
            result: 'SAP_ORDER_NOT_FOUND'
          });
        }

        pso = {
          _id: null,
          orderId: logEntry.data.orderNo,
          orderData: sapOrder,
          startedAt: new Date(logEntry.data.scannedAt)
        };
      }
      else
      {
        if (!pso)
        {
          return this.skip(null, {
            result: 'ORDER_NOT_FOUND'
          });
        }

        if (sapOrder)
        {
          const qtyTodoTotal = sapOrder.qtyMax
            && sapOrder.qtyMax[pso.operationNo]
            || sapOrder.qty;
          const qtyDoneTotal = sapOrder.qtyDone
            && sapOrder.qtyDone.byOperation
            && sapOrder.qtyDone.byOperation[pso.operationNo]
            || 0;

          if (qtyDoneTotal >= qtyTodoTotal)
          {
            return this.skip(null, {
              result: 'MAX_TOTAL'
            });
          }
        }
      }

      module.getProdData('shift', logEntry.prodShift, this.parallel());

      setImmediate(this.parallel(), null, pso);

      ProdSerialNumber
        .findById(logEntry.data._id)
        .lean()
        .exec(this.parallel());

      if (bomCheck || !logEntry.prodShiftOrder)
      {
        return;
      }

      ProdSerialNumber
        .findOne({prodShiftOrder: logEntry.prodShiftOrder}, {scannedAt: 1, iptAt: 1})
        .sort({scannedAt: -1})
        .limit(1)
        .lean()
        .exec(this.parallel());

      ProdDowntime
        .find({
          prodShiftOrder: logEntry.prodShiftOrder,
          reason: {$in: module.settingsCache['taktTime.ignoredDowntimes'] || []},
          finishedAt: {$ne: null}
        }, {
          _id: 0,
          startedAt: 1,
          finishedAt: 1
        })
        .sort({startedAt: 1})
        .lean()
        .exec(this.parallel());
    },
    function(err, shift, pso, usedSn, previousSn, downtimes)
    {
      if (err)
      {
        return this.skip(err);
      }

      if (!shift)
      {
        return this.skip(null, {
          result: 'SHIFT_NOT_FOUND'
        });
      }

      if (usedSn)
      {
        return this.skip(null, {
          result: 'ALREADY_USED',
          serialNumber: usedSn
        });
      }

      if (bomCheck)
      {
        return this.skip(null, {
          result: 'CHECK_BOM',
          logEntry,
          components,
          orderData: {
            no: pso.orderId,
            nc12: (pso.orderData ? pso.orderData.nc12 : null) || '000000000000',
            description: resolveProductName(pso.orderData)
          }
        });
      }

      this.previousSn = previousSn;
      this.shift = shift;
      this.pso = pso;

      this.sn = new ProdSerialNumber(logEntry.data);
      this.sn.station = logEntry.station;
      this.sn.taktTime = 0;
      this.sn.prodShiftOrder = logEntry.prodShiftOrder;
      this.sn.prodLine = logEntry.prodLine;
      this.sn.mrp = pso.orderData && pso.orderData.mrp || '';

      const previousScannedAt = (previousSn ? previousSn.scannedAt : pso.startedAt).getTime();
      const latestScannedAt = this.sn.scannedAt.getTime();
      let ignoredDuration = 0;

      (downtimes || []).forEach(d =>
      {
        if (d.startedAt >= previousScannedAt && d.finishedAt <= latestScannedAt)
        {
          ignoredDuration += d.finishedAt - d.startedAt;
        }
      });

      this.ignoredDuration = ignoredDuration;

      if (logEntry.data.extraPsn)
      {
        this.sn.taktTime = latestScannedAt - previousScannedAt - ignoredDuration;
      }

      if (!this.virtual && !logEntry.data.extraPsn)
      {
        findIptSn(this.sn._id, this.next());
      }

      if (previousScannedAt < 946684800000 || this.sn.taktTime > 3600000)
      {
        module.warn(`[checkSerialNumber] Potentially invalid takt time [${this.sn._id}]:`, {
          pso: {
            _id: pso._id,
            startedAt: pso.startedAt
          },
          previousSn,
          currentSn: this.sn,
          previousScannedAt,
          latestScannedAt,
          ignoredDuration
        });
      }
    },
    function(err, iptSn)
    {
      if (err)
      {
        module.error(`[checkSerialNumber] Failed to find IPT SN [${this.sn._id}]: ${err.message}`);
      }

      if (iptSn)
      {
        this.sn.iptAt = iptSn.timestamp;

        const previousIptAt = this.previousSn ? this.previousSn.iptAt : this.pso.startedAt;
        const latestIptAt = this.sn.iptAt;
        const iptTaktTime = previousIptAt ? (latestIptAt.getTime() - previousIptAt.getTime()) : 0;

        if (iptTaktTime)
        {
          this.sn.iptTaktTime = iptTaktTime - this.ignoredDuration;
        }
      }

      this.sn.save(this.next());
    },
    function(err)
    {
      if (err)
      {
        return this.skip(err);
      }

      if (!logEntry.data.extraPsn)
      {
        return;
      }

      ProdSerialNumber.aggregate([
        {$match: {
          prodShiftOrder: this.sn.prodShiftOrder,
          taktTime: {$gt: 0}
        }},
        {$group: {
          _id: '$prodShiftOrder',
          quantityDone: {$sum: 1},
          totalTaktTime: {$sum: '$taktTime'}
        }}
      ], this.parallel());

      const scannedAt = moment(this.sn.scannedAt.getTime());
      const $gte = new Date(scannedAt.startOf('hour').valueOf());
      const $lt = scannedAt.add(1, 'hour').toDate();

      this.hourlyQuantityIndex = ProdShift.HOUR_TO_INDEX[$gte.getHours()];

      ProdSerialNumber.aggregate([
        {$match: {
          prodLine: this.sn.prodLine,
          scannedAt: {
            $gte: $gte,
            $lt: $lt
          },
          taktTime: {$gt: 0}
        }},
        {$group: {
          _id: null,
          quantityDone: {$sum: 1}
        }}
      ], this.parallel());
    },
    function(err, orderResults = [], shiftResults = [])
    {
      if (err)
      {
        return this.skip(err);
      }

      const quantityDone = orderResults.length ? orderResults[0].quantityDone : 0;
      const totalTaktTime = orderResults.length ? orderResults[0].totalTaktTime : 0;
      const avgTaktTime = Math.round((totalTaktTime / quantityDone) || 0);
      const hourlyQuantityDone = shiftResults.length ? shiftResults[0].quantityDone : 0;

      this.result = {
        instanceId: logEntry.instanceId,
        result: 'SUCCESS',
        serialNumber: this.sn.toJSON()
      };

      if (!logEntry.data.extraPsn)
      {
        this.result.quantityDone = quantityDone;
        this.result.lastTaktTime = this.sn.taktTime;
        this.result.avgTaktTime = avgTaktTime;
        this.result.hourlyQuantityDone = {
          index: this.hourlyQuantityIndex,
          value: hourlyQuantityDone
        };
        this.result.totalQuantityDone = null;

        this.shift.quantitiesDone[this.hourlyQuantityIndex].actual = hourlyQuantityDone;
        this.shift.save(this.group());

        this.pso.quantityDone = quantityDone;
        this.pso.lastTaktTime = this.sn.taktTime;
        this.pso.avgTaktTime = avgTaktTime;
        this.pso.save(this.group());
      }
    },
    function(err)
    {
      if (err)
      {
        return this.skip(err);
      }

      if (!logEntry.data.extraPsn)
      {
        Order.recountQtyDone(this.pso.orderId, this.next());
      }
    },
    function(err)
    {
      if (err)
      {
        return this.skip(err);
      }

      const currentShiftId = module.getProdLineState(this.sn.prodLine).getCurrentShiftId();

      if (logEntry.prodShift === currentShiftId)
      {
        if (this.pso._id)
        {
          app.broker.publish(`production.synced.${this.sn.prodLine}`, {
            prodLine: this.sn.prodLine,
            types: ['changeQuantityDone', 'changeQuantitiesDone'],
            prodShift: {
              quantitiesDone: this.shift.quantitiesDone
            },
            prodShiftOrder: {
              _id: this.pso._id,
              quantityDone: this.pso.quantityDone,
              lastTaktTime: this.pso.lastTaktTime,
              avgTaktTime: this.pso.avgTaktTime
            }
          });
        }

        app.broker.publish(`production.taktTime.snChecked.${this.sn.prodLine}`, this.result);
      }

      setImmediate(this.next(), null, this.result);
    },
    function(err, result)
    {
      done(err, result);

      this.locks.forEach(release => release());
    }
  );

  function handleVirtualSn(logEntry, done)
  {
    const orderNo = logEntry.data.orderNo;

    if (ORDER_LOCKS[orderNo])
    {
      ORDER_LOCKS[orderNo].push(logEntry, done);
    }
    else
    {
      ORDER_LOCKS[orderNo] = [];

      replaceVirtualSn(logEntry, done);
    }

    return releaseVirtualSn.bind(null, orderNo);
  }

  function releaseVirtualSn(orderNo)
  {
    const lock = ORDER_LOCKS[orderNo];

    if (!lock)
    {
      return;
    }

    const logEntry = lock.shift();
    const done = lock.shift();

    if (!lock.length)
    {
      delete ORDER_LOCKS[orderNo];
    }

    if (logEntry)
    {
      replaceVirtualSn(logEntry, done);
    }
  }

  function replaceVirtualSn(logEntry, done)
  {
    step(
      function()
      {
        ProdSerialNumber
          .findOne({orderNo: logEntry.data.orderNo}, {serialNo: 1})
          .sort({scannedAt: -1})
          .lean()
          .exec(this.next());
      },
      function(err, prodSerialNumber)
      {
        if (err)
        {
          return this.skip(err);
        }

        logEntry.data.serialNo = prodSerialNumber ? (prodSerialNumber.serialNo + 1) : 1;

        const snParts = logEntry.data._id.split('.');

        logEntry.data._id = snParts[0]
          + '.' + logEntry.data.orderNo
          + '.' + logEntry.data.serialNo.toString().padStart(4, '0');
      },
      function()
      {
        if (logEntry.data.serialNo === 1)
        {
          findIptOperation(logEntry.data.orderNo, this.next());
        }
      },
      function(err, hasOperation)
      {
        if (err)
        {
          return done(err);
        }

        if (hasOperation)
        {
          return done(null, {
            result: 'STANDARD_LABEL'
          });
        }

        return done();
      }
    );
  }

  function findIptSn(serialNumber, done)
  {
    if (!mysql)
    {
      return done();
    }

    step(
      function()
      {
        mysql.pool.getConnection(this.next());
      },
      function(err, conn)
      {
        if (err)
        {
          return this.skip(err);
        }

        this.conn = conn;

        conn.query('SELECT * FROM serialnumber WHERE serialnumber=? LIMIT 1', [serialNumber], this.next());
      },
      function(err, results)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (results && results.length)
        {
          return this.skip(null, results[0]);
        }
      },
      function(err, result)
      {
        if (this.conn)
        {
          this.conn.release();
          this.conn = null;
        }

        done(err, result);
      }
    );
  }

  function findIptOperation(orderNo, done)
  {
    if (!mysql)
    {
      return done();
    }

    step(
      function()
      {
        mysql.pool.getConnection(this.next());
      },
      function(err, conn)
      {
        if (err)
        {
          return this.skip(err);
        }

        this.conn = conn;

        const sql = `SELECT 1 FROM operation
WHERE production_order_id=(SELECT id FROM productionorder WHERE order_id=?)
AND operation='PrintStandardLabel'
AND disabledTimestamp IS NULL
LIMIT 1`;

        conn.query(sql, [orderNo], this.next());
      },
      function(err, results)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (results && results.length)
        {
          return this.skip(null, true);
        }
      },
      function(err, result)
      {
        if (this.conn)
        {
          this.conn.release();
          this.conn = null;
        }

        done(err, !!result);
      }
    );
  }
};
