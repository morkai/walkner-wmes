// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const step = require('h5.step');
const moment = require('moment');
const {formatDate} = require('util/dateFormatter');
const {mapOperations} = require('./logEntryHandlers/util');

module.exports = (app, module, id, done) =>
{
  const orgUnits = app[module.config.orgUnitsId];
  const {
    PlanSettings,
    Plan,
    ProdShift
  } = module;

  const orderQueue = [];
  const execution = {
    todoOrders: [],
    todoDowntimes: [],
    doneOrders: [],
    doneDowntimes: []
  };
  let prodShiftId = null;
  let prodLineId = null;

  step(
    function()
    {
      if (!id)
      {
        return this.skip();
      }
    },
    function()
    {
      const prodLine = orgUnits.getByTypeAndId('prodLine', id);

      if (prodLine)
      {
        const prodLineState = module.getProdLineState(prodLine._id);

        prodShiftId = prodLineState ? prodLineState.getCurrentShiftId() : null;
        prodLineId = prodLine._id;
      }
      else
      {
        prodShiftId = id;
      }

      module.getProdData('shift', prodShiftId, this.next());
    },
    function(err, prodShift)
    {
      if (err)
      {
        return this.skip(app.createError(`Failed to find shift: ${err.message}`, 500));
      }

      setTimeout(this.next(), prodShift ? 1 : 2000, null, prodShift);
    },
    function(err, prodShift) // eslint-disable-line handle-callback-err
    {
      if (prodShift)
      {
        setImmediate(this.parallel(), null, prodShift);
      }
      else
      {
        module.getProdData('shift', prodShiftId, this.parallel());
      }

      if (prodShiftId)
      {
        module.getProdShiftOrders(prodShiftId, this.parallel());
        module.getProdDowntimes(prodShiftId, this.parallel());
      }
      else
      {
        setImmediate(this.parallel(), null, []);
      }
    },
    function(err, prodShift, prodShiftOrders, prodDowntimes)
    {
      if (err)
      {
        return this.skip(app.createError(`Failed to find shift: ${err.message}`, 500));
      }

      if (!prodShift)
      {
        return this.skip(app.createError('Shift not found.', 404));
      }

      this.startedOrdersMap = {};

      prodShiftOrders.forEach(pso =>
      {
        if (pso.quantityDone > 0 || !pso.finishedAt)
        {
          this.startedOrdersMap[pso.orderId] = true;
        }

        execution.doneOrders.push({
          orderId: pso.orderId,
          operationNo: pso.operationNo,
          startedAt: pso.startedAt,
          finishedAt: pso.finishedAt,
          quantityDone: pso.quantityDone,
          workerCount: pso.workerCount,
          taktTime: pso.avgTaktTime && pso.sapTaktTime
            ? (pso.avgTaktTime >= pso.sapTaktTime ? 'ok' : 'nok')
            : 'na'
        });
      });

      prodDowntimes.forEach(dt =>
      {
        execution.doneDowntimes.push({
          aor: dt.aor,
          reason: dt.reason,
          startedAt: dt.startedAt,
          finishedAt: dt.finishedAt
        });
      });

      this.planId = moment.utc(formatDate(prodShift.date), 'YYYY-MM-DD').toDate();
      this.shiftNo = prodShift.shift;

      PlanSettings.aggregate([
        {$match: {_id: this.planId}},
        {$unwind: '$mrps'},
        {$unwind: '$mrps.lines'},
        {$match: {'mrps.lines._id': prodShift.prodLine}},
        {$project: {_id: 0, mrp: '$mrps._id', workerCount: '$mrps.lines.workerCount'}}
      ], this.parallel());

      const shiftMoment = moment.utc(this.planId.getTime()).hours(ProdShift.NO_TO_START_HOUR[prodShift.shift]);

      Plan.aggregate([
        {$match: {_id: this.planId}},
        {$unwind: '$lines'},
        {$match: {'lines._id': prodShift.prodLine}},
        {$unwind: '$lines.orders'},
        {$project: {
          _id: '$lines.orders.orderNo',
          startAt: '$lines.orders.startAt',
          finishAt: '$lines.orders.finishAt',
          quantity: '$lines.orders.quantity'
        }},
        {$match: {
          startAt: {
            $gte: shiftMoment.clone().toDate(),
            $lt: shiftMoment.add(8, 'hours').toDate()
          }
        }},
        {$sort: {startAt: 1}}
      ], this.parallel());
    },
    function(err, settings, lineOrders)
    {
      if (err)
      {
        return this.skip(app.createError(`Failed to find line orders: ${err.message}`, 500));
      }

      if (!lineOrders.length)
      {
        return this.skip(null, []);
      }

      this.lineOrdersList = lineOrders;
      this.lineOrdersMap = {};
      this.workerCountMap = {};

      lineOrders.forEach(lineOrder =>
      {
        this.lineOrdersMap[lineOrder._id] = lineOrder;
      });

      settings.forEach(settings =>
      {
        this.workerCountMap[settings.mrp] = settings.workerCount;
      });

      const orderIds = Object.keys(this.lineOrdersMap);

      Plan.aggregate([
        {$match: {_id: this.planId}},
        {$unwind: '$orders'},
        {$match: {'orders._id': {$in: orderIds}}},
        {$project: {_id: '$orders._id', operationNo: '$orders.operation.no'}}
      ], this.parallel());

      module.orderFinder.findOrdersByNo(orderIds, this.parallel());
    },
    function(err, planOrders, sapOrders)
    {
      if (err)
      {
        return this.skip(app.createError(`Failed to find orders: ${err.message}`, 500));
      }

      planOrders.forEach(planOrder =>
      {
        this.lineOrdersMap[planOrder._id].operationNo = planOrder.operationNo;
      });

      sapOrders.forEach(sapOrder =>
      {
        sapOrder.operations = mapOperations(sapOrder.operations);
        sapOrder.no = sapOrder._id;

        delete sapOrder._id;

        const workerCount = this.workerCountMap[sapOrder.mrp] || {};

        this.lineOrdersMap[sapOrder.no].workerCount = workerCount[this.shiftNo - 1] || 0;
        this.lineOrdersMap[sapOrder.no].sapOrder = sapOrder;
      });

      this.lineOrdersList.forEach(o =>
      {
        execution.todoOrders.push({
          orderId: o._id,
          operationNo: o.operationNo,
          startedAt: utcToLocal(o.startAt),
          finishedAt: utcToLocal(o.finishAt),
          quantityDone: o.quantity,
          workerCount: o.workerCount,
          taktTime: 'na'
        });

        if (o.sapOrder && o.operationNo && o.workerCount >= 0 && !this.startedOrdersMap[o._id])
        {
          orderQueue.push({
            order: o.sapOrder,
            operationNo: o.operationNo,
            workerCount: o.workerCount
          });
        }
      });

      setImmediate(this.next());
    },
    function(err)
    {
      if (err)
      {
        module.error(`Failed to get order queue for [${prodShiftId || prodLineId}]: ${err.message}`);
      }

      done(null, {orderQueue, execution});
    }
  );
};

function utcToLocal(date)
{
  return new Date(date.getTime() + date.getTimezoneOffset() * 60 * 1000);
}
