// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const step = require('h5.step');
const moment = require('moment');
const shifts = require('util/shifts');
const {formatDate} = require('util/dateFormatter');
const {mapOperations} = require('./logEntryHandlers/util');

module.exports = (app, module, id, options, done) =>
{
  const orgUnits = app[module.config.orgUnitsId];
  const {
    PlanSettings,
    Plan,
    ProdShift,
    ProdShiftOrder,
    ProdDowntime
  } = module;

  options = {
    orderQueue: true,
    execution: true,
    prev: false,
    ...options
  };

  const orderQueue = [];
  const execution = {
    todoOrders: [],
    todoDowntimes: [],
    doneOrders: [],
    doneDowntimes: []
  };
  let prodShiftId = null;
  let prodLineId = null;

  step(
    function()
    {
      if (!id)
      {
        return this.skip();
      }
    },
    function()
    {
      const prodLine = orgUnits.getByTypeAndId('prodLine', id);

      if (prodLine)
      {
        const prodLineState = module.getProdLineState(prodLine._id);

        prodShiftId = prodLineState ? prodLineState.getCurrentShiftId() : null;
        prodLineId = prodLine._id;
      }
      else
      {
        prodShiftId = id;
      }

      module.getProdData('shift', prodShiftId, this.next());
    },
    function(err, prodShift)
    {
      if (err)
      {
        return this.skip(app.createError(`Failed to find shift: ${err.message}`, 500));
      }

      setTimeout(this.next(), prodShift ? 1 : 2000, null, prodShift);
    },
    function(err, prodShift) // eslint-disable-line handle-callback-err
    {
      if (prodShift)
      {
        setImmediate(this.parallel(), null, prodShift);
      }
      else
      {
        module.getProdData('shift', prodShiftId, this.parallel());
      }
    },
    function(err, prodShift)
    {
      if (err)
      {
        return this.skip(app.createError(`Failed to find shift: ${err.message}`, 500));
      }

      if (!prodShift)
      {
        return this.skip(app.createError('Shift not found.', 404));
      }

      this.prodShift = prodShift;

      ProdDowntime
        .find({prodShift: prodShift._id})
        .select({
          shift: 1,
          aor: 1,
          reason: 1,
          startedAt: 1,
          finishedAt: 1
        })
        .sort({startedAt: 1})
        .lean()
        .exec(this.parallel());

      ProdShiftOrder
        .find({prodShift: prodShift._id})
        .select({
          shift: 1,
          orderId: 1,
          operationNo: 1,
          startedAt: 1,
          finishedAt: 1,
          quantityDone: 1,
          workerCount: 1,
          avgTaktTime: 1,
          sapTaktTime: 1
        })
        .sort({startedAt: 1})
        .lean()
        .exec(this.parallel());
    },
    function(err, prodDowntimes, prodShiftOrders)
    {
      if (err)
      {
        return this.skip(app.createError(`Failed to find shift: ${err.message}`, 500));
      }

      if (!this.prodShift)
      {
        return this.skip(app.createError('Shift not found.', 404));
      }

      this.startedOrdersMap = {};

      prodShiftOrders.forEach(pso =>
      {
        if (pso.quantityDone > 0 || !pso.finishedAt)
        {
          this.startedOrdersMap[pso.orderId] = true;
        }

        execution.doneOrders.push({
          shift: pso.shift,
          orderId: pso.orderId,
          operationNo: pso.operationNo,
          startedAt: pso.startedAt.getTime(),
          finishedAt: pso.finishedAt ? pso.finishedAt.getTime() : 0,
          quantityDone: pso.quantityDone,
          workerCount: pso.workerCount,
          taktTime: pso.avgTaktTime && pso.sapTaktTime
            ? (pso.avgTaktTime >= pso.sapTaktTime ? 'ok' : 'nok')
            : 'na'
        });
      });

      prodDowntimes.forEach(dt =>
      {
        execution.doneDowntimes.push({
          shift: dt.shift,
          aor: dt.aor,
          reason: dt.reason,
          startedAt: dt.startedAt.getTime(),
          finishedAt: dt.finishedAt ? dt.finishedAt.getTime() : 0,
        });
      });

      this.planId = moment.utc(formatDate(this.prodShift.date), 'YYYY-MM-DD').toDate();
// TODO remove
this.planId = new Date('2021-04-22T00:00:00Z');

      PlanSettings.aggregate([
        {$match: {_id: this.planId}},
        {$unwind: '$mrps'},
        {$unwind: '$mrps.lines'},
        {$match: {'mrps.lines._id': this.prodShift.prodLine}},
        {$project: {_id: 0, mrp: '$mrps._id', workerCount: '$mrps.lines.workerCount'}}
      ], this.parallel());

      const pipeline = [
        {$match: {_id: this.planId}},
        {$unwind: '$lines'},
        {$match: {'lines._id': this.prodShift.prodLine}},
        {$unwind: '$lines.orders'},
        {$project: {
          _id: '$lines.orders.orderNo',
          startAt: '$lines.orders.startAt',
          finishAt: '$lines.orders.finishAt',
          quantity: '$lines.orders.quantity'
        }}
      ];

      if (!options.prev)
      {
        const shiftMoment = moment.utc(this.planId.getTime()).hours(ProdShift.NO_TO_START_HOUR[this.prodShift.shift]);

        pipeline.push({$match: {
          startAt: {
            $gte: shiftMoment.clone().toDate(),
            $lt: shiftMoment.add(8, 'hours').toDate()
          }
        }});
      }

      pipeline.push({$sort: {startAt: 1}});

      Plan.aggregate(pipeline, this.parallel());
    },
    function(err, settings, lineOrders)
    {
      if (err)
      {
        return this.skip(app.createError(`Failed to find line orders: ${err.message}`, 500));
      }

      if (!lineOrders.length)
      {
        return this.skip(null, []);
      }

      this.lineOrdersList = lineOrders;
      this.lineOrdersMap = {};
      this.workerCountMap = {};

      lineOrders.forEach(lineOrder =>
      {
        if (!this.lineOrdersMap[lineOrder._id])
        {
          this.lineOrdersMap[lineOrder._id] = [];
        }

        this.lineOrdersMap[lineOrder._id].push(lineOrder);
      });

      settings.forEach(settings =>
      {
        this.workerCountMap[settings.mrp] = settings.workerCount;
      });

      const orderIds = Object.keys(this.lineOrdersMap);

      Plan.aggregate([
        {$match: {_id: this.planId}},
        {$unwind: '$orders'},
        {$match: {'orders._id': {$in: orderIds}}},
        {$project: {_id: '$orders._id', operationNo: '$orders.operation.no'}}
      ], this.parallel());

      module.orderFinder.findOrdersByNo(orderIds, this.parallel());

      if (options.prev)
      {
        ProdShiftOrder
          .find({
            orderId: {$in: orderIds},
            prodLine: this.prodShift.prodLine,
            prodShift: {$ne: this.prodShift._id},
            quantityDone: {$gt: 0}
          })
          .select({
            shift: 1,
            orderId: 1,
            operationNo: 1,
            startedAt: 1,
            finishedAt: 1,
            quantityDone: 1,
            workerCount: 1,
            avgTaktTime: 1,
            sapTaktTime: 1
          })
          .sort({startedAt: -1})
          .lean()
          .exec(this.parallel());
      }
      else
      {
        setImmediate(this.parallel(), null, []);
      }
    },
    function(err, planOrders, sapOrders, prodShiftOrders)
    {
      if (err)
      {
        return this.skip(app.createError(`Failed to find orders: ${err.message}`, 500));
      }

      planOrders.forEach(planOrder =>
      {
        this.lineOrdersMap[planOrder._id].forEach(lineOrder =>
        {
          lineOrder.operationNo = planOrder.operationNo;
        });
      });

      sapOrders.forEach(sapOrder =>
      {
        sapOrder.operations = mapOperations(sapOrder.operations);
        sapOrder.no = sapOrder._id;

        delete sapOrder._id;

        const workerCount = this.workerCountMap[sapOrder.mrp] || {};

        this.lineOrdersMap[sapOrder.no].forEach(lineOrder =>
        {
          lineOrder.workerCount = workerCount[this.prodShift.shift - 1] || 0;
          lineOrder.sapOrder = sapOrder;
        });
      });

      prodShiftOrders.forEach(pso =>
      {
        if (pso.quantityDone > 0)
        {
          this.startedOrdersMap[pso.orderId] = true;
        }

        execution.doneOrders.unshift({
          shift: pso.shift,
          orderId: pso.orderId,
          operationNo: pso.operationNo,
          startedAt: pso.startedAt.getTime(),
          finishedAt: pso.finishedAt ? pso.finishedAt.getTime() : 0,
          quantityDone: pso.quantityDone,
          workerCount: pso.workerCount,
          taktTime: pso.avgTaktTime && pso.sapTaktTime
            ? (pso.avgTaktTime >= pso.sapTaktTime ? 'ok' : 'nok')
            : 'na'
        });
      });

      this.lineOrdersList.forEach(o =>
      {
        const shift = shifts.getShiftNo(o.startAt, true);

        execution.todoOrders.push({
          shift,
          orderId: o._id,
          operationNo: o.operationNo,
          startedAt: moment.utc(o.startAt).local(true).valueOf(),
          finishedAt: moment.utc(o.finishAt).local(true).valueOf(),
          quantityDone: o.quantity,
          workerCount: o.workerCount,
          taktTime: 'na'
        });

        if (shift === this.prodShift.shift
          && o.sapOrder
          && o.operationNo
          && o.workerCount >= 0
          && !this.startedOrdersMap[o._id])
        {
          orderQueue.push({
            order: o.sapOrder,
            operationNo: o.operationNo,
            workerCount: o.workerCount
          });
        }
      });

      setImmediate(this.next());
    },
    function(err)
    {
      if (err)
      {
        module.error(err, `Failed to get order queue.`, {
          prodShiftId,
          prodLineId
        });
      }

      done(null, {
        orderQueue: options.orderQueue ? orderQueue : undefined,
        execution: options.execution ? execution : undefined
      });
    }
  );
};
