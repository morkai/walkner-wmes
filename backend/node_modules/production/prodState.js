// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');
const moment = require('moment');
const ProdLineState = require('./ProdLineState');

module.exports = (app, module) =>
{
  const orgUnits = app[module.config.orgUnitsId];
  const mongoose = app[module.config.mongooseId];
  const Order = mongoose.model('Order');

  const CRUD_OPERATION_TYPES = {
    addOrder: true,
    editOrder: true,
    deleteOrder: true,
    addDowntime: true,
    editDowntime: true,
    deleteDowntime: true
  };

  const prodLineStateMap = {};
  let loaded = false;

  module.settings = {
    extendedDowntimeDelay: 15,
    qiKinds: []
  };

  module.getProdLineStates = function(done)
  {
    if (loaded)
    {
      const prodLineStateList = Object.values(prodLineStateMap);

      if (!done)
      {
        return Promise.resolve(prodLineStateList);
      }

      return done(null, prodLineStateList);
    }

    if (!done)
    {
      return new Promise(resolve =>
      {
        module.getProdLineState(() => resolve());
      });
    }

    app.broker.subscribe('production.stateLoaded').setLimit(1).on('message', () =>
    {
      module.getProdLineStates(done);
    });
  };

  module.getProdLineState = function(prodLineId)
  {
    return prodLineStateMap[prodLineId] || null;
  };

  _.forEach(orgUnits.getAllByType('prodLine'), function(prodLine)
  {
    createProdLineState(prodLine, false);
  });

  scheduleHourChange();

  app.broker.subscribe('prodLines.added', function(message)
  {
    const prodLineId = message.model._id;
    const prodLine = orgUnits.getByTypeAndId('prodLine', prodLineId);

    if (prodLine)
    {
      createProdLineState(prodLine, true);

      return;
    }

    const startTime = Date.now();
    const sub = app.broker.subscribe('prodLines.synced', function()
    {
      const prodLine = orgUnits.getByTypeAndId('prodLine', prodLineId);

      if (prodLine)
      {
        createProdLineState(prodLine, true);
      }

      if (prodLine || (Date.now() - startTime) > 10000)
      {
        sub.cancel();
      }
    });
  });

  app.broker.subscribe('prodLines.deleted', function(message)
  {
    const prodLineId = message.model._id;
    let prodLineState = prodLineStateMap[prodLineId];

    if (prodLineState)
    {
      delete prodLineStateMap[prodLineId];

      prodLineState.destroy();
      prodLineState = null;
    }
  });

  app.broker.subscribe('production.synced.**', function(changes)
  {
    const multiChange = changes.types.length > 1;

    if (!multiChange && changes.types[0] === 'corroborateDowntime' && !changes.prodShift)
    {
      return;
    }

    const prodLineState = prodLineStateMap[changes.prodLine];

    if (!prodLineState)
    {
      return module.info('Data synced but no state for prod line...', {prodLineId: changes.prodLine});
    }

    const operationTypes = {
      crud: false,
      finishOrder: false,
      changeOrder: false,
      finishDowntime: false,
      startDowntime: false
    };

    _.forEach(changes.types, function(type)
    {
      if (CRUD_OPERATION_TYPES[type])
      {
        operationTypes.crud = true;
      }
      else
      {
        operationTypes[type] = true;
      }
    });

    const reloadOrders = operationTypes.crud
      || (multiChange && operationTypes.finishOrder && operationTypes.changeOrder);
    const reloadDowntimes = operationTypes.crud
      || (multiChange && operationTypes.finishDowntime && operationTypes.startDowntime);

    prodLineState.update(changes, {reloadOrders, reloadDowntimes});
  });

  app.broker.subscribe('qi.results.added', ({model}) =>
  {
    updateLineQi(model.line);
  });

  app.broker.subscribe('qi.results.edited', ({model}) =>
  {
    const change = _.last(model.changes);

    if (change.data.line)
    {
      updateLineQi(change.data.line[0]);
      updateLineQi(change.data.line[1]);
    }
    else if (change.data.ok || change.data.kind)
    {
      updateLineQi(model.line);
    }
  });

  app.broker.subscribe('qi.results.deleted', ({model}) =>
  {
    updateLineQi(model.line);
  });

  app.broker.subscribe('hourlyPlans.quantitiesPlanned', function(data)
  {
    const prodLineState = prodLineStateMap[data.prodLine];

    if (prodLineState && prodLineState.getCurrentShiftId() === data.prodShift)
    {
      prodLineState.onQuantitiesPlanned();
    }
  });

  app.broker.subscribe('settings.updated.factoryLayout.**', function(message)
  {
    const id = message._id.replace('factoryLayout.', '');

    module.settings[id] = message.value;

    _.forEach(prodLineStateMap, prodLineState =>
    {
      if (id === 'extendedDowntimeDelay')
      {
        prodLineState.checkExtendedDowntime();
      }
      else if (id === 'qiKinds')
      {
        prodLineState.updateQi();
      }
    });
  });

  app.broker.subscribe('orders.operationsChanged', message => copyNewOperationData(message.orders));

  app.broker.subscribe('shiftChanged', currentShift =>
  {
    _.forEach(prodLineStateMap, prodLineState =>
    {
      prodLineState.onShiftChanged(currentShift);
    });
  });

  app.broker.subscribe('fap.entries.added', onFapAdded);
  app.broker.subscribe('fap.entries.deleted', onFapDeleted);
  app.broker.subscribe('fap.entries.updated.*', onFapUpdated);

  app.broker.subscribe('app.started').setLimit(1).on('message', function()
  {
    app[module.config.settingsId].findValues('factoryLayout.', (err, settings) =>
    {
      if (err)
      {
        module.error(err, 'Failed to load settings.');
      }
      else
      {
        Object.assign(module.settings, settings);
      }

      loaded = true;

      app.broker.publish('production.stateLoaded');
    });
  });

  function createProdLineState(prodLine, notify)
  {
    if (prodLine.deactivatedAt)
    {
      return;
    }

    const subdivision = orgUnits.getSubdivisionFor(prodLine);

    if (!subdivision || subdivision.type !== 'assembly')
    {
      return;
    }

    const prodLineState = new ProdLineState(app, module, prodLine);

    prodLineStateMap[prodLine._id] = prodLineState;

    if (notify)
    {
      app.broker.publish('production.stateCreated', prodLineState.toJSON());
    }
  }

  function scheduleHourChange()
  {
    const nextHourTime = moment().minutes(0).seconds(0).milliseconds(999).add(1, 'hours').valueOf();
    const delay = nextHourTime - Date.now();

    setTimeout(onHourChanged, delay);
  }

  function onHourChanged()
  {
    if (!loaded)
    {
      return app.broker.subscribe('production.stateLoaded', onHourChanged).setLimit(1);
    }

    const currentHour = new Date().getHours();

    _.forEach(prodLineStateMap, function(prodLineState)
    {
      prodLineState.onHourChanged(currentHour);
    });

    setImmediate(scheduleHourChange);
  }

  function copyNewOperationData(orderIds)
  {
    step(
      function()
      {
        Order.find({_id: {$in: orderIds}}, {operations: 1}).lean().exec(this.parallel());

        module.getProdShiftOrders({orderId: {$in: orderIds}}, this.parallel());
      },
      function(err, orders, prodShiftOrders)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (prodShiftOrders.length === 0)
        {
          return this.skip();
        }

        const shiftsSet = new Set();
        const ordersMap = new Map();

        orders.forEach(order => ordersMap.set(order._id, order));

        prodShiftOrders.forEach(prodShiftOrder =>
        {
          const order = ordersMap.get(prodShiftOrder.orderId);

          if (!order)
          {
            return;
          }

          prodShiftOrder.copyOperationData(order.operations);
          prodShiftOrder.save(this.group());

          shiftsSet.add(prodShiftOrder.prodShift);
        });

        module.getMultipleProdData('shift', Array.from(shiftsSet), this.group());
      },
      function(err, results)
      {
        if (err)
        {
          return this.skip(err);
        }

        results.pop().forEach(prodShift => recalcShiftOrderData(prodShift, this.group()));
      },
      function(err)
      {
        if (err)
        {
          module.error(`Failed to copy new operation data for [${orderIds}]: ${err.message}`);
        }
      }
    );
  }

  function recalcShiftOrderData(prodShift, done)
  {
    module.getProdShiftOrders(prodShift._id, (err, prodShiftOrders) =>
    {
      if (err)
      {
        return done(err);
      }

      prodShift.recalcOrderData(prodShiftOrders);
      prodShift.save(done);
    });
  }

  function updateLineQi(line)
  {
    const pls = module.getProdLineState(line);

    if (!pls)
    {
      return;
    }

    pls.updateQi((err) =>
    {
      if (err)
      {
        module.error(err, 'Failed to update line QI.', {line});
      }
    });
  }

  function onFapAdded({model})
  {
    if (!model.orderNo || model.orderNo === '000000000')
    {
      return;
    }

    app.broker.publish('production.fapEntries.updated', {
      added: [_.pick(model, module.FAP_PROPS)]
    });
  }

  function onFapDeleted({model})
  {
    if (!model.orderNo || model.orderNo === '000000000')
    {
      return;
    }

    app.broker.publish('production.fapEntries.updated', {
      deleted: [_.pick(model, module.FAP_PROPS)]
    });
  }

  function onFapUpdated(update)
  {
    const {data} = update.change;

    const updated = {
      _id: update._id,
      rid: update.rid
    };

    module.FAP_PROPS.forEach(prop =>
    {
      if (data[prop])
      {
        updated[prop] = data[prop][1];
      }
    });

    if (Object.keys(updated).length === 2)
    {
      return;
    }

    app.broker.publish('production.fapEntries.updated', {
      updated: [updated]
    });
  }
};
