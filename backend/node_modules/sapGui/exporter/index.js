// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const os = require('os');
const path = require('path');
const fs = require('fs');
const zlib = require('zlib');
const step = require('h5.step');
const request = require('request');

const lockedFiles = new Map();

exports.DEFAULT_CONFIG = {
  maxConcurrentUploads: 5,
  filters: [],
  uploadUrl: 'http://127.0.0.1/sapGui;import',
  secretKey: '',
  apiKey: ''
};

exports.start = (app, module) =>
{
  const filePathCache = {};
  const exportQueue = [];

  app.broker.subscribe('directoryWatcher.changed', exportFile).setFilter(filterFile);

  function filterFile(fileInfo)
  {
    if (filePathCache[fileInfo.filePath])
    {
      return false;
    }

    const filters = module.config.filters;

    for (let i = 0; i < filters.length; ++i)
    {
      if (filters[i].test(fileInfo.fileName))
      {
        return true;
      }
    }

    return false;
  }

  function exportFile(fileInfo)
  {
    if (!lockedFiles.has(fileInfo))
    {
      lockedFiles.set(fileInfo, new Set());
    }

    lockedFiles.get(fileInfo).add(module);

    if (Object.keys(filePathCache).length >= module.config.maxConcurrentUploads)
    {
      module.info('Delaying export.', {fileInfo});

      exportQueue.push(fileInfo);

      return;
    }

    filePathCache[fileInfo.filePath] = true;

    module.info('Exporting.', {fileInfo});

    step(
      function waitToDownloadStep()
      {
        waitToDownload(fileInfo.filePath, this.next());
      },
      function readFileStep(err)
      {
        if (err)
        {
          return this.skip(err);
        }

        fs.readFile(fileInfo.filePath, 'utf8', this.next());
      },
      function prepareBodyStep(err, fileContents)
      {
        if (err)
        {
          return this.skip(err);
        }

        zlib.gzip(fileContents, {level: zlib.constants.Z_BEST_COMPRESSION}, this.next());
      },
      function saveArchiveStep(err, compressed)
      {
        if (err)
        {
          return this.skip(err);
        }

        this.archiveFile = path.join(os.tmpdir(), `${fileInfo.timestamp}_${fileInfo.fileName}.gz`);
        this.knownLength = compressed.length;

        fs.writeFile(this.archiveFile, compressed, this.next());
      },
      function uploadStep(err)
      {
        if (err)
        {
          return this.skip(err);
        }

        const requestOptions = {
          url: module.config.uploadUrl,
          method: 'POST',
          headers: {
            'x-api-key': module.config.secretKey
          },
          formData: {
            file: {
              value: fs.createReadStream(this.archiveFile),
              options: {
                filepath: fileInfo.filePath,
                contentType: 'application/gzip',
                knownLength: this.knownLength
              }
            }
          }
        };

        request(requestOptions, this.next());
      },
      function handleResponseStep(err, res)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (res.statusCode !== 204)
        {
          return this.skip(new Error(`Unexpected response status code: ${res.statusCode}`));
        }
      },
      function cleanUpStep(err)
      {
        if (this.archiveFile)
        {
          fs.unlink(this.archiveFile, () => {});
        }

        if (err)
        {
          module.error(err, 'Failed to export.', {fileInfo});

          delete filePathCache[fileInfo.filePath];

          return setImmediate(exportNext);
        }

        module.info('Exported.', {fileInfo});

        delete filePathCache[fileInfo.filePath];

        setImmediate(exportNext);

        lockedFiles.get(fileInfo).delete(module);

        if (lockedFiles.get(fileInfo).size)
        {
          return;
        }

        fs.unlink(fileInfo.filePath, () => {});
      }
    );
  }

  function exportNext()
  {
    const currentUploadsCount = Object.keys(filePathCache).length;
    const availableUploadsCount = module.config.maxConcurrentUploads - currentUploadsCount;
    const toUploadCount = Math.min(availableUploadsCount, exportQueue.length);

    for (let i = 0; i < toUploadCount; ++i)
    {
      exportFile(exportQueue.shift());
    }
  }

  function waitToDownload(filePath, done)
  {
    fs.stat(filePath, (err, stats) =>
    {
      if (err)
      {
        return done(err);
      }

      if ((Date.now() - stats.mtime) <= 15000)
      {
        return setTimeout(waitToDownload, 1000, filePath, done);
      }

      return done();
    });
  }
};
