// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const os = require('os');
const path = require('path');
const {URL} = require('url');
const fs = require('fs-extra');
const axios = require('axios');
const moment = require('moment');
const shifts = require('util/shifts');
const businessDays = require('reports/businessDays');
const parseSapTextTable = require('sap/util/parseSapTextTable');
const parseSapString = require('sap/util/parseSapString');
const parseSapNumber = require('sap/util/parseSapNumber');
const parseSapDate = require('sap/util/parseSapDate');
const parseSapTime = require('sap/util/parseSapTime');

const COMPLETED_STATUS = {
  CNF: true,
  DLV: true,
  TECO: true,
  DLT: true,
  DLFL: true
};

module.exports = (app, module, job, done) =>
{
  const jobId = job.id;
  const tasks = job.tasks || [];
  const inputPath = os.tmpdir();
  const filesToClean = [];

  if (!tasks.length)
  {
    const workDays = {
      current: shifts.getCurrentDate(false),
      before: [],
      after: []
    };
    const fromDate = moment(job.from, 'DD.MM.YYYY');
    const toDate = moment(job.to, 'DD.MM.YYYY');

    while (fromDate.isSameOrBefore(toDate))
    {
      if (businessDays.countInDay(fromDate.toDate()))
      {
        if (fromDate.isBefore(workDays.current))
        {
          workDays.before.push(fromDate.clone());
        }
        else if (fromDate.isAfter(workDays.current))
        {
          workDays.after.push(fromDate.clone());
        }
      }

      fromDate.add(1, 'days');
    }

    workDays.before.reverse();

    if (!businessDays.countInDay(workDays.current.toDate()))
    {
      if (workDays.after.length)
      {
        workDays.current = workDays.after.shift();
      }
      else if (workDays.before.length)
      {
        workDays.current = workDays.before.shift();
      }
      else
      {
        workDays.current = null;
      }
    }

    if (!workDays.current)
    {
      return setImmediate(done, app.createError('No work days.', 'CONFIG', 500));
    }

    const hh = moment().hours();
    const clipTime = hh >= 6 && hh < 14;

    if (clipTime)
    {
      for (let i = 0; i <= 1 && workDays.before.length; ++i)
      {
        const date = workDays.before.shift();

        tasks.push({
          statuses: {
            from: date.format('DD.MM.YYYY'),
            to: date.format('DD.MM.YYYY')
          }
        });
      }
    }

    tasks.push({
      headers: {
        from: workDays.current.format('DD.MM.YYYY'),
        to: workDays.current.format('DD.MM.YYYY')
      },
      operations: clipTime ? 'missing' : 'incomplete',
      components: clipTime ? 'missing' : 'incomplete',
      documents: clipTime ? 'missing' : 'incomplete'
    });

    if (workDays.after.length)
    {
      const date = workDays.after.shift();

      tasks.push({
        headers: {
          from: date.format('DD.MM.YYYY'),
          to: date.format('DD.MM.YYYY')
        },
        operations: 'incomplete',
        components: 'incomplete',
        documents: clipTime ? 'missing' : 'incomplete'
      });
    }

    if (workDays.before.length)
    {
      const date = workDays.before.shift();

      tasks.push({
        statuses: {
          from: date.format('DD.MM.YYYY'),
          to: date.format('DD.MM.YYYY')
        }
      });
    }

    if (workDays.after.length)
    {
      const date = workDays.after.shift();

      tasks.push({
        headers: {
          from: date.format('DD.MM.YYYY'),
          to: date.format('DD.MM.YYYY')
        },
        operations: 'incomplete',
        components: 'incomplete',
        documents: clipTime ? 'missing' : 'incomplete'
      });
    }

    if (workDays.before.length)
    {
      const date = workDays.before.shift();

      tasks.push({
        statuses: {
          from: date.format('DD.MM.YYYY'),
          to: date.format('DD.MM.YYYY')
        }
      });
    }

    if (!clipTime)
    {
      workDays.after.forEach(date =>
      {
        tasks.push({
          headers: {
            from: date.format('DD.MM.YYYY'),
            to: date.format('DD.MM.YYYY')
          },
          operations: 'incomplete',
          components: 'incomplete',
          documents: 'missing'
        });
      });
    }

    workDays.before.forEach(date =>
    {
      tasks.push({
        statuses: {
          from: date.format('DD.MM.YYYY'),
          to: date.format('DD.MM.YYYY')
        }
      });
    });
  }

  let excludedMrps = null;

  runNextTask();

  async function runNextTask()
  {
    const task = tasks.shift();
    const orders = new Map();

    try
    {
      if (!excludedMrps)
      {
        const res = await request({
          method: 'GET',
          url: buildUrl('/settings') + '?select(value)&_id=orders.documents.excludedMrps'
        });

        if (res.body && res.body.collection && res.body.collection.length === 1)
        {
          excludedMrps = res.body.collection[0].value;
        }
        else
        {
          excludedMrps = [];
        }
      }

      const ts = Math.round(Date.now() / 1000);

      await dumpCoois(task.headers, orders, parseHeadersTable, 'headers', 'WMES_ORDERS', 1000);
      await dumpCoois(task.statuses, orders, parseStatusesTable, 'headers', 'WMES_STATUSES', 1000);
      await dumpCoois(task.operations, orders, parseOperationsTable, 'operations', 'WMES_OPERS', 1000);
      await dumpCoois(task.components, orders, parseComponentsTable, 'components', 'WMES_BOM', 1000);
      await dumpCoois(task.documents, orders, parseDocumentsTable, 'documents', 'WMES_DOCS', 100);

      cleanUpFiles();

      await fs.writeFile(
        path.join(module.config.outputPath, `${ts}@ORDERS.json`),
        JSON.stringify(Array.from(orders.values()))
      );
    }
    catch (err)
    {
      return done(err);
    }

    if (tasks.length)
    {
      setTimeout(runNextTask, 1000);
    }
    else
    {
      done();
    }
  }

  async function prepareFilter(list, filter, orders)
  {
    if (filter === 'headers')
    {
      filter = {
        orders: Array.from(orders.keys())
      };
    }
    else if (filter === 'incomplete')
    {
      filter = {
        orders: filterIncompleteOrders(orders)
      };
    }
    else if (filter === 'missing')
    {
      filter = {
        orders: await filterMissingOrders(list, filterIncompleteOrders(orders))
      };
    }
    else if (Array.isArray(filter))
    {
      filter = {
        orders: filter.filter(v => typeof v === 'string' && /^[0-9]{9}$/.test(v))
      };
    }

    if (Array.isArray(filter.orders) && list === 'documents' && excludedMrps.length)
    {
      filter.orders = filter.orders.filter(orderNo =>
      {
        const order = orders.get(orderNo);

        if (!order || !order.mrp)
        {
          return true;
        }

        return !excludedMrps.includes(order.mrp);
      });
    }

    return filter;
  }

  function filterIncompleteOrders(orders)
  {
    const incompleteOrders = [];

    orders.forEach(o =>
    {
      if (Array.isArray(o.statuses) && o.statuses.every(s => !COMPLETED_STATUS[s]))
      {
        incompleteOrders.push(o._id);
      }
    });

    return incompleteOrders;
  }

  async function filterMissingOrders(list, orders)
  {
    if (orders.length === 0)
    {
      return [];
    }

    const res = await request({
      method: 'POST',
      url: `${buildUrl('/orders;missing')}`,
      data: {
        list,
        orders
      }
    });

    if (res.body && Array.isArray(res.body.orders))
    {
      return res.body.orders.filter(o => /^[0-9]{9}$/.test(o));
    }

    throw app.createError('Invalid missing orders response.', 'INVALID_REMOTE_RESPONSE', 500, {
      response: {
        status: res.status,
        headers: res.headers,
        body: res.body
      }
    });
  }

  function createBatches(limit, filter)
  {
    if (!Array.isArray(filter.orders) || filter.orders.length <= limit)
    {
      return [filter];
    }

    const batches = [];

    while (filter.orders.length)
    {
      batches.push({
        ...filter,
        orders: filter.orders.splice(0, limit)
      });
    }

    return batches;
  }

  async function runNextBatch(filter, parseTable, list, layout, orders)
  {
    const table = await runScript(list, layout, filter);

    parseTable(table, orders);
  }

  async function dumpCoois(filter, orders, parseTable, list, layout, limit)
  {
    if (!filter)
    {
      return;
    }

    module.debug(`Dumping ${list}...`, {jobId, filter});

    filter = await prepareFilter(list, filter, orders);

    if ((!Array.isArray(filter.orders) || filter.orders.length === 0) && !filter.from)
    {
      module.warn(`Skipping empty filter...`, {jobId, list, filter});

      return;
    }

    const batches = createBatches(limit, filter);

    while (batches.length)
    {
      await runNextBatch(batches.shift(), parseTable, list, layout, orders);
    }
  }

  async function request(req)
  {
    req.retries = (req.retries || 0) + 1;

    if (req.maxRetries == null)
    {
      req.maxRetries = 3;
    }

    if (req.proxy == null)
    {
      req.proxy = false;
    }

    if (req.timeout == null)
    {
      req.timeout = 20000;
    }

    if (!req.headers)
    {
      req.headers = {};
    }

    if (module.config.secretKey && !req.headers['x-api-key'])
    {
      req.headers['x-api-key'] = module.config.secretKey;
    }

    try
    {
      return await axios(req);
    }
    catch (err)
    {
      if (!req.maxRetries || req.retries === req.maxRetries)
      {
        throw app.createError(`Invalid remote response: ${err.message}`, 'INVALID_REMOTE_RESPONSE', 500, {
          status: err.response.status,
          headers: err.response.headers,
          body: err.response.body
        });
      }

      module.debug(err, `Retrying remote request...`, {jobId, retries: req.retries});

      return wait(20000).then(() => request(req));
    }
  }

  function buildUrl(pathname)
  {
    return Object.assign(new URL(job.baseUrl), {pathname}).toString();
  }

  async function runScript(list, layout, filter, retries = 1)
  {
    const outputFile = `${jobId.replace(/[^A-Z0-9]+/gi, '_')}_${Date.now()}_${retries}_${list}.txt`;

    const args = [
      '--output-file', outputFile,
      '--list', list,
      '--layout', layout
    ];

    if (Array.isArray(filter.orders) && filter.orders.length)
    {
      const ordersFilePath = path.join(inputPath, outputFile);

      filesToClean.push(ordersFilePath);

      await fs.writeFile(ordersFilePath, filter.orders.join('\r\n'));

      args.push(
        '--input-path', inputPath,
        '--orders-file', outputFile
      );
    }
    else
    {
      filter = {
        ...job.cooisFilter,
        ...filter
      };

      if (filter.plant)
      {
        args.push('--plant', filter.plant);
      }

      if (filter.deleted && list === 'headers')
      {
        args.push('--deleted', '1');
      }

      if (filter.from)
      {
        args.push('--from', filter.from);
      }

      if (filter.to && filter.to !== filter.from)
      {
        args.push('--to', filter.to);
      }
    }

    try
    {
      const output = await module.runScript(job, 'T_COOIS.exe', args);

      if (output.includes('NO_DATA'))
      {
        return;
      }

      const outputPath = (output.match(/--output-path=(.*?)$/m) || [null, null])[1];

      if (!outputPath)
      {
        throw new Error('Invalid script output: no output path.');
      }

      const outputFilePath = path.join(outputPath, outputFile);

      filesToClean.push(path.join(outputPath, outputFile));

      return await fs.readFile(outputFilePath, 'utf8');
    }
    catch (err)
    {
      if (retries === 3)
      {
        throw err;
      }

      module.debug(err, `Retrying COOIS script...`, {jobId, retries});

      return wait(30000).then(() => runScript(list, layout, filter, retries + 1));
    }
  }

  function cleanUpFiles()
  {
    filesToClean.forEach(f =>
    {
      fs.unlink(f, () => {});
    });
  }

  function wait(delay)
  {
    return new Promise(resolve => setTimeout(resolve, delay));
  }

  function parseHeadersTable(input, orders)
  {
    if (!input.trim().endsWith('----------'))
    {
      return;
    }

    parseSapTextTable(input, {
      columnMatchers: {
        _id: /^Order$/,
        nc12: /^Material$/,
        name: /^Mat.*?desc/,
        description: /^Mat.*?Desc.*?SO/,
        mrp: /^MRP/,
        qty: /^Target.*?q/,
        unit: /^Unit$/,
        startDate: /^B.*?sta/,
        finishDate: /^B.*?fin/,
        statuses: /^System Status/,
        salesOrder: /^Sales O/,
        salesOrderItem: /^S.*?It/,
        priority: /^Priority$/,
        scheduledStartDate: /^Sch.*?Sta/,
        scheduledFinishDate: /^Sch.*?Fin/,
        leadingOrder: /^Lead.*?Ord/,
        enteredBy: /^Ent.*?by/i,
        changedBy: /^Cha.*?by/i,
        createdDate: /^Created on$/,
        createdTime: /^Time$/
      },
      valueParsers: {
        nc12: input => input.replace(/^0+/, ''),
        name: parseSapString,
        description: parseSapString,
        qty: parseSapNumber,
        startDate: parseSapDate,
        finishDate: parseSapDate,
        scheduledStartDate: parseSapDate,
        scheduledFinishDate: parseSapDate,
        statuses: input => input
          .replace(/\s+/g, ' ')
          .split(' ')
          .map(status => status.replace(/\*/g, ''))
          .filter(status => status.length > 0),
        enteredBy: parseSapString,
        changedBy: parseSapString,
        createdDate: parseSapDate,
        createdTime: parseSapTime
      },
      itemDecorator: obj =>
      {
        obj.enteredBy = obj.enteredBy.includes('SYSBTC') ? 'System' : obj.enteredBy;
        obj.changedBy = obj.changedBy.includes('SYSBTC') ? 'System' : obj.changedBy;
        obj.startDate = prepareSapDate(obj.startDate);
        obj.finishDate = prepareSapDate(obj.finishDate);
        obj.scheduledStartDate = prepareSapDate(obj.scheduledStartDate);
        obj.scheduledFinishDate = prepareSapDate(obj.scheduledFinishDate);
        obj.sapCreatedAt = new Date(
          obj.createdDate.y, obj.createdDate.m - 1, obj.createdDate.d,
          obj.createdTime.h, obj.createdTime.m, obj.createdTime.s
        );

        delete obj.createdDate;
        delete obj.createdTime;

        if (orders.has(obj._id))
        {
          Object.assign(orders.get(obj._id), obj);
        }
        else
        {
          orders.set(obj._id, obj);
        }

        return null;
      }
    });
  }

  function parseStatusesTable(input, orders)
  {
    if (!input.trim().endsWith('----------'))
    {
      return;
    }

    parseSapTextTable(input, {
      columnMatchers: {
        _id: /^Order$/,
        statuses: /^System Status/,
        changedBy: /^Cha.*?by/i
      },
      valueParsers: {
        statuses: input => input
          .replace(/\s+/g, ' ')
          .split(' ')
          .map(status => status.replace(/\*/g, ''))
          .filter(status => status.length > 0),
        changedBy: parseSapString
      },
      itemDecorator: obj =>
      {
        if (orders.has(obj._id))
        {
          Object.assign(orders.get(obj._id), obj);
        }
        else
        {
          orders.set(obj._id, obj);
        }

        return null;
      }
    });
  }

  function parseOperationsTable(input, orders)
  {
    if (!input.trim().endsWith('----------'))
    {
      return;
    }

    parseSapTextTable(input, {
      columnMatchers: {
        order: /^Order$/,
        no: /^Oper.*?Act/,
        workCenter: /^Work c/,
        name: /^Op.*?short text$/i,
        qty: /^Op.*?(qty|quantity)/i,
        unit: /^Act.*?Op.*?UoM/,
        machineSetupTime: /^Std Value$/,
        laborSetupTime: /^Std Value$/,
        machineTime: /^Std Value$/,
        laborTime: /^Std Value$/
      },
      valueParsers: {
        name: parseSapString,
        qty: parseSapNumber,
        machineSetupTime: parseStdValue,
        laborSetupTime: parseStdValue,
        machineTime: parseStdValue,
        laborTime: parseStdValue
      },
      itemDecorator: obj =>
      {
        if (!orders.has(obj.order))
        {
          orders.set(obj.order, {
            _id: obj.order,
            operations: []
          });
        }

        const order = orders.get(obj.order);

        delete obj.order;

        if (!order.operations)
        {
          order.operations = [];
        }

        order.operations.push(obj);

        return null;
      }
    });
  }

  function parseComponentsTable(input, orders)
  {
    if (!input.trim().endsWith('----------'))
    {
      return;
    }

    parseSapTextTable(input, {
      columnMatchers: {
        order: /^Order$/,
        nc12: /^Material$/,
        item: /^BOM item$/,
        qty: /^Req.*?qty$/,
        unit: /^Unit$/,
        name: /^Material Desc/,
        unloadingPoint: /^Unl.*?Point/,
        supplyArea: /^Sup.*?Area/
      },
      valueParsers: {
        nc12: input => input.replace(/^0+/, ''),
        qty: parseSapNumber,
        name: parseSapString,
        unloadingPoint: parseSapString,
        supplyArea: parseSapString
      },
      itemDecorator: obj =>
      {
        if (!orders.has(obj.order))
        {
          orders.set(obj.order, {
            _id: obj.order,
            bom: []
          });
        }

        if (obj.nc12.length > 0 && obj.nc12.length < 12)
        {
          obj.nc12 = obj.nc12.padStart(12, '0');
        }

        const order = orders.get(obj.order);

        delete obj.order;

        if (!order.bom)
        {
          order.bom = [];
        }

        order.bom.push(obj);

        return null;
      }
    });
  }

  function parseDocumentsTable(input, orders)
  {
    if (!input.trim().endsWith('----------'))
    {
      return;
    }

    parseSapTextTable(input, {
      columnMatchers: {
        order: /^Order/,
        item: /^Item/,
        nc15: /^Document/,
        name: /^Description/
      },
      valueParsers: {
        name: parseSapString
      },
      itemDecorator: obj =>
      {
        if (!orders.has(obj.order))
        {
          orders.set(obj.order, {
            _id: obj.order,
            documents: []
          });
        }

        const order = orders.get(obj.order);

        delete obj.order;

        if (!order.documents)
        {
          order.documents = [];
        }

        order.documents.push(obj);

        return null;
      }
    });
  }

  function parseStdValue(input)
  {
    return input === '' || input === '0' ? 0 : parseSapNumber(input);
  }

  function prepareSapDate(sapDate)
  {
    return sapDate
      ? new Date(sapDate.y, sapDate.m - 1, sapDate.d)
      : null;
  }
};
