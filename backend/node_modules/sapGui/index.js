// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const {spawn, exec} = require('child_process');
const {join} = require('path');
const {URL} = require('url');
const path = require('path');
const os = require('os');
const fs = require('fs');
const _ = require('lodash');
const later = require('later');
const request = require('request');
const jobs = require('./jobs');
const setUpRoutes = require('./routes');

exports.DEFAULT_CONFIG = {
  expressId: 'express',
  httpServerId: 'httpServer',
  mailSenderId: 'mail/sender',
  scriptsPath: 'C:/SAP/Scripts',
  outputPath: 'C:/SAP/Output',
  jobs: [],
  remoteUrl: null,
  secretKey: null
};

exports.start = (app, module) =>
{
  const lastJobRunTimes = {};
  const scriptQueue = [];
  const sessionsToKill = new Set();
  let sessionKillTimer = null;
  let sessionReady = true;
  let notReadyCounter = 0;
  let restarting = false;

  module.jobs = jobs;

  module.jobCount = 0;

  module.workerJobIds = new Map();

  module.runJob = (job, done) =>
  {
    if (!module.config.scriptsPath)
    {
      return done(app.createError('Scripts are disabled.', 'DISABLED', 500));
    }

    runJob(_.cloneDeep(job), 0, done);
  };

  module.runRemoteJob = (job, done) =>
  {
    if (!done)
    {
      return new Promise((resolve, reject) =>
      {
        doRunRemoteJob((err, body) =>
        {
          if (err)
          {
            reject(err);
          }
          else
          {
            resolve(body);
          }
        });
      });
    }

    doRunRemoteJob(done);

    function doRunRemoteJob(done)
    {
      if (!module.config.remoteUrl)
      {
        return done(app.createError('Remote jobs are disabled.', 'DISABLED', 500));
      }

      runRemoteJob(_.cloneDeep(job), done);
    }
  };

  module.runScript = runScript;

  app.onModuleReady(
    [
      module.config.expressId
    ],
    setUpRoutes.bind(null, app, module)
  );

  app.broker.subscribe('app.started', setUpJobs).setLimit(1);

  app.broker.subscribe('sapGui.jobDone', notifyAboutFailedJob);

  function runScript(job, scriptFile, args, done)
  {
    if (!module.config.scriptsPath)
    {
      return done(app.createError('Scripts are disabled.', 'DISABLED', 500));
    }

    scriptQueue.push({job, scriptFile, args, done});

    if (sessionReady)
    {
      runNextScript();
    }
    else
    {
      module.info('Script queued.', {jobId: job.id, scriptFile, args});
    }
  }

  function runNextScript()
  {
    if (!scriptQueue.length)
    {
      return;
    }

    sessionReady = false;

    const {job, scriptFile, args, done} = scriptQueue.shift();

    module.debug('Running script...', {jobId: job.id, scriptFile, args});

    const killSession = scriptFile.includes('KillSession');
    const file = join(module.config.scriptsPath, scriptFile);
    let sessionId = null;
    let cp = null;
    let output = '';
    let wasReady = false;
    let timeoutTimer = setTimeout(
      () => bail(app.createError('Session not ready.', 'NOT_READY', 500), null),
      90 * 1000
    );

    if (restarting)
    {
      return bail(app.createError('Restaring SAP GUI...', 'RESTARTING', 500), null);
    }

    cp = spawn(file, args);

    cp.on('error', err => bail(err, null));

    cp.on('exit', exitCode => bail(null, exitCode));

    cp.stderr.setEncoding('utf8');
    cp.stderr.on('data', function(data)
    {
      data.trim().split(/\r\n|\n/).forEach(line =>
      {
        output += line + '\r\n';

        module.error(line, {jobId: job.id});
      });
    });

    cp.stdout.setEncoding('utf8');
    cp.stdout.on('data', data =>
    {
      data.trim().split(/\r\n|\n/).forEach(line =>
      {
        output += line + '\r\n';

        module.debug(line, {jobId: job.id});

        if (line.startsWith('SESSION_READY'))
        {
          clearTimeout(timeoutTimer);
          timeoutTimer = !job.scriptTimeout ? null : setTimeout(
            () => bail(app.createError('Script timeout.', 'SCRIPT_TIMEOUT', 500), null),
            _.result(job, 'scriptTimeout', 0)
          );

          if (scriptQueue.length)
          {
            setImmediate(runNextScript);
          }
          else
          {
            sessionReady = true;
          }

          wasReady = true;
        }

        if (killSession)
        {
          if (line.startsWith('SESSION_CLOSED='))
          {
            sessionsToKill.delete(line.split('=')[1].trim());
          }
        }
        else if (line.startsWith('SESSION_ID='))
        {
          sessionId = line.split('=')[1].trim();
        }
      });
    });

    function bail(err, exitCode)
    {
      if (bail.called)
      {
        return;
      }

      bail.called = true;

      if (!wasReady)
      {
        if (scriptQueue.length)
        {
          setImmediate(runNextScript);
        }
        else
        {
          sessionReady = true;
        }
      }

      if (err && sessionId && (err.code === 'SCRIPT_TIMEOUT' || err.code === 'NOT_READY'))
      {
        sessionsToKill.add(sessionId);
        scheduleSessionKill();
      }

      if (cp !== null)
      {
        cp.removeAllListeners();
        cp.on('error', () => {});
        cp.kill();
        cp = null;
      }

      if (timeoutTimer !== null)
      {
        clearTimeout(timeoutTimer);
        timeoutTimer = null;
      }

      if (err && err.code === 'NOT_READY')
      {
        notReadyCounter += 1;

        if (notReadyCounter === 3)
        {
          restartSapGui();
        }
      }
      else
      {
        notReadyCounter = 0;
      }

      done(err, exitCode, output);
    }
  }

  function runJob(job, repeatCounter, done)
  {
    if (typeof done !== 'function')
    {
      done = () => {};
    }

    if (!job || !jobs[job.name])
    {
      return done(app.createError('Unknown job.', 'INPUT', 400));
    }

    const startedAt = Date.now();

    if (!job.key)
    {
      job.key = `${job.name}#${startedAt}`;
    }

    const lastJobRunTime = lastJobRunTimes[job.key] || 0;

    if (startedAt - lastJobRunTime < 5000)
    {
      module.warn('Stopped a possible duplicate run of a job.', {
        jobKey: job.key,
        lastJobRunTime: new Date(lastJobRunTime)
      });

      return done(app.createError('Duplicate job', 'DUPLICATE', 500));
    }

    lastJobRunTimes[job.key] = startedAt;

    ++module.jobCount;

    job.id = job.name + '#' + module.jobCount;

    if (job.key !== job.name)
    {
      job.id = job.key + ':' + job.id;
    }

    let jobDone = false;

    module.info(`${repeatCounter === 0 ? 'Starting' : ('Repeating #' + repeatCounter)}...`, {
      jobId: job.id
    });

    if (repeatCounter === 0 && job.waitForResult === false)
    {
      done();
    }

    if (job.workerJobId)
    {
      module.workerJobIds.set(job.workerJobId, (module.workerJobIds.get(job.workerJobId) || 0) + 1);
    }

    jobs[job.name](app, module, job, (err, exitCode, output) =>
    {
      if (jobDone)
      {
        return;
      }

      jobDone = true;

      let failure = !!err || exitCode !== 0;

      if (!_.isEmpty(job.ignoredResults) && isMatchingResult(job.ignoredResults, err, output))
      {
        failure = false;
        err = null;
        exitCode = 0;
      }
      else if (!_.isEmpty(job.expectedResults))
      {
        if (isMatchingResult(job.expectedResults, err, output))
        {
          failure = false;
          err = null;
          exitCode = 0;
        }
        else if (!failure)
        {
          failure = true;
          err = new Error('Unexpected result.');
        }
      }

      if (err)
      {
        module.error(err, {jobId: job.id});
      }
      else
      {
        module.info('Finished.', {jobId: job.id, exitCode, duration: (Date.now() - startedAt) / 1000});
      }

      const repeatOnFailure = _.result(job, 'repeatOnFailure', 0);

      if (!repeatOnFailure || !failure || repeatOnFailure === repeatCounter)
      {
        return handleJobResult(done, job, startedAt, err, exitCode, output);
      }

      module.info('Failed... will retry in 1s...', {jobId: job.id});

      setTimeout(
        () => runJob(job, repeatCounter + 1, done),
        1000
      );
    });
  }

  function runRemoteJob(job, done)
  {
    const req = {
      method: 'POST',
      url: Object.assign(new URL(module.config.remoteUrl), {pathname: '/sapGui/jobs;run'}).toString(),
      json: true,
      body: {
        secretKey: module.config.secretKey,
        job
      },
      timeout: 60000 + _.result(job, 'scriptTimeout', 0)
    };

    request(req, (err, res, body) =>
    {
      if (err)
      {
        return done(err);
      }

      if (res.statusCode !== 200 && res.statusCode !== 204)
      {
        return done(app.createError(
          `Unexpected response status code: ${res.statusCode}`,
          'UNEXPECTED_STATUS_CODE',
          500
        ));
      }

      done(null, body);
    });
  }

  function handleJobResult(done, job, startedAt, err, exitCode, output)
  {
    const jobResult = {
      job,
      result: err || exitCode ? 'failure' : 'success',
      startedAt: startedAt,
      finishedAt: Date.now(),
      output: output || '',
      error: err ? err.message : null,
      exitCode: typeof exitCode === 'number' ? exitCode : null
    };

    app.broker.publish('sapGui.jobDone', jobResult);

    if (job.waitForResult !== false)
    {
      done(err, exitCode, output);
    }

    if (job.sendResult)
    {
      sendJobResult(jobResult, 1);
    }

    setTimeout(() =>
    {
      const count = module.workerJobIds.get(job.workerJobId);

      if (!count)
      {
        return;
      }

      if (count === 1)
      {
        module.workerJobIds.delete(job.workerJobId);
      }
      else
      {
        module.workerJobIds.set(job.workerJobId, count - 1);
      }
    }, 10000);
  }

  function sendJobResult(jobResult, tryCount)
  {
    const job = jobResult.job;
    const jobId = job.id;
    const sendResult = job.sendResult;
    const req = {
      method: sendResult.method || 'POST',
      url: sendResult.url,
      json: true,
      headers: sendResult.headers || {},
      body: {
        ...sendResult.body,
        ...jobResult
      },
      timeout: 10000
    };

    if (tryCount === 1)
    {
      const lastResultFile = path.join(os.tmpdir(), 'WMES_SAPGUI_LAST_JOB_RESULT.json');

      fs.writeFile(lastResultFile, JSON.stringify(req, null, 2), err =>
      {
        if (err)
        {
          module.error(err, 'Failed to save the last job result file.');
        }
      });
    }

    request(req, (err, res, body) =>
    {
      if (res && (res.statusCode === 200 || res.statusCode === 204))
      {
        return;
      }

      if (tryCount === 3 || (res && res.statusCode >= 400 && res.statusCode < 500))
      {
        module.warn('Giving up sending the job result...', {
          jobId,
          error: err || undefined,
          response: !res ? undefined : {
            status: res.statusCode,
            body
          }
        });
      }
      else
      {
        setTimeout(sendJobResult, tryCount * 2000, jobResult, tryCount + 1);
      }
    });
  }

  function isMatchingResult(patterns, err, output)
  {
    const error = err && err.message ? err.message : '';

    if (!_.isString(output))
    {
      output = '';
    }

    for (let i = 0; i < patterns.length; ++i)
    {
      const pattern = patterns[i];

      if (_.isString(pattern) && (_.includes(error, pattern) || _.includes(output, pattern)))
      {
        return true;
      }
      else if (_.isRegExp(pattern) && (pattern.test(error) || pattern.test(output)))
      {
        return true;
      }
    }

    return false;
  }

  function setUpJobs()
  {
    module.config.jobs.forEach((job, i) =>
    {
      if (!job.key)
      {
        job.key = job.name + '#' + i;
      }

      later.setInterval(module.runJob.bind(null, job), job.schedule);
    });
  }

  function notifyAboutFailedJob(message)
  {
    if (message.result === 'success')
    {
      return;
    }

    const mailSender = app[module.config.mailSenderId];
    const job = message.job;

    if (!mailSender || !Array.isArray(job.failureRecipients) || !job.failureRecipients.length)
    {
      return;
    }

    const subject = `[${app.options.id}:sapGui:jobFailed] ${job.id}`;
    const text = [
      'Job name: ' + job.name,
      'Started at: ' + new Date(message.startedAt),
      'Finished at: ' + new Date(message.finishedAt),
      'Duration: ' + ((message.finishedAt - message.startedAt) / 1000) + 's',
      'Exit code: ' + (message.exitCode === null ? 'n/a' : message.exitCode),
      'Error: ' + (message.error || 'n/a'),
      'Output:',
      _.isPlainObject(message.output) ? JSON.stringify(message.output, null, 2) : (message.output || 'n/a')
    ];

    mailSender.send(job.failureRecipients, subject, text.join('\r\n'), err =>
    {
      if (err)
      {
        module.error(err, 'Failed to send e-mail.', {subject, recipients: job.failureRecipients});
      }
    });
  }

  function scheduleSessionKill()
  {
    clearTimeout(sessionKillTimer);

    if (sessionsToKill.size)
    {
      sessionKillTimer = setTimeout(killSessions, 60000);
    }
  }

  function killSessions()
  {
    if (!sessionsToKill.size)
    {
      return;
    }

    runScript({id: 'SessionKiller'}, 'KillSession.exe', Array.from(sessionsToKill), () =>
    {
      scheduleSessionKill();
    });
  }

  function restartSapGui()
  {
    if (restarting)
    {
      return;
    }

    restarting = true;

    exec('TASKKILL /IM saplogon.exe /T /F', (err, stdout, stderr) =>
    {
      if (err)
      {
        module.warn(err, 'Failed to kill saplogon.exe', {stderr});
      }

      setTimeout(() =>
      {
        exec('TASKLIST /FI "IMAGENAME eq saplogon.exe"', (err, stdout, stderr) =>
        {
          if (err)
          {
            module.warn(err, 'Failed to list saplogon.exe', {stderr});
          }

          if (stdout && stdout.includes('saplogon.exe'))
          {
            setTimeout(restartSapGui, 30000);
          }
          else
          {
            restarting = false;
          }
        });
      }, 5000);
    });
  }
};
