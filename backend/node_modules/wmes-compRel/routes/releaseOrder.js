// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const moment = require('moment');
const uuid = require('uuid');
const step = require('h5.step');
const locks = require('util/locks');

module.exports = (app, {user, CompRelEntry}, req, res, next) =>
{
  const sessionUser = req.session.user;

  step(
    function()
    {
      if (!user.isAllowedTo(sessionUser, [['PROD_DATA:MANAGE', 'COMP_REL:MANAGE', 'FN:production-planner']]))
      {
        return this.skip(app.createError('Not allowed.', 'AUTH', 400));
      }

      this.releaseLock = locks.create(`compRel/entries/${req.params.id}`, this.next());
    },
    function()
    {
      CompRelEntry.findById(req.params.id).exec(this.next());
    },
    function(err, entry)
    {
      if (err)
      {
        return this.skip(err);
      }

      if (!entry)
      {
        return this.skip(app.createError('Not found.', 'NOT_FOUND', 400));
      }

      if (entry.status !== 'accepted')
      {
        return this.skip(app.createError('Invalid status.', 'STATUS', 400));
      }

      const orderNos = (Array.isArray(req.body.orders) ? req.body.orders : [])
        .filter(v => /^[0-9]{9}$/.test(v) && v !== '000000000');

      if (!orderNos.length)
      {
        orderNos.push('000000000');
      }

      let removedOrder = null;

      if (req.body.remove)
      {
        removedOrder = entry.orders.find(o => o._id === req.body.remove);

        if (!removedOrder)
        {
          return this.skip(app.createError('Unknown order.', 'INPUT', 400));
        }
      }

      let validFrom = moment(req.body.validFrom || '2000-01-01', 'YYYY-MM-DD');
      let validTo = moment(req.body.validTo || '2100-01-01', 'YYYY-MM-DD');

      if (!validFrom.isValid())
      {
        validFrom = moment('2000-01-01', 'YYYY-MM-DD');
      }

      if (!validTo.isValid())
      {
        validTo = moment('2100-01-01', 'YYYY-MM-DD');
      }

      validFrom = validFrom.toDate();
      validTo = validTo.toDate();

      if (validFrom > validTo)
      {
        return this.skip(app.createError('Invalid valid from/to.', 'INPUT', 400));
      }

      const oldOrders = new Map();
      const newOrders = new Set();
      const now = new Date();
      const userInfo = user.createUserInfo(sessionUser, req);
      const changes = {
        orders: [null, null]
      };

      if (removedOrder)
      {
        entry.orders = entry.orders.filter(o => o !== removedOrder);

        changes.orders[0] = [removedOrder];
      }
      else
      {
        entry.orders.forEach(order =>
        {
          if (order.orderNo !== '000000000')
          {
            oldOrders.set(order.orderNo, order);
          }
        });

        orderNos.forEach(orderNo =>
        {
          const oldOrder = oldOrders.get(orderNo);

          if (!oldOrder)
          {
            newOrders.add(orderNo);
          }
        });

        if (!newOrders.size)
        {
          return this.skip();
        }

        changes.orders[1] = [];

        newOrders.forEach(orderNo =>
        {
          const order = {
            _id: uuid(),
            orderNo,
            releasedAt: now,
            releasedBy: userInfo,
            validFrom,
            validTo
          };

          changes.orders[1].push(order);
          entry.orders.push(order);
        });
      }

      if (!changes.orders[0] && !changes.orders[1])
      {
        return this.skip();
      }

      entry.updatedAt = now;
      entry.updater = userInfo;

      entry.changes.push({
        date: now,
        user: userInfo,
        data: changes,
        comment: req.body.comment || ''
      });

      entry.save(this.next());
    },
    function(err, entry)
    {
      setImmediate(this.releaseLock);

      if (err)
      {
        return next(err);
      }

      if (!entry)
      {
        return res.sendStatus(204);
      }

      app.broker.publish(`${CompRelEntry.TOPIC_PREFIX}.updated.${entry._id}`, {
        _id: entry._id,
        change: _.last(entry.changes)
      });

      res.json(entry);
    }
  );
};
