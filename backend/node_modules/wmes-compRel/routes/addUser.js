// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');
const locks = require('util/locks');

module.exports = (app, {user, CompRelEntry}, req, res, next) =>
{
  const sessionUser = req.session.user;

  step(
    function()
    {
      this.releaseLock = locks.create(`compRel/entries/${req.params.id}`, this.next());
    },
    function()
    {
      CompRelEntry.findById(req.params.id).exec(this.next());
    },
    function(err, entry)
    {
      if (err)
      {
        return this.skip(err);
      }

      if (!entry)
      {
        return this.skip(app.createError('Not found.', 'NOT_FOUND', 400));
      }

      const funcI = entry.funcs.findIndex(f => f._id === req.body.func);

      if (funcI === -1)
      {
        return this.skip(app.createError('Invalid func.', 'INPUT', 400));
      }

      if (!user.isAllowedTo(sessionUser, [['PROD_DATA:MANAGE'], ['COMP_REL:MANAGE'], ['FN:logistic-buyer']])
        && !entry.funcs.some(f => f.users.some(u => u.id === sessionUser._id)))
      {
        return this.skip(app.createError('Not allowed.', 'AUTH', 400));
      }

      const now = new Date();
      const userInfo = user.createUserInfo(sessionUser, req);
      const oldFunc = entry.funcs[funcI].toObject();
      const newFunc = {
        _id: oldFunc._id,
        acceptedAt: null,
        acceptedBy: null,
        status: 'pending',
        comment: '',
        users: [].concat(oldFunc.users)
      };
      const newUsers = [];
      const oldUsers = new Set();

      oldFunc.users.forEach(u => oldUsers.add(u.id));

      if (Array.isArray(req.body.users))
      {
        req.body.users.forEach(u =>
        {
          if (typeof u.id === 'string'
            && typeof u.label === 'string'
            && !oldUsers.has(u.id))
          {
            const newUser = {
              id: u.id,
              label: u.label
            };

            newUsers.push(newUser);
            newFunc.users.push(newUser);
          }
        });
      }

      if (!newUsers.length)
      {
        return this.skip();
      }

      entry.updatedAt = now;
      entry.updater = userInfo;
      entry.funcs[funcI] = newFunc;

      const changes = {
        funcs: [{}, {}]
      };

      changes.funcs[0][newFunc._id] = oldFunc;
      changes.funcs[1][newFunc._id] = newFunc;

      entry.updateStatus(changes);

      entry.changes.push({
        date: now,
        user: userInfo,
        data: changes,
        comment: newFunc.comment
      });

      entry.save(this.parallel());
    },
    function(err, entry)
    {
      setImmediate(this.releaseLock);

      if (err)
      {
        return next(err);
      }

      if (!entry)
      {
        return res.sendStatus(204);
      }

      app.broker.publish(`${CompRelEntry.TOPIC_PREFIX}.updated.${entry._id}`, {
        _id: entry._id,
        change: _.last(entry.changes)
      });

      res.json(entry);
    }
  );
};
