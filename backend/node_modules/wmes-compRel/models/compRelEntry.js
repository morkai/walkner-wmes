// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const autoIncrement = require('mongoose-plugin-autoinc-fix');
const userInfoSchema = require('user/models/userInfoSchema');
const jsonDeepEqual = require('util/jsonDeepEqual');

exports.name = 'CompRelEntry';

exports.setUp = (app, mongoose) =>
{
  const componentSchema = new mongoose.Schema({
    _id: String,
    name: String
  }, {
    _id: false,
    minimize: false
  });

  const funcSchema = new mongoose.Schema({
    _id: String,
    acceptedAt: Date,
    acceptedBy: userInfoSchema,
    status: {
      type: String,
      enum: ['pending', 'accepted', 'rejected']
    },
    comment: String,
    users: [userInfoSchema]
  }, {
    _id: false,
    minimize: false
  });

  const orderSchema = new mongoose.Schema({
    _id: String,
    releasedAt: Date,
    releasedBy: userInfoSchema,
    validFrom: Date,
    validTo: Date
  }, {
    _id: false,
    minimize: false
  });

  const attachmentSchema = new mongoose.Schema({
    _id: {
      type: String,
      required: true
    },
    date: {
      type: Date,
      required: true
    },
    user: userInfoSchema,
    type: {
      type: String,
      required: true
    },
    size: {
      type: Number,
      required: true
    },
    name: {
      type: String,
      required: true
    }
  }, {
    id: false,
    minimize: false
  });

  const changeSchema = new mongoose.Schema({
    date: {
      type: Date,
      required: true
    },
    user: userInfoSchema,
    data: {},
    comment: {
      type: String,
      trim: true,
      default: ''
    }
  }, {
    _id: false,
    minimize: false
  });

  const entrySchema = new mongoose.Schema({
    creator: userInfoSchema,
    createdAt: {
      type: Date,
      required: true
    },
    updater: userInfoSchema,
    updatedAt: {
      type: Date,
      required: true
    },
    acceptedAt: Date,
    status: {
      type: String,
      enum: ['pending', 'accepted', 'rejected']
    },
    mrps: {
      type: [String],
      required: true
    },
    oldComponents: [componentSchema],
    newCode: {
      type: String,
      required: true
    },
    newName: {
      type: String,
      required: true
    },
    reason: {
      type: mongoose.Schema.Types.ObjectId,
      required: true,
      ref: 'CompRelReason'
    },
    funcs: [funcSchema],
    orders: [orderSchema],
    attachments: [attachmentSchema],
    users: [String],
    changes: [changeSchema]
  }, {
    id: false,
    minimize: false
  });

  entrySchema.plugin(autoIncrement.plugin, {
    model: exports.name,
    field: 'rid',
    startAt: 1,
    incrementBy: 1
  });

  entrySchema.statics.TOPIC_PREFIX = 'compRel.entries';
  entrySchema.statics.BROWSE_LIMIT = 100;

  entrySchema.index({createdAt: -1});
  entrySchema.index({'createdBy.id': 1});
  entrySchema.index({'funcs.acceptedBy.id': 1});
  entrySchema.index({users: 1});
  entrySchema.index({oldCode: 1});
  entrySchema.index({newCode: 1});
  entrySchema.index({'orders._id': 1});
  entrySchema.index({reason: 1});

  entrySchema.pre('save', function(next)
  {
    this.collectUsers();

    next();
  });

  entrySchema.methods.collectUsers = function()
  {
    const users = new Set();

    users.add(this.creator.id);
    users.add(this.updater.id);

    this.funcs.forEach(func =>
    {
      if (func.acceptedBy)
      {
        users.add(func.acceptedBy.id);
      }

      func.users.forEach(user =>
      {
        users.add(user.id);
      });
    });

    this.orders.forEach(order =>
    {
      if (order.releasedBy)
      {
        users.add(order.releasedBy.id);
      }
    });

    this.changes.forEach(change =>
    {
      users.add(change.user.id);
    });

    users.delete(null);

    this.users = Array.from(users);
  };

  entrySchema.methods.updateStatus = function(changes)
  {
    const funcStatuses = {
      pending: 0,
      rejected: 0,
      accepted: 0
    };

    this.funcs.forEach(func =>
    {
      funcStatuses[func.status] += 1;
    });

    let newStatus = 'pending';

    if (funcStatuses.rejected)
    {
      newStatus = 'rejected';
    }
    else if (funcStatuses.accepted === this.funcs.length)
    {
      newStatus = 'accepted';
    }

    if (newStatus !== this.status)
    {
      changes.status = [this.status, newStatus];
      this.status = newStatus;

      if (newStatus === 'accepted')
      {
        changes.acceptedAt = [this.acceptedAt, this.updatedAt];
        this.acceptedAt = this.updatedAt;
      }
    }
  };

  entrySchema.methods.updateAttachments = function(changes, attachments)
  {
    if (!Array.isArray(attachments))
    {
      return;
    }

    const added = [null, []];
    const edited = [[], []];
    const removed = [[], null];
    const map = {};

    this.attachments.forEach(a => map[a._id] = a);

    attachments.forEach(newAttachment =>
    {
      const oldAttachment = map[newAttachment._id];

      if (!oldAttachment)
      {
        added[1].push(newAttachment);

        return;
      }

      if (newAttachment.name === oldAttachment.name)
      {
        removed[0].push(oldAttachment);

        return;
      }

      edited[0].push(oldAttachment);
      edited[1].push(newAttachment);
    });

    if (added[1].length)
    {
      changes.attachments = added;

      added[1].forEach(a => this.attachments.push(a));
    }
    else if (edited[0].length)
    {
      changes.attachments = edited;

      edited[1].forEach(a => Object.assign(map[a._id], a));
    }
    else if (removed[0].length)
    {
      changes.attachments = removed;

      this.attachments = this.attachments.filter(a => !removed[0].includes(a));
    }
  };

  entrySchema.methods.updateFuncs = function(changes, funcs)
  {
    const reset = !!changes.oldComponents || !!changes.newCode;

    if (!Array.isArray(funcs))
    {
      if (reset)
      {
        funcs = this.funcs.map(f => f.toObject());
      }
      else
      {
        return;
      }
    }

    funcs.forEach(func =>
    {
      func.acceptedAt = null;
      func.acceptedBy = null;
      func.status = 'pending';
      func.comment = '';
      func.users.sort((a, b) => a.label.localeCompare(b.label, undefined, {ignorePunctuation: true}));
    });

    const change = [{}, {}];
    const oldFuncs = {};
    const newFuncs = [];

    this.funcs.forEach(func =>
    {
      oldFuncs[func._id] = func.toObject();
    });

    funcs.forEach(newFunc =>
    {
      if (!Array.isArray(newFunc.users) || !newFunc.users.length)
      {
        return;
      }

      const oldFunc = oldFuncs[newFunc._id];

      if (oldFunc)
      {
        delete oldFuncs[newFunc._id];

        oldFunc.users.sort((a, b) => a.label.localeCompare(b.label, undefined, {ignorePunctuation: true}));

        if (!reset && jsonDeepEqual(newFunc.users, oldFunc.users))
        {
          newFuncs.push(oldFunc);
        }
        else
        {
          change[0][newFunc._id] = oldFunc;
          change[1][newFunc._id] = newFunc;

          newFuncs.push(newFunc);
        }
      }
      else
      {
        change[0][newFunc._id] = null;
        change[1][newFunc._id] = newFunc;

        newFuncs.push(newFunc);
      }
    });

    Object.keys(oldFuncs).forEach(func =>
    {
      change[0][func._id] = func;
      change[1][func._id] = null;
    });

    if (!Object.keys(change[0]).length)
    {
      return;
    }

    newFuncs.sort((a, b) => a._id.localeCompare(b._id));

    this.funcs = newFuncs;
    changes.funcs = change;
  };

  entrySchema.methods.applyChanges = function(input, updater, updatedAt)
  {
    this.updater = updater;
    this.updatedAt = updatedAt;

    const changes = this.compareProperties(_.omit(input, [
      'funcs',
      'orders',
      'comment',
      'attachments'
    ]));

    this.updateFuncs(changes, input.funcs);
    this.updateStatus(changes);
    this.updateAttachments(changes, input.attachments);

    const changedProperties = Object.keys(changes);
    const comment = _.isEmpty(input.comment) || !_.isString(input.comment) ? '' : input.comment.trim();

    if (!_.isEmpty(input.comment))
    {
      changedProperties.push('comment');
    }

    if (!changedProperties.length)
    {
      return false;
    }

    if (_.isEmpty(comment) && _.isEmpty(changes))
    {
      return false;
    }

    this.changes.push({
      date: this.updatedAt,
      user: updater,
      data: changes,
      comment
    });

    return true;
  };

  entrySchema.methods.compareProperties = function(input)
  {
    const changes = {};

    Object.keys(input).forEach(property =>
    {
      this.compareProperty(property, input, changes);
    });

    return changes;
  };

  entrySchema.methods.compareProperty = function(property, input, changes)
  {
    let oldValue = this[property];
    let newValue = input[property];

    if (_.isObject(oldValue) && _.isFunction(oldValue.toObject))
    {
      oldValue = oldValue.toObject();
    }

    if (_.isObject(newValue) && _.isFunction(newValue.toObject))
    {
      newValue = newValue.toObject();
    }

    if (oldValue instanceof mongoose.Types.ObjectId)
    {
      oldValue = oldValue.toString();
    }

    if (newValue instanceof mongoose.Types.ObjectId)
    {
      newValue = newValue.toString();
    }

    if (_.isString(newValue))
    {
      newValue = newValue.trim();
    }

    if (jsonDeepEqual(newValue, oldValue))
    {
      return false;
    }

    changes[property] = [oldValue, newValue];
    this[property] = newValue;

    return true;
  };

  mongoose.model(exports.name, entrySchema);
};
