// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const fs = require('fs');
const _ = require('lodash');
const step = require('h5.step');
const ejs = require('ejs');
const {ObjectId} = require('mongoose').Types;

module.exports = (app, module) =>
{
  const {
    mailSender,
    User,
    MrpController,
    CompRelReason,
    CompRelEntry
  } = module;

  const emailTemplateFile = `${__dirname}/templates/notifier.email.pl.ejs`;
  const renderEmail = ejs.compile(fs.readFileSync(emailTemplateFile, 'utf8'), {
    cache: true,
    filename: emailTemplateFile,
    compileDebug: false,
    rmWhitespace: true
  });
  const nameMaps = {
    mrps: {},
    reason: {}
  };

  app.broker.subscribe(`${CompRelEntry.TOPIC_PREFIX}.added`, ({model}) =>
  {
    handleAdd(model, model.creator.id, 'pending');
  });

  app.broker.subscribe(`${CompRelEntry.TOPIC_PREFIX}.notifyRequested`, ({model, requester}) =>
  {
    handleAdd(model, requester.id, 'reminder');
  });

  app.broker.subscribe(`${CompRelEntry.TOPIC_PREFIX}.updated.*`, update =>
  {
    handleUpdate(update._id, update.change);
  });

  function handleAdd(entry, invokerId, kind)
  {
    const recipients = new Set();

    entry.users.forEach(uid => recipients.add(uid));

    recipients.delete(invokerId);

    sendEmail(null, kind, recipients, entry);
  }

  function handleUpdate(entryId, change)
  {
    const {status, funcs} = change.data;

    if (!status && !funcs)
    {
      return;
    }

    let kind = null;
    let entry = null;
    const recipients = new Set();

    step(
      function()
      {
        CompRelEntry
          .findById(entryId)
          .select({changes: 0})
          .lean()
          .exec(this.next());
      },
      function(err, compRelEntry)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!compRelEntry)
        {
          return this.done();
        }

        entry = compRelEntry;

        if (status && status[0] !== 'rejected' && status[1] === 'rejected')
        {
          kind = 'rejected';

          entry.users.forEach(uid => recipients.add(uid));

          return;
        }

        if (status && status[0] !== 'accepted' && status[1] === 'accepted')
        {
          kind = 'accepted';

          recipients.add(entry.creator.id);

          return;
        }

        Object.keys(funcs[0]).forEach(funcId =>
        {
          const oldFunc = funcs[0][funcId];
          const newFunc = funcs[1][funcId];

          if ((oldFunc && newFunc && oldFunc.status !== 'pending' && newFunc.status === 'pending')
            || (!oldFunc && newFunc && newFunc.status === 'pending'))
          {
            kind = 'pending';

            newFunc.users.forEach(u => recipients.add(u.id));

            return;
          }

          if (oldFunc && newFunc && newFunc.status === 'pending')
          {
            const oldUsers = oldFunc.users.map(u => u.id);
            const newUsers = newFunc.users.map(u => u.id);
            const diffUsers = _.difference(newUsers, oldUsers);

            if (diffUsers.length)
            {
              kind = 'pending';

              diffUsers.forEach(uid => recipients.add(uid));
            }
          }
        });
      },
      function(err)
      {
        recipients.delete(change.user.id);

        sendEmail(err, kind, recipients, entry);
      }
    );
  }

  function sendEmail(err, kind, recipients, entry, done)
  {
    step(
      function()
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!kind || !recipients.size)
        {
          return this.skip();
        }

        const recipientIds = [];

        try
        {
          recipients.forEach(id => recipientIds.push(new ObjectId(id)));
        }
        catch (err)
        {
          return this.skip(err);
        }

        User
          .find({
            _id: {$in: recipientIds},
            email: {
              $type: 'string',
              $regex: /@/
            }
          })
          .select({email: 1})
          .lean()
          .exec(this.parallel());

        prepareTemplateData(kind, entry, this.parallel());
      },
      function(err, users, templateData)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!users.length)
        {
          return this.skip();
        }

        const email = {
          to: users.map(u => u.email),
          subject: `[WMES] [Dopuszczenia] `,
          html: renderEmail(templateData)
        };

        switch (kind)
        {
          case 'pending':
            email.subject += `[Nowe] Wniosek oczekuje na opinię: ${entry.rid}`;
            break;

          case 'reminder':
            email.subject += `[Aktualizacja] Wniosek oczekuje na opinię: ${entry.rid}`;
            break;

          case 'rejected':
            email.subject += `Wniosek odrzucony: ${entry.rid}`;
            break;

          case 'accepted':
            email.subject += `Wniosek zaakceptowany: ${entry.rid}`;
            break;
        }

        mailSender.send(email, this.next());
      },
      function(err)
      {
        if (err)
        {
          module.error(err, 'Failed to notify users.', {
            rid: entry.rid,
            kind
          });
        }

        if (typeof done === 'function')
        {
          done(err);
        }
      }
    );
  }

  function prepareTemplateData(kind, entry, done)
  {
    const templateData = {
      kind,
      urlPrefix: app.options.emailUrlPrefix,
      entry: {
        rid: entry.rid,
        mrps: entry.mrps,
        oldComponents: entry.oldComponents,
        newComponents: entry.newComponents,
        reason: entry.reason,
        creator: entry.creator.label
      }
    };

    step(
      function()
      {
        findName(MrpController, entry, 'mrps', 'description', this.parallel());
        findName(CompRelReason, entry, 'reason', 'name', this.parallel());
      },
      function(err, mrps, reason)
      {
        if (err)
        {
          return done(err);
        }

        templateData.entry.mrps = entry.mrps.map(id =>
        {
          const name = mrps[id];

          return name ? `${id}: ${name}` : id;
        });

        if (reason)
        {
          templateData.entry.reason = reason;
        }

        return done(null, templateData);
      }
    );
  }

  function findName(Model, model, mapProperty, nameProperty, done)
  {
    const id = model[mapProperty];
    const nameMap = nameMaps[mapProperty];
    const multiple = _.isArray(id);

    if (multiple)
    {
      const names = [];

      _.forEach(id, id =>
      {
        if (nameMap[id])
        {
          names.push(nameMap[id]);
        }
      });

      if (names.length === id.length)
      {
        return setImmediate(done, null, names);
      }
    }
    else if (nameMap[id])
    {
      return setImmediate(done, null, nameMap[id]);
    }

    const conditions = {
      _id: multiple ? {$in: id} : id
    };
    const fields = {};
    fields[nameProperty] = 1;

    Model.find(conditions).select(fields).lean().exec((err, models) =>
    {
      if (err)
      {
        return done(err);
      }

      if (_.isEmpty(models))
      {
        return done(null, id);
      }

      if (multiple)
      {
        const names = [];

        _.forEach(models, model =>
        {
          const name = model[nameProperty];

          nameMap[model._id] = name;

          names.push(name);
        });

        return done(null, names);
      }

      return done(null, models[0][nameProperty]);
    });
  }
};
