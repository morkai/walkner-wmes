// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const fs = require('fs');
const _ = require('lodash');
const step = require('h5.step');
const ejs = require('ejs');
const moment = require('moment');
const {ObjectId} = require('mongoose').Types;

module.exports = (app, module) =>
{
  const CHECK_HOUR = 5;
  const CHECK_MINUTE = 30;

  const {mailSender, settings, User, ToolCalTool, ToolCalType} = module;
  const logger = module.logger.create({submodule: 'notifier'});

  const emailTemplateFile = `${__dirname}/templates/notifier.email.pl.ejs`;
  const renderEmail = ejs.compile(fs.readFileSync(emailTemplateFile, 'utf8'), {
    cache: true,
    filename: emailTemplateFile,
    compileDebug: false,
    rmWhitespace: true
  });

  app.broker.subscribe('app.started', scheduleNext).setLimit(1);

  function scheduleNext()
  {
    const nextAt = moment();

    if (nextAt.hours() === CHECK_HOUR && nextAt.minutes() === CHECK_MINUTE)
    {
      check();

      return;
    }

    if (nextAt.hours() > CHECK_HOUR || (nextAt.hours() === CHECK_HOUR && nextAt.minutes() > CHECK_MINUTE))
    {
      nextAt.add(24, 'hours');
    }

    nextAt.hours(CHECK_HOUR).minutes(CHECK_MINUTE).startOf('minute').add(30, 'seconds');

    const delay = Math.min(4 * 3600 * 1000, nextAt.valueOf() - Date.now());

    setTimeout(scheduleNext, delay);

    logger.info(`Scheduled the next check.`, {
      nextCheckAt: new Date(Date.now() + delay)
    });
  }

  function check()
  {
    step(
      function()
      {
        settings.findValues('toolcal.', this.next());
      },
      function(err, settings)
      {
        if (err)
        {
          return this.skip(app.createError(`Failed to find the settings: ${err.message}`));
        }

        const daysBefore = _.filter(settings['notifier.daysBefore'], v => v > 0);

        if (!daysBefore.length)
        {
          logger.warn(`Skipped: days before setting not set.`);

          return this.skip();
        }

        const nowMoment = moment().startOf('day');
        const nextDates = daysBefore.map(v => nowMoment.clone().add(v, 'days').toDate());

        logger.info('Checking...', {nextDates});

        ToolCalTool
          .find({
            nextDate: {$in: nextDates},
            status: {$ne: 'retired'}
          })
          .sort({nextDate: 1})
          .lean()
          .exec(this.parallel());

        ToolCalType
          .find({})
          .lean()
          .exec(this.parallel());
      },
      function(err, tools, typeList)
      {
        if (err)
        {
          return this.skip(app.createError(`Failed to fetch data: ${err.message}`));
        }

        if (tools.length === 0)
        {
          logger.info(`Skipped: no tools found.`);
        }

        const typeMap = {};

        typeList.forEach(type => typeMap[type._id] = type);

        notifyNext(tools, typeMap, this.next());
      },
      function(err)
      {
        if (err)
        {
          logger.error(err, `Checking failed.`);
        }
        else
        {
          logger.info(`Checked!`);
        }

        setTimeout(scheduleNext, 60000);
      }
    );
  }

  function notifyNext(tools, types, done)
  {
    if (tools.length === 0)
    {
      return done();
    }

    const tool = tools.shift();

    step(
      function()
      {
        const userIds = tool.users.map(u => new ObjectId(u.id));

        User
          .find({_id: {$in: userIds}}, {email: 1})
          .lean()
          .exec(this.next());
      },
      function(err, recipients)
      {
        if (err)
        {
          return this.skip(err);
        }

        this.recipients = recipients
          .filter((recipient) => _.isString(recipient.email) && recipient.email.includes('@'))
          .map((recipient) => recipient.email);

        if (!this.recipients.length)
        {
          return this.skip();
        }

        const mailOptions = {
          to: this.recipients,
          replyTo: this.recipients,
          subject: `[WMES] [TOOLCAL] NadchodzÄ…ca kalibracja: ${tool.name}`,
          html: renderEmail({
            urlPrefix: app.options.emailUrlPrefix,
            tool: {
              ...tool,
              type: types[tool.type] || tool.type,
              lastDate: moment(tool.lastDate).format('LL'),
              nextDate: moment(tool.nextDate).format('LL')
            }
          })
        };

        mailSender.send(mailOptions, this.next());
      },
      function(err)
      {
        if (err)
        {
          module.error(err, `Failed to notify.`, {
            tool: tool.rid,
            recipients: this.recipients || []
          });
        }
        else if (this.recipients.length)
        {
          module.info(`Notified.`, {
            tool: tool.rid,
            recipients: this.recipients
          });
        }
        else
        {
          module.info(`No one to notify.`, {
            tool: tool.rid
          });
        }

        setImmediate(notifyNext, tools, types, done);
      }
    );
  }
};
