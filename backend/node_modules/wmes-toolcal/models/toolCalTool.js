// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const moment = require('moment');
const deepEqual = require('deep-equal');
const autoIncrement = require('mongoose-plugin-autoinc-fix');

exports.name = 'ToolCalTool';

exports.setUp = (app, mongoose) =>
{
  const userSchema = new mongoose.Schema({
    id: String,
    label: String,
    kind: {
      type: String,
      enum: ['current', 'individual']
    }
  }, {
    _id: false,
    minimize: false
  });

  const attachmentSchema = new mongoose.Schema({
    hash: String,
    type: String,
    size: Number,
    name: String
  }, {
    _id: false
  });

  const changeSchema = new mongoose.Schema({
    date: Date,
    user: {},
    data: {},
    comment: {
      type: String,
      trim: true,
      default: ''
    }
  }, {
    _id: false,
    minimize: false
  });

  const toolSchema = new mongoose.Schema({
    type: {
      type: String,
      ref: 'ToolCalType',
      required: true,
      maxLength: 40,
      trim: true
    },
    status: {
      type: String,
      required: true,
      enum: ['in-use', 'retired']
    },
    name: {
      type: String,
      required: true,
      maxLength: 100,
      trim: true
    },
    sn: {
      type: String,
      maxLength: 100,
      trim: true
    },
    lastDate: {
      type: Date,
      required: true
    },
    nextDate: {
      type: Date,
      required: true
    },
    interval: {
      type: Number,
      required: true,
      min: 1,
      max: 9999
    },
    intervalUnit: {
      type: String,
      required: true,
      enum: ['year', 'month', 'week', 'day']
    },
    certificateFile: attachmentSchema,
    users: [userSchema],
    changes: [changeSchema]
  }, {
    id: false,
    minimize: false
  });

  toolSchema.plugin(autoIncrement.plugin, {
    model: 'ToolCalTool',
    field: 'rid',
    startAt: 1,
    incrementBy: 1
  });

  toolSchema.index({nextDate: -1});

  toolSchema.statics.TOPIC_PREFIX = 'toolcal.tools';

  toolSchema.pre('validate', function()
  {
    if (this.isNew)
    {
      this.nextDate = this.calcNextDate();
    }
  });

  toolSchema.methods.calcNextDate = function()
  {
    return this.lastDate
      ? moment(this.lastDate.getTime()).add(this.interval, this.intervalUnit).toDate()
      : null;
  };

  toolSchema.methods.applyChanges = function(input, user)
  {
    const data = this.compareProperties(_.pick(input, [
      'type',
      'status',
      'name',
      'sn',
      'lastDate',
      'interval',
      'intervalUnit',
      'certificateFile',
      'users'
    ]));

    Object.assign(data, this.compareProperties({nextDate: this.calcNextDate()}));

    const changedProperties = Object.keys(data);
    const comment = _.isEmpty(input.comment) || !_.isString(input.comment) ? '' : input.comment.trim();

    if (!_.isEmpty(input.comment))
    {
      changedProperties.push('comment');
    }

    if (changedProperties.length)
    {
      this.changes.push({
        date: new Date(),
        user,
        data,
        comment
      });

      return true;
    }

    return false;
  };

  toolSchema.methods.compareProperties = function(input)
  {
    const changes = {};

    _.forEach(input, (value, key) => { this.compareProperty(key, input, changes); });

    return changes;
  };

  toolSchema.methods.compareProperty = function(property, input, changes)
  {
    let oldValue = this[property];
    let newValue = input[property];

    if (_.isObject(oldValue) && _.isFunction(oldValue.toObject))
    {
      oldValue = oldValue.toObject();
    }

    if (_.isObject(newValue) && _.isFunction(newValue.toObject))
    {
      newValue = newValue.toObject();
    }

    if (oldValue instanceof mongoose.Types.ObjectId)
    {
      oldValue = oldValue.toString();
    }

    if (_.isString(newValue))
    {
      newValue = newValue.trim();

      if (/date/i.test(property))
      {
        newValue = new Date(newValue);
      }
    }

    if (deepEqual(newValue, oldValue, {strict: true}))
    {
      return false;
    }

    changes[property] = [oldValue, newValue];
    this[property] = newValue;

    return true;
  };

  mongoose.model(exports.name, toolSchema);
};
