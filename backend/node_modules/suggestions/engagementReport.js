// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');
const util = require('reports/util');

exports.models = [
  require('./models/suggestion'),
  require('kaizen/models/kaizenOrder'),
  require('kaizen/models/kaizenSection'),
  require('behaviorObsCards/models/behaviorObsCard'),
  require('minutesForSafetyCards/models/minutesForSafetyCard'),
  require('wmes-oshAudits/models/oshAudit'),
  require('wmes-oshTalks/models/oshTalk'),
  require('user/models/user')
];

exports.report = (app, module, options, done) =>
{
  const {
    User,
    KaizenSection,
    KaizenOrder,
    Suggestion,
    BehaviorObsCard,
    MinutesForSafetyCard,
    OshAudit,
    OshTalk
  } = module;

  const results = {
    options: options,
    sections: {},
    users: {},
    groups: {}
  };

  step(
    function findStep()
    {
      findSections(this.group());
      countNearMisses(options, _.once(this.group()));
      countSuggestions(options, _.once(this.group()));
      countObservations(options, _.once(this.group()));
      countMinutes(options, _.once(this.group()));
      countAudits(options, _.once(this.group()));
      countTalks(options, _.once(this.group()));
    },
    function sendResultsStep(err)
    {
      return done(err, results);
    }
  );

  function findSections(done)
  {
    KaizenSection.find().lean().exec(function(err, sections)
    {
      if (err)
      {
        return done(err);
      }

      _.forEach(sections, function(section)
      {
        results.sections[section._id] = section.name;
      });

      done();
    });
  }

  function countNearMisses(options, done)
  {
    const conditions = {
      types: 'nearMiss'
    };

    if (Array.isArray(options.status) && !_.isEmpty(options.status))
    {
      conditions.status = {$in: options.status};
    }

    if (Array.isArray(options.sections) && !_.isEmpty(options.sections))
    {
      conditions.section = {$in: options.sections};
    }

    if (options.fromTime)
    {
      conditions.eventDate = {$gte: new Date(options.fromTime)};
    }

    if (options.toTime)
    {
      if (!conditions.eventDate)
      {
        conditions.eventDate = {};
      }

      conditions.eventDate.$lt = new Date(options.toTime);
    }

    const stream = KaizenOrder
      .find(conditions)
      .select({
        section: 1,
        eventDate: 1,
        nearMissOwners: 1
      })
      .lean()
      .cursor();

    stream.on('error', done);
    stream.on('end', done);
    stream.on('data', handleNearMiss);
  }

  function countSuggestions(options, done)
  {
    const conditions = {};

    if (Array.isArray(options.status) && !_.isEmpty(options.status))
    {
      conditions.status = {$in: options.status};
    }

    if (Array.isArray(options.sections) && !_.isEmpty(options.sections))
    {
      conditions.section = {$in: options.sections};
    }

    if (options.fromTime)
    {
      conditions.date = {$gte: new Date(options.fromTime)};
    }

    if (options.toTime)
    {
      if (!conditions.date)
      {
        conditions.date = {};
      }

      conditions.date.$lt = new Date(options.toTime);
    }

    const stream = Suggestion
      .find(conditions)
      .select({
        categories: 1,
        section: 1,
        date: 1,
        owners: 1
      })
      .lean()
      .cursor();

    stream.on('error', done);
    stream.on('end', done);
    stream.on('data', handleSuggestion);
  }

  function countObservations(options, done)
  {
    const conditions = {};

    if (Array.isArray(options.sections) && !_.isEmpty(options.sections))
    {
      conditions.observerSection = {$in: options.sections};
    }

    if (options.fromTime)
    {
      conditions.date = {$gte: new Date(options.fromTime)};
    }

    if (options.toTime)
    {
      if (!conditions.date)
      {
        conditions.date = {};
      }

      conditions.date.$lt = new Date(options.toTime);
    }

    const stream = BehaviorObsCard
      .find(conditions)
      .select({
        observerSection: 1,
        date: 1,
        observer: 1
      })
      .lean()
      .cursor();

    stream.on('error', done);
    stream.on('end', done);
    stream.on('data', handleObservation);
  }

  function countMinutes(options, done)
  {
    const conditions = {};

    if (Array.isArray(options.sections) && !_.isEmpty(options.sections))
    {
      conditions.section = {$in: options.sections};
    }

    if (options.fromTime)
    {
      conditions.date = {$gte: new Date(options.fromTime)};
    }

    if (options.toTime)
    {
      if (!conditions.date)
      {
        conditions.date = {};
      }

      conditions.date.$lt = new Date(options.toTime);
    }

    const stream = MinutesForSafetyCard
      .find(conditions)
      .select({
        section: 1,
        date: 1,
        owner: 1,
        confirmer: 1,
        participants: 1
      })
      .lean()
      .cursor();

    stream.on('error', done);
    stream.on('end', done);
    stream.on('data', handleMinutesForSafetyCard);
  }

  function countAudits(options, done)
  {
    const conditions = {};

    if (Array.isArray(options.sections) && !_.isEmpty(options.sections))
    {
      conditions.section = {$in: options.sections};
    }

    if (options.fromTime)
    {
      conditions.date = {$gte: new Date(options.fromTime)};
    }

    if (options.toTime)
    {
      if (!conditions.date)
      {
        conditions.date = {};
      }

      conditions.date.$lt = new Date(options.toTime);
    }

    const stream = OshAudit
      .find(conditions)
      .select({
        section: 1,
        date: 1,
        auditor: 1,
        'results.owner': 1
      })
      .lean()
      .cursor();

    stream.on('error', done);
    stream.on('end', done);
    stream.on('data', handleAudit);
  }

  function countTalks(options, done)
  {
    const conditions = {};

    if (Array.isArray(options.sections) && !_.isEmpty(options.sections))
    {
      conditions.section = {$in: options.sections};
    }

    if (options.fromTime)
    {
      conditions.date = {$gte: new Date(options.fromTime)};
    }

    if (options.toTime)
    {
      if (!conditions.date)
      {
        conditions.date = {};
      }

      conditions.date.$lt = new Date(options.toTime);
    }

    const stream = OshTalk
      .find(conditions)
      .select({
        section: 1,
        date: 1,
        auditor: 1,
        participants: 1
      })
      .lean()
      .cursor();

    stream.on('error', done);
    stream.on('end', done);
    stream.on('data', handleTalk);
  }

  function handleNearMiss(doc)
  {
    const groupKey = util.createGroupKey(options.interval, doc.eventDate, false);

    _.forEach(doc.nearMissOwners, owner =>
    {
      getGroup(groupKey, owner, doc.section).nearMisses += 1;
    });
  }

  function handleSuggestion(doc)
  {
    const groupKey = util.createGroupKey(options.interval, doc.date, false);

    _.forEach(doc.owners, function(owner)
    {
      const group = getGroup(groupKey, owner, doc.section);

      group.suggestions += 1;

      if (doc.categories.includes('BHP'))
      {
        group.osh += 1;
      }
    });
  }

  function handleObservation(doc)
  {
    const groupKey = util.createGroupKey(options.interval, doc.date, false);

    getGroup(groupKey, doc.observer, doc.observerSection).observations += 1;
  }

  function handleMinutesForSafetyCard(doc)
  {
    const groupKey = util.createGroupKey(options.interval, doc.date, false);
    const used = new Set();

    getGroup(groupKey, doc.owner, doc.section).minutes += 1;
    used.add(doc.owner.id);

    if (doc.confirmer && !used.has(doc.confirmer.id))
    {
      getGroup(groupKey, doc.confirmer, doc.section).minutes += 1;
      used.add(doc.confirmer.id);
    }

    _.forEach(doc.participants, participant =>
    {
      if (!used.has(participant.id))
      {
        getGroup(groupKey, participant, doc.section).minutes += 1;
        used.add(participant.id);
      }
    });
  }

  function handleAudit(doc)
  {
    const groupKey = util.createGroupKey(options.interval, doc.date, false);
    const used = new Set();

    getGroup(groupKey, doc.auditor, doc.section).audits += 1;
    used.add(doc.auditor.id);

    _.forEach(doc.results, result =>
    {
      if (result.owner && !used.has(result.owner.id))
      {
        getGroup(groupKey, result.owner, doc.section).audits += 1;
        used.add(result.owner.id);
      }
    });
  }

  function handleTalk(doc)
  {
    const groupKey = util.createGroupKey(options.interval, doc.date, false);
    const used = new Set();

    getGroup(groupKey, doc.auditor, doc.section).talks += 1;
    used.add(doc.auditor.id);

    _.forEach(doc.participants, participant =>
    {
      if (!used.has(participant.id))
      {
        getGroup(groupKey, participant, doc.section).talks += 1;
        used.add(participant.id);
      }
    });
  }

  function getGroup(key, owner, section)
  {
    let group = results.groups[key];

    if (!group)
    {
      group = results.groups[key] = {};
    }

    const user = User.transliterateName(owner.label);

    if (!results.users[user])
    {
      results.users[user] = owner.label;
    }

    if (!group[user])
    {
      group[user] = {
        nearMisses: 0,
        osh: 0,
        suggestions: 0,
        observations: 0,
        minutes: 0,
        audits: 0,
        talks: 0,
        sections: {}
      };
    }

    if (!group[user].sections[section])
    {
      group[user].sections[section] = 0;
    }

    group[user].sections[section] += 1;

    return group[user];
  }
};
