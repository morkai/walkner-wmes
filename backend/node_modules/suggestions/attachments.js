// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const fs = require('fs');
const _ = require('lodash');

module.exports = (app, module) =>
{
  const pendingUploads = new Map();

  module.attachments = {
    addPendingUploads,
    claimPendingUploads,
    prepareInput
  };

  function addPendingUploads(files)
  {
    const attachments = [];

    _.forEach(files, file =>
    {
      const id = file.filename.replace(/\..*?$/, '');

      if (pendingUploads.has(id))
      {
        return;
      }

      const attachment = {
        _id: id,
        type: file.mimetype,
        path: file.filename,
        name: file.originalname,
        size: file.size,
        description: file.fieldname
      };

      const cleanupTimer = setTimeout(
        removePendingUpload,
        Math.max(30000, Math.ceil(attachment.size / 100)),
        id,
        file.path
      );

      const upload = {
        attachment,
        cleanupTimer
      };

      pendingUploads.set(id, upload);
      attachments.push(id);
    });

    return attachments;
  }

  function removePendingUpload(uploadId, filePath)
  {
    const upload = pendingUploads.get(uploadId);

    if (!upload)
    {
      return;
    }

    fs.unlink(filePath, err =>
    {
      if (err)
      {
        module.error(err, 'Failed to remove pending upload.', {
          uploadId,
          filePath
        });
      }
      else
      {
        module.debug('Removed pending upload.', {
          uploadId,
          filePath
        });
      }
    });
  }

  function claimPendingUploads(uploadIds)
  {
    const attachments = [];

    if (!Array.isArray(uploadIds) || uploadIds.length === 0)
    {
      return attachments;
    }

    uploadIds.forEach(uploadId =>
    {
      const upload = pendingUploads.get(uploadId);

      if (!upload)
      {
        return;
      }

      clearTimeout(upload.cleanupTimer);

      attachments.push(upload.attachment);
    });

    return attachments;
  }

  function prepareInput(input, suggestion)
  {
    const newAttachmentMap = {};

    claimPendingUploads(input).forEach(attachment =>
    {
      newAttachmentMap[attachment.description] = attachment;
    });

    const attachments = [];

    suggestion.attachments.forEach(oldAttachment =>
    {
      const newAttachment = newAttachmentMap[oldAttachment.description];

      if (newAttachment)
      {
        delete newAttachmentMap[oldAttachment.description];

        attachments.push(newAttachment);
      }
      else
      {
        attachments.push(oldAttachment.toObject());
      }
    });

    _.forEach(newAttachmentMap, function(newAttachment)
    {
      attachments.push(newAttachment);
    });

    const sortOrder = {
      scan: 1,
      before: 2,
      after: 3
    };

    attachments.sort((a, b) => sortOrder[a.description] - sortOrder[b.description]);

    return attachments;
  }
};
