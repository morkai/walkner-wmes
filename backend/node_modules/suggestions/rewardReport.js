// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const moment = require('moment');
const step = require('h5.step');

exports.models = [
  require('./models/suggestion'),
  require('kaizen/models/kaizenSection'),
  require('user/models/user'),
  require('settings/models/setting')
];

exports.report = (app, {mongoose}, options, done) =>
{
  const Suggestion = mongoose.model('Suggestion');
  const KaizenSection = mongoose.model('KaizenSection');
  const User = mongoose.model('User');
  const Setting = mongoose.model('Setting');

  const results = {
    options,
    sections: {},
    users: {}
  };

  step(
    function()
    {
      findSettings(this.group());
      findSections(this.group());
      countSuggestions(options, _.once(this.group()));
    },
    function(err)
    {
      if (err)
      {
        return done(err);
      }

      const users = [];

      Object.keys(results.users).sort().forEach(k =>
      {
        const user = results.users[k];

        user.finished[1] = Math.round(user.finished[1] * 100) / 100;
        user.kom[1] = Math.round(user.kom[1] * 100) / 100;
        user.sections = Object.keys(user.sections);

        users.push(user);
      });

      results.users = users;

      done(null, results);
    }
  );

  function findSettings(done)
  {
    options.reward = {
      kz: 0,
      kom: 0
    };

    Setting.find({_id: /^kaizen\.reward\./}).select({value: 1}).lean().exec((err, settings) =>
    {
      if (err)
      {
        return done(err);
      }

      settings.forEach(setting =>
      {
        const k = setting._id.split('.').pop();

        if (setting.value > 0 && typeof options.reward[k] === 'number')
        {
          options.reward[k] = setting.value;
        }
      });

      done();
    });
  }

  function findSections(done)
  {
    KaizenSection.find().lean().exec((err, sections) =>
    {
      if (err)
      {
        return done(err);
      }

      sections.forEach(section =>
      {
        results.sections[section._id] = section.name;
      });

      done();
    });
  }

  function countSuggestions(options, done)
  {
    const conditions = {
      status: 'finished',
      finishedAt: {
        $gte: moment(options.month, 'YYYY-MM').toDate(),
        $lt: moment(options.month, 'YYYY-MM').add(1, 'month').toDate()
      }
    };

    if (Array.isArray(options.sections) && !_.isEmpty(options.sections))
    {
      conditions.section = {$in: options.sections};
    }

    if (options.confirmer)
    {
      conditions['confirmer.id'] = options.confirmer;
    }

    if (options.superior)
    {
      conditions['superior.id'] = options.superior;
    }

    const stream = Suggestion
      .find(conditions)
      .select({
        kom: 1,
        owners: 1,
        section: 1
      })
      .lean()
      .cursor();

    stream.on('error', done);
    stream.on('end', done);
    stream.on('data', handleSuggestion);
  }

  function handleSuggestion(doc)
  {
    const part = 1 / doc.owners.length;

    doc.owners.forEach(owner =>
    {
      const user = User.transliterateName(owner.label);

      if (!results.users[user])
      {
        results.users[user] = {
          name: owner.label,
          finished: [0, 0],
          kom: [0, 0],
          sections: {}
        };
      }

      if (doc.kom)
      {
        results.users[user].kom[0] += 1;
        results.users[user].kom[1] += part;
      }
      else
      {
        results.users[user].finished[0] += 1;
        results.users[user].finished[1] += part;
      }

      results.users[user].sections[doc.section] = 1;
    });
  }
};
