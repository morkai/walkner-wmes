// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const moment = require('moment');
const step = require('h5.step');

exports.models = [
  require('./models/suggestion'),
  require('kaizen/models/kaizenSection'),
  require('user/models/user')
];

exports.report = (app, {mongoose}, options, done) =>
{
  const Suggestion = mongoose.model('Suggestion');
  const KaizenSection = mongoose.model('KaizenSection');
  const User = mongoose.model('User');

  const results = {
    options: options,
    sections: {},
    users: {}
  };

  step(
    function()
    {
      findSections(this.group());
      countSuggestions(options, _.once(this.group()));
    },
    function(err)
    {
      if (err)
      {
        return done(err);
      }

      const users = [];

      Object.keys(results.users).sort().forEach(k =>
      {
        const user = results.users[k];

        user.sections = Object.keys(user.sections);

        users.push(user);
      });

      results.users = users;

      done(null, results);
    }
  );

  function findSections(done)
  {
    KaizenSection.find().lean().exec((err, sections) =>
    {
      if (err)
      {
        return done(err);
      }

      sections.forEach(section =>
      {
        results.sections[section._id] = section.name;
      });

      done();
    });
  }

  function countSuggestions(options, done)
  {
    const conditions = {
      status: 'finished',
      finishedAt: {
        $gte: moment(options.month, 'YYYY-MM').toDate(),
        $lt: moment(options.month, 'YYYY-MM').add(1, 'month').toDate()
      }
    };

    if (Array.isArray(options.sections) && !_.isEmpty(options.sections))
    {
      conditions.section = {$in: options.sections};
    }

    const stream = Suggestion
      .find(conditions)
      .select({
        kom: 1,
        owners: 1,
        section: 1
      })
      .lean()
      .cursor();

    stream.on('error', done);
    stream.on('end', done);
    stream.on('data', handleSuggestion);
  }

  function handleSuggestion(doc)
  {
    doc.owners.forEach(owner =>
    {
      const user = User.transliterateName(owner.label);

      if (!results.users[user])
      {
        results.users[user] = {
          name: owner.label,
          finished: 0,
          kom: 0,
          sections: {}
        };
      }

      if (doc.kom)
      {
        results.users[user].kom += 1;
      }
      else
      {
        results.users[user].finished += 1;
      }

      results.users[user].sections[doc.section] = 1;
    });
  }
};
