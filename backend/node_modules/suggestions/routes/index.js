// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');
const multer = require('multer');
const countReport = require('../countReport');
const summaryReport = require('../summaryReport');
const engagementReport = require('../engagementReport');
const rewardReport = require('../rewardReport');
const browseRoute = require('./browse');
const editRoute = require('./edit');
const coordinateRoute = require('./coordinate');
const findByRidRoute = require('./findByRid');
const sendAttachmentRoute = require('./sendAttachment');

module.exports = (app, module) =>
{
  const {
    mongoose,
    express,
    user,
    reports,
    kaizen,
    mor,
    Suggestion,
    KaizenCategory,
    KaizenProductFamily,
    KaizenSection
  } = module;

  const canView = user.auth('LOCAL', 'USER');
  const canManage = user.auth('USER');

  express.get('/suggestions/stats', canView, statsRoute);

  express.get('/suggestions', canView, browseRoute.bind(null, app, module));
  express.get('/suggestions;rid', canView, findByRidRoute.bind(null, app, module));
  express.post(
    '/suggestions',
    canView,
    prepareCoordSections,
    prepareForAdd,
    express.crud.addRoute.bind(null, app, Suggestion)
  );
  express.post('/suggestions/:id;coordinate', coordinateRoute.bind(null, app, module));
  express.get('/suggestions/:id', canView, express.crud.readRoute.bind(null, app, {
    model: Suggestion,
    idProperty: req => /^[0-9]+$/.test(req.params.id) ? 'rid' : '_id',
    prepareReadResult
  }));
  express.put('/suggestions/:id', canView, prepareCoordSections, editRoute.bind(null, app, module));
  express.delete('/suggestions/:id', canManage, express.crud.deleteRoute.bind(null, app, Suggestion));

  express.get('/suggestions;export.:format?', canView, fetchDictionaries, express.crud.exportRoute.bind(null, app, {
    filename: 'SUGGESTIONS',
    serializeRow: exportSuggestion,
    cleanUp: cleanUpSuggestionExport,
    model: Suggestion,
    freezeRows: 1,
    freezeColumns: 1,
    columns: {
      rid: 10,
      createdAt: 'datetime',
      status: 10,
      subject: 40,
      sectionId: 10,
      confirmedAt: 'datetime',
      finishedAt: 'datetime',
      date: 'date',
      productFamilyId: 10,
      kaizenStartDate: 'date',
      kaizenFinishDate: 'date',
      implementationDays: 'integer',
      kaizenDuration: 'integer'
    }
  }));

  express.get(
    '/suggestions/:modelId/attachments/:attachmentId/:fileName?',
    canView,
    sendAttachmentRoute.bind(null, app, module)
  );

  express.get(
    '/suggestions/reports/count',
    canView,
    reports.helpers.sendCachedReport.bind(null, 'suggestions/count'),
    countReportRoute
  );
  express.get(
    '/suggestions/reports/summary',
    canView,
    reports.helpers.sendCachedReport.bind(null, 'suggestions/summary'),
    summaryReportRoute
  );
  express.get(
    '/suggestions/reports/engagement',
    canView,
    reports.helpers.sendCachedReport.bind(null, 'suggestions/engagement'),
    engagementReportRoute
  );
  express.get(
    '/suggestions/reports/reward',
    canView,
    reports.helpers.sendCachedReport.bind(null, 'suggestions/reward'),
    rewardReportRoute
  );

  express.get('/r/suggestions/:filter', redirectToListRoute);
  express.get('/r/suggestion/:rid', redirectToDetailsRoute);

  if (module.config.attachmentsDest)
  {
    express.post(
      '/suggestions;upload',
      canView,
      multer({
        dest: module.config.attachmentsDest,
        limits: {
          files: 10,
          fileSize: 10 * 1024 * 1024
        }
      }).any(),
      uploadAttachmentsRoute
    );
  }

  async function prepareCoordSections(req, res, next)
  {
    const {body} = req;

    if (!Array.isArray(body.coordSections))
    {
      return next();
    }

    try
    {
      const [categories, productFamily] = await Promise.all([
        KaizenCategory
          .find({_id: {$in: body.categories}})
          .select({coordSections: 1})
          .lean()
          .exec(),
        !body.productFamily ? {mrps: [], coordSections: []} : KaizenProductFamily
          .findOne({_id: body.productFamily})
          .select({
            _id: 0,
            mrps: 1,
            coordSections: 1
          })
          .lean()
          .exec()
      ]);

      const coordSectionsMap = new Map();

      body.coordSections.forEach(coordSection =>
      {
        if (!coordSectionsMap.has(coordSection._id))
        {
          coordSectionsMap.set(coordSection._id, []);
        }

        coordSectionsMap.get(coordSection._id).push({
          section: coordSection._id,
          filterSections: [],
          excludeSections: false,
          coordinators: true,
          funcs: [],
          mor: 'none',
          users: [],
          subdivisions: false
        });
      });

      categories.forEach(category =>
      {
        category.coordSections.forEach(coordSection =>
        {
          if (coordSection.section === '_section')
          {
            coordSection.section = body.section;
          }

          if (!coordSectionsMap.has(coordSection.section))
          {
            coordSectionsMap.set(coordSection.section, []);
          }

          coordSection.subdivisions = false;

          coordSectionsMap.get(coordSection.section).push(coordSection);
        });
      });

      if (productFamily && productFamily.coordSections.length)
      {
        productFamily.coordSections.forEach(coordSection =>
        {
          if (coordSection.section === '_section')
          {
            coordSection.section = body.section;
          }

          if (!coordSectionsMap.has(coordSection.section))
          {
            coordSectionsMap.set(coordSection.section, []);
          }

          coordSection.subdivisions = true;

          coordSectionsMap.get(coordSection.section).push(coordSection);
        });
      }

      body.coordSections = [];

      if (coordSectionsMap.size)
      {
        const sections = await KaizenSection
          .find({
            _id: {$in: Array.from(coordSectionsMap.keys())}
          })
          .select({
            name: 1,
            subdivisions: 1,
            coordinators: 1
          })
          .lean()
          .exec();

        sections.forEach(section =>
        {
          const coordSection = {
            _id: section._id,
            name: section.name,
            status: 'pending',
            user: null,
            time: null,
            comment: '',
            users: new Map()
          };

          (coordSectionsMap.get(coordSection._id) || []).forEach(categoryCoordSection =>
          {
            if (categoryCoordSection.filterSections.length)
            {
              const filteredSection = categoryCoordSection.filterSections.includes(body.section);

              if (categoryCoordSection.excludeSections && filteredSection)
              {
                return;
              }

              if (!categoryCoordSection.excludeSections && !filteredSection)
              {
                return;
              }
            }

            if (categoryCoordSection.coordinators)
            {
              section.coordinators.forEach(user =>
              {
                coordSection.users.set(user.id, user);
              });
            }

            if (body.confirmer && categoryCoordSection.funcs.includes('_confirmer'))
            {
              coordSection.users.set(body.confirmer.id, body.confirmer);
            }

            if (body.superior && categoryCoordSection.funcs.includes('_superior'))
            {
              coordSection.users.set(body.superior.id, body.superior);
            }

            categoryCoordSection.users.forEach(user =>
            {
              coordSection.users.set(user.id, user);
            });

            if (categoryCoordSection.funcs.length
              && categoryCoordSection.mor !== 'none'
              && (categoryCoordSection.mor !== 'mrp' || productFamily.mrps.length))
            {
              resolveCoordSectionMorUsers(
                coordSection.users,
                categoryCoordSection.mor,
                categoryCoordSection.funcs,
                categoryCoordSection.subdivisions ? section.subdivisions.map(s => s.toString()) : [],
                new Set(productFamily.mrps)
              );
            }
          });

          coordSection.users = Array.from(coordSection.users.values()).sort((a, b) =>
          {
            return a.label.localeCompare(b.label, undefined, {ignorePunctuation: true});
          });

          if (coordSection.users.length)
          {
            body.coordSections.push(coordSection);
          }
        });

        body.coordSections.sort((a, b) => a.name.localeCompare(b.name, undefined, {
          ignorePunctuation: true,
          numeric: true
        }));
      }

      next();
    }
    catch (err)
    {
      next(err);
    }
  }

  function resolveCoordSectionMorUsers(userMap, morType, funcs, subdivisions, mrps)
  {
    mrps.add('$all');

    mor.state.globalProdFunctions.forEach(globalProdFunction =>
    {
      if (funcs.includes(globalProdFunction._id))
      {
        globalProdFunction.users.forEach(addMorUser);
      }
    });

    mor.state.sections.forEach(section =>
    {
      const onlyAll = section.mrps.length === 1 && section.mrps[0]._id === '$all';

      if (subdivisions.length && !_.intersection(subdivisions, section.subdivisions).length)
      {
        return;
      }

      section.mrps.forEach(sectionMrp =>
      {
        sectionMrp.prodFunctions.forEach(prodFunction =>
        {
          if (!funcs.includes(prodFunction._id) || morType === 'none')
          {
            return;
          }

          if (morType === 'mrp' && (onlyAll || !mrps.has(sectionMrp._id)))
          {
            return;
          }

          prodFunction.users.forEach(addMorUser);
        });
      });
    });

    function addMorUser(userId)
    {
      if (userMap.has(userId))
      {
        return;
      }

      const morUser = mor.getUser(userId);

      if (!morUser)
      {
        return;
      }

      userMap.set(userId, {
        id: userId,
        label: `${morUser.lastName} ${morUser.firstName}`.trim()
      });
    }
  }

  function prepareForAdd(req, res, next)
  {
    const body = req.body;

    body.creator = user.createUserInfo(req.session.user, req);
    body.observers = Suggestion.prepareSubscribers(body.subscribers);
    body.status = Array.isArray(body.coordSections) && body.coordSections.length ? 'new' : 'accepted';

    if (body.attachments && Array.isArray(body.attachments.added))
    {
      body.attachments = module.attachments.claimPendingUploads(body.attachments.added);
    }
    else
    {
      body.attachments = [];
    }

    next();
  }

  function redirectToListRoute(req, res)
  {
    let url = '/#suggestions?exclude(changes)&sort(-date)&limit(-1337)';

    if (req.params.filter === 'mine')
    {
      url += '&observers.user.id=mine';
    }
    else if (req.params.filter === 'unseen')
    {
      url += '&observers.user.id=unseen';
    }
    else if (req.params.filter === 'open')
    {
      url += '&status=in=(new,accepted,inProgress,verification)';
    }
    else if (req.params.filter === 'confirmer')
    {
      url += '&status=in=(new,accepted,inProgress,verification)';

      if (req.query.user && /^[0-9a-f]{24}$/.test(req.query.user))
      {
        url += '&confirmer.id=' + req.query.user;
      }
    }

    res.redirect(url);
  }

  function redirectToDetailsRoute(req, res, next)
  {
    Suggestion.findOne({rid: parseInt(req.params.rid, 10)}, {_id: 1}).lean().exec(function(err, suggestion)
    {
      if (err)
      {
        return next(err);
      }

      if (suggestion)
      {
        return res.redirect('/#suggestions/' + suggestion._id);
      }

      return res.sendStatus(404);
    });
  }

  function uploadAttachmentsRoute(req, res)
  {
    const uploader = user.createUserInfo(req.session.user, req);

    res.json(module.attachments.addPendingUploads(req.files, uploader));
  }

  function fetchDictionaries(req, res, next)
  {
    req.kaizenDictionaries = {};

    step(
      function findStep()
      {
        const step = this;

        _.forEach(kaizen.DICTIONARIES, function(modelName)
        {
          mongoose.model(modelName).find({}, {name: 1}).lean().exec(step.group());
        });
      },
      function sendResultStep(err, dictionaries)
      {
        if (err)
        {
          return next(err);
        }

        _.forEach(Object.keys(kaizen.DICTIONARIES), function(dictionaryName, i)
        {
          req.kaizenDictionaries[dictionaryName] = {};

          _.forEach(dictionaries[i], function(dictionaryModel)
          {
            req.kaizenDictionaries[dictionaryName][dictionaryModel._id] = dictionaryModel.name;
          });
        });

        setImmediate(next);
      }
    );
  }

  function cleanUpSuggestionExport(req)
  {
    req.kaizenDictionaries = null;
  }

  function exportSuggestion(doc, req)
  {
    const dict = req.kaizenDictionaries;

    return {
      rid: doc.rid,
      createdAt: doc.createdAt,
      creator: doc.creator.label,
      status: doc.status,
      subject: doc.subject,
      sectionId: doc.section,
      sectionName: dict.sections[doc.section] || doc.section,
      confirmedAt: doc.confirmedAt,
      finishedAt: doc.finishedAt,
      confirmer: doc.confirmer ? doc.confirmer.label : '',
      date: doc.date,
      categoryIds: doc.categories.join('; '),
      categoryNames: doc.categories.map(c => dict.categories[c] || c).join('; '),
      productFamilyId: doc.productFamily,
      productFamilyName: dict.productFamilies[doc.productFamily] || doc.productFamily,
      howItIs: doc.howItIs,
      howItShouldBe: doc.howItShouldBe,
      suggestion: doc.suggestion,
      kaizenStartDate: doc.kaizenStartDate,
      kaizenFinishDate: doc.kaizenFinishDate,
      kaizenImprovements: doc.kaizenImprovements,
      kaizenEffect: doc.kaizenEffect,
      suggestionOwners: exportSuggestionOwners(doc.suggestionOwners),
      kaizenOwners: exportSuggestionOwners(doc.kaizenOwners),
      implementationDays: doc.finishDuration,
      kaizenDuration: doc.kaizenDuration
    };
  }

  function exportSuggestionOwners(owners)
  {
    return _.map(owners, owner => owner.label).join('; ');
  }

  function countReportRoute(req, res, next)
  {
    const query = req.query;
    const options = {
      fromTime: reports.helpers.getTime(query.from) || null,
      toTime: reports.helpers.getTime(query.to) || null,
      interval: reports.helpers.getInterval(query.interval, 'month'),
      sections: _.isEmpty(query.sections) ? [] : query.sections.split(','),
      categories: _.isEmpty(query.categories) ? [] : query.categories.split(',')
    };

    reports.helpers.generateReport(
      app,
      reports,
      countReport,
      'suggestions/count',
      req.reportHash,
      options,
      (err, reportJson) =>
      {
        if (err)
        {
          return next(err);
        }

        res.type('json');
        res.send(reportJson);
      }
    );
  }

  function summaryReportRoute(req, res, next)
  {
    const query = req.query;
    const options = {
      fromTime: reports.helpers.getTime(query.from) || null,
      toTime: reports.helpers.getTime(query.to) || null,
      section: _.isEmpty(query.section) ? [] : query.section.split(','),
      productFamily: _.isEmpty(query.productFamily) ? [] : query.productFamily.split(','),
      confirmer: _.isEmpty(query.confirmer) ? [] : query.confirmer.split(',')
    };

    reports.helpers.generateReport(
      app,
      reports,
      summaryReport,
      'suggestions/summary',
      req.reportHash,
      options,
      (err, reportJson) =>
      {
        if (err)
        {
          return next(err);
        }

        res.type('json');
        res.send(reportJson);
      }
    );
  }

  function engagementReportRoute(req, res, next)
  {
    const query = req.query;
    const options = {
      fromTime: reports.helpers.getTime(query.from) || null,
      toTime: reports.helpers.getTime(query.to) || null,
      interval: reports.helpers.getInterval(query.interval, 'year'),
      status: _.isEmpty(query.status) ? [] : query.status.split(','),
      sections: _.isEmpty(query.sections) ? [] : query.sections.split(',')
    };

    reports.helpers.generateReport(
      app,
      reports,
      engagementReport,
      'suggestions/engagement',
      req.reportHash,
      options,
      (err, reportJson) =>
      {
        if (err)
        {
          return next(err);
        }

        res.type('json');
        res.send(reportJson);
      }
    );
  }

  function rewardReportRoute(req, res, next)
  {
    const query = req.query;
    const options = {
      month: query.month,
      confirmer: query.confirmer,
      superior: query.superior,
      sections: _.isEmpty(query.sections) ? [] : query.sections.split(',')
    };

    reports.helpers.generateReport(
      app,
      reports,
      rewardReport,
      'suggestions/reward',
      req.reportHash,
      options,
      (err, reportJson) =>
      {
        if (err)
        {
          return next(err);
        }

        res.type('json');
        res.send(reportJson);
      }
    );
  }

  function statsRoute(req, res, next)
  {
    module.getStats(req.session.user._id, (err, stats) =>
    {
      if (err)
      {
        return next(err);
      }

      return res.json(stats);
    });
  }

  async function prepareReadResult(model, formatResult, req)
  {
    if (!model.resolutions
      || !model.resolutions.length
      || req.rql.fields.resolutions === false
      || (req.rql.fields.resolutions !== true && Object.keys(req.rql.fields).length))
    {
      return formatResult(null, model);
    }

    try
    {
      model.resolutions = await Suggestion.findRelations(model.resolutions);

      formatResult(null, model);
    }
    catch (err)
    {
      formatResult(err);
    }
  }
};
