// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const fs = require('fs');
const path = require('path');
const _ = require('lodash');
const step = require('h5.step');
const multer = require('multer');
const contentDisposition = require('content-disposition');
const countReport = require('../countReport');
const summaryReport = require('../summaryReport');
const engagementReport = require('../engagementReport');
const coordinateRoute = require('./coordinate');

module.exports = (app, module) =>
{
  const {
    mongoose,
    express,
    user,
    reports,
    kaizen,
    mor,
    Suggestion,
    KaizenCategory,
    KaizenProductFamily,
    KaizenSection
  } = module;

  const tmpAttachments = {};

  const canView = user.auth('LOCAL', 'USER');
  const canManage = user.auth('USER');

  express.get('/suggestions/stats', canView, statsRoute);

  express.get('/suggestions', canView, prepareObserverFilter, express.crud.browseRoute.bind(null, app, Suggestion));
  express.get('/suggestions;rid', canView, findByRidRoute);
  express.post(
    '/suggestions',
    canView,
    prepareCoordSections,
    prepareForAdd,
    express.crud.addRoute.bind(null, app, Suggestion)
  );
  express.post('/suggestions/:id;coordinate', coordinateRoute.bind(null, app, module));
  express.get('/suggestions/:id', canView, express.crud.readRoute.bind(null, app, {
    model: Suggestion,
    idProperty: req => /^[0-9]+$/.test(req.params.id) ? 'rid' : '_id'
  }));
  express.put('/suggestions/:id', canView, prepareCoordSections, editSuggestionRoute);
  express.delete('/suggestions/:id', canManage, express.crud.deleteRoute.bind(null, app, Suggestion));

  express.get('/suggestions;export.:format?', canView, fetchDictionaries, express.crud.exportRoute.bind(null, app, {
    filename: 'SUGGESTIONS',
    serializeRow: exportSuggestion,
    cleanUp: cleanUpSuggestionExport,
    model: Suggestion,
    freezeRows: 1,
    freezeColumns: 1,
    columns: {
      rid: 10,
      createdAt: 'datetime',
      status: 10,
      subject: 40,
      sectionId: 10,
      confirmedAt: 'datetime',
      finishedAt: 'datetime',
      date: 'date',
      productFamilyId: 10,
      kaizenStartDate: 'date',
      kaizenFinishDate: 'date',
      implementationDays: 'integer',
      kaizenDuration: 'integer'
    }
  }));

  express.get('/suggestions/:order/attachments/:attachment', canView, sendAttachmentRoute);

  express.get(
    '/suggestions/reports/count',
    canView,
    reports.helpers.sendCachedReport.bind(null, 'suggestions/count'),
    countReportRoute
  );
  express.get(
    '/suggestions/reports/summary',
    canView,
    reports.helpers.sendCachedReport.bind(null, 'suggestions/summary'),
    summaryReportRoute
  );
  express.get(
    '/suggestions/reports/engagement',
    canView,
    reports.helpers.sendCachedReport.bind(null, 'suggestions/engagement'),
    engagementReportRoute
  );

  express.get('/r/suggestions/:filter', redirectToListRoute);
  express.get('/r/suggestion/:rid', redirectToDetailsRoute);

  if (module.config.attachmentsDest)
  {
    express.post(
      '/suggestions;upload',
      canView,
      multer({
        dest: module.config.attachmentsDest,
        limits: {
          files: 3,
          fileSize: 10 * 1024 * 1024
        }
      }).any(),
      uploadAttachmentsRoute
    );
  }

  function prepareObserverFilter(req, res, next)
  {
    const observer = req.query['observers.user.id'];

    if (observer !== 'mine' && observer !== 'unseen')
    {
      return next();
    }

    req.rql.selector.args = req.rql.selector.args.filter(function(term)
    {
      return term.args[0] !== 'observers.user.id';
    });

    if (observer === 'mine')
    {
      req.rql.selector.args.push({
        name: 'eq',
        args: ['observers.user.id', req.session.user._id]
      });
    }
    else
    {
      req.rql.selector.args.push({
        name: 'elemMatch',
        args: [
          'observers',
          {name: 'eq', args: ['user.id', req.session.user._id]},
          {name: 'eq', args: ['notify', true]}
        ]
      });
    }

    return next();
  }

  async function prepareCoordSections(req, res, next)
  {
    try
    {
      const body = req.body;

      if (!Array.isArray(body.coordSections))
      {
        return next();
      }

      const [categories, productFamily] = await Promise.all([
        KaizenCategory
          .find({_id: {$in: body.categories}})
          .select({coordSections: 1})
          .lean()
          .exec(),
        !body.productFamily ? {mrps: [], coordSections: []} : KaizenProductFamily
          .findOne({_id: body.productFamily})
          .select({
            _id: 0,
            mrps: 1,
            coordSections: 1
          })
          .lean()
          .exec()
      ]);

      const coordSectionsMap = new Map();

      body.coordSections.forEach(coordSection =>
      {
        if (!coordSectionsMap.has(coordSection._id))
        {
          coordSectionsMap.set(coordSection._id, []);
        }

        coordSectionsMap.get(coordSection._id).push({
          section: coordSection._id,
          funcs: [],
          mor: 'none',
          subdivisions: false
        });
      });

      categories.forEach(category =>
      {
        category.coordSections.forEach(coordSection =>
        {
          if (!coordSectionsMap.has(coordSection.section))
          {
            coordSectionsMap.set(coordSection.section, []);
          }

          coordSection.subdivisions = false;

          coordSectionsMap.get(coordSection.section).push(coordSection);
        });
      });

      if (productFamily && productFamily.coordSections.length)
      {
        productFamily.coordSections.forEach(coordSection =>
        {
          if (!coordSectionsMap.has(coordSection.section))
          {
            coordSectionsMap.set(coordSection.section, []);
          }

          coordSection.subdivisions = true;

          coordSectionsMap.get(coordSection.section).push(coordSection);
        });
      }

      body.coordSections = [];

      if (coordSectionsMap.size)
      {
        const sections = await KaizenSection
          .find({
            _id: {$in: Array.from(coordSectionsMap.keys())}
          })
          .select({
            name: 1,
            subdivisions: 1,
            coordinators: 1
          })
          .lean()
          .exec();

        sections.forEach(section =>
        {
          const coordSection = {
            _id: section._id,
            name: section.name,
            status: 'pending',
            user: null,
            time: null,
            comment: '',
            users: new Map()
          };

          section.coordinators.forEach(user =>
          {
            coordSection.users.set(user.id, user);
          });

          (coordSectionsMap.get(coordSection._id) || []).forEach(categoryCoordSection =>
          {
            if (categoryCoordSection.funcs.length
              && categoryCoordSection.mor !== 'none'
              && (categoryCoordSection.mor !== 'mrp' || productFamily.mrps.length))
            {
              resolveCoordSectionMorUsers(
                coordSection.users,
                categoryCoordSection.mor,
                categoryCoordSection.funcs,
                categoryCoordSection.subdivisions ? section.subdivisions.map(s => s.toString()) : [],
                new Set(productFamily.mrps)
              );
            }
          });

          coordSection.users = Array.from(coordSection.users.values()).sort((a, b) =>
          {
            return a.label.localeCompare(b.label, undefined, {ignorePunctuation: true});
          });

          body.coordSections.push(coordSection);
        });

        body.coordSections.sort((a, b) => a.name.localeCompare(b.name, undefined, {
          ignorePunctuation: true,
          numeric: true
        }));
      }

      next();
    }
    catch (err)
    {
      next(err);
    }
  }

  function prepareForAdd(req, res, next)
  {
    const body = req.body;

    body.creator = user.createUserInfo(req.session.user, req);
    body.creator.id = body.creator.id.toString();
    body.attachments = prepareAttachments(body.attachments);
    body.observers = prepareSubscribers(body.subscribers);
    body.status = Array.isArray(body.coordSections) && body.coordSections.length ? 'new' : 'accepted';

    next();
  }

  function resolveCoordSectionMorUsers(userMap, morType, funcs, subdivisions, mrps)
  {
    mrps.add('$all');

    mor.state.globalProdFunctions.forEach(globalProdFunction =>
    {
      if (funcs.includes(globalProdFunction._id))
      {
        globalProdFunction.users.forEach(addMorUser);
      }
    });

    mor.state.sections.forEach(section =>
    {
      const onlyAll = section.mrps.length === 1 && section.mrps[0]._id === '$all';

      if (subdivisions.length && !_.intersection(subdivisions, section.subdivisions).length)
      {
        return;
      }

      section.mrps.forEach(sectionMrp =>
      {
        sectionMrp.prodFunctions.forEach(prodFunction =>
        {
          if (!funcs.includes(prodFunction._id) || morType === 'none')
          {
            return;
          }

          if (morType === 'mrp' && (onlyAll || !mrps.has(sectionMrp._id)))
          {
            return;
          }

          prodFunction.users.forEach(addMorUser);
        });
      });
    });

    function addMorUser(userId)
    {
      if (userMap.has(userId))
      {
        return;
      }

      const morUser = mor.getUser(userId);

      if (!morUser)
      {
        return;
      }

      userMap.set(userId, {
        id: userId,
        label: `${morUser.lastName} ${morUser.firstName}`.trim()
      });
    }
  }

  function findByRidRoute(req, res, next)
  {
    const rid = parseInt(req.query.rid, 10);

    if (isNaN(rid) || rid <= 0)
    {
      return res.sendStatus(400);
    }

    Suggestion.findOne({rid: rid}, {_id: 1}).lean().exec(function(err, kaizenOrder)
    {
      if (err)
      {
        return next(err);
      }

      if (kaizenOrder)
      {
        return res.json(kaizenOrder._id);
      }

      return res.sendStatus(404);
    });
  }

  function redirectToListRoute(req, res)
  {
    let url = '/#suggestions';

    if (req.params.filter === 'mine')
    {
      url += '?observers.user.id=mine&sort(-date)&limit(15)';
    }
    else if (req.params.filter === 'unseen')
    {
      url += '?observers.user.id=unseen&sort(-date)&limit(15)';
    }
    else if (req.params.filter === 'open')
    {
      url += '?status=in=(new,accepted,inProgress,verification)&sort(-date)&limit(15)';
    }

    res.redirect(url);
  }

  function redirectToDetailsRoute(req, res, next)
  {
    Suggestion.findOne({rid: parseInt(req.params.rid, 10)}, {_id: 1}).lean().exec(function(err, suggestion)
    {
      if (err)
      {
        return next(err);
      }

      if (suggestion)
      {
        return res.redirect('/#suggestions/' + suggestion._id);
      }

      return res.sendStatus(404);
    });
  }

  function editSuggestionRoute(req, res, next)
  {
    const sessionUser = req.session.user;
    let body = req.body;

    if (!sessionUser.loggedIn)
    {
      body = _.pick(body, 'comment');
    }

    const newAttachmentList = prepareAttachments(body.attachments);
    const newAttachmentMap = {};

    _.forEach(newAttachmentList, function(attachment)
    {
      newAttachmentMap[attachment.description] = attachment;
    });

    const updater = user.createUserInfo(sessionUser, req);

    step(
      function findStep()
      {
        Suggestion.findById(req.params.id).exec(this.next());
      },
      function applyChangesStep(err, suggestion)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!suggestion)
        {
          return this.skip(app.createError('NOT_FOUND', 404));
        }

        body.attachments = mergeAttachments(suggestion, newAttachmentMap);
        body.subscribers = prepareSubscribers(body.subscribers);

        if ((body.status && body.status !== suggestion.status) || Array.isArray(body.coordSections))
        {
          _.defaults(body, {
            status: suggestion.status,
            coordSections: suggestion.coordSections.toObject()
          });

          const oldCoordSections = new Map();

          suggestion.coordSections.forEach(coordSection =>
          {
            oldCoordSections.set(coordSection._id, coordSection.toObject());
          });

          body.coordSections.forEach(newCoordSection =>
          {
            const oldCoordSection = oldCoordSections.get(newCoordSection._id);

            if (!oldCoordSection)
            {
              return;
            }

            newCoordSection.status = oldCoordSection.status;
            newCoordSection.user = oldCoordSection.user;
            newCoordSection.time = oldCoordSection.time;
            newCoordSection.comment = oldCoordSection.comment;
          });

          if (body.status === 'new' && suggestion.status !== 'new')
          {
            body.coordSections.forEach(coordSection =>
            {
              coordSection.status = 'pending';
              coordSection.user = null;
              coordSection.time = null;
              coordSection.comment = '';
            });
          }

          if (body.status === 'new' && body.coordSections.every(({status}) => status !== 'pending'))
          {
            body.status = 'accepted';
          }
          else if (body.status === 'accepted' && body.coordSections.some(({status}) => status === 'pending'))
          {
            body.status = 'new';
          }
        }

        this.usersToNotify = suggestion.applyChanges(body, updater);

        if (this.usersToNotify)
        {
          suggestion.save(this.next());
        }
      },
      function sendResponseStep(err, suggestion)
      {
        if (err)
        {
          return next(err);
        }

        if (suggestion)
        {
          res.json(suggestion);

          app.broker.publish('suggestions.edited', {
            model: suggestion,
            user: updater,
            notify: this.usersToNotify
          });
        }
        else
        {
          res.json({_id: req.params.id});
        }
      }
    );
  }

  function uploadAttachmentsRoute(req, res)
  {
    const attachments = [];

    _.forEach(req.files, function(file)
    {
      const id = file.filename.replace(/\..*?$/, '');

      tmpAttachments[id] = {
        data: {
          _id: id,
          type: file.mimetype,
          path: file.filename,
          name: file.originalname,
          size: file.size,
          description: file.fieldname
        },
        timer: setTimeout(removeAttachmentFile, 30000, id, file.path)
      };

      attachments.push(id);
    });

    res.json(attachments);
  }

  function sendAttachmentRoute(req, res, next)
  {
    Suggestion.findById(req.params.order, {attachments: 1, changes: 1}).lean().exec(function(err, suggestion)
    {
      if (err)
      {
        return next(err);
      }

      if (!suggestion)
      {
        return res.sendStatus(404);
      }

      let attachment;
      const changeIndex = parseInt(req.query.change, 10);

      if (!isNaN(changeIndex))
      {
        const change = suggestion.changes[Math.abs(changeIndex)];

        if (change && change.data.attachments)
        {
          attachment = _.find(change.data.attachments[changeIndex < 0 ? 0 : 1], function(attachment)
          {
            return attachment._id === req.params.attachment;
          });
        }
      }
      else
      {
        attachment = _.find(suggestion.attachments, function(attachment)
        {
          return attachment._id === req.params.attachment;
        });
      }

      if (!attachment)
      {
        return res.sendStatus(404);
      }

      const disposition = req.query.download ? 'attachment' : 'inline';

      res.type(attachment.type);
      res.append('Content-Disposition', contentDisposition(attachment.name, {type: disposition}));
      res.sendFile(path.join(module.config.attachmentsDest, attachment.path));
    });
  }

  function mergeAttachments(suggestion, newAttachmentMap)
  {
    const attachments = [];

    _.forEach(suggestion.attachments, function(oldAttachment)
    {
      const newAttachment = newAttachmentMap[oldAttachment.description];

      if (newAttachment)
      {
        delete newAttachmentMap[oldAttachment.description];

        attachments.push(newAttachment);
      }
      else
      {
        attachments.push(oldAttachment.toObject());
      }
    });

    _.forEach(newAttachmentMap, function(newAttachment)
    {
      attachments.push(newAttachment);
    });

    const sortOrder = {
      scan: 1,
      before: 2,
      after: 3
    };

    attachments.sort(function(a, b)
    {
      return sortOrder[a.description] - sortOrder[b.description];
    });

    return attachments;
  }

  function prepareAttachments(attachments)
  {
    return _.map(attachments, function(id)
    {
      if (!_.isString(id))
      {
        return null;
      }

      const attachment = tmpAttachments[id];

      if (!attachment)
      {
        return null;
      }

      delete tmpAttachments[id];

      clearTimeout(attachment.timer);

      return attachment.data;
    })
      .filter(function(attachment)
      {
        return attachment !== null;
      });
  }

  function removeAttachmentFile(id, filePath)
  {
    delete tmpAttachments[id];

    fs.unlink(filePath, function(err)
    {
      if (err)
      {
        module.error(`Failed to remove an unused attachment [${filePath}]: ${err.message}`);
      }
      else
      {
        module.info(`Removed an unused attachment: ${filePath}`);
      }
    });
  }

  function prepareSubscribers(subscribers)
  {
    return (Array.isArray(subscribers) ? subscribers : [])
      .filter(function(subscriber)
      {
        return _.isString(subscriber.id)
          && !_.isEmpty(subscriber.id)
          && _.isString(subscriber.label)
          && !_.isEmpty(subscriber.label);
      })
      .map(function(subscriber)
      {
        return {
          user: subscriber,
          role: 'subscriber',
          lastSeenAt: null,
          notify: true,
          changes: {}
        };
      });
  }

  function fetchDictionaries(req, res, next)
  {
    req.kaizenDictionaries = {};

    step(
      function findStep()
      {
        const step = this;

        _.forEach(kaizen.DICTIONARIES, function(modelName)
        {
          mongoose.model(modelName).find({}, {name: 1}).lean().exec(step.group());
        });
      },
      function sendResultStep(err, dictionaries)
      {
        if (err)
        {
          return next(err);
        }

        _.forEach(Object.keys(kaizen.DICTIONARIES), function(dictionaryName, i)
        {
          req.kaizenDictionaries[dictionaryName] = {};

          _.forEach(dictionaries[i], function(dictionaryModel)
          {
            req.kaizenDictionaries[dictionaryName][dictionaryModel._id] = dictionaryModel.name;
          });
        });

        setImmediate(next);
      }
    );
  }

  function cleanUpSuggestionExport(req)
  {
    req.kaizenDictionaries = null;
  }

  function exportSuggestion(doc, req)
  {
    const dict = req.kaizenDictionaries;

    return {
      rid: doc.rid,
      createdAt: doc.createdAt,
      creator: doc.creator.label,
      status: doc.status,
      subject: doc.subject,
      sectionId: doc.section,
      sectionName: dict.sections[doc.section] || doc.section,
      confirmedAt: doc.confirmedAt,
      finishedAt: doc.finishedAt,
      confirmer: doc.confirmer ? doc.confirmer.label : '',
      date: doc.date,
      categoryIds: doc.categories.join('; '),
      categoryNames: doc.categories.map(function(c) { return dict.categories[c] || c; }).join('; '),
      productFamilyId: doc.productFamily,
      productFamilyName: dict.productFamilies[doc.productFamily] || doc.productFamily,
      howItIs: doc.howItIs,
      howItShouldBe: doc.howItShouldBe,
      suggestion: doc.suggestion,
      kaizenStartDate: doc.kaizenStartDate,
      kaizenFinishDate: doc.kaizenFinishDate,
      kaizenImprovements: doc.kaizenImprovements,
      kaizenEffect: doc.kaizenEffect,
      suggestionOwners: exportSuggestionOwners(doc.suggestionOwners),
      kaizenOwners: exportSuggestionOwners(doc.kaizenOwners),
      implementationDays: doc.finishDuration,
      kaizenDuration: doc.kaizenDuration
    };
  }

  function exportSuggestionOwners(owners)
  {
    return _.map(owners, function(owner) { return owner.label; }).join('; ');
  }

  function countReportRoute(req, res, next)
  {
    const query = req.query;
    const options = {
      fromTime: reports.helpers.getTime(query.from) || null,
      toTime: reports.helpers.getTime(query.to) || null,
      interval: reports.helpers.getInterval(query.interval, 'month'),
      sections: _.isEmpty(query.sections) ? [] : query.sections.split(','),
      categories: _.isEmpty(query.categories) ? [] : query.categories.split(',')
    };

    reports.helpers.generateReport(
      app,
      reports,
      countReport,
      'suggestions/count',
      req.reportHash,
      options,
      function(err, reportJson)
      {
        if (err)
        {
          return next(err);
        }

        res.type('json');
        res.send(reportJson);
      }
    );
  }

  function summaryReportRoute(req, res, next)
  {
    const query = req.query;
    const options = {
      fromTime: reports.helpers.getTime(query.from) || null,
      toTime: reports.helpers.getTime(query.to) || null,
      section: _.isEmpty(query.section) ? [] : query.section.split(','),
      productFamily: _.isEmpty(query.productFamily) ? [] : query.productFamily.split(','),
      confirmer: _.isEmpty(query.confirmer) ? [] : query.confirmer.split(',')
    };

    reports.helpers.generateReport(
      app,
      reports,
      summaryReport,
      'suggestions/summary',
      req.reportHash,
      options,
      function(err, reportJson)
      {
        if (err)
        {
          return next(err);
        }

        res.type('json');
        res.send(reportJson);
      }
    );
  }

  function engagementReportRoute(req, res, next)
  {
    const query = req.query;
    const options = {
      fromTime: reports.helpers.getTime(query.from) || null,
      toTime: reports.helpers.getTime(query.to) || null,
      interval: reports.helpers.getInterval(query.interval, 'year'),
      status: _.isEmpty(query.status) ? [] : query.status.split(','),
      sections: _.isEmpty(query.sections) ? [] : query.sections.split(',')
    };

    reports.helpers.generateReport(
      app,
      reports,
      engagementReport,
      'suggestions/engagement',
      req.reportHash,
      options,
      function(err, reportJson)
      {
        if (err)
        {
          return next(err);
        }

        res.type('json');
        res.send(reportJson);
      }
    );
  }

  function statsRoute(req, res, next)
  {
    module.getStats(req.session.user._id, function(err, stats)
    {
      if (err)
      {
        return next(err);
      }

      return res.json(stats);
    });
  }
};
