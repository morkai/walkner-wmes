// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const fs = require('fs');
const _ = require('lodash');
const step = require('h5.step');
const ejs = require('ejs');
const moment = require('moment');
const {ObjectId} = require('mongoose').Types;

module.exports = (app, module) =>
{
  const {
    mailSender,
    User,
    KaizenSection,
    KaizenCategory,
    KaizenProductFamily,
    Suggestion
  } = module;

  const emailTemplateFile = `${__dirname}/templates/notifier.email.pl.ejs`;
  const renderEmail = ejs.compile(fs.readFileSync(emailTemplateFile, 'utf8'), {
    cache: true,
    filename: emailTemplateFile,
    compileDebug: false,
    rmWhitespace: true
  });
  const nameMaps = {
    status: {
      new: 'Nowe',
      accepted: 'Zaakceptowane',
      inProgress: 'W realizacji',
      verification: 'Weryfikacja',
      finished: 'Zakończone',
      cancelled: 'Anulowane'
    },
    section: {},
    categories: {},
    productFamily: {}
  };

  app.broker.subscribe(`${Suggestion.TOPIC_PREFIX}.added`, message =>
  {
    notifyAboutAdd(message.model);
  });

  app.broker.subscribe(`${Suggestion.TOPIC_PREFIX}.edited`, message =>
  {
    notifyAboutEdit(message.model);
  });

  function notifyAboutAdd(suggestion)
  {
    const newRecipients = new Map();
    const coordRecipients = new Map();

    suggestion.observers.forEach(observer =>
    {
      newRecipients.set(observer.user.id, '');
    });

    if (suggestion.status === 'new')
    {
      newRecipients.delete(suggestion.confirmer.id);
    }

    step(
      function findCoordinatorsStep()
      {
        if (!suggestion.coordSections.length)
        {
          return;
        }

        const coordSections = suggestion.coordSections.map(coordSection => coordSection._id);

        KaizenSection
          .find({_id: {$in: coordSections}})
          .select({coordinators: 1})
          .lean()
          .exec(this.next());
      },
      function handleCoordinatorsStep(err, sections)
      {
        if (err)
        {
          return this.skip(err);
        }

        (sections || []).forEach(section =>
        {
          section.coordinators.forEach(user =>
          {
            newRecipients.delete(user.id);
            coordRecipients.set(user.id, '');
          });
        });

        newRecipients.delete(suggestion.creator.id);
        coordRecipients.delete(suggestion.creator.id);
      },
      function findRecipientsAndNamesStep()
      {
        const recipientIds = [];

        try
        {
          newRecipients.forEach((email, id) => recipientIds.push(new ObjectId(id)));
          coordRecipients.forEach((email, id) => recipientIds.push(new ObjectId(id)));
        }
        catch (err)
        {
          return this.skip(err);
        }

        User
          .find({
            _id: {$in: recipientIds},
            email: {
              $type: 'string',
              $regex: /@/
            }
          })
          .select({email: 1})
          .lean()
          .exec(this.next());
      },
      function prepareTemplateDataStep(err, recipients)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!recipients.length)
        {
          return this.skip();
        }

        recipients.forEach(user =>
        {
          const id = user._id.toString();

          if (newRecipients.has(id))
          {
            newRecipients.set(id, user.email);
          }
          else if (coordRecipients.has(id))
          {
            coordRecipients.set(id, user.email);
          }
        });

        this.emails = [{
          to: Array.from(newRecipients.values()).filter(v => v.length > 0),
          subject: `[WMES] [Usprawnienia] Nowe zgłoszenie: ${suggestion.rid}`,
          html: ''
        }, {
          to: Array.from(coordRecipients.values()).filter(v => v.length > 0),
          subject: `[WMES] [Usprawnienia] Zgłoszenie do zatwierdzenia: ${suggestion.rid}`,
          html: ''
        }];

        return prepareTemplateData('add', suggestion, this.next());
      },
      function sendEmailStep(err, templateData)
      {
        if (err)
        {
          return this.skip(err);
        }

        const html = renderEmail(templateData);

        this.emails.forEach(email =>
        {
          if (email.to.length)
          {
            email.html = html;

            mailSender.send(email, this.group());
          }
        });
      },
      function finalizeStep(err)
      {
        if (err)
        {
          module.error(err, 'Failed to notify users about a new suggestion.', {rid: suggestion.rid});
        }
        else if (this.emails.length)
        {
          module.info('Notified users about a new suggestion.', {
            count: this.emails.reduce((prev, curr) => prev + curr.to.length, 0),
            rid: suggestion.rid
          });
        }

        this.mailOptions = null;
      }
    );
  }

  function notifyAboutEdit(suggestion)
  {
    const lastChange = (_.last(suggestion.changes) || {data: {}}).data;
    const emails = [];

    if (lastChange.status)
    {
      const email = {
        to: new Map(),
        subject: '[WMES] [Usprawnienia]',
        html: ''
      };

      switch (lastChange.status[1])
      {
        case 'new':
          email.subject += ` Zgłoszenie do poprawy: ${suggestion.rid}`;

          email.to.set(suggestion.creator.id, '');

          suggestion.suggestionOwners.forEach(owner =>
          {
            email.to.set(owner.id, '');
          });
          break;

        case 'accepted':
          email.subject += ` Zgłoszenie do akceptacji: ${suggestion.rid}`;

          email.to.set(suggestion.confirmer.id, '');
          break;

        case 'inProgress':
          if (lastChange.status[0] === 'verification')
          {
            email.subject += ` Zgłoszenie do poprawy: ${suggestion.rid}`;
          }
          else
          {
            email.subject += ` Zgłoszenie do realizacji: ${suggestion.rid}`;
          }

          suggestion.kaizenOwners.forEach(owner =>
          {
            email.to.set(owner.id, '');
          });
          break;

        case 'verification':
          email.subject += ` Zgłoszenie do weryfikacji: ${suggestion.rid}`;

          email.to.set(suggestion.confirmer.id, '');
          break;

        case 'finished':
          email.subject += ` Zgłoszenie zakończone: ${suggestion.rid}`;

          suggestion.suggestionOwners.forEach(owner =>
          {
            email.to.set(owner.id, '');
          });

          suggestion.kaizenOwners.forEach(owner =>
          {
            email.to.set(owner.id, '');
          });
          break;

        case 'cancelled':
          email.subject += ` Zgłoszenie anulowane: ${suggestion.rid}`;

          email.to.set(suggestion.confirmer.id, '');

          suggestion.suggestionOwners.forEach(owner =>
          {
            email.to.set(owner.id, '');
          });

          suggestion.kaizenOwners.forEach(owner =>
          {
            email.to.set(owner.id, '');
          });
          break;
      }

      emails.push(email);
    }

    step(
      function findNewSectionsStep()
      {
        if (!lastChange.coordSections || suggestion.status !== 'new')
        {
          return setImmediate(this.next(), null, []);
        }

        const oldSections = (lastChange.coordSections[0] || [])
          .map(s => s._id).sort();

        const newSections = (lastChange.coordSections[1] || [])
          .filter(s => s.status === 'pending')
          .map(s => s._id).sort();

        const diffSections = _.difference(newSections, oldSections);

        if (diffSections.length === 0)
        {
          return setImmediate(this.next(), null, []);
        }

        KaizenSection
          .find({
            _id: {$in: diffSections},
            'coordinators.0': {$exists: true}
          })
          .lean()
          .exec(this.next());
      },
      function findNewCoordinatorsStep(err, sections)
      {
        if (err)
        {
          return this.skip(err);
        }

        const email = {
          to: new Map(),
          subject: `[WMES] [Usprawnienia] Zgłoszenie do zatwierdzenia: ${suggestion.rid}`,
          html: ''
        };

        sections.forEach(section =>
        {
          section.coordinators.forEach(user =>
          {
            email.to.set(user.id, '');
          });
        });

        emails.push(email);
      },
      function findRecipientsStep()
      {
        if (!emails.length)
        {
          return this.skip();
        }

        const userIds = new Map();

        emails.forEach(email =>
        {
          email.to.forEach((v, id) =>
          {
            try
            {
              userIds.set(id, new ObjectId(id));
            }
            catch (err) {} // eslint-disable-line no-empty
          });
        });

        if (suggestion.updater)
        {
          userIds.delete(suggestion.updater.id);
        }

        if (!userIds.size)
        {
          return this.skip();
        }

        User
          .find({
            _id: {$in: Array.from(userIds.values())},
            email: /@/
          })
          .select({email: 1})
          .lean()
          .exec(this.next());
      },
      function prepareTemplateDataStep(err, recipients)
      {
        if (err)
        {
          return this.skip(err);
        }

        const addresses = new Map();

        recipients.forEach(user =>
        {
          addresses.set(user._id.toString(), user.email);
        });

        emails.forEach(email =>
        {
          email.to.forEach((v, k) =>
          {
            if (addresses.has(k))
            {
              email.to.set(k, addresses.get(k));
            }
            else
            {
              email.to.delete(k);
            }
          });
        });

        return prepareTemplateData('edit', suggestion, this.next());
      },
      function sendEmailStep(err, templateData)
      {
        if (err)
        {
          return this.skip(err);
        }

        const html = renderEmail(templateData);

        emails.forEach(email =>
        {
          email.to = Array.from(email.to.values());

          if (email.to.length)
          {
            email.html = html;

            mailSender.send(email, this.group());
          }
        });
      },
      function finalizeStep(err)
      {
        if (err)
        {
          module.error(err, 'Failed to notify users about a suggestion change.', {rid: suggestion.rid});
        }
        else if (emails.length)
        {
          module.info('Notified users about a suggestion change.', {
            count: emails.reduce((prev, curr) => prev + curr.to.length, 0) || 0,
            rid: suggestion.rid
          });
        }
      }
    );
  }

  function prepareTemplateData(mode, suggestion, done)
  {
    const lastChange = _.last(suggestion.changes);
    const templateData = {
      mode: mode,
      urlPrefix: app.options.emailUrlPrefix,
      suggestion: {
        rid: suggestion.rid,
        subject: suggestion.subject,
        section: suggestion.section,
        confirmer: suggestion.confirmer.label,
        coordSections: suggestion.coordSections.map(s => s.name).join('; '),
        suggestionOwners: suggestion.suggestionOwners.map(o => o.label).join('; '),
        categories: suggestion.categories.join('; '),
        productFamily: suggestion.productFamily,
        status: nameMaps.status[suggestion.status],
        date: moment(suggestion.date).format('LL'),
        howItIs: suggestion.howItIs,
        howItShouldBe: suggestion.howItShouldBe,
        suggestion: suggestion.suggestion,
        kaizenOwners: suggestion.kaizenOwners.map(o => o.label).join('; '),
        kaizenImprovements: suggestion.kaizenImprovements,
        kaizenEffect: suggestion.kaizenEffect,
        comment: lastChange ? lastChange.comment : ''
      }
    };

    step(
      function()
      {
        findName(KaizenSection, suggestion, 'section', 'name', this.parallel());
        findName(KaizenCategory, suggestion, 'categories', 'name', this.parallel());
        findName(KaizenProductFamily, suggestion, 'productFamily', 'name', this.parallel());
      },
      function(err, section, categories, productFamily)
      {
        if (err)
        {
          return done(err);
        }

        templateData.suggestion.section = section;
        templateData.suggestion.categories = categories.join('; ');
        templateData.suggestion.productFamily = productFamily;

        return done(null, templateData);
      }
    );
  }

  function findName(Model, suggestion, mapProperty, nameProperty, done)
  {
    const id = suggestion[mapProperty];
    const nameMap = nameMaps[mapProperty];
    const multiple = _.isArray(id);

    if (multiple)
    {
      const names = [];

      _.forEach(id, id =>
      {
        if (nameMap[id])
        {
          names.push(nameMap[id]);
        }
      });

      if (names.length === id.length)
      {
        return setImmediate(done, null, names);
      }
    }
    else if (nameMap[id])
    {
      return setImmediate(done, null, nameMap[id]);
    }

    const conditions = {
      _id: multiple ? {$in: id} : id
    };
    const fields = {};
    fields[nameProperty] = 1;

    Model.find(conditions, fields).lean().exec((err, models) =>
    {
      if (err)
      {
        return done(err);
      }

      if (_.isEmpty(models))
      {
        return done(null, id);
      }

      if (multiple)
      {
        const names = [];

        _.forEach(models, model =>
        {
          const name = model[nameProperty];

          nameMap[model._id] = name;

          names.push(name);
        });

        return done(null, names);
      }

      return done(null, models[0][nameProperty]);
    });
  }
};
