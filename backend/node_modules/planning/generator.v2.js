// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const {createHash} = require('crypto');
const _ = require('lodash');
const step = require('h5.step');
const moment = require('moment');
const {ObjectId} = require('mongoose').Types;
const jsonDeepEqual = require('util/jsonDeepEqual');
const shifts = require('util/shifts');
const setUpAutoDowntimeCache = require('./autoDowntimeCache');

const ORDER_IGNORED_PROPERTIES = {
  incomplete: true
};
const ORDER_USER_PROPERTIES = [
  'quantityPlan',
  'lines',
  'ignored',
  'urgent'
];
const ORDER_KINDS = ['small', 'medium', 'big'];
const EMPTY_HOURLY_PLAN = [
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0
];
const HOUR_TO_INDEX = [
  18, 19, 20, 21, 22, 23, 0, 1,
  2, 3, 4, 5, 6, 7, 8, 9,
  10, 11, 12, 13, 14, 15, 16, 17
];

module.exports = (app, module, acceptDate) =>
{
  const DEV = app.options.env === 'development';
  const PROD = app.options.env === 'production';
  const UNFROZEN_PLANS = PROD ? [] : [];
  const LOG_LINES = PROD ? {} : {};
  const LOCK_LINES = true;
  const LOG = !PROD;
  const AUTO_GENERATE_NEXT = !DEV;
  const AUTO_GENERATE_START = !!1;

  const logger = module.logger.create({submodule: 'generator2'});
  const log = LOG && DEV
    ? (...args) => logger.debug(...args)
    : () => {};
  const logLine = (lineState, ...args) => !LOG_LINES || LOG_LINES[lineState._id]
    ? log(...args)
    : undefined;

  const {
    mongoose,
    Order,
    Plan,
    PlanSettings,
    PlanChange,
    PlanOrderGroup
  } = module;

  const autoDowntimeCache = setUpAutoDowntimeCache(app, module);
  const generatorQueue = [];
  let generatorTimer = null;
  let generatorState = null;

  app.broker.subscribe('app.started').setLimit(1).on('message', onAppStarted);
  app.broker.subscribe('planning.generator.requested', onGenerateRequested);

  function onAppStarted()
  {
    if (!AUTO_GENERATE_START)
    {
      return;
    }

    if (DEV)
    {
      UNFROZEN_PLANS.forEach(generatePlan);

      if (UNFROZEN_PLANS.length)
      {
        return;
      }

      const m = moment();

      if (m.hours() < 6)
      {
        m.subtract(1, 'days');
      }

      generatePlan(m.startOf('day').add(1, 'days').format('YYYY-MM-DD'));
    }
    else
    {
      generateActivePlans();
    }

    scheduleNextLastPlanGeneration();
  }

  function scheduleNextLastPlanGeneration()
  {
    const now = moment();

    if (now.hours() === 5 && now.minutes() === 59)
    {
      generatePlan(now.format('YYYY-MM-DD'));

      setTimeout(scheduleNextLastPlanGeneration, 23 * 3600 * 1000);

      return;
    }

    const next = moment().startOf('day');

    if (now.hours() >= 6)
    {
      next.add(1, 'day');
    }

    next.hours(5).minutes(59);

    const delay = next.valueOf() - now.valueOf();

    if (delay < 60000)
    {
      setTimeout(scheduleNextLastPlanGeneration, delay + 1000);
    }
    else
    {
      setTimeout(scheduleNextLastPlanGeneration, Math.round(delay * 0.9));
    }
  }

  function onGenerateRequested(message)
  {
    module.debug('Received generate request...', {request: message});

    if (message.reloadAutoDowntimes)
    {
      autoDowntimeCache.clear();
    }

    if (!message.date)
    {
      generateActivePlans();
    }
    else
    {
      generatePlan(message.date);
    }
  }

  function createPlanGeneratorState(key)
  {
    const lastMinute = moment(key, 'YYYY-MM-DD').hours(5).minutes(59);
    const lastMinuteStartTime = lastMinute.valueOf();
    const lastMinuteEndTime = lastMinuteStartTime + 60000;
    const now = Date.now();
    const date = moment.utc(key, 'YYYY-MM-DD').toDate();

    return {
      key,
      date,
      time: date.getTime(),
      lastMinute: now >= lastMinuteStartTime && now < lastMinuteEndTime,
      lockedMrps: new Set(),
      lockedLines: new Set(),
      cancelled: false,
      new: false,
      generateCallCount: 0,
      linesWithChanges: new Set(),
      settings: null,
      autoDowntimes: null,
      planOrders: null,
      sapOrders: new Map(),
      plan: null,
      oldPlanLines: new Map(),
      orderStates: new Map(),
      lineStates: new Map(),
      lineStateQueue: [],
      oldIncompleteOrders: new Map(),
      newIncompleteOrders: new Map(),
      unfinishedOrders: new Map(),
      orderToLines: new Map(),
      hourlyPlanRecount: new Set(),
      grouping: {
        orderToLineGroups: new Map(),
        lineToGroups: new Map(),
        orderGroups: new Map(),
        noMatchOrderGroup: null
      },
      changes: {
        addedOrders: new Map(),
        removedOrders: new Map(),
        changedOrders: new Map(),
        changedLines: new Map()
      },
      log: (message, ...args) => logger.info(message, {date: key}, ...args),
      err: (message, ...args) => logger.error(message, {date: key}, ...args)
    };
  }

  function generateActivePlans()
  {
    const plansToGenerate = {};
    const date = moment.utc().startOf('day');

    step(
      function()
      {
        Plan.findOne({}, {_id: 1}).sort({_id: -1}).lean().exec(this.parallel());

        Order.aggregate([
          {$match: {
            scheduledStartDate: {
              $gte: date.toDate(),
              $lt: date.clone().add(14, 'days').toDate()
            },
            statuses: {$in: ['REL'], $nin: ['TECO', 'DLT', 'DLFL']},
            'bom.0': {$exists: true}
          }},
          {$group: {_id: null, date: {$max: '$scheduledStartDate'}}}
        ], this.parallel());
      },
      function(err, latestPlan, latestOrders)
      {
        if (err)
        {
          logger.error(err, `Failed to find active plans.`);
        }

        const now = moment();
        const h = now.hours();
        const today = now.format('YYYY-MM-DD');

        if (h < 5 || (h === 5 && now.minutes() < 59))
        {
          plansToGenerate[today] = true;
        }

        const latestPlanTime = latestPlan ? latestPlan._id.getTime() : 0;
        const latestOrderTime = latestOrders && latestOrders.length
          ? moment.utc(moment(latestOrders[0].date).format('YYYY-MM-DD'), 'YYYY-MM-DD').valueOf()
          : 0;
        const maxPlanKey = moment.utc(Math.max(date.valueOf(), latestPlanTime, latestOrderTime)).format('YYYY-MM-DD');
        let nextPlanKey = null;

        if (maxPlanKey !== today)
        {
          do
          {
            nextPlanKey = now.add(1, 'day').format('YYYY-MM-DD');

            if (nextPlanKey === today)
            {
              continue;
            }

            plansToGenerate[nextPlanKey] = true;
          }
          while (nextPlanKey !== maxPlanKey);
        }

        Object.keys(plansToGenerate).forEach(date => generatePlan(date));
      }
    );
  }

  function generatePlan(date)
  {
    const dateMoment = moment.utc(date, 'YYYY-MM-DD').startOf('day');

    if (!dateMoment.isValid())
    {
      return;
    }

    const planKey = dateMoment.format('YYYY-MM-DD');

    if (!generatorQueue.includes(planKey))
    {
      generatorQueue.push(planKey);

      app.broker.publish('planning.generator.started', {
        date: planKey
      });
    }

    if (generatorState !== null)
    {
      generatorState.log(`Cancelling...`);

      generatorState.cancelled = true;

      return;
    }

    if (generatorTimer !== null)
    {
      clearTimeout(generatorTimer);
    }

    generatorTimer = setTimeout(generateNextPlan, 1);
  }

  function generateNextPlan()
  {
    if (generatorState)
    {
      return;
    }

    const planKey = generatorQueue.sort((a, b) => a.localeCompare(b)).shift();

    if (!planKey)
    {
      return;
    }

    generatorTimer = null;
    generatorState = createPlanGeneratorState(planKey);

    tryGeneratePlan(generatorState, () =>
    {
      step(
        function()
        {
          const nextPlanId = moment.utc(generatorState.date.getTime()).add(1, 'days').toDate();

          Plan.findById(nextPlanId, {_id: 1}).lean().exec(this.next());
        },
        function(err, nextPlan)
        {
          if (err)
          {
            generatorState.err(err, `Failed to find the next plan.`);
          }

          if (generatorState.cancelled && !generatorQueue.includes(planKey))
          {
            generatorQueue.push(planKey);
          }

          if (AUTO_GENERATE_NEXT && nextPlan)
          {
            const nextPlanKey = moment.utc(nextPlan._id).format('YYYY-MM-DD');

            if (!generatorQueue.includes(nextPlanKey))
            {
              generatorQueue.push(nextPlanKey);
            }
          }

          generatorState = null;

          if (generatorTimer !== null)
          {
            clearTimeout(generatorTimer);
          }

          generatorTimer = setTimeout(generateNextPlan, 1);
        }
      );
    });
  }

  function tryGeneratePlan(state, done)
  {
    if (!acceptDate(moment.utc(state.date)))
    {
      return done();
    }

    const startedAt = Date.now();

    state.log(`Started...`);

    step(
      function checkFrozenStep()
      {
        const currentDay = moment();

        if (currentDay.hours() < 6)
        {
          currentDay.subtract(1, 'days');
        }

        if (!UNFROZEN_PLANS.includes(state.key) && state.date <= currentDay.toDate())
        {
          this.skip(new Error('Plan is frozen.'));
        }
      },
      function waitToCalmDownStep()
      {
        waitToCalmDown(state, 0, this.next());
      },
      function loadSettingsStep(err)
      {
        if (err)
        {
          return this.skip(new Error(`Failed to wait to calm down: ${err.message}`));
        }

        loadSettings(state, this.next());
      },
      function loadAutoDowntimesStep(err)
      {
        if (state.cancelled)
        {
          return this.skip();
        }

        if (err)
        {
          return this.skip(new Error(`Failed to load settings: ${err.message}`));
        }

        loadAutoDowntimes(state, this.next());
      },
      function loadOrdersStep(err)
      {
        if (state.cancelled)
        {
          return this.skip();
        }

        if (err)
        {
          return this.skip(new Error(`Failed to load auto downtimes: ${err.message}`));
        }

        loadOrders(state, 'plan', null, this.next());
      },
      function loadPlanStep(err)
      {
        if (state.cancelled)
        {
          return this.skip();
        }

        if (err)
        {
          return this.skip(new Error(`Failed to load orders: ${err.message}`));
        }

        loadPlan(state, this.next());
      },
      function generatePlanStep(err)
      {
        if (state.cancelled)
        {
          return this.skip();
        }

        if (err)
        {
          return this.skip(new Error(`Failed to load plan: ${err.message}`));
        }

        doGeneratePlan(state, this.next());
      },
      function markIncompleteOrdersStep(err)
      {
        if (state.cancelled || err)
        {
          return this.skip(err);
        }

        state.newIncompleteOrders.forEach((newValue, orderNo) =>
        {
          const oldValue = state.oldIncompleteOrders.get(orderNo) || 0;

          state.oldIncompleteOrders.delete(orderNo);

          if (newValue === oldValue)
          {
            return;
          }

          const changedOrder = state.changes.changedOrders.get(orderNo);

          if (changedOrder)
          {
            changedOrder.changes.incomplete = [oldValue, newValue];
          }
          else
          {
            state.changes.changedOrders.set(orderNo, {
              _id: orderNo,
              changes: {
                incomplete: [oldValue, newValue]
              }
            });
          }
        });

        state.oldIncompleteOrders.forEach((oldValue, orderNo) =>
        {
          const changedOrder = state.changes.changedOrders.get(orderNo);

          if (changedOrder)
          {
            changedOrder.changes.incomplete = [oldValue, 0];
          }
          else
          {
            state.changes.changedOrders.set(orderNo, {
              _id: orderNo,
              changes: {
                incomplete: [oldValue, 0]
              }
            });
          }
        });

        state.changes.addedOrders.forEach(addedOrder =>
        {
          addedOrder.incomplete = state.newIncompleteOrders.get(addedOrder._id) || 0;
        });

        setImmediate(this.next());
      },
      function restoreRemovedLockedOrdersStep()
      {
        if (state.cancelled)
        {
          return this.skip();
        }

        if (state.changes.removedOrders.size)
        {
          return;
        }

        let restoredCount = 0;

        state.plan.lines.forEach(planLine =>
        {
          planLine.orders.forEach(lineOrder =>
          {
            const removedOrder = state.changes.removedOrders.get(lineOrder.orderNo);

            if (removedOrder)
            {
              state.plan.orders.push(removedOrder.planOrder);

              ++restoredCount;
            }
          });
        });

        if (restoredCount)
        {
          state.log(`Restored removed orders!`, {restoredCount});
        }

        state.changes.removedOrders.forEach(removedOrder =>
        {
          delete removedOrder.planOrder;
        });

        setImmediate(this.next());
      },
      function calcStatsStep()
      {
        if (state.cancelled)
        {
          return this.skip();
        }

        state.log('Calculating stats...');

        const stats = [];

        for (let i = 0; i <= 3; ++i)
        {
          stats.push({
            startAt: Number.MAX_SAFE_INTEGER,
            finishAt: Number.MIN_SAFE_INTEGER,
            mrpCount: new Set(),
            lineCount: 0,
            orderCount: new Set(),
            manHours: 0,
            quantity: 0
          });
        }

        state.plan.lines.forEach(planLine =>
        {
          if (!planLine.orders.length)
          {
            return;
          }

          stats[0].lineCount += 1;

          for (let s = 1; s <= 3; ++s)
          {
            const shiftData = planLine.shiftData[s];

            if (shiftData.orderCount)
            {
              stats[s].lineCount += 1;
            }

            stats[0].manHours += shiftData.manHours;
            stats[s].manHours += shiftData.manHours;
            stats[0].quantity += shiftData.quantity;
            stats[s].quantity += shiftData.quantity;
          }

          planLine.orders.forEach(lineOrder =>
          {
            const sapOrder = state.sapOrders.get(lineOrder.orderNo);

            if (!sapOrder)
            {
              module.warn('Missing order for stats.', {
                line: planLine._id,
                orderNo: lineOrder.orderNo
              });

              return;
            }

            const s = +lineOrder._id.substr(10, 1);

            stats[0].mrpCount.add(sapOrder.mrp);
            stats[s].mrpCount.add(sapOrder.mrp);
            stats[0].orderCount.add(lineOrder.orderNo);
            stats[s].orderCount.add(lineOrder.orderNo);

            if (lineOrder.startAt < stats[s].startAt)
            {
              stats[s].startAt = lineOrder.startAt;
            }

            if (lineOrder.finishAt > stats[s].finishAt)
            {
              stats[s].finishAt = lineOrder.finishAt;
            }
          });

          const startAt = planLine.orders[0].startAt;
          const finishAt = _.last(planLine.orders).finishAt;

          if (startAt < stats[0].startAt)
          {
            stats[0].startAt = startAt;
          }

          if (finishAt > stats[0].finishAt)
          {
            stats[0].finishAt = finishAt;
          }
        });

        stats.forEach(stat =>
        {
          stat.mrpCount = stat.mrpCount.size;
          stat.orderCount = stat.orderCount.size;
          stat.manHours = Math.round(stat.manHours * 100) / 100;

          if (stat.startAt === Number.MAX_SAFE_INTEGER)
          {
            stat.startAt = null;
          }

          if (stat.finishAt === Number.MIN_SAFE_INTEGER)
          {
            stat.finishAt = null;
          }
        });

        state.plan.stats = stats;

        setImmediate(this.next());
      },
      function savePlanStep()
      {
        if (state.cancelled)
        {
          return this.skip();
        }

        state.log('Saving...');

        state.plan.updatedAt = new Date();

        Plan.collection.replaceOne(
          {_id: state.plan._id},
          state.plan.toJSON(),
          {upsert: true, w: 'majority'},
          this.next()
        );
      },
      function finalizeStep(err)
      {
        if (state.cancelled)
        {
          state.log(`Cancelled!`);

          return done();
        }

        const duration = (Date.now() - startedAt) / 1000;

        if (err)
        {
          state.err(err);
        }
        else
        {
          state.log(`Finished!`, {duration});

          savePlanChanges(state);
        }

        app.broker.publish('planning.generator.finished', {
          date: state.key,
          duration
        });

        done();
      }
    );
  }

  function waitToCalmDown(state, tryCount, done)
  {
    if (!mongoose.connection.db)
    {
      return done(app.createError('No DB connection.', 'NO_DB_CONNECTION', 500));
    }

    const cmd = {
      currentOp: true,
      $all: true,
      $or: [
        {
          ns: /\.orders$/,
          op: {$in: ['insert', 'update', 'delete']}
        },
        {
          ns: /\.orders$/,
          op: 'command',
          'query.createIndexes': {$exists: true}
        }
      ]
    };

    mongoose.connection.db.executeDbAdminCommand(cmd, (err, result) =>
    {
      if (err)
      {
        return done(err);
      }

      if (!result.inprog.length || tryCount === 10)
      {
        return done();
      }

      state.log(`Waiting to calm down (${tryCount + 1}/10)...`);

      setTimeout(waitToCalmDown, 1000, state, tryCount + 1, done);
    });
  }

  function savePlanChanges(state)
  {
    const changes = state.new ? {addedOrders: state.changes.addedOrders} : state.changes;
    let anyChanges = false;

    if (!state.new)
    {
      changes.changedLines.forEach(changedLine =>
      {
        const lineState = state.lineStates.get(changedLine._id);

        if (lineState.finalHash === lineState.initialHash)
        {
          changes.changedLines.delete(changedLine._id);
        }
      });
    }

    Object.keys(changes).forEach(key =>
    {
      anyChanges = anyChanges || changes[key].size > 0;
    });

    if (!anyChanges)
    {
      return;
    }

    const data = {};

    Object.keys(changes).forEach(key =>
    {
      if (changes[key].size)
      {
        data[key] = Array.from(changes[key].values());
      }
    });

    const planChange = new PlanChange({
      plan: state.plan._id,
      date: state.plan.updatedAt,
      user: null,
      data
    });
    const json = planChange.toJSON();

    PlanChange.collection.insertOne(json, err =>
    {
      if (err)
      {
        state.err(err, `Failed to save changes.`);
      }
      else
      {
        app.broker.publish('planning.changes.created', planChange.toCreatedMessage(state.plan, state.new, json));
      }
    });

    app.broker.publish('planning.stats.updated', {
      plan: state.key,
      stats: state.plan.stats
    });
  }

  function loadSettings(state, done)
  {
    step(
      function findExistingStep()
      {
        state.log('Loading existing settings...');

        PlanSettings.forGenerator(state.date, this.parallel());

        PlanOrderGroup.find({active: true}).lean().exec(this.parallel());
      },
      function findPrevStep(err, settings, orderGroups)
      {
        if (state.cancelled)
        {
          return this.skip();
        }

        if (err)
        {
          return this.skip(app.createError(err, `Failed to load existing settings.`));
        }

        orderGroups.forEach(g =>
        {
          const noMatchOrderGroup = g._id.getTimestamp().getTime() === 0;

          g._id = g._id.toString();
          g.empty = true;
          g.orderStates = {small: [], medium: [], big: []};

          if (noMatchOrderGroup)
          {
            state.grouping.noMatchOrderGroup = g;
          }

          if (g.productInclude.length > 0
            || g.productExclude.length > 0
            || g.bomInclude.length > 0
            || g.bomExclude.length > 0)
          {
            state.grouping.orderGroups.set(g._id, g);
          }
        });

        if (settings)
        {
          state.settings = settings;

          return this.skip();
        }

        state.log('Loading previous settings...');

        PlanSettings
          .findOne({_id: {$lt: state.date}})
          .sort({_id: -1})
          .exec(this.next());
      },
      function createNewStep(err, prevSettings)
      {
        if (state.cancelled)
        {
          return this.skip();
        }

        if (err)
        {
          return this.skip(app.createError(err, `Failed to load previous settings.`));
        }

        state.log(prevSettings ? 'Copying previous settings...' : 'Creating new settings...');

        const newSettings = prevSettings
          ? PlanSettings.copyFrom(state.date, prevSettings)
          : PlanSettings.createNew(state.date);

        newSettings.save(this.next(), {w: 'majority'});
      },
      function handleSaveStep(err)
      {
        if (state.cancelled)
        {
          return this.skip();
        }

        if (err)
        {
          return this.skip(app.createError(err, `Failed to save new settings.`));
        }

        PlanSettings.forGenerator(state.date, this.next());
      },
      function handleNewSettings(err, settings)
      {
        if (state.cancelled)
        {
          return this.skip();
        }

        if (err)
        {
          return this.skip(app.createError(err, `Failed to load new settings`));
        }

        if (!settings)
        {
          return this.skip(app.createError('New settings not found!?'));
        }

        state.settings = settings;
      },
      function(err)
      {
        if (state.cancelled || err)
        {
          return done(err);
        }

        const mrpsToLines = new Map();
        const linesToMrps = new Map();

        state.settings.mrps.forEach(mrpId =>
        {
          const mrpSettings = state.settings.mrp(mrpId);

          mrpsToLines.set(mrpId, []);

          if (mrpSettings.locked)
          {
            state.lockedMrps.add(mrpId);
          }

          mrpSettings.groups.forEach(group =>
          {
            group.lines.forEach(lineId =>
            {
              const lineSettings = state.settings.line(lineId);

              if (!lineSettings || !lineSettings.mrpPriority.includes(mrpId))
              {
                return;
              }

              if (!state.grouping.lineToGroups.has(lineId))
              {
                state.grouping.lineToGroups.set(lineId, []);
              }

              state.grouping.lineToGroups.get(lineId).push(group);
            });
          });
        });

        state.settings.lines.forEach(lineId =>
        {
          linesToMrps.set(lineId, []);

          state.settings.line(lineId).mrpPriority.forEach(mrpId =>
          {
            mrpsToLines.get(mrpId).push(lineId);
            linesToMrps.get(lineId).push(mrpId);
          });
        });

        linesToMrps.forEach((mrps) =>
        {
          const anyLocked = mrps.some(mrpId => state.lockedMrps.has(mrpId));

          if (anyLocked)
          {
            mrps.forEach(mrpId => state.lockedMrps.add(mrpId));
          }
        });

        mrpsToLines.forEach((lines, mrpId) =>
        {
          if (state.lockedMrps.has(mrpId))
          {
            lines.forEach(lineId => state.lockedLines.add(lineId));
          }
        });

        done();
      }
    );
  }

  function loadAutoDowntimes(state, done)
  {
    state.log('Loading auto downtimes...');

    autoDowntimeCache.get(state.key, (err, autoDowntimes) =>
    {
      if (err)
      {
        return done(err);
      }

      state.autoDowntimes = autoDowntimes;

      setImmediate(done);
    });
  }

  function loadOrders(state, source, ids, done)
  {
    state.log(`Loading orders...`, {source});

    if (!ids && !state.settings.mrps.length)
    {
      return done(new Error('No MRPs defined!'));
    }

    step(
      function findStep()
      {
        const conditions = ids ? {_id: {$in: ids}} : {
          scheduledStartDate: moment(state.key, 'YYYY-MM-DD').toDate(),
          mrp: {$in: state.settings.mrps}
        };

        Order
          .find(conditions)
          .select(Plan.SAP_ORDER_FIELDS)
          .sort({_id: 1})
          .lean()
          .exec(this.next());
      },
      function prepareStep(err, sapOrders)
      {
        if (err || state.cancelled)
        {
          return this.skip(err);
        }

        state.log(`Preparing ${sapOrders.length} ${ids ? 'additional orders' : 'orders'}...`);

        if (!state.planOrders)
        {
          state.planOrders = new Map();
        }

        sapOrders.forEach(sapOrder =>
        {
          const mrpSettings = state.settings.mrp(sapOrder.mrp);

          if (!mrpSettings)
          {
            return;
          }

          const planOrder = Plan.createPlanOrder(source, sapOrder);

          if (state.settings.ignoredWorkCenters.has(planOrder.operation.workCenter))
          {
            return;
          }

          sapOrder.bomCodes = new Set();
          sapOrder.bomItems = [];

          (sapOrder.bom || []).forEach(component =>
          {
            if (component.nc12)
            {
              sapOrder.bomCodes.add(component.nc12);
            }

            const item = component.item || '0000';
            const nc12 = component.nc12 || '000000000000';
            const name = component.name || '?';

            sapOrder.bomItems.push(
              `ITEM ${item} 12NC ${nc12} NAME ${name}`
            );
          });

          state.planOrders.set(sapOrder._id, planOrder);
          state.sapOrders.set(sapOrder._id, sapOrder);
        });

        setImmediate(this.next());
      },
      done
    );
  }

  function preparePlanOrder(state, planOrder)
  {
    const quantityTodo = getQuantityTodo(state, planOrder);
    const mrpSettings = state.settings.mrp(planOrder.mrp);

    planOrder.kind = classifyPlanOrder(state, planOrder);
    planOrder.manHours = getManHours(planOrder, quantityTodo, mrpSettings);
    planOrder.incomplete = quantityTodo;

    state.newIncompleteOrders.set(planOrder._id, quantityTodo);

    state.grouping.orderToLineGroups.set(planOrder._id, []);

    if (mrpSettings.groups.length)
    {
      const lineGroups = state.grouping.orderToLineGroups.get(planOrder._id);
      const sapOrder = state.sapOrders.get(planOrder._id);

      mrpSettings.groups.forEach(group =>
      {
        if (group.components.some(nc12 => sapOrder.bomCodes.has(nc12)))
        {
          lineGroups.push(group);
        }
      });

      if (!lineGroups.length)
      {
        mrpSettings.groups.forEach(group =>
        {
          if (!group.components.length)
          {
            lineGroups.push(group);
          }
        });
      }

      lineGroups.sort((a, b) => b.components.length - a.components.length);
    }

    return planOrder;
  }

  function loadPlan(state, done)
  {
    state.log('Loading plan...');

    step(
      function findExistingStep()
      {
        Plan.findById(state.date).exec(this.next());
      },
      function createNewStep(err, existingPlan)
      {
        if (state.cancelled)
        {
          return this.skip();
        }

        if (err)
        {
          return this.skip(new Error(`Failed to load existing plan: ${err.message}`));
        }

        if (existingPlan)
        {
          removeUnusedLines(existingPlan, state.settings);
        }
        else
        {
          state.new = true;
        }

        state.plan = existingPlan || new Plan({
          _id: state.date,
          createdAt: new Date(),
          updatedAt: null,
          orders: [],
          lines: [],
          stats: []
        });

        if (state.plan.frozen && !UNFROZEN_PLANS.includes(state.key))
        {
          return this.skip(new Error('Plan is frozen.'));
        }

        state.plan.lines.forEach(planLine =>
        {
          state.oldPlanLines.set(planLine._id, planLine);
        });

        setImmediate(this.next());
      },
      function compareOrdersStep()
      {
        if (state.new)
        {
          state.plan.orders = Array.from(state.planOrders.values())
            .map(o => preparePlanOrder(state, o))
            .filter(o => filterPlanOrder(state, o) === null);

          state.plan.orders.forEach(planOrder => state.changes.addedOrders.set(planOrder._id, planOrder));

          state.log(`Classified ${state.plan.orders.length} new orders!`);

          setImmediate(this.next());
        }
        else
        {
          compareOrders(state, this.next());
        }
      },
      done
    );
  }

  function removeUnusedLines(plan, settings)
  {
    plan.lines = plan.lines.filter(line => settings.lines.includes(line._id));
  }

  function filterPlanOrder(state, planOrder)
  {
    const actualStatuses = new Set();

    for (let i = 0; i < planOrder.statuses.length; ++i)
    {
      const actualStatus = planOrder.statuses[i];

      if (state.settings.ignoredStatuses.has(actualStatus))
      {
        state.newIncompleteOrders.delete(planOrder._id);

        planOrder.incomplete = 0;

        if (!state.settings.completedStatuses.includes(actualStatus))
        {
          return {
            _id: planOrder._id,
            reason: 'IGNORED_STATUS',
            data: {
              actualStatuses: planOrder.statuses,
              ignoredStatus: actualStatus
            },
            planOrder
          };
        }
      }

      actualStatuses.add(actualStatus);
    }

    for (let i = 0; i < state.settings.requiredStatuses.length; ++i)
    {
      const requiredStatus = state.settings.requiredStatuses[i];

      if (!actualStatuses.has(requiredStatus))
      {
        state.newIncompleteOrders.delete(planOrder._id);

        return {
          _id: planOrder._id,
          reason: 'REQUIRED_STATUS',
          data: {
            actualStatuses: planOrder.statuses,
            requiredStatus
          }
        };
      }
    }

    return null;
  }

  function classifyPlanOrder(state, planOrder)
  {
    if (isSmallOrder(state, planOrder))
    {
      return 'small';
    }

    if (isBigOrder(state, planOrder))
    {
      return 'big';
    }

    return 'medium';
  }

  function getQuantityTodo(state, planOrder)
  {
    return Math.max(planOrder.quantityTodo - planOrder.quantityDone, 0);
  }

  function isSmallOrder(state, planOrder)
  {
    const quantityTodo = getQuantityTodo(state, planOrder);
    const {smallOrderQuantity} = state.settings.mrp(planOrder.mrp);

    return quantityTodo <= smallOrderQuantity;
  }

  function isBigOrder(state, planOrder)
  {
    const quantityTodo = getQuantityTodo(state, planOrder);
    const {bigOrderQuantity} = state.settings.mrp(planOrder.mrp);

    return quantityTodo >= bigOrderQuantity;
  }

  function compareOrders(state, done)
  {
    const oldPlanOrders = state.plan.orders;
    const newPlanOrders = [];
    const latestOrders = state.planOrders;

    state.log(`Comparing orders...`, {
      oldCount: oldPlanOrders.length,
      newCount: latestOrders.size
    });

    oldPlanOrders.forEach(oldOrder =>
    {
      const latestOrder = latestOrders.get(oldOrder._id);

      if (!latestOrder)
      {
        state.changes.removedOrders.set(oldOrder._id, {
          _id: oldOrder._id,
          reason: 'MISSING_ORDER',
          planOrder: oldOrder
        });

        return;
      }

      if (compareOrder(state, oldOrder, latestOrder))
      {
        newPlanOrders.push(latestOrder);
      }

      latestOrders.delete(latestOrder._id);
    });

    latestOrders.forEach(latestOrder =>
    {
      preparePlanOrder(state, latestOrder);

      if (filterPlanOrder(state, latestOrder) === null)
      {
        newPlanOrders.push(latestOrder);

        state.changes.addedOrders.set(latestOrder._id, latestOrder);
      }
    });

    latestOrders.clear();

    newPlanOrders.forEach(planOrder =>
    {
      latestOrders.set(planOrder._id, planOrder);
    });

    state.plan.orders = newPlanOrders;

    state.log(`Orders compared!`, {
      addedCount: state.changes.addedOrders.size,
      changedCount: state.changes.changedOrders.size,
      removedCount: state.changes.removedOrders.size
    });

    setImmediate(done);
  }

  function compareOrder(state, oldOrder, latestOrder)
  {
    Object.assign(latestOrder, _.pick(oldOrder, ORDER_USER_PROPERTIES));

    preparePlanOrder(state, latestOrder);

    const removedOrder = filterPlanOrder(state, latestOrder);

    if (removedOrder !== null)
    {
      state.changes.removedOrders.set(removedOrder._id, removedOrder);

      return false;
    }

    if (oldOrder.incomplete)
    {
      state.oldIncompleteOrders.set(oldOrder._id, oldOrder.incomplete);
    }

    const changes = {};
    let changed = false;

    Object.keys(latestOrder).forEach(key =>
    {
      if (ORDER_IGNORED_PROPERTIES[key])
      {
        return;
      }

      const oldValue = oldOrder[key] && oldOrder[key].toObject ? oldOrder[key].toObject() : oldOrder[key];
      const newValue = latestOrder[key] && latestOrder[key].toObject ? latestOrder[key].toObject() : latestOrder[key];

      if (key === 'operation' && !_.isEmpty(oldValue) && _.isEmpty(newValue))
      {
        latestOrder[key] = oldValue;

        return;
      }

      if (jsonDeepEqual(newValue, oldValue))
      {
        return;
      }

      changes[key] = [oldValue, newValue];
      changed = true;
    });

    if (changed)
    {
      state.changes.changedOrders.set(oldOrder._id, {
        _id: oldOrder._id,
        changes
      });
    }

    return true;
  }

  function doGeneratePlan(state, done)
  {
    state.log('Generating...');

    step(
      function()
      {
        createOrderStates(state, this.next());
      },
      function()
      {
        if (state.cancelled)
        {
          return this.skip();
        }

        createLineStates(state, this.next());
      },
      function()
      {
        if (state.cancelled)
        {
          return this.skip();
        }

        generatePlanForLines(1, state, this.next());
      },
      function()
      {
        if (state.cancelled)
        {
          return this.skip();
        }

        fillLines(state, this.next());
      },
      function()
      {
        if (state.cancelled)
        {
          return this.skip();
        }

        state.hourlyPlanRecount.forEach(lineId => recountHourlyPlan(state.plan.lines.find(l => l._id === lineId)));

        state.plan.lines.forEach(planLine =>
        {
          planLine.orders.forEach(lineOrder =>
          {
            lineOrder.pceTimes = [];
          });
        });

        setImmediate(this.next());
      },
      done
    );
  }

  function createOrderStates(state, done)
  {
    state.plan.orders.forEach(planOrder =>
    {
      if (isPlannableOrder(state, planOrder))
      {
        createOrderState(state, planOrder);
      }
    });

    state.grouping.orderGroups.set(state.grouping.noMatchOrderGroup._id, state.grouping.noMatchOrderGroup);

    state.grouping.orderGroups.forEach(orderGroup =>
    {
      orderGroup.empty = ORDER_KINDS.every(kind => orderGroup.orderStates[kind].length === 0);

      if (!orderGroup.empty)
      {
        sortSmallOrders(orderGroup.orderStates.small);
        sortMediumOrders(orderGroup.orderStates.medium);
        sortBigOrders(orderGroup.orderStates.big);
      }
    });

    setImmediate(done);
  }

  function createOrderState(state, planOrder)
  {
    const orderState = {
      planOrder,
      sapOrder: state.sapOrders.get(planOrder._id),
      pinnedLines: getAvailablePinnedLines(state, planOrder),
      quantityTodo: getQuantityTodo(state, planOrder),
      startTimes: [],
      lineGroup: null,
      remainingGroupLines: new Set(),
      plannedOnLines: new Set()
    };

    groupOrder(state, orderState);

    state.orderStates.set(planOrder._id, orderState);
  }

  function groupOrder(state, orderState)
  {
    const {sapOrder, planOrder} = orderState;
    const {kind} = planOrder;
    let noMatch = true;

    state.grouping.orderGroups.forEach(orderGroup =>
    {
      const orderData = {
        mrp: sapOrder.mrp,
        product: `${sapOrder.nc12} ${sapOrder.name} ${sapOrder.description}`.trim().toUpperCase(),
        bom: sapOrder.bomItems
      };

      if (PlanOrderGroup.matchOrder(orderGroup, orderData))
      {
        orderGroup.orderStates[kind].push(orderState);
        noMatch = false;
      }
    });

    if (noMatch)
    {
      state.grouping.noMatchOrderGroup.orderStates[kind].push(orderState);
    }
  }

  function isPlannableOrder(state, planOrder)
  {
    return planOrder.quantityTodo > 0
      && planOrder.operation.laborTime > 0
      && !isCompletedOrder(state, planOrder);
  }

  function isCompletedOrder(state, planOrder)
  {
    const {completedStatuses} = state.settings;
    const {statuses} = planOrder;

    for (let i = 0; i < completedStatuses.length; ++i)
    {
      if (statuses.includes(completedStatuses[i]))
      {
        return true;
      }
    }

    return false;
  }

  function getAvailablePinnedLines(state, planOrder)
  {
    const pinnedLines = planOrder.lines;

    if (pinnedLines.length === 0)
    {
      return [];
    }

    const availableLines = pinnedLines
      .map(l => state.settings.line(l))
      .filter(l => l.workerCount.some(c => c > 0))
      .map(l => l._id);

    return _.intersection(pinnedLines, availableLines);
  }

  function sortSmallOrders(orderStates)
  {
    orderStates.sort(sortOrdersByManHoursDesc);
  }

  function sortMediumOrders(orderStates)
  {
    orderStates.sort(sortOrdersByManHoursAsc);
  }

  function sortBigOrders(orderStates)
  {
    orderStates.sort(sortOrdersByManHoursAsc);
  }

  function sortOrdersByManHoursAsc(a, b)
  {
    let cmp = a.planOrder.manHours - b.planOrder.manHours;

    if (cmp === 0)
    {
      cmp = a.planOrder._id.localeCompare(b.planOrder._id);
    }

    return cmp;
  }

  function sortOrdersByManHoursDesc(a, b)
  {
    let cmp = b.planOrder.manHours - a.planOrder.manHours;

    if (cmp === 0)
    {
      cmp = a.planOrder._id.localeCompare(b.planOrder._id);
    }

    return cmp;
  }

  function createLineStates(state, done)
  {
    const mrpToLinesMap = new Map();

    state.settings.lines.forEach(lineId =>
    {
      const lineSettings = state.settings.line(lineId);
      const planLine = state.plan.lines.find(l => l._id === lineId);
      const activeTimes = createActiveTimes(state.date.getTime(), lineSettings);
      const lineState = {
        _id: lineId,
        locked: LOCK_LINES && !state.new && state.lockedLines.has(lineId),
        forward: true,
        backward: false,
        completed: false,
        overtime: false,
        allActiveTimes: cloneActiveTimes(activeTimes),
        activeTimes,
        activeTime: null,
        extraCapacity: calcExtraCapacity(activeTimes, lineSettings.extraCapacity),
        nextDowntime: state.autoDowntimes.get(lineId),
        downtimes: [],
        orderStateQueue: createLineOrderStateQueue(state, lineId),
        orderStateToGroups: new Map(),
        orderPriority: lineSettings.orderPriority,
        orderPriorityI: 0,
        plannedOrders: [],
        triedOrdersSet: new Set(),
        hourlyPlan: EMPTY_HOURLY_PLAN.slice(),
        hash: '',
        initialHash: planLine ? planLine.hash : '',
        finalHash: ''
      };

      lineState.orderStateQueue.forEach(({orderGroup, orderStates}) =>
      {
        ORDER_KINDS.forEach(kind =>
        {
          orderStates[kind].forEach(orderState =>
          {
            if (!lineState.orderStateToGroups.has(orderState))
            {
              lineState.orderStateToGroups.set(orderState, []);
            }

            lineState.orderStateToGroups.get(orderState).push(orderGroup);
          });
        });
      });

      lineSettings.mrpPriority.forEach(mrpId =>
      {
        if (!mrpToLinesMap.has(mrpId))
        {
          mrpToLinesMap.set(mrpId, []);
        }

        mrpToLinesMap.get(mrpId).push(lineState);
      });
    });

    const sortedMrps = Array.from(mrpToLinesMap.keys()).sort((a, b) => a.localeCompare(b, undefined, {
      numeric: true,
      ignorePunctuation: true
    }));

    sortedMrps.forEach(mrpId =>
    {
      const lineStates = mrpToLinesMap.get(mrpId);

      sortMrpLines(lineStates, state.settings.mrp(mrpId).linePriority);

      lineStates.forEach(lineState =>
      {
        if (!state.lineStates.has(lineState._id))
        {
          state.lineStates.set(lineState._id, lineState);
          state.lineStateQueue.push(lineState);
        }
      });
    });

    setImmediate(done);
  }

  function sortMrpLines(lineStates, linePriority)
  {
    lineStates.sort((a, b) =>
    {
      const aI = linePriority.indexOf(a._id);
      const bI = linePriority.indexOf(b._id);

      if (aI === bI)
      {
        return a._id.localeCompare(b._id, undefined, {numeric: true, ignorePunctuation: true});
      }

      if (aI === -1)
      {
        return 1;
      }

      if (bI === -1)
      {
        return -1;
      }

      return aI - bI;
    });
  }

  function createLineOrderStateQueue(state, lineId)
  {
    const lineSettings = state.settings.line(lineId);
    const lineOrderStateQueue = [];

    lineSettings.orderGroupPriority.forEach(groupId =>
    {
      const orderGroup = state.grouping.orderGroups.get(groupId.toString());

      if (!orderGroup || orderGroup.empty)
      {
        return;
      }

      const orderStates = filterLineOrderStates(state, lineId, orderGroup.orderStates);

      if (ORDER_KINDS.every(kind => orderStates[kind].length === 0))
      {
        return;
      }

      lineOrderStateQueue.push({orderGroup, orderStates});
    });

    return lineOrderStateQueue;
  }

  function filterLineOrderStates(state, lineId, allOrderStates)
  {
    const {mrpPriority, orderPriority} = state.settings.line(lineId);
    const lineGroups = state.grouping.lineToGroups.get(lineId);
    const lineOrderStates = {};

    Object.keys(allOrderStates).forEach(kind =>
    {
      if (!orderPriority.includes(kind))
      {
        lineOrderStates[kind] = [];

        return;
      }

      lineOrderStates[kind] = allOrderStates[kind].filter(orderState =>
      {
        if (!mrpPriority.includes(orderState.planOrder.mrp))
        {
          return false;
        }

        const orderLineGroups = state.grouping.orderToLineGroups.get(orderState.planOrder._id);

        if (!orderLineGroups.length)
        {
          return true;
        }

        if (!lineGroups)
        {
          return false;
        }

        return orderLineGroups.some(group => lineGroups.includes(group));
      });
    });

    return lineOrderStates;
  }

  function createActiveTimes(planTime, lineSettings)
  {
    if (_.isEmpty(lineSettings.activeTime))
    {
      lineSettings.activeTime = [{from: '06:00', to: '06:00'}];
    }

    let activeTimes = lineSettings.activeTime.map(rawActiveTime => ({
      from: createMomentFromActiveTime(planTime, rawActiveTime.from, true),
      to: createMomentFromActiveTime(planTime, rawActiveTime.to, false)
    }));

    activeTimes.sort((a, b) => a.from.valueOf() - b.from.valueOf());

    activeTimes = mergeIntervals(activeTimes);

    lineSettings.workerCount.forEach((workerCount, i) =>
    {
      if (workerCount > 0)
      {
        return;
      }

      const splitActiveTimes = [];

      activeTimes.forEach(activeTime =>
      {
        const shiftNo = i + 1;
        const shiftStartHour = shifts.SHIFT_START_HOUR[shiftNo];
        const shiftStartTime = moment.utc(planTime).hours(shiftStartHour).valueOf();
        const shiftEndTime = shiftStartTime + shifts.SHIFT_LENGTH * 3600 * 1000;

        if (activeTime.from.valueOf() >= shiftStartTime && activeTime.from.valueOf() <= shiftEndTime)
        {
          activeTime.from = moment.utc(shiftEndTime);
        }

        if (activeTime.to.valueOf() >= shiftStartTime && activeTime.to.valueOf() <= shiftEndTime)
        {
          activeTime.to = moment.utc(shiftStartTime);
        }

        if (shiftStartTime > activeTime.from.valueOf() && shiftEndTime < activeTime.to.valueOf())
        {
          splitActiveTimes.push({
            from: activeTime.from,
            to: moment.utc(shiftStartTime)
          });

          splitActiveTimes.push({
            from: moment.utc(shiftEndTime),
            to: activeTime.to
          });
        }
        else
        {
          splitActiveTimes.push(activeTime);
        }
      });

      activeTimes = splitActiveTimes.filter(activeTime => activeTime.from.valueOf() < activeTime.to.valueOf());
    });

    return activeTimes;
  }

  function cloneActiveTimes(activeTimes)
  {
    return activeTimes.map(activeTime =>
    {
      return {
        from: activeTime.from.clone(),
        to: activeTime.to.clone()
      };
    });
  }

  function mergeIntervals(intervals)
  {
    if (intervals.length <= 1)
    {
      return intervals;
    }

    const result = [];

    result.push(intervals[0]);

    for (let i = 1; i < intervals.length; ++i)
    {
      const top = result[result.length - 1];

      if (top.to.valueOf() < intervals[i].from.valueOf())
      {
        result.push(intervals[i]);
      }
      else if (top.to.valueOf() < intervals[i].to.valueOf())
      {
        top.to = intervals[i].to;

        result.pop();
        result.push(top);
      }
    }

    return result;
  }

  function createMomentFromActiveTime(planTime, activeTimeString, from)
  {
    const matches = activeTimeString.match(/([0-9]{1,2})(?::([0-9]{1,2}))?/);
    const hours = matches && matches[1] < 24 ? +matches[1] : 6;
    const minutes = matches && matches[2] < 60 ? +matches[2] : 0;
    const activeTimeMoment = moment.utc(planTime);

    if (hours < 6 || (!from && hours <= 6 && minutes === 0))
    {
      activeTimeMoment.add(1, 'days');
    }

    return activeTimeMoment.hours(hours).minutes(minutes);
  }

  function getShiftFromMoment(moment)
  {
    const hours = moment.hours();

    return hours >= 6 && hours < 14 ? 1 : hours >= 14 && hours < 22 ? 2 : 3;
  }

  function generatePlanForLines(increment, state, done)
  {
    if (state.cancelled || !state.lineStateQueue.length)
    {
      return done();
    }

    state.generateCallCount += increment;

    generatePlanForLine(state, state.lineStateQueue.shift(), () => generatePlanForLines(0, state, done));
  }

  function generatePlanForLine(state, lineState, done)
  {
    if (lineState.locked)
    {
      logLine(lineState, 'Skipping line: locked!', {line: lineState._id});
    }
    else if ((state.settings.line(lineState._id).workerCount || []).every(c => c === 0))
    {
      logLine(lineState, 'Skipping line: no workers!', {line: lineState._id});
    }
    else if (lineState.orderPriority.length === 0)
    {
      logLine(lineState, 'Skipping line: no order priority!', {line: lineState._id});
    }
    else
    {
      if (!lineState.activeTime)
      {
        lineState.activeTime = lineState.activeTimes.shift();
      }

      if (!lineState.activeTime)
      {
        logLine(lineState, 'Skipping line: no active time!', {line: lineState._id});
      }
      else
      {
        initLineState(state, lineState);

        logLine(lineState, 'Generating plan for line...', {
          line: lineState._id,
          direction: lineState.forward ? 'forward' : 'backward'
        });

        while (!lineState.completed)
        {
          const {orderState, orderGroup} = getNextOrderForLine(state, lineState);

          if (!orderState)
          {
            break;
          }

          handleOrderState(state, lineState, orderState, orderGroup);
        }

        if (lineState.backward)
        {
          reverseLineState(state, lineState);
        }
      }
    }

    setImmediate(completeLine, state, lineState, done);
  }

  function initLineState(state, lineState)
  {
    if (state.unfinishedOrders.size === 0)
    {
      return;
    }

    const unfinishedCount = {};
    let unfinishedForward = false;
    let unfinishedOrder = null;
    let firstOrderGroup = null;

    for (const [orderState, forward] of state.unfinishedOrders)
    {
      const orderGroups = lineState.orderStateToGroups.get(orderState);

      if (!orderGroups)
      {
        continue;
      }

      for (const plannedLineState of orderState.plannedOnLines)
      {
        if (!unfinishedCount[plannedLineState._id])
        {
          unfinishedCount[plannedLineState._id] = 1;
        }
        else
        {
          unfinishedCount[plannedLineState._id] += 1;
        }

        const lastPlannedOrder = _[forward ? 'last' : 'first'](plannedLineState.plannedOrders);

        if (!unfinishedOrder && lastPlannedOrder.orderNo === orderState.sapOrder._id)
        {
          unfinishedForward = forward;
          unfinishedOrder = orderState;
          firstOrderGroup = orderGroups[0];
        }
      }
    }

    if (!unfinishedOrder)
    {
      return;
    }

    if (Object.values(unfinishedCount).some(c => c > 1))
    {
      const lineGroups = state.grouping.lineToGroups.get(lineState._id);

      if (!lineGroups)
      {
        return;
      }

      for (const lineGroup of lineGroups)
      {
        for (const lineId of lineGroup.lines)
        {
          if (lineId === lineState._id)
          {
            continue;
          }

          const groupedLineState = state.lineStates.get(lineId);

          if (!groupedLineState)
          {
            continue;
          }

          lineState.forward = groupedLineState.forward;
          lineState.backward = !lineState.forward;

          return;
        }
      }

      return;
    }

    const itemsBefore = [];
    const itemsAfter = [];
    let theItem = null;

    lineState.orderStateQueue.forEach(item =>
    {
      if (item.orderGroup === firstOrderGroup)
      {
        theItem = item;

        item.orderStates[unfinishedOrder.planOrder.kind].sort((a, b) =>
        {
          if (a === unfinishedOrder)
          {
            return -1;
          }

          if (b === unfinishedOrder)
          {
            return 1;
          }

          return 0;
        });
      }
      else if (theItem)
      {
        itemsAfter.push(item);
      }
      else
      {
        itemsBefore.unshift(item);
      }
    });

    logLine(lineState, 'Order state queue before...', {
      line: lineState._id,
      orderPriority: lineState.orderPriority,
      orderPriorityI: lineState.orderPriorityI
    });

    lineState.forward = !unfinishedForward;
    lineState.backward = !lineState.forward;
    lineState.orderPriorityI = lineState.orderPriority.indexOf(unfinishedOrder.planOrder.kind);

    if (!LOG_LINES || LOG_LINES[lineState._id])
    {
      console.inspect(lineState.orderStateQueue.map(({orderGroup, orderStates}) =>
      {
        return {
          orderGroup: orderGroup.name,
          orderStates: {
            small: orderStates.small.map(orderState => orderState.sapOrder._id),
            medium: orderStates.medium.map(orderState => orderState.sapOrder._id),
            big: orderStates.big.map(orderState => orderState.sapOrder._id)
          }
        };
      }));
    }

    lineState.orderStateQueue = [theItem].concat(itemsBefore, itemsAfter);

    logLine(lineState, 'Order state queue after...', {
      line: lineState._id,
      orderPriority: lineState.orderPriority,
      orderPriorityI: lineState.orderPriorityI
    });

    if (!LOG_LINES || LOG_LINES[lineState._id])
    {
      console.inspect(lineState.orderStateQueue.map(({orderGroup, orderStates}) =>
      {
        return {
          orderGroup: orderGroup.name,
          orderStates: {
            small: orderStates.small.map(orderState => orderState.sapOrder._id),
            medium: orderStates.medium.map(orderState => orderState.sapOrder._id),
            big: orderStates.big.map(orderState => orderState.sapOrder._id)
          }
        };
      }));
    }
  }

  function reverseLineState(state, lineState)
  {
    const oldPlannedOrders = lineState.plannedOrders;

    if (oldPlannedOrders.length === 0)
    {
      return;
    }

    logLine(lineState, 'Reversing line state...', {line: lineState._id});

    const originalExtraCapacity = lineState.extraCapacity;

    lineState.overtime = false;
    lineState.activeTimes = cloneActiveTimes(lineState.allActiveTimes);
    lineState.activeTime = lineState.activeTimes.shift();
    lineState.extraCapacity = 24 * 3600 * 1000;
    lineState.nextDowntime = state.autoDowntimes.get(lineState._id);
    lineState.downtimes = [];
    lineState.plannedOrders = [];
    lineState.triedOrdersSet = new Set();
    lineState.hourlyPlan = EMPTY_HOURLY_PLAN.slice();
    lineState.hash = '';

    const reversedOrderStates = [];
    const orderQuantities = {};

    oldPlannedOrders.forEach(lineOrder =>
    {
      const orderState = state.orderStates.get(lineOrder.orderNo);

      orderState.quantityTodo += lineOrder.quantity;

      if (!orderQuantities[lineOrder.orderNo])
      {
        orderQuantities[lineOrder.orderNo] = lineOrder.quantity;

        reversedOrderStates.unshift({
          orderState,
          orderGroup: state.grouping.orderGroups.get(lineOrder.group.toString())
        });
      }
      else
      {
        orderQuantities[lineOrder.orderNo] += lineOrder.quantity;
      }
    });

    reversedOrderStates.forEach(({orderState, orderGroup}) =>
    {
      planOrderOnLine(state, lineState, orderState, orderGroup, orderQuantities[orderState.sapOrder._id]);
    });

    lineState.extraCapacity = originalExtraCapacity;
  }

  function fillLines(state, done)
  {
    if (state.unfinishedOrders.size === 0)
    {
      return done();
    }

    const unfinishedOrders = Array.from(state.unfinishedOrders.keys());

    unfinishedOrders.forEach(orderState =>
    {
      const candidates = [];

      orderState.plannedOnLines.forEach(lineState =>
      {
        if (lineState.overtime)
        {
          return;
        }

        const lineOrder = _.last(lineState.plannedOrders);

        if (lineOrder.orderNo !== orderState.sapOrder._id)
        {
          return;
        }

        const remainingTime = getRemainingAvailableTime(lineState);

        if (remainingTime < lineOrder.pceTime)
        {
          return;
        }

        candidates.push({
          lineState,
          lineOrder,
          remainingTime
        });
      });

      candidates.sort((a, b) => b.remainingTime - a.remainingTime);

      while (candidates.length && orderState.quantityTodo)
      {
        const {lineState, lineOrder} = candidates.shift();
        const orderGroup = state.grouping.orderGroups.get(lineOrder.group.toString());

        state.log('Filling order...', {
          line: lineState._id,
          orderNo: orderState.sapOrder._id,
          quantity: orderState.quantityTodo
        });

        const plannedOrderCount = lineState.plannedOrders.length;

        planOrderOnLine(state, lineState, orderState, orderGroup, orderState.quantityTodo);

        if (lineState.plannedOrders.length === plannedOrderCount)
        {
          break;
        }

        const lastLineOrderFinishAt = lineOrder.finishAt.getTime();
        const lastLineOrderShift = getShiftFromMoment(moment.utc(lineOrder.startAt));
        const extraLineOrders = lineState.plannedOrders.splice(
          plannedOrderCount,
          lineState.plannedOrders.length - plannedOrderCount
        );

        extraLineOrders.forEach(extraLineOrder =>
        {
          const extraLineOrderShift = getShiftFromMoment(moment.utc(extraLineOrder.startAt));

          if (extraLineOrder.startAt.getTime() === lastLineOrderFinishAt
            && extraLineOrderShift === lastLineOrderShift)
          {
            lineOrder.quantity += extraLineOrder.quantity;
            lineOrder.manHours += extraLineOrder.manHours;
            lineOrder.finishAt = extraLineOrder.finishAt;
            lineOrder.pceTimes = lineOrder.pceTimes.concat(extraLineOrder.pceTimes);
          }
          else
          {
            lineState.plannedOrders.push(extraLineOrder);
          }
        });

        completeLine(state, lineState);
      }
    });

    done();
  }

  function handleOrderState(state, lineState, orderState, orderGroup)
  {
    if (lineState.triedOrdersSet.has(orderState))
    {
      logLine(lineState, 'Skipping order: already tried...', {
        line: lineState._id,
        order: orderState.planOrder._id
      });

      return;
    }

    lineState.triedOrdersSet.add(orderState);

    if (orderState.lineGroup)
    {
      if (!orderState.lineGroup.lines.includes(lineState._id) && orderState.lineGroup.components.length)
      {
        logLine(lineState, 'Skipping grouped order: line not in assigned group with components...', {
          line: lineState._id,
          order: orderState.planOrder._id,
          lineGroup: orderState.lineGroup
        });

        return;
      }
    }
    else
    {
      const orderLineGroups = state.grouping.orderToLineGroups.get(orderState.planOrder._id);

      orderState.lineGroup = orderLineGroups.find(group => group.lines.includes(lineState._id)) || null;

      if (orderLineGroups.length && !orderState.lineGroup)
      {
        logLine(lineState, 'Skipping grouped order: line not in group...', {
          line: lineState._id,
          order: orderState.planOrder._id,
          lineGroups: orderLineGroups
        });

        return;
      }

      if (orderState.lineGroup)
      {
        orderState.remainingGroupLines = resolveAvailableGroupLines(state, lineState, orderState);

        if (orderState.remainingGroupLines.size === 0)
        {
          orderState.lineGroup = null;
        }
        else
        {
          logLine(lineState, 'Assigned order to line group.', {
            line: lineState._id,
            order: orderState.planOrder._id,
            lineGroup: orderState.lineGroup,
            quantityTodo: orderState.quantityTodo,
            remainingGroupLines: orderState.remainingGroupLines
          });
        }
      }
    }

    planOrderOnLine(state, lineState, orderState, orderGroup, 0);
  }

  function resolveAvailableGroupLines(state, lineState, orderState)
  {
    if (orderState.planOrder.quantityTodo < orderState.lineGroup.splitOrderQuantity)
    {
      return new Set();
    }

    const availableLines = orderState.lineGroup.lines.filter(lineId =>
    {
      const lineState = state.lineStates.get(lineId);

      if (!lineState || lineState.completed)
      {
        return false;
      }

      const lineSettings = state.settings.line(lineId);

      if (lineSettings.workerCount.every(c => c === 0))
      {
        return false;
      }

      if (!lineSettings.orderPriority.includes(orderState.planOrder.kind))
      {
        return false;
      }

      return lineState.orderStateToGroups.has(orderState);
    });

    if (availableLines.length < 2)
    {
      return new Set();
    }

    return new Set(availableLines);
  }

  function planOrderOnLine(state, lineState, orderState, orderGroup, quantityRemaining = 0)
  {
    const {sapOrder, planOrder} = orderState;
    const orderNo = sapOrder._id;
    const settings = state.settings;
    const lineSettings = settings.line(lineState._id);
    const mrpSettings = settings.mrp(planOrder.mrp);
    const workerCounts = lineSettings.workerCount.slice();
    const oldLineState = {
      completed: lineState.completed,
      overtime: lineState.overtime,
      activeTime: {
        from: lineState.activeTime.from.clone(),
        to: lineState.activeTime.to.clone()
      },
      activeTimes: cloneActiveTimes(lineState.activeTimes)
    };

    let shiftNo = getShiftFromMoment(lineState.activeTime.from);
    let workerCount = workerCounts[shiftNo - 1];

    if (workerCount === 0)
    {
      logLine(lineState, `Line doesn't have workers.`, {
        line: lineState._id,
        orderNo
      });

      return;
    }

    let pceTime = getPceTime(planOrder, workerCount, mrpSettings);
    let startAt = lineState.activeTime.from.valueOf();
    let finishAt = startAt + getOrderStartOverhead(settings, lineState, orderState);
    let quantityPlanned = 0;
    let pceTimes = [];
    let downtimes = [];
    let nextDowntime = lineState.nextDowntime;

    if (!quantityRemaining)
    {
      quantityRemaining = orderState.quantityTodo;

      if (orderState.remainingGroupLines.size)
      {
        quantityRemaining = Math.ceil(quantityRemaining / orderState.remainingGroupLines.size);
      }
    }

    orderState.remainingGroupLines.delete(lineState._id);

    const hourlyPlan = EMPTY_HOURLY_PLAN.slice();
    const plannedOrders = [];

    logLine(lineState, 'Trying order on line...', {
      line: lineState._id,
      orderNo,
      workerCount,
      pceTime,
      activeFrom: lineState.activeTime.from.toDate(0),
      activeTo: lineState.activeTime.to.toDate(),
      extraCapacity: lineState.extraCapacity,
      quantityRemaining,
      quantityTodo: orderState.quantityTodo,
      orderGroup: orderGroup.name,
      lineGroup: orderState.lineGroup
    });

    while (quantityRemaining > 0)
    {
      let newFinishAt = finishAt + pceTime;
      let newNextDowntime = nextDowntime;
      const newDowntimes = [];

      while (!lineState.overtime && newNextDowntime)
      {
        if (newNextDowntime.startTime <= newFinishAt)
        {
          if (newNextDowntime.startTime >= startAt)
          {
            newDowntimes.push({
              reason: newNextDowntime.reason,
              startAt: new Date(newNextDowntime.startTime),
              duration: newNextDowntime.duration
            });

            newFinishAt += newNextDowntime.duration;
          }

          newNextDowntime = newNextDowntime.next;

          continue;
        }

        break;
      }

      const newFinishMoment = moment.utc(newFinishAt);
      const overTimeRange = newFinishAt > lineState.activeTime.to.valueOf();
      let newShiftNo = getShiftFromMoment(newFinishMoment);
      let overShift = shiftNo !== newShiftNo;

      if (overTimeRange || overShift)
      {
        let orderPushed = false;

        if (quantityPlanned > 0)
        {
          plannedOrders.push({
            _id: getNextLineOrderId(orderNo, shiftNo, lineState.plannedOrders, plannedOrders),
            orderNo,
            quantity: quantityPlanned,
            pceTime,
            manHours: getManHours(planOrder, quantityPlanned, mrpSettings),
            startAt: new Date(startAt),
            finishAt: new Date(finishAt),
            pceTimes,
            group: new ObjectId(orderGroup._id)
          });

          orderPushed = true;
          quantityPlanned = 0;
          pceTimes = [];
        }

        if (overTimeRange)
        {
          if (!lineState.activeTimes.length)
          {
            lineState.completed = true;

            const remainingTime = lineState.activeTime.to.valueOf() - finishAt;
            const extraTime = remainingTime + lineState.extraCapacity;
            const remainingDuration = pceTime * quantityRemaining;

            if (remainingDuration > extraTime)
            {
              break;
            }

            lineState.activeTime.to.add(Math.max(lineState.extraCapacity, 8 * 3600 * 1000));

            for (let i = 0; i < workerCounts.length; ++i)
            {
              workerCounts[i] = workerCount;
            }

            lineState.overtime = true;

            if (orderPushed)
            {
              const lastOrder = plannedOrders.pop();

              quantityPlanned = lastOrder.quantity;
              pceTimes = lastOrder.pceTimes;
            }

            continue;
          }

          lineState.activeTime = lineState.activeTimes.shift();
          startAt = lineState.activeTime.from.valueOf();
          finishAt = startAt;
          newShiftNo = getShiftFromMoment(lineState.activeTime.from);
          overShift = newShiftNo !== shiftNo;
        }
        else
        {
          startAt = settings.shiftStartTimes[newShiftNo - 1];

          if (newShiftNo === 1 && shiftNo === 3)
          {
            startAt += 24 * 3600 * 1000;
          }

          finishAt = startAt;
        }

        if (overShift)
        {
          shiftNo = newShiftNo;
          finishAt += getOrderStartOverhead(settings, lineState, orderState);
          workerCount = workerCounts[shiftNo - 1];
          pceTime = getPceTime(planOrder, workerCount, mrpSettings);
        }

        continue;
      }

      const h = newFinishMoment.hours();

      pceTimes.push(h, newFinishMoment.minutes());
      hourlyPlan[HOUR_TO_INDEX[h]] += 1;
      downtimes = downtimes.concat(newDowntimes);
      nextDowntime = newNextDowntime;
      finishAt = newFinishAt;
      quantityPlanned += 1;
      quantityRemaining -= 1;

      if (quantityRemaining === 0)
      {
        plannedOrders.push({
          _id: getNextLineOrderId(orderNo, shiftNo, lineState.plannedOrders, plannedOrders),
          orderNo,
          quantity: quantityPlanned,
          pceTime,
          manHours: getManHours(planOrder, quantityPlanned, mrpSettings),
          startAt: new Date(startAt),
          finishAt: new Date(finishAt),
          pceTimes,
          group: new ObjectId(orderGroup._id)
        });

        break;
      }
    }

    if (plannedOrders.length === 0)
    {
      logLine(lineState, `Order does not fit on line.`, {
        line: lineState._id,
        orderNo
      });

      return;
    }

    let totalQuantityPlanned = 0;
    let totalDurationPlanned = 0;

    plannedOrders.forEach(lineOrder =>
    {
      totalQuantityPlanned += lineOrder.quantity;
      totalDurationPlanned += lineOrder.finishAt - lineOrder.startAt;
    });

    if (state.settings.minIncompleteDuration > 0
      && !oldLineState.completed
      && lineState.completed
      && orderState.quantityTodo - totalQuantityPlanned > 0
      && totalDurationPlanned < state.settings.minIncompleteDuration)
    {
      logLine(lineState, 'Order is too short to fit on line.', {
        line: lineState._id,
        orderNo,
        quantityRemaining: orderState.quantityTodo - totalQuantityPlanned,
        quantityPlanned: totalQuantityPlanned,
        durationPlanned: totalDurationPlanned / 60 / 1000
      });

      Object.assign(lineState, oldLineState);

      if (orderState.lineGroup && orderState.plannedOnLines.size === 0)
      {
        orderState.lineGroup = null;
      }

      return;
    }

    const lastPlannedOrder = _.last(plannedOrders);
    const prevPlannedOrder = plannedOrders[plannedOrders.length - 2];

    if (prevPlannedOrder
      && lastPlannedOrder.orderNo === prevPlannedOrder.orderNo
      && lastPlannedOrder.startAt.getTime() >= (state.date.getTime() + 24 * 3600 * 1000))
    {
      plannedOrders.pop();

      prevPlannedOrder.manHours += lastPlannedOrder.manHours;
      prevPlannedOrder.quantity += lastPlannedOrder.quantity;
    }

    orderState.quantityTodo -= totalQuantityPlanned;

    plannedOrders.forEach(lineOrder =>
    {
      lineState.hash += lineOrder._id
        + 0
        + lineOrder.quantity
        + lineOrder.startAt.getTime()
        + lineOrder.finishAt.getTime();
    });

    if (lineState.activeTime)
    {
      lineState.activeTime.from = moment.utc(_.last(plannedOrders).finishAt.getTime());
    }

    lineState.nextDowntime = nextDowntime;
    lineState.plannedOrders = lineState.plannedOrders.concat(plannedOrders);
    lineState.downtimes = lineState.downtimes.concat(downtimes);

    hourlyPlan.forEach((v, k) => lineState.hourlyPlan[k] += v);

    planOrder.incomplete = orderState.quantityTodo;

    if (planOrder.incomplete > 0)
    {
      state.newIncompleteOrders.set(orderNo, planOrder.incomplete);
      state.unfinishedOrders.set(orderState, lineState.forward);
    }
    else
    {
      state.newIncompleteOrders.delete(orderNo);
      state.unfinishedOrders.delete(orderState);
    }

    orderState.plannedOnLines.add(lineState);

    logLine(lineState, 'Order planned on line.', {
      line: lineState._id,
      orderNo,
      plannedOrders: plannedOrders.map(o => ({
        quantity: o.quantity,
        startAt: o.startAt,
        finishAt: o.finishAt
      })),
      quantityTodo: orderState.quantityTodo
    });
  }

  function completeLine(state, lineState, done)
  {
    if (!done)
    {
      done = () => {};
    }

    const oldPlanLine = state.oldPlanLines.get(lineState._id);
    const planLineI = state.plan.lines.findIndex(planLine => planLine._id === lineState._id);
    const locked = !!oldPlanLine && lineState.locked;

    lineState.completed = true;

    const newPlanLine = locked ? oldPlanLine : {
      _id: lineState._id,
      version: 1,
      hash: createHash('md5').update(lineState.hash).digest('hex'),
      orders: lineState.plannedOrders,
      downtimes: lineState.downtimes,
      hourlyPlan: lineState.hourlyPlan,
      shiftData: null,
      frozenOrders: []
    };

    lineState.finalHash = newPlanLine.hash;

    if (!oldPlanLine)
    {
      calcShiftData(newPlanLine);

      if (planLineI !== -1)
      {
        state.plan.lines[planLineI] = newPlanLine;
      }
      else
      {
        state.plan.lines.push(newPlanLine);
      }

      state.changes.changedLines.set(newPlanLine._id, {
        _id: newPlanLine._id,
        version: newPlanLine.version
      });

      state.log('Completed new line!', {line: lineState._id});

      return setImmediate(done);
    }

    if (oldPlanLine.hash !== newPlanLine.hash)
    {
      calcShiftData(newPlanLine);

      if (lineState.initialHash !== newPlanLine.hash)
      {
        newPlanLine.version = oldPlanLine.version + 1;

        state.changes.changedLines.set(oldPlanLine._id, {
          _id: oldPlanLine._id,
          version: oldPlanLine.version
        });
      }

      if (planLineI !== -1)
      {
        state.plan.lines[planLineI] = newPlanLine;
      }
      else
      {
        state.plan.lines.push(newPlanLine);
      }

      state.log('Completed existing line with changes!', {
        line: lineState._id,
        newVersion: oldPlanLine.version
      });

      state.linesWithChanges.add(lineState);

      return setImmediate(done);
    }

    if (locked)
    {
      oldPlanLine.orders.forEach(lineOrder =>
      {
        const orderState = state.orderStates.get(lineOrder.orderNo);

        if (!orderState)
        {
          return;
        }

        const {planOrder} = orderState;

        orderState.quantityTodo -= lineOrder.quantity;
        planOrder.incomplete = Math.max(0, orderState.quantityTodo);

        if (planOrder.incomplete)
        {
          state.newIncompleteOrders.set(planOrder._id, planOrder.incomplete);
        }
        else
        {
          state.newIncompleteOrders.delete(planOrder._id);
        }
      });
    }

    state.log('Completed existing line with no changes!', {
      line: lineState._id,
      locked
    });

    setImmediate(done);
  }

  function calcShiftData(planLine)
  {
    const shiftData = [
      {startAt: null, finishAt: null, manHours: 0, quantity: 0, orderCount: 0},
      {startAt: null, finishAt: null, manHours: 0, quantity: 0, orderCount: 0},
      {startAt: null, finishAt: null, manHours: 0, quantity: 0, orderCount: 0},
      {startAt: null, finishAt: null, manHours: 0, quantity: 0, orderCount: 0}
    ];
    const total = shiftData[0];

    planLine.orders.forEach(planLineOrder =>
    {
      const h = planLineOrder.startAt.getUTCHours();
      const shift = shiftData[h >= 6 && h < 14 ? 1 : h >= 14 && h < 22 ? 2 : 3];

      if (!shift.startAt)
      {
        shift.startAt = planLineOrder.startAt;
      }

      shift.finishAt = planLineOrder.finishAt;
      shift.manHours += planLineOrder.manHours;
      shift.quantity += planLineOrder.quantity;
      shift.orderCount += 1;

      if (!total.startAt)
      {
        total.startAt = planLineOrder.startAt;
      }

      total.finishAt = planLineOrder.finishAt;
      total.manHours += planLineOrder.manHours;
      total.quantity += planLineOrder.quantity;
      total.orderCount += 1;
    });

    shiftData.forEach(shift =>
    {
      shift.manHours = Math.round(shift.manHours * 1000) / 1000;
    });

    planLine.shiftData = shiftData;
  }

  function getNextOrderForLine(state, lineState)
  {
    logLine(lineState, 'Resolving next order for line...', {
      line: lineState._id
    });

    while (lineState.orderStateQueue.length)
    {
      const {orderGroup, orderStates} = lineState.orderStateQueue[0];

      if (ORDER_KINDS.every(kind => orderStates[kind].length === 0))
      {
        logLine(lineState, 'Emptied order group.', {line: lineState._id, orderGroup: orderGroup.name});

        lineState.orderStateQueue.shift();

        continue;
      }

      const kind = lineState.orderPriority[lineState.orderPriorityI];

      lineState.orderPriorityI += 1;

      if (lineState.orderPriorityI === lineState.orderPriority.length)
      {
        lineState.orderPriorityI = 0;
      }

      while (orderStates[kind].length && orderStates[kind][0].quantityTodo === 0)
      {
        orderStates[kind].shift();
      }

      if (orderStates[kind].length === 0)
      {
        logLine(lineState, 'Emptied order kind.', {line: lineState._id, orderGroup: orderGroup.name, kind});

        continue;
      }

      return {
        orderState: orderStates[kind].shift(),
        orderGroup
      };
    }

    logLine(lineState, 'No order found!', {
      line: lineState._id
    });

    return {
      orderState: null,
      orderGroup: null
    };
  }

  function getNextLineOrderId(orderId, shiftNo, linePlannedOrders, newPlannedOrders)
  {
    return `${orderId}-${shiftNo}-${1 + linePlannedOrders.length + newPlannedOrders.length}`;
  }

  function getPceTime(planOrder, workerCount, mrpSettings)
  {
    if (!planOrder.operation.laborTime || !workerCount)
    {
      return 0;
    }

    const {schedulingRate, taktTimeCoeff} = mrpSettings;

    return Math.ceil(
      planOrder.operation.laborTime / 100 / workerCount * 3600
        * schedulingRate
        * taktTimeCoeff(planOrder)
    ) * 1000;
  }

  function getManHours(planOrder, quantityTodo, mrpSettings)
  {
    if (!planOrder.operation.laborTime)
    {
      return 0;
    }

    const {schedulingRate, taktTimeCoeff} = mrpSettings;

    return ((planOrder.operation.laborTime / 100 * quantityTodo) + planOrder.operation.laborSetupTime)
      * schedulingRate
      * taktTimeCoeff(planOrder);
  }

  function getOrderStartOverhead(settings, lineState, orderState)
  {
    if (lineState.completed)
    {
      return 0;
    }

    const shiftStartTimes = settings.shiftStartTimes;
    const {
      extraOrderSeconds,
      extraShiftSeconds,
      schedulingRate,
      taktTimeCoeff
    } = settings.mrp(orderState.planOrder.mrp);
    const hours = lineState.activeTime.from.hours();
    const seconds = lineState.activeTime.from.minutes() * 60;
    const laborSetupTime = orderState.planOrder.operation.laborSetupTime
      * schedulingRate
      * taktTimeCoeff(orderState.planOrder);
    let shiftStartTime = 0;
    let extraShiftStartTime = 0;

    if (hours === 6 && seconds < extraShiftSeconds[0])
    {
      shiftStartTime = shiftStartTimes[0];
      extraShiftStartTime = extraShiftSeconds[0] * 1000;
    }
    else if (hours === 14 && seconds < extraShiftSeconds[1])
    {
      shiftStartTime = shiftStartTimes[1];
      extraShiftStartTime = extraShiftSeconds[1] * 1000;
    }
    else if (hours === 22 && seconds < extraShiftSeconds[2])
    {
      shiftStartTime = shiftStartTimes[2];
      extraShiftStartTime = extraShiftSeconds[2] * 1000;
    }
    else
    {
      return (extraOrderSeconds * 1000) + laborSetupTime;
    }

    const orderStartAt = lineState.activeTime.from.valueOf();
    const startDowntimeFinishAt = shiftStartTime + extraShiftStartTime;

    if (orderStartAt >= startDowntimeFinishAt)
    {
      return (extraOrderSeconds * 1000) + laborSetupTime;
    }

    return (extraShiftStartTime - (orderStartAt - shiftStartTime)) + laborSetupTime;
  }

  function recountHourlyPlan(planLine)
  {
    for (let i = 0; i < 24; ++i)
    {
      planLine.hourlyPlan[i] = 0;
    }

    planLine.orders.forEach(lineOrder =>
    {
      for (let i = 0; i < lineOrder.pceTimes.length; i += 2)
      {
        planLine.hourlyPlan[HOUR_TO_INDEX[lineOrder.pceTimes[i]]] += 1;
      }
    });
  }

  function getRemainingAvailableTime(lineState)
  {
    let remainingTime = 0;

    [lineState.activeTime].concat(lineState.activeTimes).forEach(activeTime =>
    {
      remainingTime += activeTime.to.valueOf() - activeTime.from.valueOf();
    });

    return remainingTime;
  }

  function calcExtraCapacity(activeTimes, extraCapacity)
  {
    if (!extraCapacity || extraCapacity === '0' || !activeTimes.length)
    {
      return 0;
    }

    if (extraCapacity.endsWith('%'))
    {
      const rel = parseInt(extraCapacity, 10) / 100;

      if (!rel || rel < 1)
      {
        return 0;
      }

      let availableCapacity = 0;

      activeTimes.forEach(activeTime =>
      {
        availableCapacity += activeTime.to.valueOf() - activeTime.from.valueOf();
      });

      return availableCapacity * rel;
    }

    const abs = parseInt(extraCapacity, 10);

    if (abs >= 1)
    {
      return abs * 60 * 1000;
    }

    return 0;
  }
};
