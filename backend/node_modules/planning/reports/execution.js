// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');
const moment = require('moment');
const {formatDateUtc} = require('util/dateFormatter');
const resolveBestOperation = require('util/resolveBestOperation');

exports.id = 'planning/execution';

exports.models = [
  require('planning/models/plan'),
  require('planning/models/planSettings'),
  require('orders/models/order'),
  require('prodShiftOrders/models/prodShiftOrder')
];

exports.report = (app, {Plan, PlanSettings, Order, ProdShiftOrder}, options, done) =>
{
  const results = {
    options,
    data: []
  };

  const stats = new Map();
  const usedMrps = new Set(options.mrps);
  const usedLines = new Set(options.lines);

  step(
    function()
    {
      const dateQueue = [];
      const nextMoment = moment.utc(options.fromTime);

      while (nextMoment.valueOf() < options.toTime)
      {
        dateQueue.push(new Date(nextMoment.valueOf()));
        nextMoment.add(1, 'days');
      }

      doNextDate(dateQueue, this.next());
    },
    function(err)
    {
      if (err)
      {
        return this.skip(err);
      }

      results.data = [];

      stats.forEach(d =>
      {
        d.manHours.todo = round(d.manHours.todo);
        d.manHours.late = round(d.manHours.late);
        d.manHours.plan = round(d.manHours.plan);
        d.manHours.remaining = round(d.manHours.remaining);

        results.data.push(d);
      });

      const cmpOptions = {
        numeric: true,
        ignorePunctuation: true
      };

      results.data.sort((a, b) =>
      {
        if (a.date === null && b.date !== null)
        {
          return -1;
        }

        if (b.date === null && a.date !== null)
        {
          return 1;
        }

        if (a.date && b.date && a.date !== b.date)
        {
          return a.date - b.date;
        }

        if (a.mrp === null && b.mrp !== null)
        {
          return -1;
        }

        if (b.mrp === null && a.mrp !== null)
        {
          return 1;
        }

        if (a.mrp && b.mrp)
        {
          const cmp = a.mrp.localeCompare(b.mrp, undefined, cmpOptions);

          if (cmp)
          {
            return cmp;
          }
        }

        if (a.line === null && b.line !== null)
        {
          return -1;
        }

        if (b.line === null && a.line !== null)
        {
          return 1;
        }

        if (a.line === b.line)
        {
          return 0;
        }

        return a.line.localeCompare(b.line, undefined, cmpOptions);
      });

      results.data.forEach(d =>
      {
        if (d.date)
        {
          d.date = formatDateUtc(d.date);
        }
      });
    },
    function(err)
    {
      done(err, results);
    }
  );

  function doNextDate(dateQueue, done)
  {
    const date = dateQueue.shift();

    if (!date)
    {
      return done();
    }

    const totalStats = getStats(null, null, null);

    step(
      function()
      {
        Plan
          .findById(date)
          .select({
            _id: 0,
            'orders._id': 1,
            'orders.mrp': 1,
            'orders.manHours': 1,
            'orders.quantityPlan': 1,
            'orders.quantityTodo': 1,
            'orders.quantityDone': 1,
            'orders.operation.no': 1,
            'orders.operation.laborTime': 1,
            'orders.operation.laborSetupTime': 1,
            'lines._id': 1,
            'lines.orders.orderNo': 1,
            'lines.orders.startAt': 1,
            'lines.orders.quantity': 1,
            'lines.orders.manHours': 1
          })
          .lean()
          .exec(this.parallel());

        PlanSettings
          .findById(date)
          .select({
            _id: 0,
            useRemainingQuantity: 1,
            requiredStatuses: 1,
            ignoredStatuses: 1,
            schedulingRate: 1,
            'mrps._id': 1
          })
          .lean()
          .exec(this.parallel());
      },
      function(err, plan, planSettings)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!planSettings || !plan)
        {
          return this.skip();
        }

        this.planSettings = planSettings;
        this.planOrders = new Map();
        this.lineOrders = new Map();
        this.orderLines = new Map();

        plan.orders.forEach(planOrder =>
        {
          if (!usedMrps.size || usedMrps.has(planOrder.mrp))
          {
            this.planOrders.set(planOrder._id, planOrder);
          }
        });

        const usedLineOrders = new Set();

        plan.lines.forEach(planLine =>
        {
          if (!planLine.orders.length)
          {
            return;
          }

          if (!isUsedLine(planLine._id))
          {
            return;
          }

          this.lineOrders.set(planLine._id, planLine.orders);

          planLine.orders.forEach(planLineOrder =>
          {
            usedLineOrders.add(planLineOrder.orderNo);

            if (!this.orderLines.has(planLineOrder.orderNo))
            {
              this.orderLines.set(planLineOrder.orderNo, new Map());
            }

            const orderLines = this.orderLines.get(planLineOrder.orderNo);

            if (!orderLines.has(planLine._id))
            {
              orderLines.set(planLine._id, new Set());
            }

            orderLines.get(planLine._id).add(planLineOrder);
          });
        });

        if (!usedMrps.size && usedLines.size)
        {
          this.planOrders.forEach(planOrder =>
          {
            if (!usedLineOrders.has(planOrder._id))
            {
              this.planOrders.delete(planOrder._id);
            }
          });
        }

        setImmediate(this.next());
      },
      function()
      {
        const orderIds = Array.from(this.planOrders.keys());

        Order
          .find({_id: {$in: orderIds}})
          .select({
            qty: 1,
            'qtyDone.total': 1,
            'qtyDone.byOperation': 1,
            statuses: 1
          })
          .lean()
          .exec(this.parallel());

        const localMoment = moment(moment.utc(date).format('YYYY-MM-DD'), 'YYYY-MM-DD').hours(6);

        ProdShiftOrder
          .find({
            orderId: {$in: orderIds},
            startedAt: {
              $gte: new Date(localMoment.valueOf()),
              $lt: new Date(localMoment.add(1, 'days').valueOf())
            }
          })
          .select({
            prodLine: 1,
            shift: 1,
            quantityDone: 1,
            orderId: 1
          })
          .lean()
          .exec(this.parallel());

        Order
          .find({
            scheduledStartDate: {
              $lt: new Date(localMoment.subtract(1, 'days').hours(0).valueOf()),
              $gte: localMoment.subtract(3, 'days').toDate()
            },
            mrp: {$in: usedMrps.size ? Array.from(usedMrps) : this.planSettings.mrps.map(mrp => mrp._id)},
            statuses: {
              $all: this.planSettings.requiredStatuses,
              $nin: this.planSettings.ignoredStatuses
            }
          })
          .select({
            mrp: 1,
            qty: 1,
            'qtyDone.total': 1,
            'qtyDone.byOperation': 1,
            operations: 1
          })
          .lean()
          .exec(this.parallel());
      },
      function(err, sapOrders, shiftOrders, lateOrders)
      {
        if (err)
        {
          return this.skip(err);
        }

        this.sapOrders = new Map();

        sapOrders.forEach(sapOrder =>
        {
          this.sapOrders.set(sapOrder._id, sapOrder);
        });

        this.shiftOrders = new Map();

        shiftOrders.forEach(shiftOrder =>
        {
          const byLine = this.shiftOrders;
          const {prodLine, shift, orderId} = shiftOrder;

          if (!byLine[prodLine])
          {
            byLine[prodLine] = {};
          }

          if (!byLine[prodLine][shift])
          {
            byLine[prodLine][shift] = {};
          }

          if (!byLine[prodLine][shift][orderId])
          {
            byLine[prodLine][shift][orderId] = [];
          }

          byLine[prodLine][shift][orderId].push(shiftOrder);
        });

        this.lateOrders = lateOrders
          .filter(o => !o.qtyDone || !o.qtyDone.total || o.qtyDone.total < o.qty)
          .map(o => {
            const operation = _.pick(resolveBestOperation(o.operations), Plan.OPERATION_PROPERTIES);
            const quantityTodo = o.qty;
            let quantityDone = 0;

            if (o.qtyDone)
            {
              if (operation && o.qtyDone.byOperation)
              {
                quantityDone = o.qtyDone.byOperation[operation.no] || 0;
              }
              else if (o.total)
              {
                quantityDone = o.total;
              }
            }

            const quantityRemaining = this.planSettings.useRemainingQuantity
              ? Math.max(0, quantityTodo - quantityDone)
              : quantityTodo;
            const manHours = operation
              ? ((operation.laborTime / 100 * quantityRemaining) + operation.laborSetupTime)
              : 0;

            return {
              _id: o._id,
              mrp: o.mrp,
              quantityTodo,
              quantityDone,
              manHours,
              operation
            };
          });

        setImmediate(this.next());
      },
      function()
      {
        const dateStats = getStats(date, null, null);
        const usedStats = new Set();

        this.lineOrders.forEach((lineOrders, line) =>
        {
          lineOrders.forEach(lineOrder =>
          {
            const planOrder = this.planOrders.get(lineOrder.orderNo);

            if (!planOrder || (!isUsedMrp(planOrder.mrp) && !isUsedLine(line)))
            {
              return;
            }

            lineOrder.shiftNo = getShiftNo(lineOrder.startAt);
            lineOrder.quantityDone = getShiftOrderQtyDone(this.shiftOrders, line, lineOrder.shiftNo, planOrder._id);

            const mrpStats = getStats(date, planOrder.mrp, null);
            const lineStats = getStats(date, planOrder.mrp, line);

            [totalStats, dateStats, mrpStats, lineStats].forEach(stats =>
            {
              usedStats.add(stats);

              stats.manHours.plan += lineOrder.manHours;
              stats.quantity.plan += lineOrder.quantity;
              stats.orders.plan += 1;
              stats.execution[0].plan += lineOrder.quantity;
              stats.execution[0].done += lineOrder.quantityDone;
              stats.execution[lineOrder.shiftNo].plan += lineOrder.quantity;
              stats.execution[lineOrder.shiftNo].done += lineOrder.quantityDone;
            });
          });
        });

        usedStats.forEach(stats =>
        {
          stats.execution.forEach(execution =>
          {
            execution.percent = execution.plan
              ? Math.round(execution.done / execution.plan * 100)
              : 100;
          });
        });

        this.planOrders.forEach(planOrder =>
        {
          const sapOrder = this.sapOrders.get(planOrder._id);

          if (!sapOrder || !isUsedMrp(planOrder.mrp))
          {
            return;
          }

          const quantityRemaining = sapOrder.qty - getSapOrderQtyDone(sapOrder, planOrder);
          const manHoursRemaining = getManHours(this.planSettings, planOrder, quantityRemaining);
          const quantityTodo = getPlanOrderQtyTodo(this.planSettings, planOrder);

          const mrpStats = getStats(date, planOrder.mrp, null);

          [totalStats, dateStats, mrpStats].forEach(stats =>
          {
            stats.manHours.todo += planOrder.manHours;
            stats.quantity.todo += quantityTodo;
            stats.orders.todo += 1;
            stats.manHours.remaining += manHoursRemaining;
            stats.quantity.remaining += quantityRemaining;
            stats.orders.remaining += quantityRemaining > 0 ? 1 : 0;
          });

          (this.orderLines.get(planOrder._id) || []).forEach((lineOrders, line) =>
          {
            if (!isUsedLine(line))
            {
              return;
            }

            const lineStats = getStats(date, planOrder.mrp, line);

            lineOrders.forEach(lineOrder =>
            {
              const quantityRemaining = lineOrder.quantity - lineOrder.quantityDone;

              lineStats.manHours.todo += lineOrder.manHours;
              lineStats.quantity.todo += lineOrder.quantity;
              lineStats.orders.todo += 1;
              lineStats.manHours.remaining += getManHours(this.planSettings, planOrder, quantityRemaining);
              lineStats.quantity.remaining += quantityRemaining;
              lineStats.orders.remaining += quantityRemaining > 0 ? 1 : 0;
            });
          });
        });

        this.lateOrders.forEach(lateOrder =>
        {
          const mrpStats = getStats(date, lateOrder.mrp, null);

          if (!this.planOrders.has(lateOrder._id))
          {
            mrpStats.manHours.late += lateOrder.manHours;
            mrpStats.quantity.late += getLateOrderQtyTodo(this.planSettings, lateOrder);
            mrpStats.orders.late += 1;
          }
        });
      },
      function(err)
      {
        if (err)
        {
          return done(err);
        }

        setImmediate(doNextDate, dateQueue, done);
      }
    );
  }

  function isUsedMrp(mrp)
  {
    return usedMrps.size === 0 || usedMrps.has(mrp);
  }

  function isUsedLine(line)
  {
    return usedLines.size === 0 || usedLines.has(line);
  }

  function getShiftNo(date)
  {
    const h = date.getUTCHours();

    return h >= 6 && h < 14 ? 1 : h >= 14 && h < 22 ? 2 : 3;
  }

  function getShiftOrderQtyDone(byLine, line, shift, orderNo)
  {
    const shiftOrders = byLine[line] && byLine[line][shift] && byLine[line][shift][orderNo];

    return shiftOrders
      ? shiftOrders.reduce((total, pso) => total + (pso.quantityDone || 0), 0)
      : 0;
  }

  function getPlanOrderQtyTodo(planSettings, planOrder)
  {
    if (planOrder.quantityPlan > 0)
    {
      return planOrder.quantityPlan;
    }

    if (planSettings.useRemainingQuantity)
    {
      return Math.max(0, planOrder.quantityTodo - planOrder.quantityDone);
    }

    return planOrder.quantityTodo;
  }

  function getSapOrderQtyDone(sapOrder, planOrder)
  {
    if (planOrder.operation)
    {
      return sapOrder.qtyDone.byOperation && sapOrder.qtyDone.byOperation[planOrder.operation.no] || 0;
    }

    return sapOrder.qtyDone.total || 0;
  }

  function getLateOrderQtyTodo(planSettings, lateOrder)
  {
    if (planSettings.useRemainingQuantity)
    {
      return Math.max(0, lateOrder.quantityTodo - lateOrder.quantityDone);
    }

    return lateOrder.quantityTodo;
  }

  function getManHours(planSettings, planOrder, quantity)
  {
    if (quantity <= 0)
    {
      return 0;
    }

    const operation = planOrder.operation;

    if (!operation.laborTime)
    {
      return 0;
    }

    const schedulingRate = planSettings.schedulingRate[planOrder.mrp] || planSettings.schedulingRate.ANY || 1;

    return ((operation.laborTime / 100 * quantity) + operation.laborSetupTime) * schedulingRate;
  }

  function getStats(date, mrp, line)
  {
    const key = `${date ? date.getTime() : null}:${mrp}:${line}`;

    if (!stats.has(key))
    {
      stats.set(key, {
        date,
        mrp,
        line,
        manHours: {
          todo: 0,
          late: 0,
          plan: 0,
          remaining: 0
        },
        quantity: {
          todo: 0,
          late: 0,
          plan: 0,
          remaining: 0
        },
        orders: {
          todo: 0,
          late: 0,
          plan: 0,
          remaining: 0
        },
        execution: [
          {
            plan: 0,
            done: 0,
            percent: 0
          },
          {
            plan: 0,
            done: 0,
            percent: 0
          },
          {
            plan: 0,
            done: 0,
            percent: 0
          },
          {
            plan: 0,
            done: 0,
            percent: 0
          }
        ]
      });
    }

    return stats.get(key);
  }

  function round(n)
  {
    return Math.round(n * 10) / 10;
  }
};
