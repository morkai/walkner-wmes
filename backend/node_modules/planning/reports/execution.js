// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');
const moment = require('moment');
const {formatDateUtc} = require('util/dateFormatter');
const resolveBestOperation = require('util/resolveBestOperation');
const shifts = require('util/shifts');

exports.id = 'planning/execution';

exports.models = [
  require('planning/models/plan'),
  require('planning/models/planSettings'),
  require('orders/models/order'),
  require('prodShiftOrders/models/prodShiftOrder'),
  require('reports/models/dailyMrpCount')
];

exports.report = (app, module, options, done) =>
{
  const {
    Plan,
    PlanSettings,
    Order,
    ProdShiftOrder,
    DailyMrpCount
  } = module;

  const results = {
    options,
    data: []
  };

  const stats = new Map();
  const usedMrps = new Set(options.mrps);
  const usedLines = new Set(options.lines);

  step(
    function()
    {
      const dateQueue = [];
      const nextMoment = moment.utc(options.fromTime);

      while (nextMoment.valueOf() < options.toTime)
      {
        dateQueue.push(new Date(nextMoment.valueOf()));
        nextMoment.add(1, 'days');
      }

      doNextDate(dateQueue, this.next());
    },
    function(err)
    {
      if (err)
      {
        return this.skip(err);
      }

      results.data = [];

      stats.forEach(d =>
      {
        d.manHours.todo = round(d.manHours.todo);
        d.manHours.late = round(d.manHours.late);
        d.manHours.plan = round(d.manHours.plan);
        d.manHours.remaining = round(d.manHours.remaining);

        results.data.push(d);
      });

      const cmpOptions = {
        numeric: true,
        ignorePunctuation: true
      };

      results.data.sort((a, b) =>
      {
        if (a.date === null && b.date !== null)
        {
          return -1;
        }

        if (b.date === null && a.date !== null)
        {
          return 1;
        }

        if (a.date && b.date && a.date !== b.date)
        {
          return a.date - b.date;
        }

        if (a.division === null && b.division !== null)
        {
          return -1;
        }

        if (b.division === null && a.division !== null)
        {
          return 1;
        }

        if (a.division && b.division)
        {
          const cmp = a.division.join('').localeCompare(b.division.join(''), undefined, cmpOptions);

          if (cmp)
          {
            return cmp;
          }
        }

        if (a.mrp === null && b.mrp !== null)
        {
          return -1;
        }

        if (b.mrp === null && a.mrp !== null)
        {
          return 1;
        }

        if (a.mrp && b.mrp)
        {
          const cmp = a.mrp.localeCompare(b.mrp, undefined, cmpOptions);

          if (cmp)
          {
            return cmp;
          }
        }

        if (a.line === null && b.line !== null)
        {
          return -1;
        }

        if (b.line === null && a.line !== null)
        {
          return 1;
        }

        if (a.line === b.line)
        {
          return 0;
        }

        return a.line.localeCompare(b.line, undefined, cmpOptions);
      });

      results.data.forEach(d =>
      {
        if (d.date)
        {
          d.date = formatDateUtc(d.date);
        }
      });
    },
    function(err)
    {
      done(err, results);
    }
  );

  function doNextDate(dateQueue, done)
  {
    const date = dateQueue.shift();

    if (!date)
    {
      return done();
    }

    const totalStats = getStats(null, null, null, null);

    step(
      function()
      {
        Plan
          .findById(date)
          .select({
            _id: 0,
            'orders._id': 1,
            'orders.mrp': 1,
            'orders.manHours': 1,
            'orders.quantityPlan': 1,
            'orders.quantityTodo': 1,
            'orders.quantityDone': 1,
            'orders.operation.no': 1,
            'orders.operation.laborTime': 1,
            'orders.operation.laborSetupTime': 1,
            'lines._id': 1,
            'lines.orders.orderNo': 1,
            'lines.orders.startAt': 1,
            'lines.orders.quantity': 1,
            'lines.orders.manHours': 1
          })
          .lean()
          .exec(this.parallel());

        PlanSettings
          .findById(date)
          .select({
            _id: 0,
            useRemainingQuantity: 1,
            requiredStatuses: 1,
            ignoredStatuses: 1,
            schedulingRate: 1,
            'mrps._id': 1
          })
          .lean()
          .exec(this.parallel());

        DailyMrpCount
          .find({_id: {
            $gt: moment.utc(date.getTime()).subtract(7, 'days').toDate(),
            $lte: date
          }})
          .select({
            'count.division': 1
          })
          .sort({
            _id: -1
          })
          .lean()
          .exec(this.parallel());
      },
      function(err, plan, planSettings, dailyMrpCounts)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!planSettings || !plan)
        {
          return this.skip();
        }

        this.planSettings = planSettings;
        this.planOrders = new Map();
        this.lineOrders = new Map();
        this.orderLines = new Map();
        this.mrpToDivisions = new Map();

        dailyMrpCounts.forEach(dailyMrpCount =>
        {
          Object.keys(dailyMrpCount.count.division).forEach(division =>
          {
            dailyMrpCount.count.division[division].forEach(mrp =>
            {
              if (!this.mrpToDivisions.has(mrp))
              {
                this.mrpToDivisions.set(mrp, new Set());
              }

              this.mrpToDivisions.get(mrp).add(division);
            });
          });
        });

        this.mrpToDivisions.forEach((divisions, mrp) =>
        {
          this.mrpToDivisions.set(mrp, Array.from(divisions));
        });

        plan.orders.forEach(planOrder =>
        {
          if (!usedMrps.size || usedMrps.has(planOrder.mrp))
          {
            this.planOrders.set(planOrder._id, planOrder);
          }
        });

        const usedLineOrders = new Set();

        plan.lines.forEach(planLine =>
        {
          if (!planLine.orders.length)
          {
            return;
          }

          if (!isUsedLine(planLine._id))
          {
            return;
          }

          this.lineOrders.set(planLine._id, planLine.orders);

          planLine.orders.forEach(planLineOrder =>
          {
            usedLineOrders.add(planLineOrder.orderNo);

            if (!this.orderLines.has(planLineOrder.orderNo))
            {
              this.orderLines.set(planLineOrder.orderNo, new Map());
            }

            const orderLines = this.orderLines.get(planLineOrder.orderNo);

            if (!orderLines.has(planLine._id))
            {
              orderLines.set(planLine._id, new Set());
            }

            orderLines.get(planLine._id).add(planLineOrder);
          });
        });

        if (!usedMrps.size && usedLines.size)
        {
          this.planOrders.forEach(planOrder =>
          {
            if (!usedLineOrders.has(planOrder._id))
            {
              this.planOrders.delete(planOrder._id);
            }
          });
        }

        setImmediate(this.next());
      },
      function()
      {
        const orderIds = Array.from(this.planOrders.keys());

        Order
          .find({_id: {$in: orderIds}})
          .select({
            qty: 1,
            'qtyDone.total': 1,
            'qtyDone.byOperation': 1,
            statuses: 1
          })
          .lean()
          .exec(this.parallel());

        const localMoment = moment(moment.utc(date).format('YYYY-MM-DD'), 'YYYY-MM-DD').hours(6);

        ProdShiftOrder
          .find({
            orderId: {$in: orderIds}
          })
          .select({
            prodLine: 1,
            shift: 1,
            quantityDone: 1,
            orderId: 1,
            operationNo: 1,
            startedAt: 1
          })
          .lean()
          .exec(this.parallel());

        Order
          .find({
            scheduledStartDate: {
              $lt: new Date(localMoment.subtract(1, 'days').hours(0).valueOf()),
              $gte: localMoment.subtract(3, 'days').toDate()
            },
            mrp: {$in: usedMrps.size ? Array.from(usedMrps) : this.planSettings.mrps.map(mrp => mrp._id)},
            statuses: {
              $all: this.planSettings.requiredStatuses,
              $nin: this.planSettings.ignoredStatuses
            }
          })
          .select({
            mrp: 1,
            qty: 1,
            'qtyDone.total': 1,
            'qtyDone.byOperation': 1,
            operations: 1
          })
          .lean()
          .exec(this.parallel());
      },
      function(err, sapOrders, shiftOrders, lateOrders)
      {
        if (err)
        {
          return this.skip(err);
        }

        this.sapOrders = new Map();

        sapOrders.forEach(sapOrder =>
        {
          this.sapOrders.set(sapOrder._id, sapOrder);
        });

        this.shiftOrders = {};

        shiftOrders.forEach(shiftOrder =>
        {
          if (!this.shiftOrders[shiftOrder.prodLine])
          {
            this.shiftOrders[shiftOrder.prodLine] = [];
          }

          this.shiftOrders[shiftOrder.prodLine].push(shiftOrder);
        });

        this.lateOrders = lateOrders
          .filter(o => !o.qtyDone || !o.qtyDone.total || o.qtyDone.total < o.qty)
          .map(o => {
            const operation = _.pick(resolveBestOperation(o.operations), Plan.OPERATION_PROPERTIES);
            const quantityTodo = o.qty;
            let quantityDone = 0;

            if (o.qtyDone)
            {
              if (operation && o.qtyDone.byOperation)
              {
                quantityDone = o.qtyDone.byOperation[operation.no] || 0;
              }
              else if (o.total)
              {
                quantityDone = o.total;
              }
            }

            const quantityRemaining = this.planSettings.useRemainingQuantity
              ? Math.max(0, quantityTodo - quantityDone)
              : quantityTodo;
            const manHours = operation
              ? ((operation.laborTime / 100 * quantityRemaining) + operation.laborSetupTime)
              : 0;

            return {
              _id: o._id,
              mrp: o.mrp,
              quantityTodo,
              quantityDone,
              manHours,
              operation
            };
          });

        setImmediate(this.next());
      },
      function()
      {
        const dateStats = getStats(date, null, null, null);
        const usedStats = new Set();

        this.lineOrders.forEach((lineOrders, line) =>
        {
          lineOrders.forEach(lineOrder =>
          {
            const planOrder = this.planOrders.get(lineOrder.orderNo);

            if (!planOrder || (!isUsedMrp(planOrder.mrp) && !isUsedLine(line)))
            {
              return;
            }

            const execution = getLineOrderExecution(this.shiftOrders[line] || [], lineOrder, planOrder);
            const executed = execution.plannedQuantitiesDone.some(quantityDone => quantityDone === lineOrder.quantity);

            lineOrder.shiftNo = getShiftNo(lineOrder.startAt);
            lineOrder.quantityDone = execution.quantityDoneOnShift;

            const divisions = this.mrpToDivisions.get(planOrder.mrp) || ['LP?'];
            const totalDivisionStats = getStats(null, divisions, null, null);
            const dateDivisionStats = getStats(date, divisions, null, null);
            const mrpStats = getStats(date, divisions, planOrder.mrp, null);
            const lineStats = getStats(date, divisions, planOrder.mrp, line);

            [totalStats, dateStats, totalDivisionStats, dateDivisionStats, mrpStats, lineStats].forEach(stats =>
            {
              usedStats.add(stats);

              stats.manHours.plan += lineOrder.manHours;
              stats.quantity.plan += lineOrder.quantity;
              stats.orders.plan += 1;
              stats.execution[0].plan += 1;
              stats.execution[0].done += executed ? 1 : 0;
              stats.execution[lineOrder.shiftNo].plan += 1;
              stats.execution[lineOrder.shiftNo].done += lineOrder.quantityDone === lineOrder.quantity ? 1 : 0;

              if (executed)
              {
                stats.manHours.executed += lineOrder.manHours;
                stats.quantity.executed += lineOrder.quantity;
                stats.orders.executed += 1;
              }
            });
          });
        });

        usedStats.forEach(stats =>
        {
          stats.execution.forEach(execution =>
          {
            execution.percent = execution.plan
              ? Math.round(execution.done / execution.plan * 100)
              : 100;
          });
        });

        this.planOrders.forEach(planOrder =>
        {
          const sapOrder = this.sapOrders.get(planOrder._id);

          if (!sapOrder || !isUsedMrp(planOrder.mrp))
          {
            return;
          }

          const quantityRemaining = sapOrder.qty - getSapOrderQtyDone(sapOrder, planOrder);
          const manHoursRemaining = getManHours(this.planSettings, planOrder, quantityRemaining);
          const quantityTodo = getPlanOrderQtyTodo(this.planSettings, planOrder);

          const divisions = this.mrpToDivisions.get(planOrder.mrp) || ['LP?'];
          const totalDivisionStats = getStats(null, divisions, null, null);
          const dateDivisionStats = getStats(date, divisions, null, null);
          const mrpStats = getStats(date, divisions, planOrder.mrp, null);

          [totalStats, dateStats, totalDivisionStats, dateDivisionStats, mrpStats].forEach(stats =>
          {
            stats.manHours.todo += planOrder.manHours;
            stats.quantity.todo += quantityTodo;
            stats.orders.todo += 1;
            stats.manHours.remaining += manHoursRemaining;
            stats.quantity.remaining += quantityRemaining;
            stats.orders.remaining += quantityRemaining > 0 ? 1 : 0;
          });

          (this.orderLines.get(planOrder._id) || []).forEach((lineOrders, line) =>
          {
            if (!isUsedLine(line))
            {
              return;
            }

            const lineStats = getStats(date, divisions, planOrder.mrp, line);

            lineOrders.forEach(lineOrder =>
            {
              const quantityRemaining = lineOrder.quantity - lineOrder.quantityDone;

              lineStats.manHours.todo += lineOrder.manHours;
              lineStats.quantity.todo += lineOrder.quantity;
              lineStats.orders.todo += 1;
              lineStats.manHours.remaining += getManHours(this.planSettings, planOrder, quantityRemaining);
              lineStats.quantity.remaining += quantityRemaining;
              lineStats.orders.remaining += quantityRemaining > 0 ? 1 : 0;
            });
          });
        });

        this.lateOrders.forEach(lateOrder =>
        {
          if (this.planOrders.has(lateOrder._id))
          {
            return;
          }

          const divisions = this.mrpToDivisions.get(lateOrder.mrp) || ['LP?'];
          const totalDivisionStats = getStats(null, divisions, null, null);
          const dateDivisionStats = getStats(date, divisions, null, null);
          const mrpStats = getStats(date, divisions, lateOrder.mrp, null);

          [totalStats, dateStats, totalDivisionStats, dateDivisionStats, mrpStats].forEach(stats =>
          {
            stats.manHours.late += lateOrder.manHours;
            stats.quantity.late += getLateOrderQtyTodo(this.planSettings, lateOrder);
            stats.orders.late += 1;
          });
        });
      },
      function(err)
      {
        if (err)
        {
          return done(err);
        }

        setImmediate(doNextDate, dateQueue, done);
      }
    );
  }

  function isUsedMrp(mrp)
  {
    return usedMrps.size === 0 || usedMrps.has(mrp);
  }

  function isUsedLine(line)
  {
    return usedLines.size === 0 || usedLines.has(line);
  }

  function getShiftNo(date)
  {
    const h = date.getUTCHours();

    return h >= 6 && h < 14 ? 1 : h >= 14 && h < 22 ? 2 : 3;
  }

  function getLineOrderExecution(shiftOrders, lineOrder, planOrder)
  {
    const execution = {
      quantityDoneOnLine: 0,
      quantityDoneOnDay: 0,
      quantityDoneOnShift: 0,
      plannedQuantityDone: 0,
      plannedQuantitiesDone: []
    };

    if (!planOrder || !shiftOrders.length)
    {
      return execution;
    }

    if (!shiftOrders.length)
    {
      return execution;
    }

    const orderNo = lineOrder.orderNo;
    const utcStartAt = Date.parse(lineOrder.startAt);
    const localStartAt = moment.utc(utcStartAt).local(true).valueOf();
    const timeWindow = 240 * 60 * 1000;
    const fromTime = localStartAt - timeWindow;
    const toTime = localStartAt + timeWindow;
    const requiredOperationNo = planOrder.operation && planOrder.operation.no || null;
    const requiredShiftStartTime = shifts.getShiftInfo(localStartAt, false).startTime;
    const requiredShiftEndTime = requiredShiftStartTime + 24 * 3600 * 1000;

    shiftOrders.forEach(function(pso)
    {
      if (pso.orderId !== orderNo)
      {
        return;
      }

      const quantityDone = pso.quantityDone;

      if (!quantityDone)
      {
        return;
      }

      const actualOperationNo = pso.operationNo;

      if (!requiredOperationNo || !actualOperationNo || actualOperationNo !== requiredOperationNo)
      {
        return;
      }

      execution.quantityDoneOnLine += quantityDone;

      const startedAt = pso.startedAt.getTime();

      if (startedAt >= requiredShiftStartTime && startedAt <= requiredShiftEndTime)
      {
        execution.quantityDoneOnDay += quantityDone;
      }

      if (shifts.getShiftInfo(startedAt, false).startTime === requiredShiftStartTime)
      {
        execution.quantityDoneOnShift += quantityDone;
      }

      if (startedAt >= fromTime && startedAt <= toTime)
      {
        execution.plannedQuantityDone += quantityDone;
        execution.plannedQuantitiesDone.push(quantityDone);
      }
    });

    return execution;
  }

  function getPlanOrderQtyTodo(planSettings, planOrder)
  {
    if (planOrder.quantityPlan > 0)
    {
      return planOrder.quantityPlan;
    }

    if (planSettings.useRemainingQuantity)
    {
      return Math.max(0, planOrder.quantityTodo - planOrder.quantityDone);
    }

    return planOrder.quantityTodo;
  }

  function getSapOrderQtyDone(sapOrder, planOrder)
  {
    if (planOrder.operation)
    {
      return sapOrder.qtyDone.byOperation && sapOrder.qtyDone.byOperation[planOrder.operation.no] || 0;
    }

    return sapOrder.qtyDone.total || 0;
  }

  function getLateOrderQtyTodo(planSettings, lateOrder)
  {
    if (planSettings.useRemainingQuantity)
    {
      return Math.max(0, lateOrder.quantityTodo - lateOrder.quantityDone);
    }

    return lateOrder.quantityTodo;
  }

  function getManHours(planSettings, planOrder, quantity)
  {
    if (quantity <= 0)
    {
      return 0;
    }

    const operation = planOrder.operation;

    if (!operation.laborTime)
    {
      return 0;
    }

    const schedulingRate = planSettings.schedulingRate[planOrder.mrp] || planSettings.schedulingRate.ANY || 1;

    return ((operation.laborTime / 100 * quantity) + operation.laborSetupTime) * schedulingRate;
  }

  function getStats(date, division, mrp, line)
  {
    const key = `${date ? date.getTime() : null}:${division}:${mrp}:${line}`;

    if (!stats.has(key))
    {
      stats.set(key, {
        date,
        division,
        mrp,
        line,
        manHours: {
          todo: 0,
          late: 0,
          plan: 0,
          remaining: 0,
          executed: 0
        },
        quantity: {
          todo: 0,
          late: 0,
          plan: 0,
          remaining: 0,
          executed: 0
        },
        orders: {
          todo: 0,
          late: 0,
          plan: 0,
          remaining: 0,
          executed: 0
        },
        execution: [
          {
            plan: 0,
            done: 0,
            percent: 0
          },
          {
            plan: 0,
            done: 0,
            percent: 0
          },
          {
            plan: 0,
            done: 0,
            percent: 0
          },
          {
            plan: 0,
            done: 0,
            percent: 0
          }
        ]
      });
    }

    return stats.get(key);
  }

  function round(n)
  {
    return Math.round(n * 10) / 10;
  }
};
