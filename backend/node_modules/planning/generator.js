// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const {createHash} = require('crypto');
const _ = require('lodash');
const step = require('h5.step');
const moment = require('moment');
const jsonDeepEqual = require('util/jsonDeepEqual');
const levenSort = require('leven-sort');
const setUpAutoDowntimeCache = require('./autoDowntimeCache');

const ORDER_IGNORED_PROPERTIES = {
  incomplete: true
};
const ORDER_USER_PROPERTIES = [
  'quantityPlan',
  'lines',
  'ignored',
  'urgent'
];
const ORDER_URGENT_SOURCE = {
  plan: 1,
  added: 2,
  incomplete: 3,
  late: 4
};
const EMPTY_HOURLY_PLAN = [
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0
];
const HOUR_TO_INDEX = [
  18, 19, 20, 21, 22, 23, 0, 1,
  2, 3, 4, 5, 6, 7, 8, 9,
  10, 11, 12, 13, 14, 15, 16, 17
];

module.exports = (app, module) =>
{
  /* eslint-disable new-cap */

  if (!module.config.generator)
  {
    return;
  }

  const DEV = app.options.env === 'development';
  const UNFROZEN_PLANS = !DEV ? [] : [];
  const LOG_LINES = !DEV ? {} : {};
  const LOCK_LINES = true;
  const LOG = DEV;
  const AUTO_GENERATE_NEXT = !DEV;
  const AUTO_GENERATE_START = !!1;
  const COMPARE_ORDERS = true;
  const RESIZE_ORDERS = true;
  // sortSmallOrdersByManHours sortSmallOrdersByLeven sortOrdersByNameParts
  const ORDERS_SORTER = sortOrdersByNameParts;

  const log = LOG && DEV
    ? (...args) => module.debug(...args)
    : () => {};
  const logLine = (lineState, ...args) => !LOG_LINES || LOG_LINES[lineState._id]
    ? log(...args)
    : undefined;

  const mongoose = app[module.config.mongooseId];
  const Order = mongoose.model('Order');
  const PaintShopOrder = mongoose.model('PaintShopOrder');
  const Plan = mongoose.model('Plan');
  const PlanSettings = mongoose.model('PlanSettings');
  const PlanChange = mongoose.model('PlanChange');

  const orderNamePartsCache = new Map();
  const autoDowntimeCache = setUpAutoDowntimeCache(app, module);
  const generatorOptions = new Map();
  const generatorQueue = [];
  let generatorTimer = null;
  let generatorState = null;

  app.broker.subscribe('app.started').setLimit(1).on('message', () =>
  {
    if (!AUTO_GENERATE_START)
    {
      return;
    }

    if (DEV)
    {
      UNFROZEN_PLANS.forEach(generatePlan);

      if (UNFROZEN_PLANS.length)
      {
        return;
      }

      const m = moment();

      if (m.hours() < 6)
      {
        m.subtract(1, 'days');
      }

      generatePlan(m.startOf('day').add(1, 'days').format('YYYY-MM-DD'));
    }
    else
    {
      generateActivePlans();
    }

    scheduleNextLastPlanGeneration();
  });

  app.broker.subscribe('planning.generator.requested', handleRequest);

  function scheduleNextLastPlanGeneration()
  {
    const now = moment();

    if (now.hours() === 5 && now.minutes() === 59)
    {
      generatePlan(now.format('YYYY-MM-DD'));

      setTimeout(scheduleNextLastPlanGeneration, 23 * 3600 * 1000);

      return;
    }

    const next = moment().startOf('day');

    if (now.hours() >= 6)
    {
      next.add(1, 'day');
    }

    next.hours(5).minutes(59);

    const delay = next.valueOf() - now.valueOf();

    if (delay < 60000)
    {
      setTimeout(scheduleNextLastPlanGeneration, delay + 1000);
    }
    else
    {
      setTimeout(scheduleNextLastPlanGeneration, Math.round(delay * 0.9));
    }
  }

  function handleRequest(message)
  {
    module.debug('Received generate request...', {request: message});

    if (message.reloadAutoDowntimes)
    {
      autoDowntimeCache.clear();
    }

    if (!message.date)
    {
      generateActivePlans(!!message.freezeFirstShiftOrders);
    }
    else
    {
      generatePlan(message.date);
    }
  }

  function createPlanGeneratorState(key)
  {
    const options = generatorOptions.get(key) || {};
    const lastMinute = moment(key, 'YYYY-MM-DD').hours(5).minutes(59);
    const lastMinuteStartTime = lastMinute.valueOf();
    const lastMinuteEndTime = lastMinuteStartTime + 60000;
    const now = Date.now();
    const date = moment.utc(key, 'YYYY-MM-DD').toDate();

    return {
      key,
      date,
      time: date.getTime(),
      lastMinute: now >= lastMinuteStartTime && now < lastMinuteEndTime,
      freezeOrders: options.freezeOrders,
      lockedMrps: new Set(),
      lockedLines: new Set(),
      cancelled: false,
      new: false,
      generateCallCount: 0,
      resized: false,
      linesWithChanges: new Set(),
      settings: null,
      autoDowntimes: null,
      orders: null,
      sapOrders: new Map(),
      plan: null,
      orderStates: new Map(),
      orderStateQueues: null,
      lineStates: null,
      lineStateQueue: [],
      oldIncompleteOrders: new Map(),
      newIncompleteOrders: new Map(),
      incompleteOrders: new Map(),
      orderToLines: new Map(),
      resizedOrders: new Set(),
      hourlyPlanRecount: new Set(),
      unpainted: new Set(),
      grouping: {
        orderToGroups: new Map(),
        lineToGroups: new Map()
      },
      changes: {
        addedOrders: new Map(),
        removedOrders: new Map(),
        changedOrders: new Map(),
        changedLines: new Map()
      },
      log: message => module.info(`[generator] [${key}] ${message}`)
    };
  }

  function updateGeneratorOptions(planKey, options)
  {
    if (!generatorOptions.has(planKey))
    {
      generatorOptions.set(planKey, {});
    }

    Object.assign(generatorOptions.get(planKey), options);
  }

  function generateActivePlans(freezeOrders)
  {
    const plansToGenerate = {};
    const date = moment.utc().startOf('day');

    step(
      function()
      {
        Plan.findOne({}, {_id: 1}).sort({_id: -1}).lean().exec(this.parallel());

        Order.aggregate([
          {$match: {
            scheduledStartDate: {
              $gte: date.toDate(),
              $lt: date.clone().add(14, 'days').toDate()
            },
            statuses: {$in: ['REL'], $nin: ['TECO', 'DLT', 'DLFL']},
            'bom.0': {$exists: true}
          }},
          {$group: {_id: null, date: {$max: '$scheduledStartDate'}}}
        ], this.parallel());
      },
      function(err, latestPlan, latestOrders)
      {
        if (err)
        {
          module.error(`[generator] Failed to find active plans: ${err.message}`);
        }

        const now = moment();
        const h = now.hours();
        const today = now.format('YYYY-MM-DD');

        if (h < 5 || (h === 5 && now.minutes() < 59))
        {
          const planKey = today;

          // Today
          plansToGenerate[planKey] = true;

          updateGeneratorOptions(planKey, {freezeOrders});
        }

        const latestPlanTime = latestPlan ? latestPlan._id.getTime() : 0;
        const latestOrderTime = latestOrders && latestOrders.length
          ? moment.utc(moment(latestOrders[0].date).format('YYYY-MM-DD'), 'YYYY-MM-DD').valueOf()
          : 0;
        const maxPlanKey = moment.utc(Math.max(date.valueOf(), latestPlanTime, latestOrderTime)).format('YYYY-MM-DD');
        let nextPlanKey = null;

        if (maxPlanKey !== today)
        {
          do
          {
            nextPlanKey = now.add(1, 'day').format('YYYY-MM-DD');

            if (nextPlanKey === today)
            {
              continue;
            }

            plansToGenerate[nextPlanKey] = true;
          }
          while (nextPlanKey !== maxPlanKey);
        }

        Object.keys(plansToGenerate).forEach(date => generatePlan(date));
      }
    );
  }

  function generatePlan(date)
  {
    const dateMoment = moment.utc(date, 'YYYY-MM-DD').startOf('day');

    if (!dateMoment.isValid())
    {
      return;
    }

    const planKey = dateMoment.format('YYYY-MM-DD');

    if (!generatorQueue.includes(planKey))
    {
      generatorQueue.push(planKey);

      app.broker.publish('planning.generator.started', {
        date: planKey
      });
    }

    if (generatorState !== null)
    {
      module.info(`[generator] [${generatorState.key}] Cancelling...`);

      generatorState.cancelled = true;

      return;
    }

    if (generatorTimer !== null)
    {
      clearTimeout(generatorTimer);
    }

    generatorTimer = setTimeout(generateNextPlan, 1);
  }

  function generateNextPlan()
  {
    if (generatorState)
    {
      return;
    }

    const planKey = generatorQueue.sort((a, b) => a.localeCompare(b)).shift();

    if (!planKey)
    {
      return;
    }

    generatorTimer = null;
    generatorState = createPlanGeneratorState(planKey);

    tryGeneratePlan(generatorState, () =>
    {
      step(
        function()
        {
          const nextPlanId = moment.utc(generatorState.date.getTime()).add(1, 'days').toDate();

          Plan.findById(nextPlanId, {_id: 1}).lean().exec(this.next());
        },
        function(err, nextPlan)
        {
          if (err)
          {
            module.error(`[generator] Failed to find the next plan: ${err.message}`);
          }

          if (generatorState.cancelled && !generatorQueue.includes(planKey))
          {
            generatorQueue.push(planKey);
          }

          if (!generatorQueue.includes(planKey))
          {
            generatorOptions.delete(planKey);
          }

          if (AUTO_GENERATE_NEXT && nextPlan)
          {
            const nextPlanKey = moment.utc(nextPlan._id).format('YYYY-MM-DD');

            if (!generatorQueue.includes(nextPlanKey))
            {
              generatorQueue.push(nextPlanKey);
            }
          }

          generatorState = null;

          if (generatorTimer !== null)
          {
            clearTimeout(generatorTimer);
          }

          generatorTimer = setTimeout(generateNextPlan, 1);
        }
      );
    });
  }

  function tryGeneratePlan(state, done)
  {
    const startedAt = Date.now();

    state.log(`Started...`);

    step(
      function checkFrozenStep()
      {
        const currentDay = moment();

        if (currentDay.hours() < 6)
        {
          currentDay.subtract(1, 'days');
        }

        if (!UNFROZEN_PLANS.includes(state.key) && state.date <= currentDay.toDate())
        {
          this.skip(new Error('Plan is frozen.'));
        }
      },
      function waitToCalmDownStep()
      {
        waitToCalmDown(state, 0, this.next());
      },
      function loadSettingsStep(err)
      {
        if (err)
        {
          return this.skip(new Error(`Failed to wait to calm down: ${err.message}`));
        }

        loadSettings(state, this.next());
      },
      function loadAutoDowntimesStep(err)
      {
        if (state.cancelled)
        {
          return this.skip();
        }

        if (err)
        {
          return this.skip(new Error(`Failed to load settings: ${err.message}`));
        }

        loadAutoDowntimes(state, this.next());
      },
      function loadOrdersStep(err)
      {
        if (state.cancelled)
        {
          return this.skip();
        }

        if (err)
        {
          return this.skip(new Error(`Failed to load auto downtimes: ${err.message}`));
        }

        loadOrders(state, 'plan', null, this.next());
      },
      function loadPlanStep(err)
      {
        if (state.cancelled)
        {
          return this.skip();
        }

        if (err)
        {
          return this.skip(new Error(`Failed to load orders: ${err.message}`));
        }

        loadPlan(state, this.next());
      },
      function loadPsStatusStep(err)
      {
        if (state.cancelled)
        {
          return this.skip();
        }

        if (err)
        {
          return this.skip(new Error(`Failed to load plan: ${err.message}`));
        }

        loadPsStatus(state, this.next());
      },
      function freezeOrdersStep(err)
      {
        if (state.cancelled)
        {
          return this.skip();
        }

        if (err)
        {
          return this.skip(new Error(`Failed to load PS status: ${err.message}`));
        }

        if (state.freezeOrders)
        {
          freezeOrders(state, this.next());
        }
      },
      function generatePlanStep(err)
      {
        if (state.cancelled)
        {
          return this.skip();
        }

        if (err)
        {
          return this.skip(new Error(`Failed to freeze orders: ${err.message}`));
        }

        doGeneratePlan(state, this.next());
      },
      function markIncompleteOrdersStep(err)
      {
        if (state.cancelled || err)
        {
          return this.skip(err);
        }

        state.newIncompleteOrders.forEach((newValue, orderNo) =>
        {
          const oldValue = state.oldIncompleteOrders.get(orderNo) || 0;

          state.oldIncompleteOrders.delete(orderNo);

          if (newValue === oldValue)
          {
            return;
          }

          const changedOrder = state.changes.changedOrders.get(orderNo);

          if (changedOrder)
          {
            changedOrder.changes.incomplete = [oldValue, newValue];
          }
          else
          {
            state.changes.changedOrders.set(orderNo, {
              _id: orderNo,
              changes: {
                incomplete: [oldValue, newValue]
              }
            });
          }
        });

        state.oldIncompleteOrders.forEach((oldValue, orderNo) =>
        {
          const changedOrder = state.changes.changedOrders.get(orderNo);

          if (changedOrder)
          {
            changedOrder.changes.incomplete = [oldValue, 0];
          }
          else
          {
            state.changes.changedOrders.set(orderNo, {
              _id: orderNo,
              changes: {
                incomplete: [oldValue, 0]
              }
            });
          }
        });

        state.changes.addedOrders.forEach(addedOrder =>
        {
          addedOrder.incomplete = state.newIncompleteOrders.get(addedOrder._id) || 0;
        });

        setImmediate(this.next());
      },
      function restoreRemovedLockedOrdersStep()
      {
        if (state.cancelled)
        {
          return this.skip();
        }

        if (state.changes.removedOrders.size)
        {
          return;
        }

        let restoredCount = 0;

        state.plan.lines.forEach(planLine =>
        {
          planLine.orders.forEach(lineOrder =>
          {
            const removedOrder = state.changes.removedOrders.get(lineOrder.orderNo);

            if (removedOrder)
            {
              state.plan.orders.push(removedOrder.planOrder);

              ++restoredCount;
            }
          });
        });

        if (restoredCount)
        {
          state.log(`Restored ${restoredCount} removed orders!`);
        }

        state.changes.removedOrders.forEach(removedOrder =>
        {
          delete removedOrder.planOrder;
        });

        setImmediate(this.next());
      },
      function calcStatsStep()
      {
        if (state.cancelled)
        {
          return this.skip();
        }

        state.log('Calculating stats...');

        const stats = [];

        for (let i = 0; i <= 3; ++i)
        {
          stats.push({
            startAt: Number.MAX_SAFE_INTEGER,
            finishAt: Number.MIN_SAFE_INTEGER,
            mrpCount: new Set(),
            lineCount: 0,
            orderCount: new Set(),
            manHours: 0,
            quantity: 0
          });
        }

        state.plan.lines.forEach(planLine =>
        {
          if (!planLine.orders.length)
          {
            return;
          }

          stats[0].lineCount += 1;

          for (let i = 0, s = 1; i < 3; ++i, ++s)
          {
            const shiftData = planLine.shiftData[i];

            if (shiftData.orderCount)
            {
              stats[s].lineCount += 1;
            }

            stats[0].manHours += shiftData.manHours;
            stats[s].manHours += shiftData.manHours;
            stats[0].quantity += shiftData.quantity;
            stats[s].quantity += shiftData.quantity;
          }

          planLine.orders.forEach(lineOrder =>
          {
            const sapOrder = state.orders.get(lineOrder.orderNo);

            if (!sapOrder)
            {
              module.warn('Missing order for stats.', {
                line: planLine._id,
                orderNo: lineOrder.orderNo
              });

              return;
            }

            const s = +lineOrder._id.substr(10, 1);

            stats[0].mrpCount.add(sapOrder.mrp);
            stats[s].mrpCount.add(sapOrder.mrp);
            stats[0].orderCount.add(lineOrder.orderNo);
            stats[s].orderCount.add(lineOrder.orderNo);

            if (lineOrder.startAt < stats[s].startAt)
            {
              stats[s].startAt = lineOrder.startAt;
            }

            if (lineOrder.finishAt > stats[s].finishAt)
            {
              stats[s].finishAt = lineOrder.finishAt;
            }
          });

          const startAt = planLine.orders[0].startAt;
          const finishAt = _.last(planLine.orders).finishAt;

          if (startAt < stats[0].startAt)
          {
            stats[0].startAt = startAt;
          }

          if (finishAt > stats[0].finishAt)
          {
            stats[0].finishAt = finishAt;
          }
        });

        stats.forEach(stat =>
        {
          stat.mrpCount = stat.mrpCount.size;
          stat.orderCount = stat.orderCount.size;
          stat.manHours = Math.round(stat.manHours * 100) / 100;

          if (stat.startAt === Number.MAX_SAFE_INTEGER)
          {
            stat.startAt = null;
          }

          if (stat.finishAt === Number.MIN_SAFE_INTEGER)
          {
            stat.finishAt = null;
          }
        });

        state.plan.stats = stats;

        setImmediate(this.next());
      },
      function savePlanStep()
      {
        if (state.cancelled)
        {
          return this.skip();
        }

        state.log('Saving...');

        state.plan.updatedAt = new Date();

        Plan.collection.replaceOne({_id: state.plan._id}, state.plan.toJSON(), {upsert: true}, this.next());
      },
      function finalizeStep(err)
      {
        if (state.cancelled)
        {
          state.log(`[generator] [${state.key}] Cancelled!`);

          return done();
        }

        const duration = (Date.now() - startedAt) / 1000;

        if (err)
        {
          module.error(`[generator] [${state.key}] ${err.message}`);
        }
        else
        {
          state.log(`Finished in ${duration}s!`);

          savePlanChanges(state);
        }

        app.broker.publish('planning.generator.finished', {
          date: state.key,
          duration
        });

        done();
      }
    );
  }

  function waitToCalmDown(state, tryCount, done)
  {
    if (!mongoose.connection.db)
    {
      return done(app.createError('No DB connection.', 'NO_DB_CONNECTION', 500));
    }

    const cmd = {
      currentOp: true,
      $all: true,
      $or: [
        {
          ns: /\.orders$/,
          op: {$in: ['insert', 'update', 'delete']}
        },
        {
          ns: /\.orders$/,
          op: 'command',
          'query.createIndexes': {$exists: true}
        }
      ]
    };

    mongoose.connection.db.executeDbAdminCommand(cmd, (err, result) =>
    {
      if (err)
      {
        return done(err);
      }

      if (!result.inprog.length || tryCount === 10)
      {
        return done();
      }

      state.log(`Waiting to calm down (${tryCount + 1}/10)...`);

      setTimeout(waitToCalmDown, 1000, state, tryCount + 1, done);
    });
  }

  function savePlanChanges(state)
  {
    const changes = state.new ? {addedOrders: state.changes.addedOrders} : state.changes;
    let anyChanges = false;

    if (!state.new)
    {
      changes.changedLines.forEach(changedLine =>
      {
        const lineState = state.lineStates.get(changedLine._id);

        if (lineState.finalHash === lineState.initialHash)
        {
          changes.changedLines.delete(changedLine._id);
        }
      });
    }

    Object.keys(changes).forEach(key =>
    {
      anyChanges = anyChanges || changes[key].size > 0;
    });

    if (!anyChanges)
    {
      return;
    }

    const data = {};

    Object.keys(changes).forEach(key =>
    {
      if (changes[key].size)
      {
        data[key] = Array.from(changes[key].values());
      }
    });

    const planChange = new PlanChange({
      plan: state.plan._id,
      date: state.plan.updatedAt,
      user: null,
      data
    });
    const json = planChange.toJSON();

    PlanChange.collection.insertOne(json, err =>
    {
      if (err)
      {
        module.error(`[generator] [${state.key}] Failed to save changes: ${err.message}`);
      }
      else
      {
        app.broker.publish('planning.changes.created', planChange.toCreatedMessage(state.plan, state.new, json));
      }
    });

    app.broker.publish('planning.stats.updated', {
      plan: state.key,
      stats: state.plan.stats
    });
  }

  function loadSettings(state, done)
  {
    step(
      function findExistingStep()
      {
        state.log('Loading existing settings...');

        PlanSettings
          .findById(state.date)
          .exec(this.next());
      },
      function findPrevStep(err, settings)
      {
        if (state.cancelled)
        {
          return this.skip();
        }

        if (err)
        {
          return this.skip(new Error(`Failed to load existing settings: ${err.message}`));
        }

        if (settings)
        {
          state.settings = settings.toGenerator();

          return this.skip();
        }

        state.log('Loading previous settings...');

        PlanSettings
          .findOne({_id: {$lt: state.date}})
          .sort({_id: -1})
          .exec(this.next());
      },
      function createNewStep(err, prevSettings)
      {
        if (state.cancelled)
        {
          return this.skip();
        }

        if (err)
        {
          return this.skip(new Error(`Failed to load previous settings: ${err.message}`));
        }

        state.log(prevSettings ? 'Copying previous settings...' : 'Creating new settings...');

        const newSettings = prevSettings
          ? PlanSettings.copyFrom(state.date, prevSettings)
          : PlanSettings.createNew(state.date);

        newSettings.save(this.next());
      },
      function handleSaveStep(err, settings)
      {
        if (state.cancelled)
        {
          return this.skip();
        }

        if (err)
        {
          return this.skip(new Error(`Failed to save new settings: ${err.message}`));
        }

        state.settings = settings.toGenerator();
      },
      function(err)
      {
        if (state.cancelled || err)
        {
          return done(err);
        }

        state.freezeOrders = state.settings.freezeFirstShiftOrders;

        const mrpsToLines = new Map();
        const linesToMrps = new Map();

        state.settings.mrps.forEach(mrpId =>
        {
          const mrpSettings = state.settings.mrp(mrpId);

          mrpsToLines.set(mrpId, []);

          if (mrpSettings.locked)
          {
            state.lockedMrps.add(mrpId);
          }

          mrpSettings.groups.forEach(group =>
          {
            group.lines.forEach(lineId =>
            {
              const lineSettings = state.settings.line(lineId);

              if (!lineSettings || !lineSettings.mrpPriority.includes(mrpId))
              {
                return;
              }

              if (!state.grouping.lineToGroups.has(lineId))
              {
                state.grouping.lineToGroups.set(lineId, []);
              }

              state.grouping.lineToGroups.get(lineId).push(group);
            });
          });
        });

        state.settings.lines.forEach(lineId =>
        {
          linesToMrps.set(lineId, []);

          state.settings.line(lineId).mrpPriority.forEach(mrpId =>
          {
            mrpsToLines.get(mrpId).push(lineId);
            linesToMrps.get(lineId).push(mrpId);
          });
        });

        linesToMrps.forEach((mrps) =>
        {
          const anyLocked = mrps.some(mrpId => state.lockedMrps.has(mrpId));

          if (anyLocked)
          {
            mrps.forEach(mrpId => state.lockedMrps.add(mrpId));
          }
        });

        mrpsToLines.forEach((lines, mrpId) =>
        {
          if (state.lockedMrps.has(mrpId))
          {
            lines.forEach(lineId => state.lockedLines.add(lineId));
          }
        });

        done();
      }
    );
  }

  function loadAutoDowntimes(state, done)
  {
    state.log('Loading auto downtimes...');

    autoDowntimeCache.get(state.key, (err, autoDowntimes) =>
    {
      if (err)
      {
        return done(err);
      }

      state.autoDowntimes = autoDowntimes;

      setImmediate(done);
    });
  }

  function loadOrders(state, source, ids, done)
  {
    state.log(`Loading ${source} orders...`);

    if (!ids && !state.settings.mrps.length)
    {
      return done(new Error('No MRPs defined!'));
    }

    step(
      function findStep()
      {
        const conditions = ids ? {_id: {$in: ids}} : {
          scheduledStartDate: moment(state.key, 'YYYY-MM-DD').toDate(),
          mrp: {$in: state.settings.mrps}
        };

        Order
          .find(conditions)
          .select(Plan.SAP_ORDER_FIELDS)
          .sort({_id: 1})
          .lean()
          .exec(this.next());
      },
      function prepareStep(err, sapOrders)
      {
        if (err || state.cancelled)
        {
          return this.skip(err);
        }

        state.log(`Preparing ${sapOrders.length} ${ids ? 'additional orders' : 'orders'}...`);

        if (!state.orders)
        {
          state.orders = new Map();
        }

        sapOrders.forEach(sapOrder =>
        {
          const mrpSettings = state.settings.mrp(sapOrder.mrp);

          if (!mrpSettings)
          {
            return;
          }

          const planOrder = Plan.createPlanOrder(source, sapOrder);

          if (state.settings.ignoredWorkCenters.has(planOrder.operation.workCenter))
          {
            return;
          }

          const bom = new Set();

          (sapOrder.bom || []).forEach(component => bom.add(component.nc12));

          sapOrder.bom = bom;

          state.orders.set(sapOrder._id, planOrder);
          state.sapOrders.set(sapOrder._id, sapOrder);
        });

        setImmediate(this.next());
      },
      done
    );
  }

  function preparePlanOrder(state, planOrder)
  {
    if (planOrder.source === 'incomplete')
    {
      const incompleteOrder = state.incompleteOrders.get(planOrder._id);

      planOrder.urgent = true;
      planOrder.quantityPlan = state.lastMinute
        ? (planOrder.quantityTodo - planOrder.quantityDone)
        : incompleteOrder.incomplete;
      planOrder.lines = incompleteOrder.lines;
    }

    const quantityTodo = getQuantityTodo(state, planOrder);
    const mrpSettings = state.settings.mrp(planOrder.mrp);

    planOrder.kind = classifyPlanOrder(state, planOrder);
    planOrder.manHours = getManHours(planOrder.operation, quantityTodo, mrpSettings.schedulingRate);
    planOrder.incomplete = quantityTodo;

    if (planOrder.quantityPlan >= 0)
    {
      state.newIncompleteOrders.set(planOrder._id, quantityTodo);
    }

    state.grouping.orderToGroups.set(planOrder._id, []);

    if (mrpSettings.groups.length)
    {
      const orderGroups = state.grouping.orderToGroups.get(planOrder._id);
      const sapOrder = state.sapOrders.get(planOrder._id);

      mrpSettings.groups.forEach(group =>
      {
        if (group.components.find(nc12 => sapOrder.bom.has(nc12)))
        {
          orderGroups.push(group);
        }
      });

      if (!orderGroups.length)
      {
        mrpSettings.groups.forEach(group =>
        {
          if (!group.components.length)
          {
            orderGroups.push(group);
          }
        });
      }

      orderGroups.sort((a, b) => b.components.length - a.components.length);
    }

    return planOrder;
  }

  function loadPlan(state, done)
  {
    state.log('Loading plan...');

    step(
      function findExistingStep()
      {
        Plan.findById(state.date).exec(this.next());
      },
      function createNewStep(err, existingPlan)
      {
        if (state.cancelled)
        {
          return this.skip();
        }

        if (err)
        {
          return this.skip(new Error(`Failed to load existing plan: ${err.message}`));
        }

        if (existingPlan)
        {
          removeUnusedLines(existingPlan, state.settings);
        }
        else
        {
          state.new = true;
        }

        state.plan = existingPlan || new Plan({
          _id: state.date,
          createdAt: new Date(),
          updatedAt: null,
          orders: [],
          lines: []
        });

        if (!UNFROZEN_PLANS.includes(state.key) && state.plan.frozen)
        {
          return this.skip(new Error('Plan is frozen.'));
        }

        setImmediate(this.next());
      },
      function loadAddedOrdersStep()
      {
        if (state.new)
        {
          return;
        }

        const addedOrders = [];

        state.plan.orders.forEach(planOrder =>
        {
          if (planOrder.source === 'added' && !state.orders.has(planOrder._id))
          {
            addedOrders.push(planOrder._id);
          }
        });

        if (addedOrders.length)
        {
          loadOrders(state, 'added', addedOrders, this.next());
        }
      },
      function loadIncompleteOrdersStep()
      {
        loadIncompleteOrders(state, this.next());
      },
      function compareOrdersStep()
      {
        if (state.new)
        {
          state.plan.orders = Array.from(state.orders.values())
            .map(order => preparePlanOrder(state, order))
            .filter(order => filterPlanOrder(state, order) === null);

          state.plan.orders.forEach(order => state.changes.addedOrders.set(order._id, order));

          state.log(`Classified ${state.plan.orders.length} new orders!`);

          setImmediate(this.next());
        }
        else
        {
          compareOrders(state, this.next());
        }
      },
      done
    );
  }

  function loadPsStatus(state, done)
  {
    state.log('Loading paint-shop statuses...');

    step(
      function()
      {
        const pipeline = [
          {$match: {
            order: {$in: state.plan.orders.map(o => o._id)}
          }},
          {$group: {
            _id: '$order',
            orderCount: {$sum: 1},
            orderQty: {$max: '$qty'},
            qtyDone: {$sum: '$qtyDone'}
          }}
        ];

        PaintShopOrder.aggregate(pipeline, this.next());
      },
      function(err, results)
      {
        if (err)
        {
          return done(err);
        }

        results.forEach(r =>
        {
          if (r.qtyDone < (r.orderCount * r.orderQty))
          {
            state.unpainted.add(r._id);
          }
        });

        done();
      }
    );
  }

  function anyFrozenOrders(state)
  {
    return state.plan.lines.find(planLine => planLine.frozenOrders.length > 0);
  }

  function freezeOrders(state, done)
  {
    if (!anyFrozenOrders(state))
    {
      state.log('Freezing first shift orders...');

      state.plan.lines.forEach(freezeLineOrders);
    }

    setImmediate(done);
  }

  function freezeLineOrders(planLine)
  {
    planLine.frozenOrders = [];

    planLine.orders.forEach(lineOrder =>
    {
      const lastFrozenOrder = _.last(planLine.frozenOrders);

      if (lastFrozenOrder && lineOrder.orderNo === lastFrozenOrder.orderNo)
      {
        lastFrozenOrder.quantity += lineOrder.quantity;
      }
      else
      {
        planLine.frozenOrders.push({
          orderNo: lineOrder.orderNo,
          quantity: lineOrder.quantity
        });
      }
    });
  }

  function isWorkDay(state, date, done)
  {
    step(
      function()
      {
        PlanSettings
          .findOne({
            _id: state.date,
            forceWorkDay: true
          })
          .select({_id: 1})
          .lean()
          .exec(this.next());
      },
      function(err, planSettings)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (planSettings)
        {
          return this.skip(null, true);
        }

        Order
          .find({
            scheduledStartDate: date,
            statuses: {$in: state.settings.requiredStatuses}
          })
          .select({_id: 1})
          .limit(1)
          .lean()
          .exec(this.next());
      },
      function(err, orders)
      {
        if (err)
        {
          return this.skip(err);
        }

        setImmediate(this.next(), null, orders.length === 1);
      },
      done
    );
  }

  function findPreviousWorkDay(state, planMoment, done)
  {
    const prevPlanId = planMoment.subtract(1, 'days').toDate();

    isWorkDay(state, prevPlanId, (err, workDay) =>
    {
      if (err)
      {
        return done(err);
      }

      if (workDay)
      {
        return done(null, planMoment);
      }

      findPreviousWorkDay(state, planMoment, done);
    });
  }

  function loadIncompleteOrders(state, done)
  {
    const planLocalMoment = moment(state.key, 'YYYY-MM-DD');

    step(
      function()
      {
        isWorkDay(state, planLocalMoment.toDate(), this.next());
      },
      function(err, workDay)
      {
        if (err || !workDay)
        {
          return this.skip(err);
        }

        findPreviousWorkDay(state, planLocalMoment, this.next());
      },
      function(err, prevPlanId)
      {
        if (err)
        {
          return this.skip(err);
        }

        this.prevPlanId = moment.utc(prevPlanId.format('YYYY-MM-DD'), 'YYYY-MM-DD').toDate();

        const pipeline = [
          {$match: {_id: this.prevPlanId}},
          {$unwind: '$orders'},
          {$match: {'orders.incomplete': {$gt: 0}}},
          {$project: {
            _id: '$orders._id',
            incomplete: '$orders.incomplete',
            date: '$orders.date'
          }}
        ];

        Plan.aggregate(pipeline, this.next());
      },
      function(err, incompleteOrders)
      {
        if (err)
        {
          return this.skip(new Error(`Failed to find incomplete orders: ${err.message}`));
        }

        this.incompleteOrderIds = [];

        incompleteOrders.forEach(order =>
        {
          if (moment(order.date, 'YYYY-MM-DD').diff(planLocalMoment, 'days') < -6)
          {
            return;
          }

          this.incompleteOrderIds.push(order._id);

          order.lines = [];

          state.incompleteOrders.set(order._id, order);
        });

        if (!this.incompleteOrderIds.length)
        {
          return this.skip();
        }

        const pipeline = [
          {$match: {_id: this.prevPlanId}},
          {$unwind: '$lines'},
          {$unwind: '$lines.orders'},
          {$match: {'lines.orders.orderNo': {$in: this.incompleteOrderIds}}},
          {$group: {
            _id: {
              line: '$lines._id',
              orderNo: '$lines.orders.orderNo'
            },
            quantity: {$sum: '$lines.orders.quantity'}
          }},
          {$sort: {quantity: -1}},
          {$project: {
            _id: '$_id.orderNo',
            line: '$_id.line'
          }}
        ];

        Plan.aggregate(pipeline, this.next());
      },
      function(err, incompleteLineOrders)
      {
        if (err)
        {
          return this.skip(new Error(`Failed to find incomplete line orders: ${err.message}`));
        }

        incompleteLineOrders.forEach(order =>
        {
          state.incompleteOrders.get(order._id).lines.push(order.line);
        });

        loadOrders(state, 'incomplete', this.incompleteOrderIds, this.next());
      },
      done
    );
  }

  function removeUnusedLines(plan, settings)
  {
    plan.lines = plan.lines.filter(line => settings.lines.includes(line._id));
  }

  function filterPlanOrder(state, planOrder)
  {
    if (planOrder.source === 'incomplete' && planOrder.quantityPlan <= 0)
    {
      state.newIncompleteOrders.delete(planOrder._id);

      return {
        _id: planOrder._id,
        reason: 'INCOMPLETE_DONE',
        data: {},
        planOrder
      };
    }

    const actualStatuses = new Set();

    for (let i = 0; i < planOrder.statuses.length; ++i)
    {
      const actualStatus = planOrder.statuses[i];

      if (state.settings.ignoredStatuses.has(actualStatus))
      {
        state.newIncompleteOrders.delete(planOrder._id);

        planOrder.incomplete = 0;

        if (!state.settings.completedStatuses.includes(actualStatus))
        {
          return {
            _id: planOrder._id,
            reason: 'IGNORED_STATUS',
            data: {
              actualStatuses: planOrder.statuses,
              ignoredStatus: actualStatus
            },
            planOrder
          };
        }
      }

      actualStatuses.add(actualStatus);
    }

    for (let i = 0; i < state.settings.requiredStatuses.length; ++i)
    {
      const requiredStatus = state.settings.requiredStatuses[i];

      if (!actualStatuses.has(requiredStatus))
      {
        state.newIncompleteOrders.delete(planOrder._id);

        return {
          _id: planOrder._id,
          reason: 'REQUIRED_STATUS',
          data: {
            actualStatuses: planOrder.statuses,
            requiredStatus
          }
        };
      }
    }

    return null;
  }

  function classifyPlanOrder(state, planOrder)
  {
    const sapOrder = state.sapOrders.get(planOrder._id);
    const {hardComponents, hardBigComponents} = state.settings.mrp(planOrder.mrp);

    planOrder.hardComponent = hardComponents.find(nc12 => sapOrder.bom.has(nc12)) || null;

    if (planOrder.hardComponent)
    {
      return 'hard';
    }

    if (isSmallOrder(state, planOrder))
    {
      return 'small';
    }

    planOrder.hardComponent = hardBigComponents.find(nc12 => sapOrder.bom.has(nc12)) || null;

    if (isHardOrder(state, planOrder))
    {
      return 'hard';
    }

    return 'easy';
  }

  function getQuantityTodo(state, planOrder)
  {
    if (planOrder.quantityPlan > 0)
    {
      return planOrder.quantityPlan;
    }

    if (state.settings.useRemainingQuantity)
    {
      return Math.max(planOrder.quantityTodo - planOrder.quantityDone, 0);
    }

    return planOrder.quantityTodo;
  }

  function isSmallOrder(state, planOrder)
  {
    const quantityTodo = getQuantityTodo(state, planOrder);
    const bigOrderQuantity = state.settings.mrp(planOrder.mrp).bigOrderQuantity;

    return bigOrderQuantity === 0 || quantityTodo < bigOrderQuantity;
  }

  function isHardOrder(state, planOrder)
  {
    // Has a hard component
    if (planOrder.hardComponent !== null)
    {
      return true;
    }

    if (!planOrder.operation.laborTime)
    {
      return false;
    }

    const hardOrderManHours = state.settings.mrp(planOrder.mrp).hardOrderManHours;

    if (hardOrderManHours <= 0)
    {
      return false;
    }

    return planOrder.manHours >= hardOrderManHours;
  }

  function compareOrders(state, done)
  {
    if (!COMPARE_ORDERS)
    {
      state.log('Not comparing orders!');

      return done();
    }

    const oldPlanOrders = state.plan.orders;
    const newPlanOrders = [];
    const latestOrders = state.orders;

    state.log(`Comparing ${oldPlanOrders.length} old with ${latestOrders.size} new orders...`);

    oldPlanOrders.forEach(oldOrder =>
    {
      const latestOrder = latestOrders.get(oldOrder._id);

      if (!latestOrder)
      {
        state.changes.removedOrders.set(oldOrder._id, {
          _id: oldOrder._id,
          reason: 'MISSING_ORDER',
          planOrder: oldOrder
        });

        return;
      }

      if (compareOrder(state, oldOrder, latestOrder))
      {
        newPlanOrders.push(latestOrder);
      }

      latestOrders.delete(latestOrder._id);
    });

    latestOrders.forEach(latestOrder =>
    {
      preparePlanOrder(state, latestOrder);

      if (filterPlanOrder(state, latestOrder) === null)
      {
        newPlanOrders.push(latestOrder);

        state.changes.addedOrders.set(latestOrder._id, latestOrder);
      }
    });

    latestOrders.clear();

    newPlanOrders.forEach(planOrder =>
    {
      latestOrders.set(planOrder._id, planOrder);
    });

    state.plan.orders = newPlanOrders;

    const added = state.changes.addedOrders.size;
    const changed = state.changes.changedOrders.size;
    const removed = state.changes.removedOrders.size;

    state.log(`Added ${added}, changed ${changed} and removed ${removed} orders!`);

    setImmediate(done);
  }

  function compareOrder(state, oldOrder, latestOrder)
  {
    Object.assign(latestOrder, _.pick(oldOrder, ORDER_USER_PROPERTIES));

    if (oldOrder.quantityPlan > 0 && oldOrder.source === 'incomplete' && latestOrder.date === state.key)
    {
      latestOrder.source = 'plan';
      latestOrder.quantityPlan = 0;
      latestOrder.lines = [];
      latestOrder.urgent = false;
    }

    preparePlanOrder(state, latestOrder);

    const removedOrder = filterPlanOrder(state, latestOrder);

    if (removedOrder !== null)
    {
      state.changes.removedOrders.set(removedOrder._id, removedOrder);

      return false;
    }

    if (oldOrder.incomplete)
    {
      state.oldIncompleteOrders.set(oldOrder._id, oldOrder.incomplete);
    }

    const changes = {};
    let changed = false;

    Object.keys(latestOrder).forEach(key =>
    {
      if (ORDER_IGNORED_PROPERTIES[key])
      {
        return;
      }

      const oldValue = oldOrder[key] && oldOrder[key].toObject ? oldOrder[key].toObject() : oldOrder[key];
      const newValue = latestOrder[key] && latestOrder[key].toObject ? latestOrder[key].toObject() : latestOrder[key];

      if (key === 'operation' && !_.isEmpty(oldValue) && _.isEmpty(newValue))
      {
        latestOrder[key] = oldValue;

        return;
      }

      if (jsonDeepEqual(newValue, oldValue))
      {
        return;
      }

      changes[key] = [oldValue, newValue];
      changed = true;
    });

    if (changed)
    {
      state.changes.changedOrders.set(oldOrder._id, {
        _id: oldOrder._id,
        changes
      });
    }

    return true;
  }

  function doGeneratePlan(state, done)
  {
    state.log('Generating...');

    step(
      function()
      {
        createOrderStateQueues(state, this.next());
      },
      function()
      {
        if (state.cancelled)
        {
          return this.skip();
        }

        createLineStates(state, this.next());
      },
      function()
      {
        if (state.cancelled)
        {
          return this.skip();
        }

        generatePlanForLines(1, state, this.next());
      },
      function()
      {
        if (RESIZE_ORDERS)
        {
          resizeAndFillLines(state, this.next());
        }
      },
      function()
      {
        if (state.cancelled)
        {
          return this.skip();
        }

        state.hourlyPlanRecount.forEach(lineId => recountHourlyPlan(state.plan.lines.find(l => l._id === lineId)));

        setImmediate(this.next());
      },
      done
    );
  }

  function createOrderStateQueues(state, done)
  {
    state.orderStateQueues = new Map();

    state.plan.orders.forEach(planOrder =>
    {
      if (isUnplannableOrder(state, planOrder))
      {
        return;
      }

      if (!state.orderStateQueues.has(planOrder.mrp))
      {
        state.orderStateQueues.set(planOrder.mrp, {
          urgent: [],
          small: [],
          easy: [],
          hard: []
        });
      }

      const sapOrder = state.sapOrders.get(planOrder._id);
      const orderStateQueue = state.orderStateQueues.get(planOrder.mrp);
      const orderState = {
        order: planOrder,
        sapOrder,
        lines: getAvailablePinnedLines(state, planOrder),
        quantityTodo: getQuantityTodo(state, planOrder),
        maxQuantityPerLine: 0,
        startTimes: [],
        frozenOnLines: [],
        timeDiff: 0,
        name: planOrder.name, // eslint-disable-line comma-dangle
        nameParts: getOrderNameParts(planOrder),
        nameRank: 0,
        group: null,
        painted: state.unpainted.has(planOrder._id) ? 1 : 0,
        small: isSmallOrder(state, planOrder)
      };

      if (planOrder.urgent || sapOrder.priority === 'E')
      {
        orderStateQueue.urgent.push(orderState);
      }
      else
      {
        orderStateQueue[planOrder.kind].push(orderState);
      }

      state.orderStates.set(planOrder._id, orderState);
    });

    for (const orderStateQueues of state.orderStateQueues.values())
    {
      orderStateQueues.urgent.sort(sortUrgentOrders);
      orderStateQueues.hard.sort(sortHardOrders);

      ORDERS_SORTER(orderStateQueues, 'small', null);
      ORDERS_SORTER(orderStateQueues, 'easy', _.last(orderStateQueues.small));
    }

    setImmediate(done);
  }

  function isUnplannableOrder(state, planOrder)
  {
    return planOrder.ignored || !planOrder.operation.laborTime || isCompletedOrder(state, planOrder);
  }

  function isCompletedOrder(state, planOrder)
  {
    const {completedStatuses} = state.settings;
    const {statuses} = planOrder;

    for (let i = 0; i < completedStatuses.length; ++i)
    {
      if (statuses.includes(completedStatuses[i]))
      {
        return true;
      }
    }

    return false;
  }

  function getAvailablePinnedLines(state, planOrder)
  {
    const pinnedLines = planOrder.lines;

    if (pinnedLines.length === 0)
    {
      return [];
    }

    const availableLines = state.settings.mrp(planOrder.mrp).lines
      .filter(l => l.workerCount.some(c => c > 0))
      .map(l => l._id);

    return _.intersection(pinnedLines, availableLines);
  }

  function sortUrgentOrders(a, b)
  {
    const aOrder = a.order;
    const bOrder = b.order;

    if (a.painted !== b.painted)
    {
      return a.painted - b.painted;
    }

    if (aOrder.lines.length && !bOrder.lines.length)
    {
      return -1;
    }

    if (bOrder.lines.length && !aOrder.lines.length)
    {
      return 1;
    }

    const cmp = ORDER_URGENT_SOURCE[bOrder.source] - ORDER_URGENT_SOURCE[aOrder.source];

    if (cmp !== 0)
    {
      return cmp;
    }

    if (aOrder.quantityDone > 0 && bOrder.quantityDone === 0)
    {
      return -1;
    }

    if (bOrder.quantityDone > 0 && aOrder.quantityDone === 0)
    {
      return 1;
    }

    return a.quantityTodo - b.quantityTodo;
  }

  function sortOrdersByManHours(orderStateQueues, kind) // eslint-disable-line no-unused-vars
  {
    orderStateQueues[kind].sort(sortEasyOrders);
  }

  function sortOrdersByLeven(orderStateQueues, kind) // eslint-disable-line no-unused-vars
  {
    const unsortedQueue = orderStateQueues[kind];

    if (unsortedQueue.length <= 1)
    {
      return;
    }

    unsortedQueue.sort(sortEasyOrders);

    if (unsortedQueue.length === 2)
    {
      return;
    }

    const sortedQueue = [
      unsortedQueue.shift()
    ];

    while (unsortedQueue.length)
    {
      levenSort(unsortedQueue, _.last(sortedQueue).name, 'name');

      sortedQueue.push(unsortedQueue.shift());
    }

    orderStateQueues[kind] = sortedQueue;
  }

  function sortOrdersByNameParts(orderStateQueues, kind, lastPrevKind) // eslint-disable-line no-unused-vars
  {
    const unsortedQueue = orderStateQueues[kind];

    if (unsortedQueue.length <= 1)
    {
      return;
    }

    unsortedQueue.sort(sortEasyOrders);

    if (unsortedQueue.length === 2)
    {
      return;
    }

    const sortedQueue = [];

    if (!lastPrevKind)
    {
      sortedQueue.push(unsortedQueue.shift());
    }

    while (unsortedQueue.length)
    {
      const lastNameParts = sortedQueue.length === 0 ? lastPrevKind.nameParts : _.last(sortedQueue).nameParts;

      for (let i = 0; i < unsortedQueue.length; ++i)
      {
        rankOrderName(unsortedQueue[i], lastNameParts);
      }

      unsortedQueue.sort(sortOrdersByNameRank);

      sortedQueue.push(unsortedQueue.shift());
    }

    sortedQueue.sort((a, b) => a.painted - b.painted);

    orderStateQueues[kind] = sortedQueue;
  }

  function sortOrdersByNameRank(a, b)
  {
    return b.nameRank - a.nameRank;
  }

  function getOrderNameParts(order) // eslint-disable-line no-unused-vars
  {
    if (!orderNamePartsCache.has(order.name))
    {
      const orderNameParts = {
        family: order.name.substring(0, 6),
        dimensions: null,
        parts: []
      };

      order.name.substring(6).trim().split(' ').forEach(part =>
      {
        if (/^W[0-9]+L[0-9]+$/.test(part))
        {
          orderNameParts.dimensions = part;
        }
        else
        {
          orderNameParts.parts.push(part);
        }
      });

      orderNamePartsCache.set(order.name, orderNameParts);
    }

    return orderNamePartsCache.get(order.name);
  }

  function rankOrderName(orderState, lastNameParts)
  {
    orderState.nameRank = orderState.nameParts.family === lastNameParts.family ? 6 : 0;

    if (orderState.nameParts.dimensions !== null || lastNameParts.dimensions !== null)
    {
      orderState.nameRank += orderState.nameParts.dimensions === lastNameParts.dimensions ? 4 : 0;
    }

    lastNameParts.parts.forEach(namePart =>
    {
      if (orderState.nameParts.parts.includes(namePart))
      {
        orderState.nameRank += 1;
      }
    });
  }

  function sortEasyOrders(a, b)
  {
    return b.order.manHours - a.order.manHours;
  }

  function sortHardOrders(a, b)
  {
    if (a.painted !== b.painted)
    {
      return a.painted - b.painted;
    }

    if (a.order.hardComponent === b.order.hardComponent)
    {
      return b.order.manHours - a.order.manHours;
    }

    if (a.order.hardComponent !== null && b.order.hardComponent === null)
    {
      return -1;
    }

    return 1;
  }

  function createLineStates(state, done)
  {
    state.lineStates = new Map();

    const mrpToLinesMap = new Map();

    state.settings.lines.forEach(lineId =>
    {
      const lineSettings = state.settings.line(lineId);
      const planLine = state.plan.lines.find(l => l._id === lineId);
      const frozenOrders = !planLine || !planLine.frozenOrders ? [] : planLine.frozenOrders.filter(frozenOrder =>
      {
        const order = state.orders.get(frozenOrder.orderNo);

        return order && lineSettings.mrpPriority.includes(order.mrp);
      });
      const activeTimes = createActiveTimes(state.date.getTime(), lineSettings.activeTime);
      const activeTime = activeTimes.shift();
      const orderStateQueue = createLineOrderStateQueue(state, lineId, lineSettings.mrpPriority, frozenOrders);
      const lineState = {
        _id: lineId,
        locked: LOCK_LINES && !state.new && state.lockedLines.has(lineId),
        completed: false,
        shiftNo: getShiftFromMoment(activeTime.from),
        activeTimes,
        activeFrom: activeTime.from,
        activeTo: activeTime.to,
        nextDowntime: state.autoDowntimes.get(lineId),
        downtimes: [],
        skippedLateOrders: [],
        skippedEtoPilots: [],
        orderStateQueue,
        bigOrderStateQueue: [],
        triedOrdersSet: new Set(),
        unresizablePlannedOrdersSet: new Set(),
        plannedOrdersSet: new Set(),
        plannedOrdersList: [],
        frozenOrdersMap: new Map(frozenOrders.map(o => [o.orderNo, o.quantity])),
        smallOrders: {
          count: orderStateQueue.reduce(
            (count, orderState) => count + (orderState.small ? 1 : 0),
            0
          ),
          limit: new Map(),
          planned: new Map()
        },
        hourlyPlan: EMPTY_HOURLY_PLAN.slice(),
        hash: frozenOrders.map(o => `${o.orderNo}:${o.quantity}`).join(':'),
        initialHash: planLine ? planLine.hash : '',
        finalHash: ''
      };

      lineSettings.mrpPriority.forEach(mrp =>
      {
        if (!mrpToLinesMap.has(mrp))
        {
          mrpToLinesMap.set(mrp, []);
        }

        mrpToLinesMap.get(mrp).push(lineState);
      });
    });

    Array.from(mrpToLinesMap.keys())
      .sort((a, b) => a.localeCompare(b, undefined, {numeric: true, ignorePunctuation: true}))
      .forEach(mrp =>
      {
        const mrpLines = mrpToLinesMap.get(mrp);
        const smallOrderLines = [];

        mrpLines
          .sort((a, b) => a._id.localeCompare(b._id, undefined, {numeric: true, ignorePunctuation: true}))
          .forEach(lineState =>
          {
            lineState.smallOrders.planned.set(mrp, 0);

            if (hasAnyWorkers(state, lineState)
              && state.settings.mrpLine(mrp, lineState._id).orderPriority.includes('small'))
            {
              smallOrderLines.push(lineState);
            }

            if (!state.lineStates.has(lineState._id))
            {
              state.lineStates.set(lineState._id, lineState);
              state.lineStateQueue.push(lineState);
            }
          });

        smallOrderLines.forEach(lineState =>
        {
          const limit = Math.ceil(lineState.smallOrders.count / smallOrderLines.length);

          lineState.smallOrders.limit.set(mrp, limit);
        });
      });

    setImmediate(done);
  }

  function createLineOrderStateQueue(state, lineId, mrpPriority, frozenOrders)
  {
    const urgentOrderStates = [];
    let lineOrderStateQueue = [];

    mrpPriority.forEach(mrpId =>
    {
      const mrpLineSettings = state.settings.mrpLine(mrpId, lineId);
      const mrpOrderStateQueue = state.orderStateQueues.get(mrpId);

      if (!mrpOrderStateQueue)
      {
        return;
      }

      mrpOrderStateQueue.urgent.forEach(orderState =>
      {
        if (mrpLineSettings.orderPriority.includes(orderState.order.kind)
          || orderState.lines.includes(lineId))
        {
          urgentOrderStates.push(orderState);
        }
      });

      mrpLineSettings.orderPriority.forEach(orderPriority =>
      {
        lineOrderStateQueue = lineOrderStateQueue.concat(mrpOrderStateQueue[orderPriority]);
      });
    });

    frozenOrders.forEach(frozenOrder =>
    {
      const frozenOrderState = state.orderStates.get(frozenOrder.orderNo);

      if (!frozenOrderState)
      {
        return;
      }

      frozenOrderState.frozenOnLines.push(lineId);

      if (!frozenOrderState.order.urgent)
      {
        urgentOrderStates.push(frozenOrderState);
      }
    });

    const lineGroups = state.grouping.lineToGroups.get(lineId);

    return urgentOrderStates.concat(lineOrderStateQueue).filter(orderState =>
    {
      const orderGroups = state.grouping.orderToGroups.get(orderState.order._id);

      if (!orderGroups.length)
      {
        return !lineGroups;
      }

      if (!lineGroups)
      {
        return false;
      }

      return !!orderGroups.find(group => lineGroups.includes(group));
    });
  }

  function createActiveTimes(planTime, rawActiveTimes)
  {
    if (_.isEmpty(rawActiveTimes))
    {
      rawActiveTimes = [{from: '06:00', to: '06:00'}];
    }

    return rawActiveTimes.map(rawActiveTime => ({
      from: createMomentFromActiveTime(planTime, rawActiveTime.from, true),
      to: createMomentFromActiveTime(planTime, rawActiveTime.to, false)
    }));
  }

  function createMomentFromActiveTime(planTime, activeTimeString, from)
  {
    const matches = activeTimeString.match(/([0-9]{1,2})(?::([0-9]{1,2}))?/);
    const hours = matches && matches[1] < 24 ? +matches[1] : 6;
    const minutes = matches && matches[2] < 60 ? +matches[2] : 0;
    const activeTimeMoment = moment.utc(planTime);

    if (hours < 6 || (!from && hours <= 6 && minutes === 0))
    {
      activeTimeMoment.add(1, 'days');
    }

    return activeTimeMoment.hours(hours).minutes(minutes);
  }

  function getShiftFromMoment(moment)
  {
    const hours = moment.hours();

    return hours >= 6 && hours < 14 ? 1 : hours >= 14 && hours < 22 ? 2 : 3;
  }

  function generatePlanForLines(increment, state, done)
  {
    if (state.cancelled || !state.lineStateQueue.length)
    {
      return done();
    }

    state.generateCallCount += increment;

    generatePlanForLine(state, state.lineStateQueue.shift(), () => generatePlanForLines(0, state, done));
  }

  function generatePlanForLine(state, lineState, done)
  {
    logLine(lineState, 'Generating plan for line...', {
      line: lineState._id,
      generateCallCount: state.generateCallCount,
      orderQueue: lineState.orderStateQueue.map(o => o.order._id)
    });

    if (lineState.locked)
    {
      logLine(lineState, 'Skipping line: locked!', {
        line: lineState._id
      });
    }
    else if (hasAnyWorkers(state, lineState))
    {
      while (!lineState.completed)
      {
        const orderState = getNextOrderForLine(state, lineState);

        if (!orderState)
        {
          break;
        }

        handleOrderState(state, lineState, orderState, false);
      }
    }
    else
    {
      logLine(lineState, 'Skipping line: no workers!', {
        line: lineState._id
      });
    }

    setImmediate(completeLine, state, lineState, done);
  }

  function hasAnyWorkers(state, lineState)
  {
    return state.settings.line(lineState._id).mrpPriority.some(
      mrpId => state.settings.mrpLine(mrpId, lineState._id).workerCount.some(workerCount => workerCount > 0)
    );
  }

  function handleOrderState(state, lineState, orderState, trying)
  {
    lineState.triedOrdersSet.add(orderState.order._id);

    if (orderState.group)
    {
      if (!orderState.group.lines.includes(lineState._id) && orderState.group.components.length)
      {
        logLine(lineState, 'Skipping grouped order: line not in assigned group with components...', {
          line: lineState._id,
          order: orderState.order._id,
          group: orderState.group
        });

        return null;
      }
    }
    else
    {
      const orderGroups = state.grouping.orderToGroups.get(orderState.order._id);

      orderState.group = orderGroups.find(group => group.lines.includes(lineState._id)) || null;

      if (orderGroups.length && !orderState.group)
      {
        logLine(lineState, 'Skipping grouped order: line not in group...', {
          line: lineState._id,
          order: orderState.order._id,
          groups: orderGroups
        });

        return null;
      }
    }

    if (!orderState.group && orderState.small)
    {
      return (trying ? trySmallOrder : handleSmallOrder)(state, lineState, orderState);
    }

    return handleBigOrder(state, lineState, orderState, trying);
  }

  function completeLine(state, lineState, done)
  {
    if (!done)
    {
      done = () => {};
    }

    const oldPlanLine = state.plan.lines.find(planLine => planLine._id === lineState._id);
    const locked = !!oldPlanLine && lineState.locked;

    if (!locked && lineState.activeTimes.length)
    {
      const nextActiveTime = lineState.activeTimes.shift();

      lineState.activeFrom = nextActiveTime.from;
      lineState.activeTo = nextActiveTime.to;

      lineState.triedOrdersSet.forEach(triedOrderNo =>
      {
        if (lineState.plannedOrdersSet.has(triedOrderNo))
        {
          return;
        }

        const triedOrderState = state.orderStates.get(triedOrderNo);

        if (triedOrderState.quantityTodo > 0)
        {
          lineState.orderStateQueue.unshift(triedOrderState);
        }
      });

      if (lineState.plannedOrdersList.length)
      {
        lineState.unresizablePlannedOrdersSet.add(_.last(lineState.plannedOrdersList).orderNo);
      }

      if (lineState.orderStateQueue.length)
      {
        lineState.completed = false;

        state.lineStateQueue.unshift(lineState);

        logLine(lineState, 'Continuing line...', {
          line: lineState._id,
          activeFrom: lineState.activeFrom.format('HH:mm:ss')
        });

        return setImmediate(done);
      }
    }

    lineState.completed = true;

    const newPlanLine = locked ? oldPlanLine : {
      _id: lineState._id,
      version: 1,
      hash: createHash('md5').update(lineState.hash).digest('hex'),
      orders: lineState.plannedOrdersList,
      downtimes: lineState.downtimes,
      hourlyPlan: lineState.hourlyPlan,
      shiftData: null,
      frozenOrders: oldPlanLine ? oldPlanLine.frozenOrders : []
    };

    lineState.finalHash = newPlanLine.hash;

    if (!oldPlanLine)
    {
      calculateShiftData(newPlanLine);

      state.plan.lines.push(newPlanLine);

      state.changes.changedLines.set(newPlanLine._id, {
        _id: newPlanLine._id,
        version: newPlanLine.version
      });

      logLine(lineState, 'Completed new line!', {
        line: lineState._id
      });

      return setImmediate(done);
    }

    if (oldPlanLine.hash !== newPlanLine.hash)
    {
      calculateShiftData(newPlanLine);

      if (lineState.initialHash !== newPlanLine.hash)
      {
        newPlanLine.version = oldPlanLine.version + 1;

        state.changes.changedLines.set(oldPlanLine._id, {
          _id: oldPlanLine._id,
          version: oldPlanLine.version
        });
      }

      Object.assign(oldPlanLine, newPlanLine);

      logLine(lineState, 'Completed existing line with changes!', {
        line: lineState._id,
        newVersion: oldPlanLine.version
      });

      state.linesWithChanges.add(lineState);

      return setImmediate(done);
    }

    if (locked)
    {
      oldPlanLine.orders.forEach(lineOrder =>
      {
        const orderState = state.orderStates.get(lineOrder.orderNo);

        if (!orderState)
        {
          return;
        }

        const {order} = orderState;

        orderState.quantityTodo -= lineOrder.quantity;
        order.incomplete = Math.max(0, orderState.quantityTodo);

        if (order.incomplete)
        {
          state.newIncompleteOrders.set(order._id, order.incomplete);
        }
        else
        {
          state.newIncompleteOrders.delete(order._id);
        }
      });
    }

    logLine(lineState, 'Completed existing line with no changes!', {
      line: lineState._id
    });

    return setImmediate(done);
  }

  function calculateShiftData(planLine)
  {
    const shiftData = [
      {manHours: 0, quantity: 0, orderCount: 0},
      {manHours: 0, quantity: 0, orderCount: 0},
      {manHours: 0, quantity: 0, orderCount: 0}
    ];

    planLine.orders.forEach(planLineOrder =>
    {
      const h = planLineOrder.startAt.getUTCHours();
      const shift = shiftData[h >= 6 && h < 14 ? 0 : h >= 14 && h < 22 ? 1 : 2];

      shift.manHours += planLineOrder.manHours;
      shift.quantity += planLineOrder.quantity;
      shift.orderCount += 1;
    });

    planLine.shiftData = shiftData;
  }

  function isOrderPinnedToLine(orderState, lineState)
  {
    if (orderState.lines.length === 0)
    {
      return false;
    }

    return orderState.lines[0] !== lineState._id;
  }

  function getNextOrderForLine(state, lineState)
  {
    logLine(lineState, 'Resolving next order for line...', {
      line: lineState._id
    });

    // Urgent orders
    const timeForEtoPilots = isTimeForEtoPilots(state, lineState);

    if (timeForEtoPilots && lineState.skippedEtoPilots.length)
    {
      logLine(lineState, 'Time for ETO pilots!', {
        line: lineState._id,
        skippedEtoPilots: lineState.skippedEtoPilots.map(o => o.order._id)
      });

      lineState.orderStateQueue = lineState.skippedEtoPilots.concat(lineState.orderStateQueue);
      lineState.skippedEtoPilots = [];
    }

    const timeForLateOrders = isTimeForLateOrders(state, lineState);

    if (timeForLateOrders && lineState.skippedLateOrders.length)
    {
      logLine(lineState, 'Time for late orders!', {
        line: lineState._id,
        skippedLateOrders: lineState.skippedLateOrders.map(o => o.order._id)
      });

      lineState.orderStateQueue = lineState.skippedLateOrders.concat(lineState.orderStateQueue);
      lineState.skippedLateOrders = [];
    }

    while (lineState.orderStateQueue.length)
    {
      const candidate = lineState.orderStateQueue[0];

      if ((!timeForLateOrders || !candidate.order.urgent)
        && (!timeForEtoPilots || candidate.sapOrder.priority !== 'E'))
      {
        logLine(lineState, 'Skipping not urgent order...', {
          line: lineState._id,
          order: candidate.order._id,
          timeForLateOrders,
          urgent: candidate.order.urgent,
          timeForEtoPilots,
          priority: candidate.sapOrder.priority
        });

        break;
      }

      const urgentOrderState = lineState.orderStateQueue.shift();

      if (!timeForLateOrders && urgentOrderState.order.urgent && urgentOrderState.order.source === 'added')
      {
        logLine(lineState, 'Skipping late order...', {
          line: lineState._id,
          order: urgentOrderState.order._id
        });

        lineState.skippedLateOrders.push(urgentOrderState);

        continue;
      }

      if (!timeForEtoPilots && urgentOrderState.sapOrder.priority === 'E')
      {
        logLine(lineState, 'Skipping ETO pilot...', {
          line: lineState._id,
          order: urgentOrderState.order._id
        });

        lineState.skippedEtoPilots.push(urgentOrderState);

        continue;
      }

      const alreadyPlanned = lineState.plannedOrdersSet.has(urgentOrderState.order._id);
      const completed = urgentOrderState.quantityTodo === 0;
      const pinned = isOrderPinnedToLine(urgentOrderState, lineState);

      if (alreadyPlanned || completed || pinned)
      {
        logLine(lineState, 'Skipping urgent order...', {
          line: lineState._id,
          order: urgentOrderState.order._id,
          alreadyPlanned,
          completed,
          pinned
        });

        continue;
      }

      logLine(lineState, 'Trying urgent order...', {
        line: lineState._id,
        order: urgentOrderState.order._id
      });

      return urgentOrderState;
    }

    // Frozen orders
    while (lineState.orderStateQueue.length)
    {
      if (!lineState.frozenOrdersMap.has(lineState.orderStateQueue[0].order._id))
      {
        logLine(lineState, 'Skipping not frozen order...', {
          line: lineState._id,
          order: lineState.orderStateQueue[0].order._id
        });

        break;
      }

      const frozenOrderState = lineState.orderStateQueue.shift();
      const alreadyPlanned = lineState.plannedOrdersSet.has(frozenOrderState.order._id);
      const completed = frozenOrderState.quantityTodo === 0;

      if (alreadyPlanned || completed)
      {
        logLine(lineState, 'Skipping frozen order...', {
          line: lineState._id,
          order: frozenOrderState.order._id,
          alreadyPlanned,
          completed
        });

        continue;
      }

      logLine(lineState, 'Trying frozen order...', {
        line: lineState._id,
        order: frozenOrderState.order._id
      });

      return frozenOrderState;
    }

    // Big order parts
    const bigOrderIdSet = new Set();

    if (lineState.bigOrderStateQueue.length)
    {
      const activeFromTime = lineState.activeFrom.valueOf();
      const bigOrderStateQueue = [];

      lineState.bigOrderStateQueue.forEach(orderState =>
      {
        if (lineState.plannedOrdersSet.has(orderState.order._id)
          || orderState.quantityTodo === 0
          || orderState.startTimes.length === 0)
        {
          return;
        }

        orderState.timeDiff = activeFromTime - orderState.startTimes[0];

        bigOrderIdSet.add(orderState.order._id);
        bigOrderStateQueue.push(orderState);
      });

      bigOrderStateQueue.sort((a, b) => b.timeDiff - a.timeDiff);

      lineState.bigOrderStateQueue = bigOrderStateQueue;

      // TODO Math.abs?
      const timeDiff = -60;

      if (bigOrderStateQueue.length && bigOrderStateQueue[0].timeDiff > timeDiff * 60 * 1000)
      {
        logLine(lineState, 'Trying big order...', {
          line: lineState._id,
          order: bigOrderStateQueue[0].order._id
        });

        return bigOrderStateQueue.shift();
      }
    }

    const firstPass = state.generateCallCount === 1;

    // Remaining orders but already started big ones
    while (lineState.orderStateQueue.length)
    {
      const orderState = lineState.orderStateQueue.shift();
      const {order, sapOrder} = orderState;

      const alreadyPlanned = lineState.plannedOrdersSet.has(order._id);
      const completed = orderState.quantityTodo <= 0;
      const bigOrder = bigOrderIdSet.has(order._id);
      const pinned = isOrderPinnedToLine(orderState, lineState);
      const frozen = firstPass && !!orderState.frozenOnLines.length && !orderState.frozenOnLines.includes(lineState._id);

      if (alreadyPlanned || completed || bigOrder || pinned || frozen)
      {
        logLine(lineState, 'Skipping remaining order...', {
          line: lineState._id,
          order: order._id,
          alreadyPlanned,
          completed,
          bigOrder,
          pinned,
          frozen
        });

        continue;
      }

      if (!timeForLateOrders && sapOrder.priority === 'E')
      {
        logLine(lineState, 'Skipping remaining ETO pilot...', {
          line: lineState._id,
          order: order._id
        });

        lineState.skippedEtoPilots.push(orderState);

        continue;
      }

      if (!timeForLateOrders && order.urgent && order.source === 'added')
      {
        logLine(lineState, 'Skipping remaining late order...', {
          line: lineState._id,
          order: order._id
        });

        lineState.skippedLateOrders.push(orderState);

        continue;
      }

      logLine(lineState, 'Trying remaining order...', {
        line: lineState._id,
        order: order._id
      });

      return orderState;
    }

    // Remaining big orders
    if (lineState.bigOrderStateQueue.length)
    {
      logLine(lineState, 'Trying remaining big order...', {
        line: lineState._id,
        order: lineState.bigOrderStateQueue[0].order._id
      });

      return lineState.bigOrderStateQueue.shift();
    }

    logLine(lineState, 'No order found!', {
      line: lineState._id
    });

    return null;
  }

  function isTimeForLateOrders(state, lineState)
  {
    if (state.generateCallCount > 1)
    {
      return true;
    }

    let activeFromHour = lineState.activeFrom.hours();

    if (activeFromHour < 6)
    {
      activeFromHour += 18;
    }
    else
    {
      activeFromHour -= 6;
    }

    return activeFromHour >= state.settings.lateHour;
  }

  function isTimeForEtoPilots(state, lineState)
  {
    if (state.generateCallCount > 1)
    {
      return true;
    }

    let activeFromHour = lineState.activeFrom.hours();

    if (activeFromHour < 6)
    {
      activeFromHour += 18;
    }
    else
    {
      activeFromHour -= 6;
    }

    return activeFromHour >= state.settings.etoPilotHour;
  }

  function handleSmallOrder(state, lineState, orderState)
  {
    let candidate = trySmallOrder(state, lineState, orderState);

    if (!candidate)
    {
      return;
    }

    if (candidate.quantityRemaining <= 0)
    {
      mergeOrderCandidate(state, lineState, candidate);

      return;
    }

    const candidates = [candidate];

    logLine(lineState, 'Order not planned in full...', {
      line: lineState._id,
      order: orderState.order._id,
      quantityRemaining: candidate.quantityRemaining
    });

    while (true) // eslint-disable-line no-constant-condition
    {
      const nextOrderState = getNextOrderForLine(state, lineState);

      if (!nextOrderState)
      {
        logLine(lineState, 'No more orders to try to replace an incomplete order!', {
          line: lineState._id,
          order: orderState.order._id
        });

        break;
      }

      if (nextOrderState === candidate.orderState)
      {
        logLine(lineState, 'Skipping the same order...', {
          line: lineState._id,
          order: orderState.order._id
        });

        continue;
      }

      logLine(lineState, 'Trying next order...', {
        line: lineState._id,
        order: orderState.order._id,
        candidate: nextOrderState.order._id
      });

      const nextCandidate = handleOrderState(state, lineState, nextOrderState, true);

      if (nextCandidate)
      {
        candidates.push(nextCandidate);

        if (nextCandidate.completion === 1)
        {
          logLine(lineState, 'Found perfect candidate!', {
            line: lineState._id,
            order: orderState.order._id,
            candidate: nextOrderState.order._id
          });

          break;
        }
      }
    }

    candidates.sort((a, b) =>
    {
      const completion = b.completion - a.completion;

      return completion === 0 ? (b.duration - a.duration) : completion;
    });

    const bestCandidate = candidates[0];
    const completion = Math.ceil(bestCandidate.completion * 100);

    // Reset the assigned groups, so the orders can be picked up by other lines
    for (let i = 1; i < candidates.length; ++i)
    {
      const {orderState} = candidates[i];
      const orderLines = state.orderToLines.get(orderState.order._id);

      if (orderLines && orderLines.size)
      {
        continue;
      }

      orderState.group = null;
    }

    if (state.generateCallCount === 1)
    {
      if (completion < 80 && !bestCandidate.lastAvailableLine)
      {
        logLine(lineState, 'Ignored low completion candidate!', {
          line: lineState._id,
          order: orderState.order._id,
          candidate: bestCandidate.orderState.order._id,
          completion
        });

        return;
      }

      if (bestCandidate.totalQuantityPlanned === 1)
      {
        logLine(lineState, 'Ignored single PCE candidate!', {
          line: lineState._id,
          order: orderState.order._id,
          candidate: bestCandidate.orderState.order._id
        });

        return;
      }
    }

    logLine(lineState, 'Merging best candidate!', {
      line: lineState._id,
      order: orderState.order._id,
      candidate: bestCandidate.orderState.order._id,
      completion
    });

    candidate = bestCandidate;

    mergeOrderCandidate(state, lineState, candidate);
  }

  function mergeOrderCandidate(state, lineState, candidate)
  {
    const plannedOrderState = candidate.orderState;
    const order = plannedOrderState.order;

    plannedOrderState.quantityTodo -= candidate.totalQuantityPlanned;

    plannedOrderState.startTimes.push(candidate.plannedOrders[0].startAt.getTime());
    plannedOrderState.startTimes.sort((a, b) => a - b);

    if (!plannedOrderState.group)
    {
      plannedOrderState.group = state.grouping.orderToGroups.get(order._id).find(
        group => group.lines.includes(lineState._id)
      );
    }

    if (plannedOrderState.startTimes.length === 1 && plannedOrderState.quantityTodo > 0)
    {
      getLinesForBigOrder(state, order).forEach(availableLineState =>
      {
        if (availableLineState === lineState)
        {
          return;
        }

        if (plannedOrderState.group && !plannedOrderState.group.lines.includes(availableLineState._id))
        {
          return;
        }

        lineState.bigOrderStateQueue.push(plannedOrderState);
      });
    }

    candidate.plannedOrders.forEach(lineOrder =>
    {
      lineState.hash += lineOrder._id
        + 3
        + lineOrder.quantity
        + lineOrder.startAt.getTime()
        + lineOrder.finishAt.getTime();
    });

    lineState.completed = candidate.completed;
    lineState.shiftNo = candidate.shiftNo;
    lineState.activeFrom = moment.utc(_.last(candidate.plannedOrders).finishAt.getTime());
    lineState.nextDowntime = candidate.nextDowntime;
    lineState.plannedOrdersList = lineState.plannedOrdersList.concat(candidate.plannedOrders);
    lineState.downtimes = lineState.downtimes.concat(candidate.downtimes);

    candidate.hourlyPlan.forEach((v, k) => lineState.hourlyPlan[k] += v);

    order.incomplete = plannedOrderState.quantityTodo;

    if (order.incomplete)
    {
      state.newIncompleteOrders.set(order._id, order.incomplete);
    }
    else
    {
      state.newIncompleteOrders.delete(order._id);
    }

    lineState.plannedOrdersSet.add(order._id);

    if (!state.orderToLines.has(order._id))
    {
      state.orderToLines.set(order._id, new Set());
    }

    state.orderToLines.get(order._id).add(lineState);

    if (plannedOrderState.small)
    {
      const oldPlannedCount = lineState.smallOrders.planned.get(order.mrp);
      const newPlannedCount = oldPlannedCount + 1;

      lineState.smallOrders.planned.set(order.mrp, newPlannedCount);
    }
  }

  function trySmallOrder(state, lineState, orderState, options)
  {
    const order = orderState.order;
    const orderNo = order._id;
    const sapOrder = state.sapOrders.get(orderNo);
    const lineId = lineState._id;
    const mrpId = order.mrp;

    const settings = state.settings;
    const mrpSettings = settings.mrp(mrpId);
    const mrpLineSettings = settings.mrpLine(mrpId, lineId);
    let workerCount = mrpLineSettings.workerCount[lineState.shiftNo - 1];

    if (workerCount === 0)
    {
      logLine(lineState, 'Order skipped: no workers!', {
        line: lineId,
        order: orderNo,
        shift: lineState.shiftNo
      });

      return null;
    }

    if (!state.resized
      && state.generateCallCount === 1
      && orderState.small
      && mrpSettings.limitSmallOrders
      && lineState.smallOrders.limit.get(mrpId) > 0
      && lineState.smallOrders.planned.get(mrpId) === lineState.smallOrders.limit.get(mrpId))
    {
      logLine(lineState, 'Order skipped: small orders limit reached!', {
        line: lineId,
        order: orderNo
      });

      return null;
    }

    const lastAvailableLine = getLinesForBigOrder(state, order).length === 1;
    const activeTo = lineState.activeTo.valueOf();
    let pceTime = getPceTime(order, workerCount, mrpSettings.schedulingRate);
    let startAt = lineState.activeFrom.valueOf();
    let finishAt = startAt + getOrderStartOverhead(state.settings, lineState, orderState);
    let totalQuantityPlanned = 0;
    let quantityPlanned = 0;
    let quantityRemaining = 0;
    let quantityTodo = orderState.quantityTodo;
    let maxQuantityPerLine = orderState.maxQuantityPerLine === 0 || lastAvailableLine
      ? orderState.quantityTodo
      : orderState.maxQuantityPerLine;
    let nextDowntime = lineState.nextDowntime;
    let shiftNo = lineState.shiftNo;
    let completed = false;
    let downtimes = [];
    let pceTimes = [];
    const plannedOrders = [];
    const hourlyPlan = EMPTY_HOURLY_PLAN.slice();

    if (options && options.continuation)
    {
      finishAt = startAt;
      maxQuantityPerLine = options.maxQuantityPerLine;
    }
    else if (state.generateCallCount === 1 && lineState.frozenOrdersMap.has(orderNo))
    {
      maxQuantityPerLine = lineState.frozenOrdersMap.get(orderNo);
    }

    logLine(lineState, 'Trying small order...', {
      line: lineId,
      order: orderNo,
      kind: order.kind,
      workerCount,
      laborTime: order.operation.laborTime,
      manHours: order.manHours,
      pceTime: pceTime / 1000,
      quantityTodo,
      maxQuantityPerLine,
      activeFrom: moment.utc(startAt).format('DD.MM HH:mm:ss'),
      activeTo: moment.utc(activeTo).format('DD.MM HH:mm:ss')
    });

    while (quantityPlanned <= quantityTodo)
    {
      let newFinishAt = finishAt + pceTime;
      let newNextDowntime = nextDowntime;
      const newDowntimes = [];

      while (newNextDowntime)
      {
        if (newNextDowntime.startTime <= newFinishAt)
        {
          if (newNextDowntime.startTime >= startAt)
          {
            newDowntimes.push({
              reason: newNextDowntime.reason,
              startAt: new Date(newNextDowntime.startTime),
              duration: newNextDowntime.duration
            });

            newFinishAt += newNextDowntime.duration;
          }

          newNextDowntime = newNextDowntime.next;

          continue;
        }

        break;
      }

      const newFinishMoment = moment.utc(newFinishAt);
      const h = newFinishMoment.hours();

      // End of 3rd shift
      if (newFinishAt > activeTo || (shiftNo === 3 && h >= 6 && h < 22))
      {
        if (quantityPlanned > 0)
        {
          quantityRemaining = quantityTodo - quantityPlanned;

          plannedOrders.push({
            _id: getNextLineOrderId(orderNo, shiftNo, lineState.plannedOrdersList, plannedOrders),
            orderNo,
            quantity: quantityPlanned,
            pceTime,
            manHours: getManHours(order.operation, quantityPlanned, mrpSettings.schedulingRate),
            startAt: new Date(startAt),
            finishAt: new Date(finishAt),
            pceTimes
          });

          pceTimes = [];
        }

        completed = true;

        break;
      }

      // PCE crosses to 2nd or 3rd shift
      if ((shiftNo === 1 && h >= 14) || (shiftNo === 2 && (h >= 22 || h < 6)))
      {
        // First PCE crosses to 2nd or 3rd shift
        if (quantityPlanned === 0)
        {
          shiftNo += 1;
          workerCount = mrpLineSettings.workerCount[shiftNo - 1];
          pceTime = getPceTime(order, workerCount, mrpSettings.schedulingRate);
          startAt = settings.shiftStartTimes[shiftNo - 1];
          finishAt = startAt + mrpSettings.extraShiftSeconds[shiftNo - 1];
        }
        else
        {
          plannedOrders.push({
            _id: getNextLineOrderId(orderNo, shiftNo, lineState.plannedOrdersList, plannedOrders),
            orderNo,
            quantity: quantityPlanned,
            pceTime,
            manHours: getManHours(order.operation, quantityPlanned, mrpSettings.schedulingRate),
            startAt: new Date(startAt),
            finishAt: new Date(finishAt),
            pceTimes
          });

          pceTimes = [];

          if (quantityPlanned === quantityTodo
            || (maxQuantityPerLine > 0 && totalQuantityPlanned === maxQuantityPerLine))
          {
            break;
          }

          shiftNo += 1;
          workerCount = mrpLineSettings.workerCount[shiftNo - 1];
          pceTime = getPceTime(order, workerCount, mrpSettings.schedulingRate);
          startAt = settings.shiftStartTimes[shiftNo - 1];
          finishAt = startAt + mrpSettings.extraOrderSeconds;
          quantityTodo -= quantityPlanned;
          quantityPlanned = 0;
        }

        continue;
      }

      if (quantityPlanned === quantityTodo
        || (maxQuantityPerLine > 0 && totalQuantityPlanned === maxQuantityPerLine))
      {
        plannedOrders.push({
          _id: getNextLineOrderId(orderNo, shiftNo, lineState.plannedOrdersList, plannedOrders),
          orderNo: orderNo,
          quantity: quantityPlanned,
          pceTime: pceTime,
          manHours: getManHours(order.operation, quantityPlanned, mrpSettings.schedulingRate),
          startAt: new Date(startAt),
          finishAt: new Date(finishAt),
          pceTimes
        });

        pceTimes = [];

        break;
      }

      finishAt = newFinishAt;
      nextDowntime = newNextDowntime;
      quantityPlanned += 1;
      totalQuantityPlanned += 1;

      downtimes = downtimes.concat(newDowntimes);
      pceTimes.push(h, newFinishMoment.minutes());
      hourlyPlan[HOUR_TO_INDEX[h]] += 1;
    }

    if (plannedOrders.length === 0)
    {
      logLine(lineState, 'Not planned anything!', {
        line: lineId,
        order: orderNo
      });

      return null;
    }

    if (sapOrder.priority === 'E')
    {
      const startHours = plannedOrders[0].startAt.getUTCHours();

      if (startHours < 6 || startHours >= 14 || plannedOrders.length > 1)
      {
        logLine(lineState, 'Ignored invalid ETO pilot!', {
          line: lineId,
          order: orderNo,
          startHours,
          plannedOrderCount: plannedOrders.length
        });

        return null;
      }
    }

    const totalQuantityToPlan = totalQuantityPlanned + quantityRemaining;
    const completion = totalQuantityPlanned / totalQuantityToPlan;
    const duration = _.last(plannedOrders).finishAt.getTime() - plannedOrders[0].startAt.getTime();

    logLine(lineState, 'Order planned!', {
      line: lineId,
      order: orderNo,
      totalQuantityToPlan,
      totalQuantityPlanned,
      quantityRemaining,
      completion: Math.round(completion * 10) / 10,
      duration: duration / 1000,
      plannedOrders: plannedOrders.map(plannedOrder =>
      {
        return {
          quantity: plannedOrder.quantity,
          startAt: moment.utc(plannedOrder.startAt).format('DD.MM HH:mm:ss'),
          finishAt: moment.utc(plannedOrder.finishAt).format('DD.MM HH:mm:ss'),
          duration: (plannedOrder.finishAt - plannedOrder.startAt) / 1000
        };
      })
    });

    return {
      orderState,
      plannedOrders,
      lastAvailableLine,
      totalQuantityPlanned,
      totalQuantityToPlan,
      quantityRemaining,
      maxQuantityPerLine,
      completed,
      shiftNo,
      nextDowntime,
      downtimes,
      hourlyPlan,
      completion,
      duration
    };
  }

  function handleBigOrder(state, lineState, orderState, trying)
  {
    const {order} = orderState;
    let {splitOrderQuantity, maxSplitLineCount} = state.settings.mrp(order.mrp);

    if (orderState.group)
    {
      splitOrderQuantity = orderState.group.splitOrderQuantity;
      maxSplitLineCount = 0;
    }

    if (orderState.quantityTodo < splitOrderQuantity
      || (maxSplitLineCount && orderState.maxQuantityPerLine > 0))
    {
      return (trying ? trySmallOrder : handleSmallOrder)(state, lineState, orderState);
    }

    const availableLines = getLinesForBigOrder(state, order).filter(
      lineState => !orderState.group || orderState.group.lines.includes(lineState._id)
    );
    const splitLineCount = maxSplitLineCount > 0 && maxSplitLineCount < availableLines.length
      ? maxSplitLineCount
      : availableLines.length;

    orderState.maxQuantityPerLine = splitLineCount === 0
      ? orderState.quantityTodo
      : Math.ceil(orderState.quantityTodo / splitLineCount);

    availableLines.forEach(availableLineState =>
    {
      if (availableLineState !== lineState)
      {
        availableLineState.bigOrderStateQueue.push(orderState);
      }
    });

    return (trying ? trySmallOrder : handleSmallOrder)(state, lineState, orderState);
  }

  function getLinesForBigOrder(state, order)
  {
    const mrpSettings = state.settings.mrp(order.mrp);

    return state.settings.mrp(order.mrp).lines
      .filter(mrpLineSettings =>
      {
        const lineState = state.lineStates.get(mrpLineSettings._id);

        if (lineState.completed
          || !mrpLineSettings.orderPriority.includes(order.kind)
          || !mrpLineSettings.workerCount.some(c => c > 0))
        {
          return false;
        }

        const availableTime = getRemainingAvailableTime(lineState);
        const workerCount = mrpLineSettings.workerCount[lineState.shiftNo - 1];
        const pceTime = getPceTime(order, workerCount, mrpSettings.schedulingRate);

        return availableTime >= pceTime;
      })
      .map(line => state.lineStates.get(line._id));
  }

  function getNextLineOrderId(orderId, shiftNo, linePlannedOrders, newPlannedOrders)
  {
    return `${orderId}-${shiftNo}-${1 + linePlannedOrders.length + newPlannedOrders.length}`;
  }

  function getPceTime(order, workerCount, schedulingRate)
  {
    return order.operation.laborTime
      ? (Math.ceil(order.operation.laborTime / 100 / workerCount * 3600 * schedulingRate) * 1000)
      : 0;
  }

  function getManHours(operation, quantityTodo, schedulingRate)
  {
    return operation.laborTime
      ? (((operation.laborTime / 100 * quantityTodo) + operation.laborSetupTime) * schedulingRate)
      : 0;
  }

  function getOrderStartOverhead(settings, lineState, orderState)
  {
    const shiftStartTimes = settings.shiftStartTimes;
    const {extraOrderSeconds, extraShiftSeconds, schedulingRate} = settings.mrp(orderState.order.mrp);
    const hours = lineState.activeFrom.hours();
    const seconds = lineState.activeFrom.minutes() * 60;
    const laborSetupTime = orderState.order.operation.laborSetupTime * schedulingRate;
    let shiftStartTime = 0;
    let extraShiftStartTime = 0;

    if (hours === 6 && seconds < extraShiftSeconds[0])
    {
      shiftStartTime = shiftStartTimes[0];
      extraShiftStartTime = extraShiftSeconds[0] * 1000;
    }
    else if (hours === 14 && seconds < extraShiftSeconds[1])
    {
      shiftStartTime = shiftStartTimes[1];
      extraShiftStartTime = extraShiftSeconds[1] * 1000;
    }
    else if (hours === 22 && seconds < extraShiftSeconds[2])
    {
      shiftStartTime = shiftStartTimes[2];
      extraShiftStartTime = extraShiftSeconds[2] * 1000;
    }
    else
    {
      return (extraOrderSeconds * 1000) + laborSetupTime;
    }

    const orderStartAt = lineState.activeFrom.valueOf();
    const startDowntimeFinishAt = shiftStartTime + extraShiftStartTime;

    if (orderStartAt >= startDowntimeFinishAt)
    {
      return (extraOrderSeconds * 1000) + laborSetupTime;
    }

    return (extraShiftStartTime - (orderStartAt - shiftStartTime)) + laborSetupTime;
  }

  function recountHourlyPlan(planLine)
  {
    for (let i = 0; i < 24; ++i)
    {
      planLine.hourlyPlan[i] = 0;
    }

    planLine.orders.forEach(lineOrder =>
    {
      for (let i = 0; i < lineOrder.pceTimes.length; i += 2)
      {
        planLine.hourlyPlan[HOUR_TO_INDEX[lineOrder.pceTimes[i]]] += 1;
      }
    });
  }

  function resizeAndFillLines(state, done)
  {
    state.resized = true;

    step(
      function()
      {
        resizeLinesMiddle(state, this.next());
      },
      function()
      {
        fillLines(state, this.next());
      },
      function(err, again) // eslint-disable-line handle-callback-err
      {
        setImmediate(this.parallel(), null, again);

        resizeLinesEnd(state, this.parallel());
      },
      function(err, again) // eslint-disable-line handle-callback-err
      {
        if (again && !state.cancelled)
        {
          log('Resize and fill lines - again...');

          setImmediate(resizeAndFillLines, state, done);
        }
        else
        {
          setImmediate(done);
        }
      }
    );
  }

  function resizeLinesMiddle(state, done)
  {
    if (state.cancelled || !state.newIncompleteOrders.size)
    {
      log('Not resizing in the middle!');

      return done();
    }

    log('Resizing in the middle...');

    const incompletePlannedOrders = [];

    state.newIncompleteOrders.forEach((incomplete, orderNo) =>
    {
      if (state.resizedOrders.has(orderNo))
      {
        return;
      }

      const order = state.orders.get(orderNo);

      if (state.lockedMrps.has(order.mrp))
      {
        return;
      }

      const quantityTodo = getQuantityTodo(state, order);

      if (incomplete >= quantityTodo)
      {
        return;
      }

      const plannedLines = Array.from(state.orderToLines.get(orderNo));

      if (plannedLines.length === 1 && state.generateCallCount === 1)
      {
        const lastPlannedOrder = _.last(plannedLines[0].plannedOrdersList);

        if (lastPlannedOrder.orderNo === orderNo)
        {
          return;
        }
      }

      let startAt = Number.MAX_SAFE_INTEGER;

      const resizeablePlannedLines = plannedLines.filter(plannedLineState =>
      {
        if (plannedLineState.unresizablePlannedOrdersSet.has(orderNo))
        {
          return false;
        }

        const plannedOrder = plannedLineState.plannedOrdersList.find(o => o.orderNo === orderNo);

        if (plannedOrder.startAt < startAt)
        {
          startAt = plannedOrder.startAt.getTime();
        }

        return true;
      });

      if (!resizeablePlannedLines.length)
      {
        return;
      }

      incompletePlannedOrders.push({
        order,
        plannedLines: resizeablePlannedLines,
        startAt
      });
    });

    if (!incompletePlannedOrders.length)
    {
      log('...nothing to resize!');

      return setImmediate(done);
    }

    const usedLines = new Set();

    incompletePlannedOrders.sort((a, b) => a.startAt - b.startAt).forEach(d =>
    {
      if (d.plannedLines.some(l => usedLines.has(l._id)))
      {
        return;
      }

      d.plannedLines.forEach(l =>
      {
        state.hourlyPlanRecount.add(l._id);
        usedLines.add(l._id);
      });

      state.resizedOrders.add(d.order._id);

      resizeIncompletePlannedOrder(state, d.order, d.plannedLines);
    });

    setImmediate(done, null, usedLines);
  }

  function resizeLinesEnd(state, done)
  {
    if (state.cancelled || !state.newIncompleteOrders.size)
    {
      return done();
    }

    log('Resizing at the end...');

    const incompletePlannedOrders = [];

    state.newIncompleteOrders.forEach((incomplete, orderNo) =>
    {
      if (state.resizedOrders.has(orderNo))
      {
        return;
      }

      const plannedLines = state.orderToLines.get(orderNo);

      if (!plannedLines)
      {
        return;
      }

      const incompleteLines = [];

      plannedLines.forEach(lineState =>
      {
        const lastPlannedOrder = _.last(lineState.plannedOrdersList);

        if (lastPlannedOrder.orderNo === orderNo)
        {
          incompleteLines.push(lineState._id);
        }
      });

      if (incompleteLines.length)
      {
        incompletePlannedOrders.push({
          orderNo,
          incompleteLines
        });
      }
    });

    if (!incompletePlannedOrders.length)
    {
      log('...nothing to resize!');

      return setImmediate(done);
    }

    log('Incomplete planned orders to resize...', {incompletePlannedOrders});

    setImmediate(done);
  }

  function resizeIncompletePlannedOrder(state, order, lineStates)
  {
    log(`Resizing incomplete order...`, {
      order: order._id,
      incomplete: state.newIncompleteOrders.get(order._id),
      lines: lineStates.map(lineState => lineState._id)
    });

    const unplannedGroupedOrderStates = new Set();
    let minPceCount = Number.MAX_SAFE_INTEGER;

    lineStates.forEach(lineState =>
    {
      log(`Resizing line...`, {
        line: lineState._id,
        order: order._id
      });

      const plannedLineOrders = lineState.plannedOrdersList;
      const plannedOrderIndex = _.findLastIndex(plannedLineOrders, o => o.orderNo === order._id);
      const plannedOrder = plannedLineOrders[plannedOrderIndex];
      const activeFromTime = plannedOrder.finishAt.getTime();

      lineState.completed = false;
      lineState.activeFrom = moment.utc(activeFromTime);
      lineState.shiftNo = getShiftFromMoment(lineState.activeFrom);

      plannedLineOrders.splice(plannedOrderIndex + 1).forEach(unplannedLineOrder =>
      {
        lineState.plannedOrdersSet.delete(unplannedLineOrder.orderNo);

        const oldIncompleteQuantity = state.newIncompleteOrders.get(unplannedLineOrder.orderNo) || 0;
        const newIncompleteQuantity = oldIncompleteQuantity + unplannedLineOrder.quantity;
        const orderToLines = state.orderToLines.get(unplannedLineOrder.orderNo);

        state.newIncompleteOrders.set(unplannedLineOrder.orderNo, newIncompleteQuantity);

        orderToLines.delete(lineState);

        const unplannedOrderState = state.orderStates.get(unplannedLineOrder.orderNo);

        unplannedOrderState.order.incomplete = newIncompleteQuantity;
        unplannedOrderState.quantityTodo = newIncompleteQuantity;

        removeFirstItem(unplannedOrderState.startTimes, unplannedLineOrder.startAt.getTime());

        if (unplannedOrderState.group)
        {
          unplannedGroupedOrderStates.add(unplannedOrderState);
        }

        log(`Removed order from line during resizing.`, {
          line: lineState._id,
          order: unplannedLineOrder.orderNo
        });
      });

      for (let i = lineState.downtimes.length - 1; i >= 0; --i)
      {
        const downtime = lineState.downtimes[i];

        if (downtime.startAt < activeFromTime)
        {
          lineState.downtimes.splice(i + 1);

          break;
        }

        lineState.nextDowntime = {
          reason: downtime.reason,
          startTime: downtime.startAt.getTime(),
          duration: downtime.duration,
          next: lineState.nextDowntime
        };
      }

      const availableTime = getRemainingAvailableTime(lineState);
      const pceTime = plannedOrder.pceTime;
      const maxPceCount = Math.floor(availableTime / pceTime);

      if (maxPceCount < minPceCount)
      {
        minPceCount = maxPceCount;
      }

      lineState.resize = {
        plannedOrderIndex,
        maxPceCount
      };
    });

    unplannedGroupedOrderStates.forEach(orderState =>
    {
      if (state.orderToLines.get(orderState.order._id).size === 0)
      {
        orderState.maxQuantityPerLine = 0;
        orderState.group = null;
      }
    });

    lineStates.sort((a, b) => a.resize.maxPceCount - b.resize.maxPceCount);

    while (lineStates.length)
    {
      const lineState = lineStates.shift();

      if (lineState.resize.maxPceCount === 0)
      {
        continue;
      }

      const orderState = state.orderStates.get(order._id);
      const options = {
        continuation: true,
        maxQuantityPerLine: Math.min(
          Math.ceil(orderState.quantityTodo / lineStates.length),
          lineState.resize.maxPceCount
        )
      };
      const candidate = trySmallOrder(state, lineState, orderState, options);

      if (candidate)
      {
        mergeOrderCandidate(state, lineState, candidate);

        const firstPart = lineState.plannedOrdersList[lineState.resize.plannedOrderIndex];
        const secondPart = lineState.plannedOrdersList[lineState.resize.plannedOrderIndex + 1];

        firstPart.finishAt = secondPart.finishAt;
        firstPart.quantity += secondPart.quantity;
        firstPart.manHours += secondPart.manHours;
        firstPart.pceTimes = firstPart.pceTimes.concat(secondPart.pceTimes);

        lineState.plannedOrdersList.splice(lineState.resize.plannedOrderIndex + 1, 1);
      }

      completeLine(state, lineState);
    }
  }

  function fillLines(state, done)
  {
    if (state.cancelled || !state.newIncompleteOrders.size)
    {
      log('Not filling lines!');

      return done(null, false);
    }

    log('Filling lines...');

    const incompleteMrps = new Map();
    const checkedMrps = new Set();

    state.newIncompleteOrders.forEach((incomplete, orderNo) =>
    {
      if (incomplete <= 0)
      {
        return;
      }

      const planOrder = state.orders.get(orderNo);

      if (isUnplannableOrder(state, planOrder))
      {
        return;
      }

      const {mrp} = planOrder;

      if (checkedMrps.has(mrp))
      {
        if (incompleteMrps.has(mrp))
        {
          incompleteMrps.get(mrp).push(orderNo);
        }

        return;
      }

      if (!state.lockedMrps.has(mrp) && hasAnyLineWithRoomForOrder(state, orderNo))
      {
        incompleteMrps.set(mrp, [orderNo]);
      }

      checkedMrps.add(mrp);
    });

    if (incompleteMrps.size && state.incompleteMrps)
    {
      incompleteMrps.forEach((orderNos, mrp) =>
      {
        const oldOrderNos = state.incompleteMrps.get(mrp);

        if (jsonDeepEqual(orderNos, oldOrderNos))
        {
          incompleteMrps.delete(mrp);
        }
      });
    }

    state.incompleteMrps = incompleteMrps;

    if (!incompleteMrps.size)
    {
      log('...nothing to fill!');

      return setImmediate(done, null, false);
    }

    const steps = [
      function()
      {
        state.linesWithChanges.clear();
      }
    ];

    incompleteMrps.forEach((orderNos, mrp) =>
    {
      steps.push(function()
      {
        if (state.cancelled)
        {
          return this.skip();
        }

        fillMrpLines(state, mrp, orderNos, this.next());
      });
    });

    steps.push(function() { generatePlanForLines(1, state, this.next()); });
    steps.push(function() { done(null, state.linesWithChanges.size > 0); });

    step(steps);
  }

  function fillMrpLines(state, mrp, orderNos, done)
  {
    log(`Filling MRP...`, {
      mrp,
      orders: orderNos
    });

    const lineStatesToFill = [];

    state.settings.mrp(mrp).lines.forEach(mrpLineSettings =>
    {
      const lineState = state.lineStates.get(mrpLineSettings._id);

      lineState.orderStateQueue = [];

      orderNos.forEach(orderNo =>
      {
        const orderState = state.orderStates.get(orderNo);

        if (orderState.group)
        {
          if (orderState.group.components.length && !orderState.group.lines.includes(lineState._id))
          {
            return;
          }

          orderState.group = null;
        }

        if (orderState.group && !orderState.group.lines.includes(lineState._id))
        {
          return;
        }

        if (!mrpLineSettings.orderPriority.includes(orderState.order.kind))
        {
          return;
        }

        orderState.lines = [];
        orderState.maxQuantityPerLine = 0;

        lineState.orderStateQueue.push(orderState);
      });

      lineState.orderStateQueue.sort((a, b) =>
      {
        const aStartTime = a.startTimes[0] || Number.MAX_SAFE_INTEGER;
        const bStartTime = b.startTimes[0] || Number.MAX_SAFE_INTEGER;

        return aStartTime === bStartTime
          ? (a.quantityTodo - b.quantityTodo)
          : (aStartTime - bStartTime);
      });

      if (lineState.orderStateQueue.length)
      {
        lineState.completed = false;

        lineStatesToFill.push(lineState);
      }
    });

    if (!lineStatesToFill.length)
    {
      log(`Nothing to fill!`);

      return setImmediate(done);
    }

    lineStatesToFill.sort((a, b) => a.activeFrom.valueOf() - b.activeFrom.valueOf());

    log(`Have lines to fill...`, {
      mrp,
      orders: orderNos,
      lines: lineStatesToFill.map(l => l._id)
    });

    state.lineStateQueue = state.lineStateQueue.concat(lineStatesToFill);

    return setImmediate(done);
  }

  function hasAnyLineWithRoomForOrder(state, orderNo)
  {
    const order = state.orders.get(orderNo);
    const mrpSettings = state.settings.mrp(order.mrp);

    return mrpSettings.lines.some(mrpLineSettings =>
    {
      if (mrpLineSettings.workerCount.every(c => c === 0) || !mrpLineSettings.orderPriority.includes(order.kind))
      {
        return false;
      }

      const lineState = state.lineStates.get(mrpLineSettings._id);
      const availableTime = getRemainingAvailableTime(lineState);
      const workerCount = mrpLineSettings.workerCount[lineState.shiftNo - 1];
      const pceTime = getPceTime(order, workerCount, mrpSettings.schedulingRate);

      return !lineState.plannedOrdersSet.has(order._id) && availableTime >= pceTime;
    });
  }

  function getRemainingAvailableTime(lineState)
  {
    const activeTo = lineState.activeTo.valueOf();

    let remaining = activeTo - lineState.activeFrom.valueOf();
    let nextDowntime = lineState.nextDowntime;

    while (nextDowntime && nextDowntime.startTime < activeTo)
    {
      remaining -= nextDowntime.duration;
      nextDowntime = nextDowntime.next;
    }

    return remaining;
  }

  function removeFirstItem(array, itemToRemove)
  {
    const i = array.indexOf(itemToRemove);

    if (i !== -1)
    {
      array.splice(i, 1);
    }
  }
};
