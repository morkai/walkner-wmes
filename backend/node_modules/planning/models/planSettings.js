// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const deepEqual = require('deep-equal');
const step = require('h5.step');
const moment = require('moment');
const {getTaktTimeCoeffForOperation} = require('production/orderFinder');

exports.name = 'PlanSettings';

exports.setUp = (app, mongoose) =>
{
  const mrpLineSettingsSchema = new mongoose.Schema({
    _id: String,
    workerCount: [Number],
    orderPriority: [String]
  }, {
    _id: false,
    minimize: false
  });

  const mrpGroupSettingsSchema = new mongoose.Schema({
    splitOrderQuantity: Number,
    lines: [String],
    components: [String]
  }, {
    _id: false,
    minimize: false
  });

  const mrpSettingsSchema = new mongoose.Schema({
    _id: String,
    locked: {
      type: Boolean,
      default: false
    },
    limitSmallOrders: {
      type: Boolean,
      default: false
    },
    extraOrderSeconds: {
      type: Number,
      default: 0
    },
    extraShiftSeconds: [Number],
    bigOrderQuantity: {
      type: Number,
      default: 70
    },
    splitOrderQuantity: {
      type: Number,
      default: 70
    },
    maxSplitLineCount: {
      type: Number,
      default: 0
    },
    hardOrderManHours: {
      type: Number,
      default: 0
    },
    hardBigComponents: [String],
    hardComponents: [String],
    lines: [mrpLineSettingsSchema],
    groups: [mrpGroupSettingsSchema]
  }, {
    _id: false,
    minimize: false
  });

  const lineActiveTimeSchema = new mongoose.Schema({
    from: String,
    to: String
  }, {
    _id: false,
    minimize: false
  });

  const lineSchema = new mongoose.Schema({
    _id: String,
    mrpPriority: [String],
    activeTime: [lineActiveTimeSchema]
  }, {
    _id: false,
    minimize: false
  });

  const planSettingsSchema = new mongoose.Schema({
    _id: Date,
    forceWorkDay: {
      type: Boolean,
      default: false
    },
    useRemainingQuantity: {
      type: Boolean,
      default: true
    },
    ignoreCompleted: {
      type: Boolean,
      default: true
    },
    requiredStatuses: [String],
    ignoredStatuses: [String],
    completedStatuses: [String],
    ignoredWorkCenters: [String],
    schedulingRate: {},
    freezeHour: {
      type: Number,
      min: 0,
      max: 23,
      default: 0
    },
    lateHour: {
      type: Number,
      min: 0,
      max: 23,
      default: 6
    },
    etoPilotHour: {
      type: Number,
      min: 0,
      max: 23,
      default: 6
    },
    lines: [lineSchema],
    mrps: [mrpSettingsSchema]
  }, {
    id: false,
    minimize: false
  });

  planSettingsSchema.statics.TOPIC_PREFIX = 'planning.settings';

  planSettingsSchema.statics.createNew = function(_id)
  {
    return new this({
      _id: _id,
      forceWorkDay: false,
      useRemainingQuantity: true,
      ignoreCompleted: true,
      requiredStatuses: ['REL'],
      ignoredStatuses: ['TECO', 'CNF', 'DLV', 'DLFL', 'DLT'],
      completedStatuses: ['CNF', 'DLV'],
      ignoredWorkCenters: [],
      schedulingRate: {},
      freezeHour: 0,
      lateHour: 6,
      etoPilotHour: 6,
      lines: [],
      mrps: []
    });
  };

  planSettingsSchema.statics.copyFrom = function(_id, sourceSettings)
  {
    return new this({
      _id: _id,
      forceWorkDay: false,
      useRemainingQuantity: sourceSettings.useRemainingQuantity,
      ignoreCompleted: sourceSettings.ignoreCompleted,
      requiredStatuses: sourceSettings.requiredStatuses,
      ignoredStatuses: sourceSettings.ignoredStatuses,
      completedStatuses: sourceSettings.completedStatuses,
      ignoredWorkCenters: sourceSettings.ignoredWorkCenters,
      schedulingRate: sourceSettings.schedulingRate,
      freezeHour: sourceSettings.freezeHour,
      lateHour: sourceSettings.lateHour,
      etoPilotHour: sourceSettings.etoPilotHour,
      lines: sourceSettings.lines,
      mrps: sourceSettings.mrps.map(mrpSettings =>
      {
        mrpSettings.locked = false;

        return mrpSettings;
      })
    });
  };

  planSettingsSchema.statics.edit = function(id, userInfo, input, done)
  {
    const PlanSettings = mongoose.model('PlanSettings');
    const PlanChange = mongoose.model('PlanChange');

    step(
      function()
      {
        PlanSettings.findById(id).exec(this.next());
      },
      function(err, planSettings)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!planSettings)
        {
          planSettings = new PlanSettings();
        }

        const planChange = new PlanChange(planSettings.applyChanges(input, userInfo));
        const anySettingsChanged = planChange.data.settings.length;

        if (planSettings.isNew || anySettingsChanged)
        {
          planSettings.save(this.parallel());
        }
        else
        {
          setImmediate(this.parallel(), null, planSettings);
        }

        if (anySettingsChanged)
        {
          planChange.save(this.parallel());
        }
        else
        {
          setImmediate(this.parallel(), null, planChange);
        }
      },
      function(err, planSettings, planChange)
      {
        if (err)
        {
          return done(err);
        }

        done(null, planSettings);

        const planChangeJson = planChange.toJSON();
        const changes = planChangeJson.data.settings;

        app.broker.publish('planning.settings.updated', {
          date: moment.utc(planChangeJson.plan).format('YYYY-MM-DD'),
          changes
        });

        if (changes.length)
        {
          app.broker.publish('planning.changes.created', planChangeJson);
        }
      }
    );
  };

  planSettingsSchema.statics.forGenerator = function(id, done)
  {
    const PlanSettings = this;
    const Setting = mongoose.model('Setting');

    step(
      function()
      {
        PlanSettings
          .findById(id)
          .exec(this.parallel());

        Setting
          .findById('production.taktTime.coeffs')
          .select({_id: 0, value: 1})
          .lean()
          .exec(this.parallel());
      },
      function(err, planSettings, taktTimeCoeffs)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!planSettings)
        {
          return this.skip(null, null);
        }

        planSettings = planSettings.toGenerator(taktTimeCoeffs && taktTimeCoeffs.value || {});

        setImmediate(this.next(), null, planSettings);
      },
      done
    );
  };

  planSettingsSchema.methods.toGenerator = function(taktTimeCoeffs)
  {
    const lines = new Map();
    const mrps = new Map();
    const mrpLines = new Map();
    const ignoredStatuses = new Set();
    const ignoredWorkCenters = new Set();
    const groupComponents = new Map();

    this.ignoredStatuses.forEach(status => ignoredStatuses.add(status));

    this.ignoredWorkCenters.forEach(wc => ignoredWorkCenters.add(wc));

    this.mrps.forEach(mrp =>
    {
      mrp.groups.forEach(group =>
      {
        group.components.forEach(nc12 =>
        {
          if (!groupComponents.has(nc12))
          {
            groupComponents.set(nc12, new Set());
          }

          groupComponents.get(nc12).add(group);
        });
      });
    });

    const line = (lineId) =>
    {
      if (!lines.has(lineId))
      {
        lines.set(lineId, this.lines.find(line => line._id === lineId));
      }

      return lines.get(lineId);
    };
    const mrp = (mrpId) =>
    {
      if (!mrps.has(mrpId))
      {
        const mrp = this.mrps.find(mrp => mrp._id === mrpId);

        if (!mrp)
        {
          return null;
        }

        mrps.set(mrpId, {
          ...mrp.toObject(),
          schedulingRate: this.schedulingRate[mrpId] || this.schedulingRate.ANY || 1,
          taktTimeCoeff: planOrder => getTaktTimeCoeffForOperation(taktTimeCoeffs, mrpId, {
            no: planOrder.operation.no,
            workCenter: planOrder.operation.workCenter,
            qty: planOrder.quantityTodo
          })
        });
      }

      return mrps.get(mrpId);
    };
    const mrpLine = (mrpId, lineId) =>
    {
      if (!mrpLines.has(lineId))
      {
        mrpLines.set(lineId, new Map());
      }

      const lineMrpMap = mrpLines.get(lineId);

      if (!lineMrpMap.has(mrpId))
      {
        const line = mrp(mrpId).lines.find(line => line._id === lineId);

        lineMrpMap.set(mrpId, line);
      }

      return lineMrpMap.get(mrpId);
    };

    const idMoment = moment.utc(this._id);

    return {
      freezeFirstShiftOrders: this.shouldFreezeFirstShiftOrders(),
      lateHour: this.lateHour < 6 ? (this.lateHour + 18) : (this.lateHour - 6),
      etoPilotHour: this.etoPilotHour < 6 ? (this.etoPilotHour + 18) : (this.etoPilotHour - 6),
      useRemainingQuantity: this.useRemainingQuantity,
      ignoreCompleted: this.ignoreCompleted,
      completedStatuses: this.completedStatuses,
      requiredStatuses: this.requiredStatuses,
      ignoredStatuses,
      ignoredWorkCenters,
      groupComponents,
      shiftStartTimes: [
        idMoment.clone().hours(6).valueOf(),
        idMoment.clone().hours(14).valueOf(),
        idMoment.clone().hours(22).valueOf()
      ],
      mrps: this.mrps.map(mrp => mrp._id),
      lines: this.lines.map(line => line._id),
      line,
      mrp,
      mrpLine
    };
  };

  planSettingsSchema.methods.removeUnused = function()
  {
    const definedLines = new Set();
    const definedMrps = new Map();
    const listedMrps = new Map();

    this.mrps.forEach(mrp => definedMrps.set(mrp._id, mrp));

    this.lines.forEach(line =>
    {
      line.mrpPriority = line.mrpPriority.filter(mrpId => typeof mrpId === 'string' && mrpId.length > 0);

      if (!line.mrpPriority.length)
      {
        return;
      }

      line.mrpPriority.forEach(mrpId =>
      {
        if (!listedMrps.has(mrpId))
        {
          listedMrps.set(mrpId, []);
        }

        listedMrps.get(mrpId).push(line._id);
      });

      definedLines.add(line);
    });

    for (const mrpId of definedMrps.keys())
    {
      if (!listedMrps.has(mrpId))
      {
        definedMrps.delete(mrpId);
      }
    }

    for (const [mrpId, lineIds] of listedMrps)
    {
      const mrp = definedMrps.get(mrpId) || {
        _id: mrpId,
        locked: false,
        limitSmallOrders: false,
        extraOrderSeconds: 0,
        extraShiftSeconds: [0, 0, 0],
        bigOrderQuantity: 70,
        splitOrderQuantity: 70,
        maxSplitLineCount: 0,
        hardOrderManHours: 0,
        hardBigComponents: [],
        hardComponents: [],
        lines: [],
        groups: []
      };

      mrp.lines = lineIds.map(lineId =>
      {
        return mrp.lines.find(line => line._id === lineId) || {
          _id: lineId,
          workerCount: [0, 0, 0],
          orderPriority: ['small', 'easy', 'hard']
        };
      });

      definedMrps.set(mrpId, mrp);
    }

    this.lines = Array.from(definedLines.values());
    this.mrps = Array.from(definedMrps.values());
  };

  planSettingsSchema.methods.applyChanges = function(input, user)
  {
    const changes = [];
    const planChange = {
      plan: this._id || input._id,
      date: new Date(),
      user,
      data: {
        settings: changes
      }
    };

    if (this.isNew)
    {
      this.set(input);
      this.removeUnused();

      return planChange;
    }

    input = new this.constructor(input);
    input.removeUnused();

    [
      'forceWorkDay',
      'useRemainingQuantity',
      'ignoreCompleted',
      'requiredStatuses',
      'ignoredStatuses',
      'ignoredWorkCenters',
      'completedStatuses',
      'schedulingRate',
      'freezeHour',
      'lateHour',
      'etoPilotHour'
    ].forEach(prop =>
    {
      if (typeof input[prop] === 'undefined')
      {
        return;
      }

      const oldValue = this[prop].toObject ? this[prop].toObject() : this[prop];
      const newValue = input[prop].toObject ? input[prop].toObject() : input[prop];

      if (deepEqual(newValue, oldValue))
      {
        return;
      }

      this[prop] = newValue;

      changes.push({
        type: 'change',
        property: prop,
        oldValue: oldValue,
        newValue: newValue
      });
    });

    this.applyLineChanges(input, changes);
    this.applyMrpChanges(input, changes);

    return planChange;
  };

  planSettingsSchema.methods.applyLineChanges = function(input, changes)
  {
    const oldLineMap = {};
    const newLineMap = {};
    const newLines = [];

    this.lines.forEach(line => oldLineMap[line._id] = line);
    input.lines.forEach(line => newLineMap[line._id] = line);

    Object.keys(newLineMap).forEach(lineId =>
    {
      const oldLine = oldLineMap[lineId] ? oldLineMap[lineId].toObject() : null;
      const newLine = newLineMap[lineId].toObject();

      delete oldLineMap[lineId];

      newLines.push(newLine);

      if (!oldLine)
      {
        changes.push({
          type: 'lines:add',
          line: newLine
        });

        return;
      }

      Object.keys(newLine).forEach(prop =>
      {
        const oldValue = oldLine[prop].toObject ? oldLine[prop].toObject() : oldLine[prop];
        const newValue = newLine[prop].toObject ? newLine[prop].toObject() : newLine[prop];

        if (deepEqual(newValue, oldValue))
        {
          return;
        }

        changes.push({
          type: 'lines:change',
          line: lineId,
          property: prop,
          oldValue: oldValue,
          newValue: newValue
        });
      });
    });

    Object.keys(oldLineMap).forEach(lineId =>
    {
      changes.push({
        type: 'lines:remove',
        line: oldLineMap[lineId]
      });
    });

    this.lines = newLines;
  };

  planSettingsSchema.methods.applyMrpChanges = function(input, changes)
  {
    const oldMrpMap = {};
    const newMrpMap = {};
    const newMrps = [];

    this.mrps.forEach(mrp => oldMrpMap[mrp._id] = mrp);
    input.mrps.forEach(mrp => newMrpMap[mrp._id] = mrp);

    Object.keys(newMrpMap).forEach(mrpId =>
    {
      const oldMrp = oldMrpMap[mrpId] ? oldMrpMap[mrpId].toObject() : null;
      const newMrp = newMrpMap[mrpId].toObject();

      delete oldMrpMap[mrpId];

      newMrps.push(newMrp);

      if (!oldMrp)
      {
        return changes.push({
          type: 'mrps:add',
          mrp: newMrp
        });
      }

      Object.keys(newMrp).forEach(prop =>
      {
        const oldValue = oldMrp[prop].toObject ? oldMrp[prop].toObject() : oldMrp[prop];
        const newValue = newMrp[prop].toObject ? newMrp[prop].toObject() : newMrp[prop];

        if (prop === 'lines')
        {
          return this.applyMrpLineChanges(mrpId, oldValue, newValue, changes);
        }

        if (!deepEqual(newValue, oldValue))
        {
          changes.push({
            type: 'mrps:change',
            mrp: mrpId,
            property: prop,
            oldValue: oldValue,
            newValue: newValue
          });
        }
      });
    });

    Object.keys(oldMrpMap).forEach(mrpId =>
    {
      changes.push({
        type: 'mrps:remove',
        mrp: oldMrpMap[mrpId]
      });
    });

    this.mrps = newMrps;
  };

  planSettingsSchema.methods.applyMrpLineChanges = function(mrpId, oldMrpLines, newMrpLines, changes)
  {
    const oldMrpLineMap = {};
    const newMrpLineMap = {};

    oldMrpLines.forEach(mrpLine => oldMrpLineMap[mrpLine._id] = mrpLine);
    newMrpLines.forEach(mrpLine => newMrpLineMap[mrpLine._id] = mrpLine);

    Object.keys(newMrpLineMap).forEach(mrpLineId =>
    {
      const oldMrpLine = oldMrpLineMap[mrpLineId];
      const newMrpLine = newMrpLineMap[mrpLineId];

      delete oldMrpLineMap[mrpLineId];

      if (!oldMrpLine)
      {
        return changes.push({
          type: 'mrpLines:add',
          mrp: mrpId,
          line: newMrpLine
        });
      }

      Object.keys(newMrpLine).forEach(prop =>
      {
        const oldValue = oldMrpLine[prop].toObject ? oldMrpLine[prop].toObject() : oldMrpLine[prop];
        const newValue = newMrpLine[prop].toObject ? newMrpLine[prop].toObject() : newMrpLine[prop];

        if (!deepEqual(newValue, oldValue))
        {
          changes.push({
            type: 'mrpLines:change',
            mrp: mrpId,
            line: mrpLineId,
            property: prop,
            oldValue: oldValue,
            newValue: newValue
          });
        }
      });
    });

    Object.keys(oldMrpLineMap).forEach(mrpLineId =>
    {
      changes.push({
        type: 'mrpLines:remove',
        mrp: mrpId,
        line: oldMrpLineMap[mrpLineId]
      });
    });
  };

  planSettingsSchema.methods.shouldFreezeFirstShiftOrders = function(offsetMin)
  {
    const freezeMoment = moment(moment.utc(this._id).format('YYYY-MM-DD'), 'YYYY-MM-DD');

    if (this.freezeHour >= 6)
    {
      freezeMoment.subtract(1, 'days');
    }

    freezeMoment.hours(this.freezeHour);

    if (offsetMin)
    {
      freezeMoment.subtract(offsetMin, 'minutes');
    }

    return Date.now() >= freezeMoment.valueOf();
  };

  mongoose.model(exports.name, planSettingsSchema);
};
