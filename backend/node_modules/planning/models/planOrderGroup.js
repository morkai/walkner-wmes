// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

exports.name = 'PlanOrderGroup';

exports.setUp = (app, mongoose) =>
{
  const schema = new mongoose.Schema({
    active: {
      type: Boolean,
      required: true
    },
    target: [String],
    name: {
      type: String,
      required: true,
      trim: true
    },
    description: {
      type: String,
      trim: true
    },
    mrp: [String],
    productInclude: [[String]],
    productExclude: [[String]],
    bomInclude: [[String]],
    bomExclude: [[String]],
    names: {}
  }, {
    id: false,
    minimize: false
  });

  schema.statics.TOPIC_PREFIX = 'planning.orderGroups';
  schema.statics.BROWSE_LIMIT = 1000;

  schema.index({'$**': 'text'}, {name: 'text', weights: {
    target: 20,
    mrp: 15,
    name: 10,
    description: 5
  }});

  schema.statics.matchOrder = function(group, {mrp, product, bom})
  {
    return matchMrp(group.mrp, mrp)
      && matchProductInclude(group.productInclude, product)
      && matchProductExclude(group.productExclude, product)
      && matchBomInclude(group.bomInclude, bom)
      && matchBomExclude(group.bomExclude, bom);
  };

  function matchAllWords(words, value)
  {
    if (words.length === 1)
    {
      return value.includes(words[0]);
    }

    for (let i = 0; i < words.length; ++i)
    {
      if (!value.includes(words[i]))
      {
        return false;
      }
    }

    return true;
  }

  function matchAnyWord(words, value)
  {
    return words.filter(word => value.includes(word));
  }

  function matchMrp(mrps, mrp)
  {
    return mrps.length === 0 || mrps.includes(mrp);
  }

  function matchProductInclude(patterns, product)
  {
    if (patterns.length === 0)
    {
      return true;
    }

    for (let i = 0; i < patterns.length; ++i)
    {
      if (matchAllWords(patterns[i], product))
      {
        return true;
      }
    }

    return false;
  }

  function matchProductExclude(patterns, product)
  {
    if (patterns.length === 0)
    {
      return true;
    }

    for (let i = 0; i < patterns.length; ++i)
    {
      if (matchAllWords(patterns[i], product))
      {
        return false;
      }
    }

    return true;
  }

  function matchBomInclude(patterns, bom)
  {
    if (patterns.length === 0)
    {
      return true;
    }

    for (let patternI = 0; patternI < patterns.length; ++patternI)
    {
      const required = patterns[patternI];
      const actual = new Set();

      for (let bomI = 0; bomI < bom.length; ++bomI)
      {
        matchAnyWord(required, bom[bomI]).forEach(word => actual.add(word));
      }

      if (actual.size === required.length)
      {
        return true;
      }
    }

    return false;
  }

  function matchBomExclude(patterns, bom)
  {
    if (patterns.length === 0)
    {
      return true;
    }

    for (let patternI = 0; patternI < patterns.length; ++patternI)
    {
      const required = patterns[patternI];
      const actual = new Set();

      for (let bomI = 0; bomI < bom.length; ++bomI)
      {
        matchAnyWord(required, bom[bomI]).forEach(word => actual.add(word));
      }

      if (actual.size === required.length)
      {
        return false;
      }
    }

    return true;
  }

  return schema;
};
