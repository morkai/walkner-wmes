// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const moment = require('moment');
const step = require('h5.step');

module.exports = {
  ORDER: handleOrderDocument,
  BOM: handleBomDocument,
  COMP_REL: handleCompRelDocument,
  ETO: handleEtoDocument
};

function handleBomDocument(app, {Order}, req, res, next)
{
  step(
    function()
    {
      Order
        .findById(req.query.order)
        .select({
          mrp: 1,
          qty: 1,
          bom: 1,
          notes: 1,
          scheduledStartDate: 1
        })
        .lean()
        .exec(this.next());
    },
    function(err, order)
    {
      if (err)
      {
        return this.skip(err);
      }

      if (!order)
      {
        return this.skip(app.createError('ORDER_NOT_FOUND', 404));
      }

      if (req.method === 'HEAD')
      {
        return this.skip();
      }

      Order.assignPkhdStrategies(order, this.parallel());
      Order.assignNotes(order, 'docs', this.parallel());
      Order.assignCompRelEntries(order, this.parallel());
    },
    function(err, order)
    {
      if (err)
      {
        return this.skip(err);
      }

      const components = [];
      const oldToNew = {};
      const newToOld = {};
      const compRels = [];
      const componentCodes = new Set();

      order.compRels.forEach(compRel =>
      {
        compRel.newComponents.forEach(newComponent =>
        {
          if (!newToOld[newComponent._id])
          {
            newToOld[newComponent._id] = [];
          }
        });

        compRel.oldComponents.forEach(oldComponent =>
        {
          if (!oldToNew[oldComponent._id])
          {
            oldToNew[oldComponent._id] = [];
          }

          oldToNew[oldComponent._id].push(compRel);

          compRel.newComponents.forEach(newComponent =>
          {
            newToOld[newComponent._id].push({compRel, oldComponent});
          });
        });
      });

      (order.bom || []).forEach(component =>
      {
        if (!component.nc12)
        {
          return;
        }

        const qty = (component.qty / order.qty).toString().split('.');

        component.qty = [
          parseInt(qty[0], 10),
          +(parseInt(qty[1], 10) || 0).toString().substring(0, 3)
        ];

        components.push(component);
        componentCodes.add(component.nc12);

        const newComponents = oldToNew[component.nc12];

        if (newComponents)
        {
          component.rowClassName = 'replaced';

          newComponents.forEach(function(compRel)
          {
            compRel.newComponents.forEach(newComponent =>
            {
              components.push({
                rowClassName: 'replacement',
                nc12: newComponent._id,
                name: newComponent.name,
                releasedAt: moment(compRel.releasedAt).format('L HH:mm'),
                releasedBy: compRel.releasedBy.label,
                supplyArea: component.supplyArea,
                usedOnStation: false
              });
            });
          });

          return;
        }

        const oldComponents = newToOld[component.nc12];

        if (oldComponents)
        {
          component.rowClassName = 'replacement';

          oldComponents.forEach(({compRel, oldComponent}) =>
          {
            components.push({
              rowClassName: 'replaced',
              nc12: oldComponent._id,
              name: oldComponent.name,
              releasedAt: moment(compRel.releasedAt).format('L HH:mm'),
              releasedBy: compRel.releasedBy.label,
              supplyArea: oldComponent.supplyArea,
              usedOnStation: false
            });
          });
        }
      });

      order.compRels.forEach(compRel =>
      {
        const hasNewComponent = compRel.newComponents.some(
          newComponent => componentCodes.has(newComponent._id)
        );

        compRel.oldComponents.forEach(oldComponent =>
        {
          if (!hasNewComponent && !componentCodes.has(oldComponent._id))
          {
            return;
          }

          compRel.newComponents.forEach(newComponent =>
          {
            compRels.push({
              oldCode: oldComponent._id,
              newCode: newComponent._id
            });
          });
        });
      });

      setImmediate(this.parallel(), null, {order, compRels, components});

      if (req.query.line && +req.query.station > 0)
      {
        Order.assignStationComponents(components, req.query.line, +req.query.station, this.parallel());
      }
    },
    function(err, data)
    {
      if (err)
      {
        return next(err);
      }

      if (req.method === 'HEAD')
      {
        return res.sendStatus(204);
      }

      const {order, compRels, components} = data;

      res.render('orderDocuments:bom', {
        order: order._id,
        notes: order.notes,
        compRels,
        components,
        windowWidth: parseInt(req.query.w, 10) || 0,
        windowHeight: parseInt(req.query.h, 10) || 0
      });
    }
  );
}

function handleCompRelDocument(app, {Order}, req, res, next)
{
  step(
    function()
    {
      Order
        .findById(req.query.order)
        .select({
          mrp: 1,
          scheduledStartDate: 1,
          bom: 1
        })
        .lean()
        .exec(this.next());
    },
    function(err, order)
    {
      if (err)
      {
        return this.skip(err);
      }

      if (!order)
      {
        return this.skip(app.createError('ORDER_NOT_FOUND', 404));
      }

      if (req.method !== 'HEAD')
      {
        Order.assignCompRelEntries(order, this.parallel());
      }
    },
    function(err, order)
    {
      if (err)
      {
        return next(err);
      }

      if (req.method === 'HEAD')
      {
        return res.sendStatus(204);
      }

      const bom = new Set((order.bom || []).map(c => c.nc12));
      const compRels = [];

      order.compRels.forEach(compRel =>
      {
        const hasNewComponent = compRel.newComponents.some(
          newComponent => bom.has(newComponent._id)
        );

        compRel.oldComponents.forEach(oldComponent =>
        {
          if (!hasNewComponent && !bom.has(oldComponent._id))
          {
            return;
          }

          compRel.newComponents.forEach(newComponent =>
          {
            compRels.push({
              oldCode: oldComponent._id,
              oldName: oldComponent.name,
              newCode: newComponent._id,
              newName: newComponent.name
            });
          });
        });
      });

      res.render('orderDocuments:compRel', {
        order: order._id,
        compRels,
        windowWidth: parseInt(req.query.w, 10) || 0,
        windowHeight: parseInt(req.query.h, 10) || 0
      });
    }
  );
}

function handleEtoDocument(app, {Order, OrderEto}, req, res, next)
{
  Order.findById(req.query.order, {nc12: 1}).lean().exec((err, order) =>
  {
    if (err)
    {
      return next(err);
    }

    if (!order)
    {
      return next(app.createError('Order not found.', 'NOT_FOUND', 404));
    }

    OrderEto.findById(order.nc12, {html: 1}).lean().exec((err, orderEto) =>
    {
      if (err)
      {
        return next(err);
      }

      if (!orderEto)
      {
        return next(app.createError('ETO not found.', 'NOT_FOUND', 404));
      }

      if (req.method === 'HEAD')
      {
        return res.sendStatus(204);
      }

      res.render('orderDocuments:eto', {
        order: order._id,
        nc12: order.nc12,
        etoTableHtml: orderEto.html,
        header: req.query.header !== '0'
      });
    });
  });
}

function handleOrderDocument(app, {Order}, req, res, next)
{
  Order.findById(req.query.order, {_id: 1}).lean().exec((err, order) =>
  {
    if (err)
    {
      return next(err);
    }

    if (!order)
    {
      return next(app.createError('ORDER_NOT_FOUND', 404));
    }

    if (req.method === 'HEAD')
    {
      return res.sendStatus(204);
    }

    res.redirect(`/#orders/${order._id}`);
  });
}
