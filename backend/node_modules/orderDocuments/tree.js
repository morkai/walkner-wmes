// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const step = require('h5.step');
const moment = require('moment');
const allowedTypes = require('./allowedTypes');

module.exports = (app, module) =>
{
  const logger = module.logger.create({submodule: 'tree'});
  const {
    settings,
    OrderDocumentFile,
    OrderDocumentFolder,
    OrderDocumentUpload
  } = module;

  const notifyFilesUploaded = _.debounce(
    app.broker.publish.bind(app.broker, 'orderDocuments.tree.filesUploaded'),
    1000
  );

  module.tree = {
    addFiles,
    editFile,
    unlinkFile,
    unlinkFiles,
    removeFile,
    removeFiles,
    recoverFile,
    recoverFiles,
    purgeFile,
    purgeFiles,
    addFolder,
    removeFolder,
    moveFolder,
    renameFolder,
    editFolder,
    recoverFolder,
    purgeFolder
  };

  function addFiles(params, user, done)
  {
    const filesToAdd = [];
    const filesWoId = [];
    const dynamicIds = new Set();
    const nc15ToFilesMap = {};
    const idToFolderMap = {};

    _.forEach(params.files, (file) =>
    {
      if (!_.isString(file.upload)
        || !file.upload.length
        || !_.isString(file.folder)
        || !file.folder.length
        || !_.isString(file.nc15)
        || (file.nc15 && !/^[0-9]{15}$/.test(file.nc15))
        || !_.isString(file.date)
        || !_.isString(file.hash)
        || !/^[a-f0-9]{32}$/.test(file.hash)
        || !_.isString(file.name)
        || !allowedTypes[file.type])
      {
        return;
      }

      const date = moment(file.date, 'YYYY-MM-DD');

      if (date.isValid())
      {
        idToFolderMap[file.folder] = false;

        filesToAdd.push(file);

        if (file.nc15)
        {
          if (file.nc15.startsWith('000'))
          {
            dynamicIds.add(file.nc15);
          }

          if (!nc15ToFilesMap[file.nc15])
          {
            nc15ToFilesMap[file.nc15] = [];
          }

          nc15ToFilesMap[file.nc15].push(file);
        }
        else
        {
          filesWoId.push(file);
        }
      }
    });

    if (!filesToAdd.length)
    {
      return done(app.createError('NO_FILES', 400));
    }

    step(
      function()
      {
        if (filesWoId.length)
        {
          assignFileIds(filesWoId, this.next());
        }
      },
      function(err, filesWithId)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!filesWithId)
        {
          return;
        }

        filesWithId.forEach(file =>
        {
          if (!nc15ToFilesMap[file.nc15])
          {
            nc15ToFilesMap[file.nc15] = [];
          }

          nc15ToFilesMap[file.nc15].push(file);
        });
      },
      function()
      {
        OrderDocumentFile
          .find({_id: {$in: Object.keys(nc15ToFilesMap)}})
          .exec(this.parallel());

        OrderDocumentFolder
          .find({_id: {$in: Object.keys(idToFolderMap)}}, {parent: 1})
          .lean()
          .exec(this.parallel());
      },
      function(err, orderDocumentFiles, orderDocumentFolders)
      {
        if (err)
        {
          return this.skip(err);
        }

        orderDocumentFiles.forEach(file => dynamicIds.delete(file._id));

        if (dynamicIds.size)
        {
          return this.skip(app.createError('Invalid 15NC.', 'INVALID_NC15', 400, {
            invalidIds: Array.from(dynamicIds)
          }));
        }

        orderDocumentFolders
          .filter(folder => folder.parent !== '__TRASH__')
          .forEach(folder => idToFolderMap[folder._id] = true);

        orderDocumentFiles.forEach(file => addFile(file, nc15ToFilesMap, idToFolderMap, user, this.group()));

        _.forEach(nc15ToFilesMap, filesToAdd =>
        {
          const fileToAdd = filesToAdd[0];
          const orderDocumentFile = new OrderDocumentFile({
            _id: fileToAdd.nc15,
            name: fileToAdd.name,
            folders: [],
            files: [],
            oldFolders: null
          });

          addFile(orderDocumentFile, nc15ToFilesMap, idToFolderMap, user, this.group());
        });
      },
      done
    );
  }

  async function assignFileIds(files, done)
  {
    try
    {
      let counter = (await settings.findValue('orders.documents.documentIdCounter')) || 0;

      files.forEach(file =>
      {
        counter += 1;

        file.nc15 = counter.toString().padStart(15, '0');
      });

      await settings.update('orders.documents.documentIdCounter', counter);

      done(null, files);
    }
    catch (err)
    {
      done(err);
    }
  }

  function addFile(orderDocumentFile, nc15ToFilesMap, idToFolderMap, user, done)
  {
    const updatedAt = new Date();
    const filesToAdd = nc15ToFilesMap[orderDocumentFile._id].filter(f => idToFolderMap[f.folder]);

    delete nc15ToFilesMap[orderDocumentFile._id];

    filesToAdd.forEach(fileToAdd =>
    {
      if (!orderDocumentFile.folders.includes(fileToAdd.folder))
      {
        orderDocumentFile.folders.push(fileToAdd.folder);
      }

      const date = moment.utc(fileToAdd.date, 'YYYY-MM-DD').toDate();

      orderDocumentFile.files = orderDocumentFile.files.filter(
        f => f.hash !== fileToAdd.hash && f.date.getTime() !== date.getTime()
      );

      orderDocumentFile.files.push({
        hash: fileToAdd.hash,
        type: fileToAdd.type,
        meta: {},
        date: date.toISOString(),
        updater: user,
        updatedAt
      });

      orderDocumentFile.name = fileToAdd.name;
    });

    const isNew = orderDocumentFile.isNew;

    orderDocumentFile.files.sort((a, b) => b.date - a.date);
    orderDocumentFile.updater = user;
    orderDocumentFile.updatedAt = updatedAt;

    orderDocumentFile.save((err) =>
    {
      if (err)
      {
        return done(err);
      }

      app.broker.publish(`orderDocuments.tree.${isNew ? 'fileAdded' : 'fileEdited'}`, {
        file: orderDocumentFile,
        user,
        uploadId: filesToAdd.map(f => f.upload)
      });

      createUploads(filesToAdd);

      done();
    });
  }

  function createUploads(addedFiles)
  {
    OrderDocumentUpload.create(addedFiles.map(f => ({_id: f.hash, nc15: f.nc15, count: 0})), (err) =>
    {
      if (err)
      {
        logger.error(err, `Failed to save uploads.`);
      }
      else
      {
        notifyFilesUploaded();
      }
    });
  }

  function editFile(params, user, done)
  {
    step(
      function()
      {
        OrderDocumentFile.findById(params.fileId).exec(this.next());
      },
      function(err, file)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!file)
        {
          return this.skip(app.createError('NOT_FOUND', 400));
        }

        const updatedAt = new Date();
        const changes = params.changes;

        if (Array.isArray(changes.files))
        {
          const oldFiles = {};

          file.files.forEach(oldFile =>
          {
            oldFiles[oldFile.hash] = oldFile;
          });

          changes.files = changes.files.filter(f =>
          {
            return !isNaN(Date.parse(f.date))
              && /^[a-f0-9]{32}$/.test(f.hash)
              && /^[a-z0-9]{1,30}\/[a-z0-9]{1,100}$/.test(f.type);
          });

          changes.files.forEach(newFile =>
          {
            const oldFile = oldFiles[newFile.hash];

            newFile.date = new Date(Date.parse(newFile.date));

            if (!oldFile || oldFile.date.getTime() !== newFile.date.getTime())
            {
              newFile.updater = user;
              newFile.updatedAt = updatedAt;
            }
            else
            {
              newFile.updater = oldFile.updater;
              newFile.updatedAt = oldFile.updatedAt;
            }

            newFile.meta = {};
          });

          changes.files.sort((a, b) => b.date - a.date);
        }

        changes.updater = user;
        changes.updatedAt = updatedAt;

        file.set(changes);
        file.save(this.next());
      },
      function(err, file)
      {
        if (err)
        {
          return done(err);
        }

        if (file)
        {
          app.broker.publish('orderDocuments.tree.fileEdited', {file, user});
        }

        done();
      }
    );
  }

  function unlinkFile(params, user, done)
  {
    step(
      function()
      {
        if (params.file && params.file instanceof OrderDocumentFile)
        {
          setImmediate(this.next(), null, params.file);
        }
        else
        {
          OrderDocumentFile.findById(params.fileId).exec(this.next());
        }
      },
      function(err, file)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!file)
        {
          return this.skip(app.createError('NOT_FOUND', 400));
        }

        if (!_.includes(file.folders, params.folderId))
        {
          return this.skip(app.createError('INVALID_FOLDER', 400));
        }

        file.folders = file.folders.filter(folderId => folderId !== params.folderId);
        file.updater = user;
        file.updatedAt = new Date();

        file.save(this.next());
      },
      function(err, file)
      {
        if (err)
        {
          return done(err);
        }

        if (file)
        {
          app.broker.publish('orderDocuments.tree.fileUnlinked', {
            file,
            folderId: params.folderId,
            user
          });
        }

        done();
      }
    );
  }

  function unlinkFiles(params, user, done)
  {
    const fileIds = _.filter(params.fileIds, fileId => _.isString(fileId) && !_.isEmpty(fileId));

    if (_.isEmpty(fileIds))
    {
      return done(app.createError('NOT_FOUND', 400));
    }

    step(
      function()
      {
        OrderDocumentFile.find({_id: {$in: fileIds}}, {folders: 1}).exec(this.next());
      },
      function(err, files)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (_.isEmpty(files))
        {
          return this.skip(app.createError('NOT_FOUND', 400));
        }

        this.unlinkedFileIds = [];
        this.removedFileIds = [];

        files.forEach(file =>
        {
          if (file.folders.length > 1)
          {
            const next = this.group();

            unlinkFile({file, folderId: params.folderId}, user, err =>
            {
              if (err)
              {
                logger.error(err, `Failed to unlink file [${file._id}] while removing files.`);
              }
              else
              {
                this.unlinkedFileIds.push(file._id);
              }

              next();
            });
          }
          else if (params.remove && file.folders.length === 1)
          {
            const next = this.group();

            removeFile({file}, user, err =>
            {
              if (err)
              {
                logger.error(err, `Failed to remove file [${file._id}] while removing files.`);
              }
              else
              {
                this.removedFileIds.push(file._id);
              }

              next();
            });
          }
        });
      },
      function(err)
      {
        if (err)
        {
          return done(err);
        }

        if (this.unlinkedFileIds.length || this.removedFileIds.length)
        {
          app.broker.publish('orderDocuments.tree.filesUnlinked', {
            unlinkedFileIds: this.unlinkedFileIds,
            removedFileIds: this.removedFileIds,
            folderId: params.folderId,
            user
          });
        }

        done();
      }
    );
  }

  function removeFile(params, user, done)
  {
    step(
      function()
      {
        if (params.file && params.file instanceof OrderDocumentFile)
        {
          setImmediate(this.next(), null, params.file);
        }
        else
        {
          OrderDocumentFile.findById(params.fileId).exec(this.next());
        }
      },
      function(err, file)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!file)
        {
          return this.skip(app.createError('NOT_FOUND', 400));
        }

        if (file.folders[0] === '__TRASH__')
        {
          return this.skip(app.createError('ALREADY_IN_TRASH', 400));
        }

        file.set({
          folders: ['__TRASH__'],
          oldFolders: file.folders,
          updater: user,
          updatedAt: new Date()
        });
        file.save(this.next());
      },
      function(err, file)
      {
        if (err)
        {
          return done(err);
        }

        if (file)
        {
          app.broker.publish('orderDocuments.tree.fileRemoved', {file, user});
        }

        done();
      }
    );
  }

  function removeFiles(params, user, done)
  {
    const fileIds = _.filter(params.fileIds, fileId => _.isString(fileId) && !_.isEmpty(fileId));

    if (_.isEmpty(fileIds))
    {
      return done(app.createError('NOT_FOUND', 400));
    }

    step(
      function()
      {
        OrderDocumentFile.find({_id: {$in: fileIds}}).exec(this.next());
      },
      function(err, files)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (_.isEmpty(files))
        {
          return this.skip(app.createError('NOT_FOUND', 400));
        }

        files.forEach(file => removeFile({file}, user, this.group()));
      },
      function(err)
      {
        if (err)
        {
          return done(err);
        }

        app.broker.publish('orderDocuments.tree.filesRemoved', {fileIds: fileIds, user});

        done();
      }
    );
  }

  function recoverFile(params, user, done)
  {
    step(
      function()
      {
        if (params.file && params.file instanceof OrderDocumentFile)
        {
          setImmediate(this.next(), null, params.file);
        }
        else
        {
          OrderDocumentFile.findById(params.fileId).exec(this.next());
        }
      },
      function(err, file)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!file)
        {
          return this.skip(app.createError('NOT_FOUND', 400));
        }

        this.file = file;

        OrderDocumentFolder
          .find({_id: {$in: file.oldFolders}}, {_id: 1})
          .lean()
          .exec(this.next());
      },
      function(err, folders)
      {
        if (err)
        {
          return done(err);
        }

        if (!folders.length)
        {
          return this.skip(app.createError('NO_VALID_FOLDERS', 400));
        }

        this.file.set({
          folders: folders.map(folder => folder._id),
          oldFolders: null,
          updater: user,
          updatedAt: new Date()
        });
        this.file.save(this.next());
      },
      function(err, file)
      {
        if (err)
        {
          return done(err);
        }

        if (file)
        {
          app.broker.publish('orderDocuments.tree.fileRecovered', {file, user});
        }

        done();
      }
    );
  }

  function recoverFiles(params, user, done)
  {
    const fileIds = _.filter(params.fileIds, fileId => _.isString(fileId) && !_.isEmpty(fileId));

    if (_.isEmpty(fileIds))
    {
      return done(app.createError('NOT_FOUND', 400));
    }

    step(
      function()
      {
        OrderDocumentFile.find({_id: {$in: fileIds}, folders: '__TRASH__'}).exec(this.next());
      },
      function(err, files)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (_.isEmpty(files))
        {
          return this.skip(app.createError('NOT_FOUND', 400));
        }

        this.files = files;
        this.folders = {};

        files.forEach(file =>
        {
          file.oldFolders.forEach(folderId => this.folders[folderId] = false);
        });

        OrderDocumentFolder.find({_id: {$in: Object.keys(this.folders)}}, {_id: 1}).lean().exec(this.next());
      },
      function(err, folders)
      {
        if (err)
        {
          return this.skip(err);
        }

        folders.forEach(folder => this.folders[folder._id] = true);

        this.recoveredFileIds = [];
        this.purgedFileIds = [];

        this.files.forEach(file =>
        {
          const oldFolders = file.oldFolders.filter(folderId => this.folders[folderId]);

          if (oldFolders.length)
          {
            const next = this.group();

            recoverFile({file}, user, err =>
            {
              if (err)
              {
                logger.error(err, `Failed to recover file [${file._id}] while recovering files.`);
              }
              else
              {
                this.recoveredFileIds.push(file._id);
              }

              next();
            });
          }
          else if (params.remove)
          {
            const next = this.group();

            purgeFile({file}, user, err =>
            {
              if (err)
              {
                logger.error(err, `Failed to purge file [${file._id}] while recovering files.`);
              }
              else
              {
                this.purgedFileIds.push(file._id);
              }

              next();
            });
          }
        });
      },
      function(err)
      {
        if (err)
        {
          return done(err);
        }

        if (this.recoveredFileIds.length || this.purgedFileIds.length)
        {
          app.broker.publish('orderDocuments.tree.filesRecovered', {
            recoveredFileIds: this.recoveredFileIds,
            purgedFileIds: this.purgedFileIds,
            user
          });
        }

        done();
      }
    );
  }

  function purgeFile(params, user, done)
  {
    step(
      function()
      {
        if (params.file && params.file instanceof OrderDocumentFile)
        {
          setImmediate(this.next(), null, params.file);
        }
        else
        {
          OrderDocumentFile.findById(params.fileId).exec(this.next());
        }
      },
      function(err, file)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!file)
        {
          return this.skip(app.createError('NOT_FOUND', 400));
        }

        file.remove(this.next());
      },
      function(err, file)
      {
        if (err)
        {
          return done(err);
        }

        if (file)
        {
          app.broker.publish('orderDocuments.tree.filePurged', {file, user});
        }

        done();
      }
    );
  }

  function purgeFiles(params, user, done)
  {
    const fileIds = _.filter(params.fileIds, fileId => _.isString(fileId) && !_.isEmpty(fileId));

    if (_.isEmpty(fileIds))
    {
      return done(app.createError('NOT_FOUND', 400));
    }

    step(
      function()
      {
        OrderDocumentFile.find({_id: {$in: fileIds}}).exec(this.next());
      },
      function(err, files)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (_.isEmpty(files))
        {
          return this.skip(app.createError('NOT_FOUND', 400));
        }

        this.unlinkedFileIds = [];
        this.purgedFileIds = [];

        files.forEach(file =>
        {
          const next = this.group();

          if (file.folders.length <= 1)
          {
            purgeFile({file}, user, err =>
            {
              if (err)
              {
                logger.error(err, `Failed to purge file [${file._id}] while purging files.`);
              }
              else
              {
                this.purgedFileIds.push(file._id);
              }

              next();
            });

            return;
          }

          unlinkFile({file, folderId: params.folderId}, user, err =>
          {
            if (err)
            {
              logger.error(err, `Failed to unlink file [${file._id}] while purging files.`);
            }
            else
            {
              this.unlinkedFileIds.push(file._id);
            }

            next();
          });
        });
      },
      function(err)
      {
        if (err)
        {
          return done(err);
        }

        app.broker.publish('orderDocuments.tree.filesRemoved', {fileIds: fileIds, user});

        done();
      }
    );
  }

  function addFolder(params, user, done)
  {
    step(
      function()
      {
        new OrderDocumentFolder(params.folder).save(this.next());
      },
      function(err, folder)
      {
        if (err)
        {
          return this.skip(err);
        }

        this.folder = folder;

        if (folder.parent)
        {
          OrderDocumentFolder.updateOne(
            {_id: folder.parent},
            {$addToSet: {children: folder._id}},
            this.next()
          );
        }
      },
      function(err)
      {
        if (err)
        {
          return done(err);
        }

        if (this.folder)
        {
          app.broker.publish('orderDocuments.tree.folderAdded', {
            folder: this.folder,
            user
          });
        }

        done();
      }
    );
  }

  function removeFolder(params, user, done)
  {
    step(
      function()
      {
        OrderDocumentFolder.findById(params.folderId).exec(this.next());
      },
      function(err, folder)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!folder)
        {
          return this.skip(app.createError('NOT_FOUND', 400));
        }

        folder.set({
          parent: '__TRASH__',
          oldParent: folder.parent
        });
        folder.save(this.parallel());

        OrderDocumentFolder.updateOne({_id: '__TRASH__'}, {$addToSet: {children: folder._id}}, this.parallel());

        if (folder.oldParent)
        {
          OrderDocumentFolder.updateOne({_id: folder.oldParent}, {$pull: {children: folder._id}}, this.parallel());
        }
      },
      function(err, folder)
      {
        if (err)
        {
          return done(err);
        }

        if (folder)
        {
          app.broker.publish('orderDocuments.tree.folderRemoved', {folder, user});
        }

        done();
      }
    );
  }

  function moveFolder(params, user, done)
  {
    step(
      function()
      {
        OrderDocumentFolder.findById(params.folderId).exec(this.parallel());

        if (params.parentId)
        {
          OrderDocumentFolder.findById(params.parentId, {_id: 1}).lean().exec(this.parallel());
        }
      },
      function(err, folder, newParentFolder)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!folder || (params.parentId && !newParentFolder))
        {
          return this.skip(app.createError('NOT_FOUND', 400));
        }

        this.newParentId = params.parentId;
        this.oldParentId = folder.parent;

        folder.set({
          parent: this.newParentId,
          oldParent: null
        });
        folder.save(this.parallel());

        if (this.newParentId)
        {
          OrderDocumentFolder.updateOne({_id: this.newParentId}, {$addToSet: {children: folder._id}}, this.parallel());
        }

        if (this.oldParentId)
        {
          OrderDocumentFolder.updateOne({_id: this.oldParentId}, {$pull: {children: folder._id}}, this.parallel());
        }
      },
      function(err, folder)
      {
        if (err)
        {
          return done(err);
        }

        if (folder)
        {
          app.broker.publish('orderDocuments.tree.folderMoved', {
            folder,
            user,
            oldParentId: this.oldParentId,
            newParentId: this.newParentId
          });
        }

        done();
      }
    );
  }

  function renameFolder(params, user, done)
  {
    const name = String(params.name).trim();

    if (!name.length)
    {
      return done(app.createError('INVALID_NAME'), 400);
    }

    step(
      function()
      {
        OrderDocumentFolder.findById(params.folderId).exec(this.next());
      },
      function(err, folder)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!folder)
        {
          return this.skip(app.createError('NOT_FOUND', 400));
        }

        folder.set('name', name);
        folder.save(this.next());
      },
      function(err, folder)
      {
        if (err)
        {
          return done(err);
        }

        if (folder)
        {
          app.broker.publish('orderDocuments.tree.folderRenamed', {folder, user});
        }

        done();
      }
    );
  }

  function editFolder(params, user, done)
  {
    const data = {};

    if (typeof params.data.name === 'string')
    {
      data.name = params.data.name.trim();

      if (!data.name.length)
      {
        return done(app.createError('Invalid name.', 'INPUT', 400));
      }
    }

    if (Array.isArray(params.data.funcs))
    {
      data.funcs = params.data.funcs.filter(id => typeof id === 'string' && !!id.length);
    }

    if (!Object.keys(data).length)
    {
      return done(app.createError('Empty data.', 'INPUT', 400));
    }

    step(
      function()
      {
        OrderDocumentFolder.findById(params.folderId).exec(this.next());
      },
      function(err, folder)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!folder)
        {
          return this.skip(app.createError('NOT_FOUND', 400));
        }

        folder.set(data);
        folder.save(this.next());
      },
      function(err, folder)
      {
        if (err)
        {
          return done(err);
        }

        if (folder)
        {
          app.broker.publish('orderDocuments.tree.folderEdited', {folder, user});
        }

        done();
      }
    );
  }

  function recoverFolder(params, user, done)
  {
    step(
      function()
      {
        OrderDocumentFolder.findById(params.folderId).exec(this.parallel());
      },
      function(err, folder)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!folder)
        {
          return this.skip(app.createError('NOT_FOUND', 400));
        }

        if (folder.parent !== '__TRASH__')
        {
          return this.skip(app.createError('INVALID_PARENT', 400));
        }

        folder.set({
          parent: folder.oldParent,
          oldParent: null
        });
        folder.save(this.parallel());

        OrderDocumentFolder.updateOne({_id: folder.parent}, {$addToSet: {children: folder._id}}, this.parallel());

        OrderDocumentFolder.updateOne({_id: '__TRASH__'}, {$pull: {children: folder._id}}, this.parallel());
      },
      function(err, folder)
      {
        if (err)
        {
          return done(err);
        }

        if (folder)
        {
          app.broker.publish('orderDocuments.tree.folderRecovered', {
            folder,
            user
          });
        }

        done();
      }
    );
  }

  function purgeFolder(params, user, done)
  {
    step(
      function()
      {
        if (params.folder && params.folder instanceof OrderDocumentFolder)
        {
          params.folderId = params.folder._id;

          setImmediate(this.parallel(), null, params.folder);
        }
        else
        {
          OrderDocumentFolder.findById(params.folderId).exec(this.parallel());
        }

        OrderDocumentFolder.find({parent: params.folderId}).exec(this.parallel());

        OrderDocumentFile.find({folders: params.folderId}).exec(this.parallel());
      },
      function(err, parentFolder, childFolders, files)
      {
        if (err)
        {
          return this.skip(err);
        }

        this.childFolders = childFolders;

        if (parentFolder._id !== '__TRASH__')
        {
          doPurgeFolder(parentFolder, user, this.group());
        }

        files.forEach(file =>
        {
          if (file.folders.length === 1)
          {
            purgeFile({file}, user, this.group());
          }
          else
          {
            unlinkFile({file, folderId: parentFolder._id}, user, this.group());
          }
        });
      },
      function(err)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!this.childFolders.length)
        {
          return;
        }

        const steps = this.childFolders.map(folder =>
        {
          return function(err)
          {
            if (err)
            {
              return this.skip(err);
            }

            purgeFolder({folder}, user, this.next());
          };
        });

        steps.push(this.next());

        step(steps);
      },
      done
    );
  }

  function doPurgeFolder(folder, user, done)
  {
    folder.remove(err =>
    {
      if (!err)
      {
        app.broker.publish('orderDocuments.tree.folderPurged', {
          folder,
          user
        });
      }

      OrderDocumentFolder.updateOne({_id: folder.parent}, {$pull: {children: folder._id}}, () => {});

      done(err);
    });
  }
};
