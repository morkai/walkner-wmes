// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const path = require('path');
const fs = require('fs');
const url = require('url');
const {exec} = require('child_process');
const _ = require('lodash');
const step = require('h5.step');
const request = require('request');
const cheerio = require('cheerio');

const CHECK_INTERVAL = 60 * 60 * 1000;
const remoteChecks = {};

module.exports = (app, module, nc15) =>
{
  const {remoteServer} = module.settings;

  if (_.isEmpty(remoteServer))
  {
    return;
  }

  const logger = module.logger.create({submodule: 'checkRemoteServer'});

  if (!remoteChecks[nc15])
  {
    remoteChecks[nc15] = {
      inProgress: false,
      lastCheckAt: 0
    };
  }

  const remoteCheck = remoteChecks[nc15];

  if (remoteCheck.inProgress || (Date.now() - remoteCheck.lastCheckAt < CHECK_INTERVAL))
  {
    return;
  }

  remoteCheck.inProgress = Date.now();

  logger.info('Checking document on remote server...', {nc15, remoteServer});

  const OrderDocumentStatus = app[module.config.mongooseId].model('OrderDocumentStatus');
  const remoteServerUrl = url.format({
    protocol: 'http',
    hostname: remoteServer,
    port: 80,
    pathname: '/ShellCgi/cpb_qdbi_proda_search_tpd_central.pl'
  });

  step(
    function requestDocumentsStep()
    {
      /* eslint-disable camelcase */
      const form = {
        form_name: 'form_docsearch',
        query: nc15,
        tpd: 'ADT',
        designation: '',
        sheet_name: '',
        projects: '',
        doc_type: 'PDF',
        status_name: 'Final',
        results: 100,
        server: 'CENTRAL',
        dba: 'DEF'
      };
      /* eslint-enable camelcase */

      request.post(remoteServerUrl, {form: form}, this.next());
    },
    function findDocumentsStep(err, res, body)
    {
      if (err)
      {
        return this.skip(err);
      }

      if (res.statusCode !== 200)
      {
        return this.skip(new Error('Invalid response status code: ' + res.statusCode));
      }

      if (!_.isString(body))
      {
        body = String(body);
      }

      const resultsStartIndex = body.indexOf('<div id=results>', 2048);

      if (resultsStartIndex === -1)
      {
        return this.skip(new Error('Invalid response body: missing `<div id=results>`!'));
      }

      const resultsEndIndex = body.indexOf('</div>', resultsStartIndex);

      if (resultsEndIndex === -1)
      {
        return this.skip(new Error('Invalid response body: missing `</div>`!'));
      }

      const documents = [];
      let maxStatusDate = 0;
      const $ = cheerio.load(body.substring(resultsStartIndex, resultsEndIndex));

      $('tr').each(function(i, row)
      {
        if (i === 0)
        {
          return;
        }

        const $td = $(row).children();
        const href = $td.first().find('a').attr('href');
        let statusDate = 0;
        const matches = ($($td.get(4)).text() || '').match(/([0-9]{4})-([0-9]{2})-([0-9]{2})/);

        if (matches !== null)
        {
          statusDate = Date.UTC(parseInt(matches[1], 10), parseInt(matches[2], 10) - 1, parseInt(matches[3], 10));
        }

        documents.push({
          url: href,
          file: url.parse(href).pathname,
          statusDate: statusDate,
          localFilePath: null
        });

        maxStatusDate = Math.max(maxStatusDate, statusDate);
      });

      logger.info('Found files.', {fileCount: documents.length, nc15});

      if (!documents.length)
      {
        return this.skip(null, false);
      }

      this.newDocuments = documents;
      this.maxStatusDate = maxStatusDate;
    },
    function findOrderDocumentStatus()
    {
      OrderDocumentStatus.findById(nc15).exec(this.next());
    },
    function checkOrderDocumentStatus(err, orderDocumentStatus)
    {
      if (err)
      {
        return this.skip(err);
      }

      const newFiles = this.newDocuments.map(function(document) { return document.file; });

      if (!orderDocumentStatus)
      {
        orderDocumentStatus = new OrderDocumentStatus({
          _id: nc15,
          statusDate: this.maxStatusDate,
          files: newFiles
        });
        orderDocumentStatus.save(function(err)
        {
          if (err)
          {
            logger.error(err, 'Failed to save OrderDocumentStatus.');
          }
        });
      }
      else if (orderDocumentStatus.statusDate <= this.maxStatusDate
        && JSON.stringify(orderDocumentStatus.files) === JSON.stringify(newFiles))
      {
        return this.skip(null, false);
      }

      orderDocumentStatus.statusDate = this.maxStatusDate;
      orderDocumentStatus.files = newFiles;

      this.orderDocumentStatus = orderDocumentStatus;

      setImmediate(this.next());
    },
    function downloadDocumentFilesStep()
    {
      const documents = this.newDocuments;

      logger.info('Downloading files...', {fileCount: documents.length, nc15});

      const isSingleFile = documents.length === 1;

      for (let i = 0; i < documents.length; ++i)
      {
        const next = this.group();
        const document = documents[i];
        let fileName = nc15;

        if (!isSingleFile)
        {
          fileName += '.' + (i + 1);
        }

        fileName += '.pdf';

        document.localFilePath = path.join(module.config.cachedPath, fileName);

        const writeStream = fs.createWriteStream(document.localFilePath);
        writeStream.on('error', onWriteStreamError);

        request
          .get(document.url)
          .on('error', next)
          .on('end', next)
          .pipe(writeStream);
      }
    },
    function combineDocumentFilesStep(err)
    {
      if (err)
      {
        return this.skip(err);
      }

      const documents = this.newDocuments;

      if (documents.length === 1)
      {
        return;
      }

      logger.info('Combining files into document...', {fileCount: documents.length, nc15});

      const cmd = [
        module.config.sejdaConsolePath,
        'merge',
        '--overwrite',
        '--output', '"' + path.join(module.config.cachedPath, nc15 + '.pdf') + '"',
        '--files'
      ];

      for (let i = 0; i < documents.length; ++i)
      {
        cmd.push('"' + documents[i].localFilePath + '"');
      }

      exec(cmd.join(' '), this.next());
    },
    function removeSinglePagesStep(err)
    {
      if (err)
      {
        return this.skip(err);
      }

      if (this.newDocuments.length > 1)
      {
        this.newDocuments.forEach(function(document) { fs.unlink(document.localFilePath, function() {}); });
      }
    },
    function finalizeStep(err, updated)
    {
      if (err)
      {
        logger.error(err, 'Failed to check document on remote server.', {nc15, remoteServer});
      }
      else
      {
        remoteCheck.lastCheckAt = Date.now();

        logger.info('Checked document!', {
          nc15,
          remoteServer,
          duration: (remoteCheck.lastCheckAt - remoteCheck.inProgress) / 1000,
          updated
        });

        if (updated !== false)
        {
          app.broker.publish('orderDocuments.remoteChecked.' + nc15, {
            nc15: nc15
          });
        }
      }

      remoteCheck.inProgress = 0;

      this.newDocuments = null;
      this.maxStatusDate = null;
      this.orderDocumentStatus = null;
    }
  );

  function onWriteStreamError(err)
  {
    logger.error(err, 'Write stream error.');
  }
};
