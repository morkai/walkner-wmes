// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const path = require('path');
const _ = require('lodash');
const step = require('h5.step');
const fs = require('fs-extra');
const cheerio = require('cheerio');

exports.DEFAULT_CONFIG = {
  mongooseId: 'mongoose',
  filterRe: /^EMAIL_[0-9]+$/,
  outputDir: './eto',
  parsedOutputDir: null
};

exports.models = [
  require('orders/models/orderEto')
];

exports.recordTopics = {
  info: ['orderDocuments.eto.synced'],
  error: ['orderDocuments.eto.syncFailed']
};

exports.requiredModules = 'mongoose';

exports.start = (app, module) =>
{
  const {OrderEto} = module;

  const filePathCache = {};
  const queue = [];
  let locked = false;

  app.broker.subscribe('directoryWatcher.changed', queueFile).setFilter(filterFile);

  function filterFile(fileInfo)
  {
    return !filePathCache[fileInfo.filePath] && module.config.filterRe.test(fileInfo.fileName);
  }

  function queueFile(fileInfo)
  {
    filePathCache[fileInfo.filePath] = true;

    queue.push(fileInfo);

    module.info('Queued...', {fileInfo});

    setImmediate(importNext);
  }

  function importNext()
  {
    if (locked)
    {
      return;
    }

    const fileInfo = queue.shift();

    if (!fileInfo)
    {
      return;
    }

    locked = true;

    const startTime = Date.now();

    module.info('Importing...', {fileInfo});

    importFile(fileInfo, (err, nc12) =>
    {
      if (err || nc12)
      {
        cleanUpFileInfoFile(fileInfo);
      }

      if (err)
      {
        module.error(err, 'Failed to import.', {fileInfo});

        app.broker.publish('orderDocuments.eto.syncFailed', {
          timestamp: fileInfo.timestamp,
          fileName: fileInfo.fileName,
          error: err.message
        });
      }
      else if (nc12)
      {
        module.info('Imported!', {fileInfo, nc12, duration: Date.now() - startTime});

        app.broker.publish('orderDocuments.eto.synced', {
          timestamp: fileInfo.timestamp,
          fileName: fileInfo.fileName,
          nc12: nc12
        });
      }
      else
      {
        module.info('Ignored!', {fileInfo});
      }

      locked = false;

      setImmediate(importNext);
    });
  }

  function importFile(fileInfo, done)
  {
    step(
      function readEmailJsonFileStep()
      {
        readEmailJsonFile(path.join(fileInfo.filePath, 'email.json'), 0, this.next());
      },
      function parseEmailJsonStep(err, fileContents)
      {
        if (err)
        {
          return this.skip(err);
        }

        module.info('Parsing email.json...', {fileInfo, fileSize: fileContents.length});

        try
        {
          setImmediate(this.next(), null, JSON.parse(fileContents));
        }
        catch (err)
        {
          setImmediate(this.next(), err);
        }
      },
      function handleEmailJsonStep(err, email)
      {
        if (err)
        {
          return this.skip(err);
        }

        const matches = email.subject.match(/ETO.*?([0-9]{12}|[0-9A-Z]{7})/);

        if (!matches)
        {
          return this.skip();
        }

        this.nc12 = matches[1];
        this.email = email;
        this.constructorUser = '';
      },
      function findEtoTableStep()
      {
        const $ = cheerio.load(this.email.body);
        const $tables = $('table');

        const nc12 = this.nc12;
        let etoTableHtml = '';
        let constructorUser = '';

        $tables.each(function()
        {
          if (etoTableHtml)
          {
            return;
          }

          const $table = $(this);
          const text = $table.text().replace(/[^0-9a-zA-Z]/g, '').toLowerCase();

          if (!text.includes('wykonanie') || !text.includes('12nc') || !text.includes(nc12))
          {
            return;
          }

          etoTableHtml = $.html(this);

          $table.find('tr').each(function()
          {
            if (constructorUser)
            {
              return;
            }

            const matches = $(this).text().trim().match(/(?:opracowa.|konstruktor)\s*:?\s*(.*?)$/i);

            if (matches)
            {
              constructorUser = matches[1];
            }
          });
        });

        if (!etoTableHtml)
        {
          return this.skip(new Error('ETO table not found in the e-mail body.'));
        }

        this.etoTableHtml = etoTableHtml;
        this.constructorUser = constructorUser;

        setImmediate(this.next());
      },
      function readInlineAttachmentFilesStep()
      {
        this.inlineAttachments = findInlineAttachments(
          this.etoTableHtml,
          mapContentAttachments(this.email.attachments, fileInfo.filePath)
        );

        for (let i = 0; i < this.inlineAttachments.length; ++i)
        {
          fs.readFile(this.inlineAttachments[i].path, this.group());
        }
      },
      function insertInlineAttachmentsStep(err, buffers)
      {
        if (err)
        {
          return this.skip(err);
        }

        for (let i = 0; i < this.inlineAttachments.length; ++i)
        {
          const inlineAttachment = this.inlineAttachments[i];
          const buffer = buffers[i];
          const replacement = 'src="data:' + inlineAttachment.type + ';base64,' + buffer.toString('base64') + '"';

          this.etoTableHtml = this.etoTableHtml.replace(inlineAttachment.pattern, replacement);
        }

        setImmediate(this.next());
      },
      function saveOrderEtoStep()
      {
        const orderEto = {
          _id: this.nc12,
          updatedAt: new Date(),
          constructorUser: this.constructorUser,
          html: this.etoTableHtml
        };

        OrderEto.collection.replaceOne({_id: orderEto._id}, orderEto, {upsert: true}, this.next());
      },
      function finalizeStep(err)
      {
        done(err, this.nc12);
      }
    );
  }

  function cleanUpFileInfoFile(fileInfo)
  {
    setTimeout(removeFilePathFromCache, 15000, fileInfo.filePath);

    if (module.config.parsedOutputDir)
    {
      moveFileInfoFile(fileInfo.filePath);
    }
    else
    {
      deleteFileInfoFile(fileInfo.filePath);
    }
  }

  function moveFileInfoFile(oldFilePath)
  {
    const newFilePath = path.join(module.config.parsedOutputDir, path.basename(oldFilePath));

    fs.move(oldFilePath, newFilePath, {overwrite: true}, (err) =>
    {
      if (err)
      {
        module.error(err, 'Failed to move.', {oldFilePath, newFilePath});
      }
    });
  }

  function deleteFileInfoFile(filePath)
  {
    fs.remove(filePath, err =>
    {
      if (err)
      {
        module.error(err, 'Failed to delete directory.', {filePath});
      }
    });
  }

  function removeFilePathFromCache(filePath)
  {
    delete filePathCache[filePath];
  }

  function readEmailJsonFile(filePath, retry, done)
  {
    if (retry > 10)
    {
      return done(new Error('email.json file not found!'));
    }

    fs.readFile(filePath, {encoding: 'utf8'}, (err, contents) =>
    {
      if (err && err.code === 'ENOENT')
      {
        return setTimeout(readEmailJsonFile, 3000, filePath, retry + 1, done);
      }

      done(err, contents);
    });
  }

  function mapContentAttachments(attachments, targetDirPath)
  {
    const contentAttachments = {};

    _.forEach(attachments, (attachment) =>
    {
      if (attachment.contentId)
      {
        attachment.path = path.join(targetDirPath, attachment.name);

        contentAttachments[attachment.contentId] = attachment;
      }
    });

    return contentAttachments;
  }

  function findInlineAttachments(html, contentAttachments)
  {
    const inlineAttachments = [];
    const re = /src="cid:(.*?)"/g;
    let match;

    while ((match = re.exec(html)) !== null) // eslint-disable-line no-cond-assign
    {
      const pattern = match[0];
      const contentId = match[1];
      const contentAttachment = contentAttachments[contentId];

      if (contentAttachment)
      {
        inlineAttachments.push({
          path: contentAttachment.path,
          type: contentAttachment.contentType,
          pattern: pattern
        });
      }
    }

    return inlineAttachments;
  }
};
