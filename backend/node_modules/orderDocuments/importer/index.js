// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const path = require('path');
const _ = require('lodash');
const jsonDeepEqual = require('util/jsonDeepEqual');
const moment = require('moment');
const step = require('h5.step');
const fs = require('fs-extra');
const parseSapTextTable = require('sap/util/parseSapTextTable');
const shifts = require('util/shifts');

exports.DEFAULT_CONFIG = {
  mongooseId: 'mongoose',
  filterRe: /^T_COOIS_DOCS\.txt$/,
  parsedOutputDir: null,
  xiconfProgramPatterns: [],
  xiconfProgramFilePathPattern: './{timestamp}@T_COOIS_XICONF.txt'
};

exports.models = [
  require('../models/orderDocumentName'),
  require('../models/orderDocumentFile'),
  require('../models/missingOrderDocument'),
  require('orders/models/order'),
  require('xiconf/models/xiconfOrder'),
  require('settings/models/setting')
];

exports.recordTopics = {
  info: ['orderDocuments.synced'],
  error: ['orderDocuments.syncFailed']
};

exports.requiredModules = 'mongoose';

exports.start = (app, module) =>
{
  const {
    Order,
    OrderDocumentName,
    OrderDocumentFile,
    MissingOrderDocument,
    XiconfOrder
  } = module;

  const XICONF_PROGRAM_PATTERNS = module.config.xiconfProgramPatterns;
  const XICONF_PROGRAM_FILE_PATH_PATTERN = module.config.xiconfProgramFilePathPattern;

  const scheduleUpdateDocumentNames = _.debounce(updateDocumentNames, 30000);

  const filePathCache = {};
  const queue = [];
  let locked = false;

  app.broker.subscribe('directoryWatcher.changed', queueFile).setFilter(filterFile);

  function filterFile(fileInfo)
  {
    if (filePathCache[fileInfo.filePath] || !module.config.filterRe.test(fileInfo.fileName))
    {
      return false;
    }

    fileInfo.timeKey = createTimeKey(fileInfo.timestamp);

    return true;
  }

  function createTimeKey(timestamp)
  {
    return moment(timestamp).subtract(1, 'days').format('YYMMDDHH');
  }

  function queueFile(fileInfo)
  {
    filePathCache[fileInfo.filePath] = true;

    queue.push(fileInfo);

    module.info('Queued...', {fileInfo});

    setImmediate(importNext);
  }

  function importNext()
  {
    if (locked)
    {
      return;
    }

    const fileInfo = queue.shift();

    if (!fileInfo)
    {
      return;
    }

    locked = true;

    const startTime = Date.now();

    module.info('Importing...', {fileInfo});

    importFile(fileInfo, (err, summary) =>
    {
      cleanUpFileInfoFile(fileInfo);

      if (err)
      {
        module.error(err, 'Failed to import.', {fileInfo});

        app.broker.publish('orderDocuments.syncFailed', {
          timestamp: fileInfo.timestamp,
          error: err.message
        });
      }
      else
      {
        module.info('Imported!', {
          fileInfo,
          summary,
          duration: (Date.now() - startTime) / 1000
        });

        app.broker.publish('orderDocuments.synced', {
          timestamp: fileInfo.timestamp,
          updateCount: summary.updateCount,
          minDate: summary.minDate === Number.MAX_SAFE_INTEGER ? 0 : summary.minDate,
          maxDate: summary.maxDate === Number.MIN_SAFE_INTEGER ? 0 : summary.maxDate
        });
      }

      locked = false;

      setImmediate(importNext);
    });
  }

  function importFile(fileInfo, done)
  {
    let minDate = Number.MAX_SAFE_INTEGER;
    let maxDate = Number.MIN_SAFE_INTEGER;

    step(
      function readFileStep()
      {
        fs.readFile(fileInfo.filePath, {encoding: 'utf8'}, this.next());
      },
      function parseFileStep(err, fileContents)
      {
        if (err)
        {
          return this.skip(err);
        }

        module.info('Parsing...', {fileInfo, fileSize: fileContents.length});

        const t = Date.now();

        this.parsedOrderDocumentsList = parseSapTextTable(fileContents, {
          columnMatchers: {
            orderNo: /^Order/,
            item: /^Item/,
            nc15: /^Document/,
            name: /^Description/
          }
        });

        module.info('Parsed!', {
          fileInfo,
          count: this.parsedOrderDocumentsList.length,
          duration: (Date.now() - t) / 1000
        });

        if (!this.parsedOrderDocumentsList.length)
        {
          return this.skip();
        }

        setImmediate(this.next());
      },
      function mapParsedOrdersStep()
      {
        const orderNoToDocumentsMap = {};
        const orderNoToProgramMap = {};

        for (let i = 0; i < this.parsedOrderDocumentsList.length; ++i)
        {
          const orderDocument = this.parsedOrderDocumentsList[i];

          if (orderNoToDocumentsMap[orderDocument.orderNo] === undefined)
          {
            orderNoToDocumentsMap[orderDocument.orderNo] = [];
          }

          orderNoToDocumentsMap[orderDocument.orderNo].push({
            item: orderDocument.item,
            nc15: orderDocument.nc15,
            name: orderDocument.name,
            added: false
          });

          matchPrograms(orderDocument, orderNoToProgramMap);
        }

        this.parsedOrderDocumentsList = null;
        this.orderNoToDocumentsMap = orderNoToDocumentsMap;
        this.orderNoToProgramMap = orderNoToProgramMap;

        setImmediate(this.next());
      },
      function findExistingOrdersStep()
      {
        const conditions = {
          _id: {
            $in: Object.keys(this.orderNoToDocumentsMap)
          }
        };
        const fields = {
          mrp: 1,
          qty: 1,
          scheduledStartDate: 1,
          sapCreatedAt: 1,
          documents: 1
        };

        Order.find(conditions, fields).lean().exec(this.next());
      },
      function compareOrderDocumentsStep(err, orders)
      {
        if (err)
        {
          return this.skip(err);
        }

        const updateList = [];
        const updatedAt = new Date();
        const missing = new Map();

        orders.forEach(order =>
        {
          const program = this.orderNoToProgramMap[order._id];
          const addedDocuments = [];
          const oldDocumentMap = new Map();
          const newDocumentMap = new Map();

          (order.documents || []).forEach(doc =>
          {
            if (doc.added)
            {
              addedDocuments.push(doc);
            }
            else
            {
              doc.added = false;
            }

            oldDocumentMap.set(doc.nc15, doc);
          });

          this.orderNoToDocumentsMap[order._id].forEach(doc =>
          {
            newDocumentMap.set(doc.nc15, doc);
          });

          addedDocuments.forEach(doc =>
          {
            if (!newDocumentMap.has(doc.nc15))
            {
              newDocumentMap.set(doc.nc15, doc);
            }
          });

          const oldDocumentList = Array.from(oldDocumentMap.values()).sort(sortDocuments);
          const newDocumentList = Array.from(newDocumentMap.values()).sort(sortDocuments);

          if (program)
          {
            program.qty = order.qty;
          }

          if (order.scheduledStartDate < minDate)
          {
            minDate = order.scheduledStartDate.getTime();
          }

          if (order.scheduledStartDate > maxDate)
          {
            maxDate = order.scheduledStartDate.getTime();
          }

          if (jsonDeepEqual(oldDocumentList, newDocumentList))
          {
            return;
          }

          if (!order.mrp.startsWith('KS'))
          {
            newDocumentList.forEach(doc =>
            {
              if (!missing.has(doc.nc15))
              {
                missing.set(doc.nc15, {
                  name: doc.name,
                  orders: new Map()
                });
              }

              missing.get(doc.nc15).orders.set(order._id, {
                _id: order._id,
                mrp: order.mrp,
                availDate: moment(order.sapCreatedAt || order.scheduledStartDate).startOf('day').utc(true).toDate(),
                startDate: moment(order.scheduledStartDate).utc(true).toDate()
              });
            });
          }

          updateList.push({
            updateOne: {
              filter: {_id: order._id},
              update: {
                $set: {
                  updatedAt: updatedAt,
                  documents: newDocumentList
                },
                $push: {
                  changes: {
                    time: updatedAt,
                    user: null,
                    oldValues: {documents: oldDocumentList},
                    newValues: {documents: newDocumentList},
                    comment: ''
                  }
                }
              }
            }
          });
        });

        this.updateList = updateList;

        setImmediate(buildXiconfProgramsDumpFile, fileInfo.timestamp, this.orderNoToProgramMap);
        setImmediate(checkMissingDocuments, missing, this.next());
      },
      function updateOrdersStep()
      {
        if (this.updateList.length)
        {
          Order.collection.bulkWrite(this.updateList, this.next());
        }
      },
      function(err)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (this.updateList.length)
        {
          app.broker.publish('orders.documentsChanged', {
            orders: this.updateList.map(u => u.updateOne.filter._id)
          });
        }
      },
      function finalizeStep(err)
      {
        const updateCount = this.updateList ? this.updateList.length : 0;

        this.parsedOrderDocumentsList = null;
        this.orderNoToDocumentsMap = null;
        this.orderNoToProgramMap = null;
        this.updateList = null;

        scheduleUpdateDocumentNames();

        if (!err || err.code === 11000)
        {
          return done(null, {updateCount, minDate, maxDate});
        }

        // mongodb package bug workaround
        if (err.err && !err.message)
        {
          const code = err.code;

          err = new Error(err.err);
          err.name = 'MongoError';
          err.code = code;
        }

        return done(err, null);
      }
    );
  }

  function cleanUpFileInfoFile(fileInfo)
  {
    setTimeout(removeFilePathFromCache, 15000, fileInfo.filePath);

    if (module.config.parsedOutputDir)
    {
      moveFileInfoFile(fileInfo.filePath);
    }
    else
    {
      deleteFileInfoFile(fileInfo.filePath);
    }
  }

  function moveFileInfoFile(oldFilePath)
  {
    const newFilePath = path.join(module.config.parsedOutputDir, path.basename(oldFilePath));

    fs.move(oldFilePath, newFilePath, {overwrite: true}, (err) =>
    {
      if (err)
      {
        module.error(err, 'Failed to rename file.', {oldFilePath, newFilePath});
      }
    });
  }

  function deleteFileInfoFile(filePath)
  {
    fs.unlink(filePath, (err) =>
    {
      if (err)
      {
        module.error(err, 'Failed to delete file.', {filePath});
      }
    });
  }

  function removeFilePathFromCache(filePath)
  {
    delete filePathCache[filePath];
  }

  function sortDocuments(a, b)
  {
    if (a.item !== b.item)
    {
      return a.item - b.item;
    }

    if (a.name !== b.name)
    {
      return a.name.localeCompare(b.name);
    }

    return a.nc15.localeCompare(b.nc15);
  }

  function matchPrograms(orderDocument, orderNoToProgramMap)
  {
    for (let i = 0; i < XICONF_PROGRAM_PATTERNS.length; ++i)
    {
      const matches = orderDocument.name.match(XICONF_PROGRAM_PATTERNS[i]);

      if (matches)
      {
        orderNoToProgramMap[orderDocument.orderNo] = {
          nc12: orderDocument.nc15.substring(3),
          name: matches.length > 1 ? matches[1] : orderDocument.name,
          qty: -1
        };

        break;
      }
    }
  }

  function buildXiconfProgramsDumpFile(timestamp, orderNoToProgramMap)
  {
    if (!module.config.xiconfProgramFilePathPattern)
    {
      return;
    }

    const orderNos = Object.keys(orderNoToProgramMap);

    if (!orderNos.length)
    {
      return;
    }

    step(
      function findXiconfOrdersStep()
      {
        XiconfOrder
          .find({_id: {$in: orderNos}})
          .lean()
          .exec(this.next());
      },
      function prepareOrderItemsStep(err, xiconfOrders)
      {
        if (err)
        {
          return this.skip(err);
        }

        const xiconfOrderItems = [];

        for (let i = 0; i < xiconfOrders.length; ++i)
        {
          const xiconfOrder = xiconfOrders[i];

          addXiconfOrderItems(
            xiconfOrder,
            orderNoToProgramMap[xiconfOrder._id],
            xiconfOrderItems
          );
        }

        setImmediate(this.next(), null, xiconfOrderItems);
      },
      function writeFileStep(err, xiconfOrderItems)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!xiconfOrderItems.length)
        {
          return this.skip();
        }

        const filePath = XICONF_PROGRAM_FILE_PATH_PATTERN.replace('{timestamp}', Math.ceil(timestamp / 1000));
        const fileContents = [
          'DOCS',
          '-----------------------------------------------------------------------------------------------------------',
          '|Order    |Material       |Reqmts qty|Material Description                             |Reqmt Date|Deleted|',
          '-----------------------------------------------------------------------------------------------------------'
        ];

        for (let i = 0; i < xiconfOrderItems.length; ++i)
        {
          const item = xiconfOrderItems[i];
          const row = [
            '',
            item.orderNo,
            '000' + item.nc12,
            _.padStart(item.quantity.toString(), 9, ' ') + ' ',
            _.padEnd(item.name, 49, ' '),
            moment(item.reqDate).format('DD.MM.YYYY'),
            '       ',
            ''
          ];

          fileContents.push(row.join('|'));
        }

        fileContents.push(fileContents[0]);

        fs.writeFile(filePath, fileContents.join('\r\n'), this.next());
      },
      function finalizeStep(err)
      {
        if (err)
        {
          module.error(err, 'Failed to build Xiconf dump file.');
        }
      }
    );
  }

  function addXiconfOrderItems(xiconfOrder, newProgram, xiconfOrderItems)
  {
    let programItem = null;

    for (let i = 0; i < xiconfOrder.items.length; ++i)
    {
      const item = xiconfOrder.items[i];

      if (item.kind !== 'led'
        && item.kind !== 'hid'
        && item.kind !== 'gprs'
        && item.kind !== 'program')
      {
        continue;
      }

      const xiconfOrderItem = {
        orderNo: xiconfOrder._id,
        nc12: item.nc12,
        name: item.name,
        quantity: item.quantityTodo,
        reqDate: xiconfOrder.reqDate
      };

      if (item.kind === 'program')
      {
        programItem = xiconfOrderItem;
      }

      xiconfOrderItems.push(xiconfOrderItem);
    }

    if (programItem)
    {
      programItem.nc12 = newProgram.nc12;
      programItem.name = newProgram.name;

      if (newProgram.qty !== -1)
      {
        programItem.quantity = newProgram.qty;
      }
    }
    else
    {
      programItem = {
        orderNo: xiconfOrder._id,
        nc12: newProgram.nc12,
        name: newProgram.name,
        quantity: newProgram.qty === -1 ? xiconfOrder.quantityTodo : newProgram.qty,
        reqDate: xiconfOrder.reqDate
      };

      xiconfOrderItems.push(programItem);
    }

    programItem.name = 'Program ' + programItem.name;
  }

  function updateDocumentNames()
  {
    module.debug('Updating document names...');

    step(
      function()
      {
        OrderDocumentName.estimatedDocumentCount({}, this.next());
      },
      function(err, count)
      {
        if (err)
        {
          return this.skip(err);
        }

        const pipeline = [
          {$unwind: '$documents'},
          {$group: {_id: '$documents.nc15', name: {$max: '$documents.name'}}}
        ];

        if (count)
        {
          pipeline.unshift({
            $match: {scheduledStartDate: {$gt: moment().startOf('day').subtract(1, 'days').toDate()}}
          });
        }

        Order.aggregate(pipeline, this.next());
      },
      function(err, documents)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!documents.length)
        {
          return this.skip();
        }

        OrderDocumentFile
          .find({$where: '!this.name || this._id === this.name'})
          .select({_id: 1})
          .lean()
          .exec(this.parallel());

        const operations = documents.map(document =>
        {
          return {
            updateOne: {
              filter: {_id: document._id},
              update: {$set: {name: document.name}},
              upsert: true
            }
          };
        });

        OrderDocumentName.collection.bulkWrite(operations, this.parallel());
      },
      function(err, files)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!files.length)
        {
          return this.skip();
        }

        OrderDocumentName.find({_id: files.map(f => f._id)}).lean().exec(this.next());
      },
      function(err, names)
      {
        if (err)
        {
          return this.skip(err);
        }

        const operations = names.map(document =>
        {
          return {
            updateOne: {
              filter: {_id: document._id},
              update: {$set: {name: document.name}}
            }
          };
        });

        if (operations.length)
        {
          OrderDocumentFile.collection.bulkWrite(operations, this.next());
        }
      },
      function(err)
      {
        if (err)
        {
          module.error(err, 'Failed to update document names.');
        }
        else
        {
          module.info('Updated document names.');
        }
      }
    );
  }

  async function checkMissingDocuments(docsToOrders, done)
  {
    if (!docsToOrders.size)
    {
      return done();
    }

    try
    {
      const currentDate = shifts.getCurrentDate(true).toDate();
      const docIds = Array.from(docsToOrders.keys());
      const [fileList, missingList] = await Promise.all([
        OrderDocumentFile
          .find({_id: {$in: docIds}})
          .select({'files.date': 1})
          .lean()
          .exec(),
        MissingOrderDocument
          .find({_id: {$in: docIds}})
          .lean()
          .exec()
      ]);

      const addedMissing = new Set();
      const updatedMissing = new Set();
      const missingMap = new Map();
      const fileMap = new Map();

      missingList.forEach(m =>
      {
        missingMap.set(m._id, m);
      });

      fileList.forEach(f =>
      {
        if (f.files.length)
        {
          fileMap.set(f._id, f.files[f.files.length - 1].date);
        }
      });

      docsToOrders.forEach(({name, orders}, nc15) =>
      {
        if (!missingMap.has(nc15))
        {
          addedMissing.add(nc15);
          missingMap.set(nc15, {
            _id: nc15,
            name,
            orders: []
          });
        }

        const missing = missingMap.get(nc15);
        const availFrom = fileMap.get(nc15);
        let changed = false;

        missing.orders = missing.orders.filter(o =>
        {
          const order = orders.get(o._id);

          orders.delete(o._id);

          if (order)
          {
            changed = changed || !jsonDeepEqual(o, order);

            Object.assign(o, order);
          }

          if (o.startDate < currentDate)
          {
            changed = true;

            return false;
          }

          if (!availFrom || o.availDate < availFrom)
          {
            return true;
          }

          changed = true;

          return false;
        });

        orders.forEach(order =>
        {
          if (order.startDate < currentDate)
          {
            return;
          }

          if (order.availDate >= availFrom)
          {
            return;
          }

          missing.orders.push(order);

          changed = true;
        });

        if (changed)
        {
          updatedMissing.add(nc15);
        }
      });

      const ops = [];
      const msg = {
        added: [],
        updated: [],
        deleted: []
      };

      missingMap.forEach(missing =>
      {
        if (missing.orders.length === 0)
        {
          if (!addedMissing.has(missing._id))
          {
            msg.deleted.push({_id: missing._id});
          }

          return;
        }

        if (addedMissing.has(missing._id))
        {
          msg.added.push(missing);
        }
        else if (!updatedMissing.has(missing._id))
        {
          return;
        }
        else
        {
          msg.updated.push(missing);
        }

        ops.push({
          replaceOne: {
            filter: {_id: missing._id},
            replacement: missing,
            upsert: true
          }
        });
      });

      if (msg.deleted.length)
      {
        ops.push({
          deleteMany: {
            filter: {_id: {$in: msg.deleted.map(m => m._id)}}
          }
        });
      }

      if (ops.length)
      {
        await MissingOrderDocument.collection.bulkWrite(ops);

        app.broker.publish(`${MissingOrderDocument.TOPIC_PREFIX}.updated`, msg);
      }
    }
    catch (err)
    {
      module.error(err, 'Failed to check missing documents.');
    }

    done();
  }
};
