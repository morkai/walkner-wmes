// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');

module.exports = (app, module) =>
{
  const {
    sio,
    production,
    orgUnits,
    user,
    OrderDocumentClient,
    OrderDocumentConfirmation
  } = module;

  const clients = {};
  const socketToClient = {};
  const prodLineToClients = {};

  const EMPTY_REMOTE_ORDER = {
    no: null,
    nc12: '',
    name: '',
    documents: {}
  };

  module.getClients = () => Object.values(clients);

  app.broker.subscribe('production.stateChanged.**', onProductionStateChanged);
  app.broker.subscribe('orderDocuments.extraUpdated', onExtraDocumentsUpdated);
  app.broker.subscribe('orders.documentsChanged', onDocumentsChanged);

  sio.on('connection', (socket) =>
  {
    socket.on('disconnect', handleSocketDisconnect.bind(null, socket));
    socket.on('orderDocuments.join', handleJoinMessage.bind(null, socket));
    socket.on('orderDocuments.update', handleUpdateMessage.bind(null, socket));
    socket.on('orderDocuments.confirm', handleConfirmMessage.bind(null, socket));
  });

  function onProductionStateChanged(changes)
  {
    const pso = changes.prodShiftOrders;

    if (pso === undefined || (_.isPlainObject(pso) && pso.orderId === undefined))
    {
      return;
    }

    updateProdLinesRemoteOrder(changes._id, null);
  }

  function onExtraDocumentsUpdated(extra)
  {
    const nameToProdLines = {};

    _.forEach(prodLineToClients, function(clientsMap, prodLineId)
    {
      const prodLineState = production.getProdLineState(prodLineId);

      if (!prodLineState)
      {
        return;
      }

      const lastOrder = prodLineState.getLastOrder();

      if (!lastOrder)
      {
        return;
      }

      const name = lastOrder.orderData.name;

      if (!name)
      {
        return;
      }

      if (nameToProdLines[name] === undefined)
      {
        nameToProdLines[name] = [];
      }

      nameToProdLines[name].push(prodLineId);
    });

    const productNames = Object.keys(nameToProdLines);

    for (let i = 0; i < extra.length; ++i)
    {
      const pattern = extra[i].pattern;

      for (let ii = 0; ii < productNames.length; ++ii)
      {
        const productName = productNames[ii];

        if (productName.indexOf(pattern) === -1)
        {
          continue;
        }

        const prodLineIds = nameToProdLines[productName];

        for (let iii = 0; iii < prodLineIds.length; ++iii)
        {
          updateProdLinesRemoteOrder(prodLineIds[iii], null);
        }

        break;
      }
    }
  }

  function onDocumentsChanged({orders})
  {
    orders.forEach(orderNo =>
    {
      module.orderDataCache.delete(orderNo);
    });

    Object.values(clients).forEach(client =>
    {
      if (client.orderInfo.orderNo && orders.includes(client.orderInfo.orderNo))
      {
        updateProdLinesRemoteOrder(client.prodLine);
      }
    });
  }

  function handleJoinMessage(socket, message)
  {
    const newClientId = message.clientId;
    const newProdLineId = orgUnits.fix.prodLine(message.prodLineId);

    if (!_.isString(newClientId)
      || _.isEmpty(newClientId)
      || !_.isString(newProdLineId)
      || _.isEmpty(newProdLineId))
    {
      return;
    }

    const currentClient = clients[newClientId];

    if (currentClient)
    {
      delete clients[newClientId];
      delete socketToClient[socket.id];

      if (prodLineToClients[currentClient.prodLineId])
      {
        delete prodLineToClients[currentClient.prodLineId][newClientId];
      }
    }

    const newClient = {
      _id: newClientId,
      connectedAt: new Date(),
      disconnectedAt: null,
      socket: socket.id,
      ipAddress: socket.handshake.user.ipAddress,
      prodLine: newProdLineId,
      station: message.station || 0,
      settings: message.settings || {},
      orderInfo: message.orderInfo || {}
    };

    if (!prodLineToClients[newProdLineId])
    {
      prodLineToClients[newProdLineId] = {};
    }

    clients[newClientId] = newClient;
    socketToClient[socket.id] = newClientId;
    prodLineToClients[newProdLineId][newClientId] = true;

    updateProdLinesRemoteOrder(newProdLineId, socket);

    OrderDocumentClient.collection.replaceOne({_id: newClient._id}, newClient, {upsert: true}, err =>
    {
      if (err)
      {
        module.error(err, 'Failed to update client after connection.', {clientId: newClient._id});
      }
      else
      {
        app.broker.publish('orderDocuments.clients.connected', newClient);
      }
    });
  }

  function handleUpdateMessage(socket, message)
  {
    if (!message || !_.isString(message.clientId))
    {
      return;
    }

    const client = clients[message.clientId];

    if (!client || socket.id !== client.socket)
    {
      return;
    }

    const update = {
      $set: {
        settings: message.settings,
        orderInfo: message.orderInfo
      }
    };

    OrderDocumentClient.collection.updateOne({_id: message.clientId}, update, err =>
    {
      if (err)
      {
        module.error(err, 'Failed to update client.', {clientId: message.clientId});
      }
      else
      {
        app.broker.publish('orderDocuments.clients.updated', message);
      }
    });
  }

  function handleSocketDisconnect(socket)
  {
    const clientId = socketToClient[socket.id];

    if (!clientId)
    {
      return;
    }

    delete socketToClient[socket.id];

    const client = clients[clientId];

    if (!client)
    {
      return;
    }

    delete clients[clientId];

    if (prodLineToClients[client.prodLine])
    {
      delete prodLineToClients[client.prodLine][socket.id];
    }

    const clientChanges = {
      _id: clientId,
      connectedAt: null,
      disconnectedAt: new Date(),
      socket: null
    };

    OrderDocumentClient.collection.updateOne({_id: clientId, socket: socket.id}, {$set: clientChanges}, err =>
    {
      if (err)
      {
        module.error(err, 'Failed to update client after disconnection.', {clientId});
      }
      else
      {
        app.broker.publish('orderDocuments.clients.disconnected', clientChanges);
      }
    });
  }

  function handleConfirmMessage(socket, message, done)
  {
    if (!message || !_.isString(message.clientId))
    {
      return done(app.createError('Invalid input.', 'INPUT', 400));
    }

    const client = clients[message.clientId];

    if (!client || socket.id !== client.socket)
    {
      return done(app.createError('Unknown client.', 'INPUT', 400));
    }

    const confirmation = new OrderDocumentConfirmation({
      user: user.createUserInfo(socket.handshake.user, socket),
      time: new Date(),
      nc15: message.nc15,
      name: message.name,
      line: message.line,
      station: message.station,
      orderNo: message.orderNo
    });

    confirmation.save(err =>
    {
      if (err)
      {
        module.error(err, 'Failed to confirm document.', {confirmation});

        return done(err);
      }

      const result = confirmation.toJSON();

      app.broker.publish(`orderDocuments.confirmed.${confirmation.line}`, result);

      done(null, result);
    });
  }

  function updateProdLinesRemoteOrder(prodLineId, optSocket)
  {
    const prodLineClients = prodLineToClients[prodLineId];

    if (_.isEmpty(prodLineClients))
    {
      return;
    }

    const prodLineState = production.getProdLineState(prodLineId);

    if (!prodLineState)
    {
      return emitEmptyRemoteOrderData(prodLineId, optSocket);
    }

    const lastOrder = prodLineState.getLastOrder();

    if (!lastOrder)
    {
      return emitEmptyRemoteOrderData(prodLineId, optSocket);
    }

    const lastOrderNo = lastOrder.orderData.no;

    if (!lastOrderNo)
    {
      return emitEmptyRemoteOrderData(prodLineId, optSocket);
    }

    const params = {
      orderNo: lastOrderNo,
      line: prodLineId,
      station: 0
    };

    module.findOrderData(params, function(err, orderData)
    {
      if (err)
      {
        module.error(err, 'Failed to find remote order.', {orderNo: lastOrderNo});

        return emitEmptyRemoteOrderData(prodLineId, optSocket);
      }

      emitRemoteOrderData(prodLineId, optSocket, orderData);
    });
  }

  function emitEmptyRemoteOrderData(prodLineId, optSocket)
  {
    emitRemoteOrderData(prodLineId, optSocket, EMPTY_REMOTE_ORDER);
  }

  function emitRemoteOrderData(prodLineId, optSocket, remoteOrder)
  {
    if (optSocket)
    {
      return optSocket.emit('orderDocuments.remoteOrderUpdated', remoteOrder);
    }

    const prodLineClients = prodLineToClients[prodLineId];

    if (_.isEmpty(prodLineClients))
    {
      return;
    }

    _.forEach(Object.keys(prodLineClients), function(clientId)
    {
      const client = clients[clientId];

      if (!client)
      {
        return;
      }

      const socket = sio.sockets.connected[client.socket];

      if (!socket)
      {
        return;
      }

      socket.emit('orderDocuments.remoteOrderUpdated', remoteOrder);
    });
  }
};
