// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');

module.exports = (app, module) =>
{
  module.cachedSettings = {
    useCatalog: false,
    excludedMrps: [],
    path: '',
    extra: [],
    remoteServer: ''
  };

  app.broker.subscribe('settings.updated.orders.documents.**', updateSettings);

  module.settings.find({_id: /^orders\.documents./}, (err, settings) =>
  {
    if (err)
    {
      return module.error(err, 'Failed to find settings.');
    }

    settings.forEach(setting => updateSettings(setting));
  });

  function updateSettings({_id, value})
  {
    const {cachedSettings} = module;
    const id = _id.split('.')[2];

    if (id === 'extra')
    {
      cachedSettings.extra = parseExtraDocumentsSetting(value);

      app.broker.publish('orderDocuments.extraUpdated', cachedSettings.extra);

      return;
    }

    if (typeof cachedSettings[id] !== 'undefined')
    {
      cachedSettings[id] = value;
    }
  }

  function parseExtraDocumentsSetting(rawValue)
  {
    const extra = [];

    if (!_.isString(rawValue) || _.isEmpty(rawValue))
    {
      return extra;
    }

    const namesToDocuments = {};
    let lastName = '';

    _.forEach(rawValue.split('\n'), (line) =>
    {
      const matches = line.match(/([0-9]{15})\s+(.*?)$/);

      if (matches)
      {
        if (lastName === '')
        {
          return;
        }

        namesToDocuments[lastName][matches[1]] = matches[2];
      }
      else
      {
        lastName = line;

        namesToDocuments[lastName] = {};
      }
    });

    _.forEach(namesToDocuments, (documents, names) =>
    {
      names = names
        .split(';')
        .map((name) => name.trim())
        .filter((name) => !!name.length);

      if (!names.length)
      {
        return;
      }

      _.forEach(names, (name) =>
      {
        extra.push({
          pattern: prepareExtraDocumentPattern(name),
          documents
        });
      });
    });

    return extra;
  }

  function prepareExtraDocumentPattern(name)
  {
    try
    {
      return new RegExp(name);
    }
    catch (err)
    {
      return name;
    }
  }
};
