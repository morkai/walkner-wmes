// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const moment = require('moment');
const step = require('h5.step');
const jsonDeepEqual = require('deep-equal');
const {ObjectId} = require('mongoose').Types;

const ORDER_COMPARE_PROPERTIES = [
  'nc12',
  'name',
  'qty',
  'mrp',
  'orders'
];

const LOCKED = {};

module.exports = (app, module) =>
{
  if (!module.config.generator)
  {
    return;
  }

  const logger = module.logger.create({submodule: 'generator'});
  const {
    settings,
    Order,
    PlanSettings,
    WiringEvent,
    WiringOrder
  } = module;

  app.broker.subscribe('wiring.generator.requested', handleRequest);

  app.broker.subscribe('planning.generator.finished', handleRequest);

  function handleRequest(message)
  {
    const date = moment.utc(message.date, 'YYYY-MM-DD');

    if (date.isValid())
    {
      generate(date.toDate());
    }
  }

  function generate(utcDate)
  {
    const startedAt = Date.now();
    const key = moment.utc(utcDate).format('YYYY-MM-DD');
    const localDate = moment(key, 'YYYY-MM-DD').toDate();

    logger.info('Generating...', {key});

    app.broker.publish('wiring.generator.started', {
      date: key
    });

    step(
      function()
      {
        this.changes = {
          added: [],
          changed: [],
          removed: []
        };

        if (LOCKED[key])
        {
          return this.skip(new Error('Locked!'));
        }
      },
      function()
      {
        settings.findValues('wiring.', this.parallel());

        PlanSettings
          .findById(utcDate)
          .select({
            requiredStatuses: 1
          })
          .lean()
          .exec(this.parallel());
      },
      function(err, wiringSettings, planSettings)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!planSettings)
        {
          return this.skip(app.createError('Plan settings not found!?'));
        }

        this.settings = {
          wiring: wiringSettings,
          plan: planSettings
        };

        const conditions = {
          scheduledStartDate: localDate,
          statuses: {
            $all: planSettings.requiredStatuses,
            $nin: ['TECO', 'DLT', 'DLFL']
          }
        };

        try
        {
          if (wiringSettings.namePattern)
          {
            conditions.name = new RegExp(wiringSettings.namePattern, 'i');
          }
        }
        catch (err)
        {
          module.warning(err, 'Invalid name pattern.', {namePattern: wiringSettings.namePattern});
        }

        if (!_.isEmpty(wiringSettings.workCenters))
        {
          conditions['operations.workCenter'] = {$in: wiringSettings.workCenters};
        }

        Order
          .find(conditions)
          .select({
            nc12: 1,
            mrp: 1,
            name: 1,
            qty: 1,
            leadingOrder: 1
          })
          .lean()
          .exec(this.next());
      },
      function(err, wireOrders)
      {
        if (err)
        {
          return this.skip(err);
        }

        if (!wireOrders.length)
        {
          return this.skip();
        }

        this.wireOrders = new Map();

        wireOrders.forEach(sapOrder =>
        {
          if (!sapOrder.leadingOrder)
          {
            sapOrder.leadingOrder = sapOrder._id;
          }

          if (!this.wireOrders.has(sapOrder.leadingOrder))
          {
            this.wireOrders.set(sapOrder.leadingOrder, []);
          }

          this.wireOrders.get(sapOrder.leadingOrder).push(sapOrder);
        });

        Order
          .find({
            _id: {$in: Array.from(this.wireOrders.keys())},
            statuses: {
              $all: this.settings.plan.requiredStatuses,
              $nin: ['TECO', 'DLT', 'DLFL']
            }
          })
          .select({
            mrp: 1
          })
          .lean()
          .exec(this.next());
      },
      function(err, leadingOrders)
      {
        if (err)
        {
          return this.skip(err);
        }

        this.newOrders = new Map();

        leadingOrders.forEach(leadingOrder =>
        {
          this.wireOrders.get(leadingOrder._id).forEach(childOrder =>
          {
            const key = `${childOrder.nc12}:${leadingOrder.mrp}`;

            if (!this.newOrders.has(key))
            {
              this.newOrders.set(key, {
                _id: null,
                status: 'new',
                startedAt: null,
                finishedAt: null,
                date: utcDate,
                nc12: childOrder.nc12,
                name: childOrder.name,
                qty: 0,
                qtyDone: 0,
                mrp: leadingOrder.mrp,
                orders: []
              });
            }

            const wiringOrder = this.newOrders.get(key);

            wiringOrder.qty += childOrder.qty;

            wiringOrder.orders.push({
              _id: childOrder._id,
              qty: childOrder.qty,
              mrp: childOrder.mrp,
              leadingOrder: leadingOrder._id
            });
          });
        });

        setImmediate(this.next());
      },
      function()
      {
        WiringOrder
          .find({date: utcDate})
          .lean()
          .exec(this.next());
      },
      function(err, oldWiringOrders)
      {
        if (err)
        {
          return this.skip(err);
        }

        this.oldOrders = new Map();

        oldWiringOrders.forEach(o => this.oldOrders.set(`${o.nc12}:${o.mrp}`, o));

        setImmediate(this.next());
      },
      function()
      {
        this.events = [];

        this.oldOrders.forEach(oldOrder =>
        {
          const key = `${oldOrder.nc12}:${oldOrder.mrp}`;
          const newOrder = this.newOrders.get(key);

          this.newOrders.delete(key);

          if (!newOrder)
          {
            if (oldOrder.status === 'new')
            {
              this.changes.removed.push(oldOrder._id);
            }
            else if (oldOrder.status !== 'cancelled')
            {
              this.changes.changed.push({
                _id: oldOrder._id,
                status: 'cancelled'
              });

              recordEvent(this.events, 'cancelled', oldOrder);
            }

            return;
          }

          const changed = compareOrders(oldOrder, newOrder);

          if (changed)
          {
            this.changes.changed.push(changed);
          }
        });

        this.newOrders.forEach(newOrder =>
        {
          newOrder._id = new ObjectId();

          newOrder.orders.sort((a, b) => a._id.localeCompare(b._id));

          this.changes.added.push(newOrder);
        });

        setImmediate(this.next());
      },
      function()
      {
        const {added, changed, removed} = this.changes;

        this.notAdded = new Map();

        if (added.length)
        {
          const next = this.group();

          WiringOrder.collection.insertMany(added, {ordered: false}, (err, res) =>
          {
            if (err && err.result)
            {
              res = err.result;
            }

            if (res && res.hasWriteErrors && res.hasWriteErrors())
            {
              res.getWriteErrors().forEach(writeError =>
              {
                const duplicateOrder = writeError.getOperation();

                this.notAdded.set(duplicateOrder._id, duplicateOrder);
              });

              this.changes.added = added.filter(o => !this.notAdded.has(o._id));
            }

            next(err && err.code === 11000 ? null : err);
          });
        }

        if (this.events.length)
        {
          const next = this.group();

          WiringEvent.collection.insertMany(this.events, {ordered: false}, err =>
          {
            if (err)
            {
              logger.error(err, `Failed to save events.`, {key});
            }

            next();
          });
        }

        if (removed.length)
        {
          WiringOrder.collection.deleteMany({_id: {$in: removed}}, this.group());
        }

        changed.forEach(change =>
        {
          WiringOrder.collection.updateOne({_id: change._id}, {$set: change}, this.group());
        });
      },
      function(err)
      {
        if (err)
        {
          return this.skip(err);
        }

        this.notAdded.forEach(duplicateOrder =>
        {
          const next = this.group();
          const filter = {_id: duplicateOrder._id};
          const update = {$set: _.pick(duplicateOrder, ORDER_COMPARE_PROPERTIES)};
          const options = {returnOriginal: false};

          WiringOrder.collection.findOneAndUpdate(filter, update, options, (err, res) =>
          {
            if (err)
            {
              logger.error(err, 'Failed to update duplicate order.', {
                key,
                duplicateOrderId: duplicateOrder._id
              });
            }
            else if (res.ok)
            {
              this.changes.added.push(res.value);
            }

            next();
          });
        });
      },
      function(err)
      {
        if (err)
        {
          return logger.error(err, 'Failed to generate.');
        }

        const added = this.changes.added.length;
        const changed = this.changes.changed.length;
        const removed = this.changes.removed.length;
        const duration = (Date.now() - startedAt) / 1000;

        logger.info('Generated.', {added, changed, removed, duration});

        if (added || changed || removed)
        {
          app.broker.publish(`${WiringOrder.TOPIC_PREFIX}.changed.${key}`, {
            date: utcDate,
            changes: this.changes
          });
        }

        app.broker.publish('wiring.generator.finished', {
          date: key,
          changeCount: {added, changed, removed},
          duration
        });
      }
    );
  }

  function recordEvent(events, type, order)
  {
    const comment = 'Zlecenie usunięte z planu.';

    if (order.comment !== comment)
    {
      events.push({
        order: order._id,
        type: type,
        time: new Date(),
        user: {
          id: null,
          ip: '127.0.0.1',
          label: 'System'
        },
        data: {comment}
      });
    }

    return comment;
  }

  function compareOrders(oldOrder, newOrder)
  {
    const changes = {
      _id: oldOrder._id
    };

    ORDER_COMPARE_PROPERTIES.forEach(p =>
    {
      const oldValue = oldOrder[p];
      const newValue = newOrder[p];

      if (!jsonDeepEqual(oldValue, newValue))
      {
        changes[p] = newValue;
      }
    });

    return Object.keys(changes).length > 1 ? changes : null;
  }
};
